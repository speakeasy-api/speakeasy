package integration_tests

import (
	"os"
	"os/exec"
	"path/filepath"
	"runtime"
	"strings"
	"testing"
	"time"

	"github.com/speakeasy-api/openapi-generation/v2/pkg/generate"
	"github.com/speakeasy-api/speakeasy/internal/testutils"
	"github.com/speakeasy-api/speakeasy/prompts"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

func TestQuickstart(t *testing.T) {
	t.Parallel()

	now := time.Now()
	t.Logf("Building binary")
	// Build the binary once to warm up the cache
	tempDir := testutils.GetTempDir()
	binaryName := "speakeasy"
	if runtime.GOOS == "windows" {
		binaryName = "speakeasy.exe"
	}
	tempBinary := filepath.Join(tempDir, binaryName)
	tempBinary = testutils.BuildTempBinary(t, tempBinary)
	t.Logf("Binary built in %s", time.Since(now))
	targets := prompts.GetSupportedTargetNames()
	for _, target := range targets {
		t.Run(target, func(t *testing.T) {
			t.Parallel()

			if shouldSkipTarget(t, target) {
				return
			}
			testQuickstartForTarget(t, target, tempBinary)
		})
	}
}

func shouldSkipTarget(t *testing.T, target string) bool {
	// Skip Alpha languages as they have different behavior
	if isAlphaTarget(target) {
		t.Skipf("Skipping %s as it's an Alpha language", target)
		return true
	}

	if target == "terraform" {
		// TODO: The petstore default spec is not supported for terraform
		t.Skipf("Skipping %s as it's not supported yet", target)
		return true
	}

	// Skip php on windows for now as linting breaks
	if runtime.GOOS == "windows" && target == "php" {
		t.Skipf("Skipping %s on windows for now as linting breaks", target)
		return true
	}

	// Skip Ruby on Windows for now as there is no sorbet-static gem for Windows
	// TODO: https://linear.app/speakeasy/issue/GEN-1728/ruby-does-not-have-static-sorbet-gem-for-windows-and-cannot-quickstart
	if runtime.GOOS == "windows" && target == "ruby" {
		t.Skipf("Skipping %s on windows for now as there is no sorbet-static gem for Windows", target)
		return true
	}

	return false
}

func testQuickstartForTarget(t *testing.T, target string, tempBinary string) {
	// Create test directory
	testDir := createTestDir(t, target)
	// Don't delete test directory - leave it for debugging
	t.Logf("Test directory for %s: %s", target, testDir)

	// Run quickstart
	now := time.Now()
	t.Logf("Running quickstart for target %s", target)
	quickstartCmd := exec.Command(tempBinary,
		"quickstart",
		"--skip-interactive",
		"--target", target,
		"--output", "console",
	)
	quickstartCmd.Dir = testDir
	quickstartCmd.Stdout = os.Stdout
	quickstartCmd.Stderr = os.Stderr

	quickstartOutput, err := quickstartCmd.CombinedOutput()
	if err != nil {
		t.Logf("Quickstart output for %s: %s", target, string(quickstartOutput))
		t.Fatalf("Quickstart failed for target %s: %v", target, err)
	}
	t.Logf("Quickstart took %s", time.Since(now))

	// Check if SDK was generated directly in test directory or in a subdirectory
	generatedDir := testDir
	if _, err := os.Stat(filepath.Join(testDir, ".speakeasy")); err != nil {
		// Not in test directory, look for subdirectory
		generatedDir = findGeneratedDirectory(t, testDir, target)
	}

	verifyBasicStructure(t, generatedDir, target)

	// Run speakeasy run
	now = time.Now()
	t.Logf("Running speakeasy run for target %s", target)
	runCmd := exec.Command(tempBinary, "run", "--output", "console", "--pinned")
	runCmd.Dir = generatedDir
	runOutput, err := runCmd.CombinedOutput()

	if err != nil {
		t.Logf("Run output for %s: %s", target, string(runOutput))
		// Don't fail the test if run fails - it might be due to compilation issues in test environment
		t.Logf("Speakeasy run failed for target %s (this might be expected in test environment): %v", target, err)
	} else {
		t.Logf("Speakeasy run succeeded for target %s", target)
	}
	t.Logf("Speakeasy run took %s", time.Since(now))
	// Verify basic structure was created
	verifyBasicStructure(t, generatedDir, target)
}

// createTestDir creates a temporary test directory for the target
func createTestDir(t *testing.T, target string) string {
	tempDir := testutils.GetTempDir()
	baseTestDir := filepath.Join(tempDir, "speakeasy-quickstart-tests")
	testDir := filepath.Join(baseTestDir, target)

	// Remove any existing directory
	os.RemoveAll(testDir)

	err := os.MkdirAll(testDir, 0o755)
	require.NoError(t, err, "Failed to create test directory %s", testDir)

	return testDir
}

// findGeneratedDirectory finds the directory that was generated by quickstart
func findGeneratedDirectory(t *testing.T, testDir, target string) string {
	// Fallback: look for any directory with .speakeasy folder
	entries, err := os.ReadDir(testDir)
	require.NoError(t, err)

	var candidates []string
	for _, entry := range entries {
		if entry.IsDir() {
			dirPath := filepath.Join(testDir, entry.Name())
			speakeasyDir := filepath.Join(dirPath, ".speakeasy")
			if _, err := os.Stat(speakeasyDir); err == nil {
				candidates = append(candidates, dirPath)
			}
		}
	}

	if len(candidates) == 0 {
		t.Fatalf("Could not find any generated directory with .speakeasy folder for target %s in %s", target, testDir)
	}

	if len(candidates) == 1 {
		return candidates[0]
	}

	// If multiple candidates, try to pick the best one
	for _, candidate := range candidates {
		name := filepath.Base(candidate)
		// Prefer directories that contain the target name or common patterns
		if strings.Contains(strings.ToLower(name), target) ||
			strings.Contains(strings.ToLower(name), "petstore") ||
			strings.Contains(strings.ToLower(name), "sdk") {
			return candidate
		}
	}

	// If no preferred match, return the first one
	t.Logf("Multiple candidates found for target %s: %v, using first one", target, candidates)
	return candidates[0]
}

// verifyBasicStructure verifies that basic files and directories were created
func verifyBasicStructure(t *testing.T, generatedDir, target string) {
	// Check for .speakeasy directory
	speakeasyDir := filepath.Join(generatedDir, ".speakeasy")
	_, err := os.Stat(speakeasyDir)
	assert.NoError(t, err, ".speakeasy directory should exist")

	// Check for workflow.yaml
	workflowFile := filepath.Join(speakeasyDir, "workflow.yaml")
	_, err = os.Stat(workflowFile)
	assert.NoError(t, err, "workflow.yaml should exist")

	// Check for OpenAPI spec file
	specFiles := []string{"openapi.yaml", "openapi.yml", "openapi.json"}
	specFound := false
	for _, specFile := range specFiles {
		if _, err := os.Stat(filepath.Join(generatedDir, specFile)); err == nil {
			specFound = true
			break
		}
	}
	assert.True(t, specFound, "OpenAPI spec file should exist")

	checkFileExists(t, generatedDir, "README.md")

	// Check for target-specific files
	verifyTargetSpecificFiles(t, generatedDir, target)
}

// verifyTargetSpecificFiles verifies target-specific files were created
func verifyTargetSpecificFiles(t *testing.T, generatedDir, target string) {
	switch target {
	case "typescript", "mcp-typescript":
		checkFileExists(t, generatedDir, "package.json")
		checkFileExists(t, generatedDir, "tsconfig.json")
	case "python":
		checkFileExists(t, generatedDir, "pyproject.toml")
	case "go":
		checkFileExists(t, generatedDir, "go.mod")
	case "php":
		checkFileExists(t, generatedDir, "composer.json")
	case "ruby":
		checkFileExists(t, generatedDir, "Gemfile")
	case "terraform":
		checkFileExists(t, generatedDir, "go.mod") // Terraform provider is Go-based
	case "java":
		checkFileExists(t, generatedDir, "build.gradle")
	case "postman":
		// Postman collections might not have standard files, just check basic structure
		t.Logf("Postman target verification - checking basic structure")
	default:
		t.Logf("No specific file verification defined for target: %s", target)
	}
}

// checkFileExists checks if a file exists and logs the result
func checkFileExists(t *testing.T, dir, filename string) {
	filePath := filepath.Join(dir, filename)
	_, err := os.Stat(filePath)
	if err == nil {
		t.Logf("✓ Found expected file: %s", filename)
	} else {
		t.Logf("✗ Missing expected file: %s", filename)
	}
}

// getTempDir returns the appropriate temp directory for the OS

// isAlphaTarget checks if a target is in Alpha stage using the existing codebase implementation
func isAlphaTarget(target string) bool {
	return generate.GetTargetNameMaturity(target) == "Alpha"
}
