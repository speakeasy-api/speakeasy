"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// node_modules/lodash.camelcase/index.js
var require_lodash = __commonJS({
  "node_modules/lodash.camelcase/index.js"(exports2, module2) {
    var INFINITY = 1 / 0;
    var symbolTag = "[object Symbol]";
    var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
    var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
    var rsAstralRange = "\\ud800-\\udfff";
    var rsComboMarksRange = "\\u0300-\\u036f\\ufe20-\\ufe23";
    var rsComboSymbolsRange = "\\u20d0-\\u20f0";
    var rsDingbatRange = "\\u2700-\\u27bf";
    var rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff";
    var rsMathOpRange = "\\xac\\xb1\\xd7\\xf7";
    var rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf";
    var rsPunctuationRange = "\\u2000-\\u206f";
    var rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000";
    var rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde";
    var rsVarRange = "\\ufe0e\\ufe0f";
    var rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
    var rsApos = "['\u2019]";
    var rsAstral = "[" + rsAstralRange + "]";
    var rsBreak = "[" + rsBreakRange + "]";
    var rsCombo = "[" + rsComboMarksRange + rsComboSymbolsRange + "]";
    var rsDigits = "\\d+";
    var rsDingbat = "[" + rsDingbatRange + "]";
    var rsLower = "[" + rsLowerRange + "]";
    var rsMisc = "[^" + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]";
    var rsFitz = "\\ud83c[\\udffb-\\udfff]";
    var rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")";
    var rsNonAstral = "[^" + rsAstralRange + "]";
    var rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}";
    var rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]";
    var rsUpper = "[" + rsUpperRange + "]";
    var rsZWJ = "\\u200d";
    var rsLowerMisc = "(?:" + rsLower + "|" + rsMisc + ")";
    var rsUpperMisc = "(?:" + rsUpper + "|" + rsMisc + ")";
    var rsOptLowerContr = "(?:" + rsApos + "(?:d|ll|m|re|s|t|ve))?";
    var rsOptUpperContr = "(?:" + rsApos + "(?:D|LL|M|RE|S|T|VE))?";
    var reOptMod = rsModifier + "?";
    var rsOptVar = "[" + rsVarRange + "]?";
    var rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*";
    var rsSeq = rsOptVar + reOptMod + rsOptJoin;
    var rsEmoji = "(?:" + [rsDingbat, rsRegional, rsSurrPair].join("|") + ")" + rsSeq;
    var rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
    var reApos = RegExp(rsApos, "g");
    var reComboMark = RegExp(rsCombo, "g");
    var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
    var reUnicodeWord = RegExp([
      rsUpper + "?" + rsLower + "+" + rsOptLowerContr + "(?=" + [rsBreak, rsUpper, "$"].join("|") + ")",
      rsUpperMisc + "+" + rsOptUpperContr + "(?=" + [rsBreak, rsUpper + rsLowerMisc, "$"].join("|") + ")",
      rsUpper + "?" + rsLowerMisc + "+" + rsOptLowerContr,
      rsUpper + "+" + rsOptUpperContr,
      rsDigits,
      rsEmoji
    ].join("|"), "g");
    var reHasUnicode = RegExp("[" + rsZWJ + rsAstralRange + rsComboMarksRange + rsComboSymbolsRange + rsVarRange + "]");
    var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2,}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
    var deburredLetters = {
      // Latin-1 Supplement block.
      "\xC0": "A",
      "\xC1": "A",
      "\xC2": "A",
      "\xC3": "A",
      "\xC4": "A",
      "\xC5": "A",
      "\xE0": "a",
      "\xE1": "a",
      "\xE2": "a",
      "\xE3": "a",
      "\xE4": "a",
      "\xE5": "a",
      "\xC7": "C",
      "\xE7": "c",
      "\xD0": "D",
      "\xF0": "d",
      "\xC8": "E",
      "\xC9": "E",
      "\xCA": "E",
      "\xCB": "E",
      "\xE8": "e",
      "\xE9": "e",
      "\xEA": "e",
      "\xEB": "e",
      "\xCC": "I",
      "\xCD": "I",
      "\xCE": "I",
      "\xCF": "I",
      "\xEC": "i",
      "\xED": "i",
      "\xEE": "i",
      "\xEF": "i",
      "\xD1": "N",
      "\xF1": "n",
      "\xD2": "O",
      "\xD3": "O",
      "\xD4": "O",
      "\xD5": "O",
      "\xD6": "O",
      "\xD8": "O",
      "\xF2": "o",
      "\xF3": "o",
      "\xF4": "o",
      "\xF5": "o",
      "\xF6": "o",
      "\xF8": "o",
      "\xD9": "U",
      "\xDA": "U",
      "\xDB": "U",
      "\xDC": "U",
      "\xF9": "u",
      "\xFA": "u",
      "\xFB": "u",
      "\xFC": "u",
      "\xDD": "Y",
      "\xFD": "y",
      "\xFF": "y",
      "\xC6": "Ae",
      "\xE6": "ae",
      "\xDE": "Th",
      "\xFE": "th",
      "\xDF": "ss",
      // Latin Extended-A block.
      "\u0100": "A",
      "\u0102": "A",
      "\u0104": "A",
      "\u0101": "a",
      "\u0103": "a",
      "\u0105": "a",
      "\u0106": "C",
      "\u0108": "C",
      "\u010A": "C",
      "\u010C": "C",
      "\u0107": "c",
      "\u0109": "c",
      "\u010B": "c",
      "\u010D": "c",
      "\u010E": "D",
      "\u0110": "D",
      "\u010F": "d",
      "\u0111": "d",
      "\u0112": "E",
      "\u0114": "E",
      "\u0116": "E",
      "\u0118": "E",
      "\u011A": "E",
      "\u0113": "e",
      "\u0115": "e",
      "\u0117": "e",
      "\u0119": "e",
      "\u011B": "e",
      "\u011C": "G",
      "\u011E": "G",
      "\u0120": "G",
      "\u0122": "G",
      "\u011D": "g",
      "\u011F": "g",
      "\u0121": "g",
      "\u0123": "g",
      "\u0124": "H",
      "\u0126": "H",
      "\u0125": "h",
      "\u0127": "h",
      "\u0128": "I",
      "\u012A": "I",
      "\u012C": "I",
      "\u012E": "I",
      "\u0130": "I",
      "\u0129": "i",
      "\u012B": "i",
      "\u012D": "i",
      "\u012F": "i",
      "\u0131": "i",
      "\u0134": "J",
      "\u0135": "j",
      "\u0136": "K",
      "\u0137": "k",
      "\u0138": "k",
      "\u0139": "L",
      "\u013B": "L",
      "\u013D": "L",
      "\u013F": "L",
      "\u0141": "L",
      "\u013A": "l",
      "\u013C": "l",
      "\u013E": "l",
      "\u0140": "l",
      "\u0142": "l",
      "\u0143": "N",
      "\u0145": "N",
      "\u0147": "N",
      "\u014A": "N",
      "\u0144": "n",
      "\u0146": "n",
      "\u0148": "n",
      "\u014B": "n",
      "\u014C": "O",
      "\u014E": "O",
      "\u0150": "O",
      "\u014D": "o",
      "\u014F": "o",
      "\u0151": "o",
      "\u0154": "R",
      "\u0156": "R",
      "\u0158": "R",
      "\u0155": "r",
      "\u0157": "r",
      "\u0159": "r",
      "\u015A": "S",
      "\u015C": "S",
      "\u015E": "S",
      "\u0160": "S",
      "\u015B": "s",
      "\u015D": "s",
      "\u015F": "s",
      "\u0161": "s",
      "\u0162": "T",
      "\u0164": "T",
      "\u0166": "T",
      "\u0163": "t",
      "\u0165": "t",
      "\u0167": "t",
      "\u0168": "U",
      "\u016A": "U",
      "\u016C": "U",
      "\u016E": "U",
      "\u0170": "U",
      "\u0172": "U",
      "\u0169": "u",
      "\u016B": "u",
      "\u016D": "u",
      "\u016F": "u",
      "\u0171": "u",
      "\u0173": "u",
      "\u0174": "W",
      "\u0175": "w",
      "\u0176": "Y",
      "\u0177": "y",
      "\u0178": "Y",
      "\u0179": "Z",
      "\u017B": "Z",
      "\u017D": "Z",
      "\u017A": "z",
      "\u017C": "z",
      "\u017E": "z",
      "\u0132": "IJ",
      "\u0133": "ij",
      "\u0152": "Oe",
      "\u0153": "oe",
      "\u0149": "'n",
      "\u017F": "ss"
    };
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    function arrayReduce(array, iteratee, accumulator, initAccum) {
      var index = -1, length = array ? array.length : 0;
      if (initAccum && length) {
        accumulator = array[++index];
      }
      while (++index < length) {
        accumulator = iteratee(accumulator, array[index], index, array);
      }
      return accumulator;
    }
    function asciiToArray(string) {
      return string.split("");
    }
    function asciiWords(string) {
      return string.match(reAsciiWord) || [];
    }
    function basePropertyOf(object) {
      return function(key) {
        return object == null ? void 0 : object[key];
      };
    }
    var deburrLetter = basePropertyOf(deburredLetters);
    function hasUnicode(string) {
      return reHasUnicode.test(string);
    }
    function hasUnicodeWord(string) {
      return reHasUnicodeWord.test(string);
    }
    function stringToArray(string) {
      return hasUnicode(string) ? unicodeToArray(string) : asciiToArray(string);
    }
    function unicodeToArray(string) {
      return string.match(reUnicode) || [];
    }
    function unicodeWords(string) {
      return string.match(reUnicodeWord) || [];
    }
    var objectProto = Object.prototype;
    var objectToString = objectProto.toString;
    var Symbol2 = root.Symbol;
    var symbolProto = Symbol2 ? Symbol2.prototype : void 0;
    var symbolToString = symbolProto ? symbolProto.toString : void 0;
    function baseSlice(array, start, end) {
      var index = -1, length = array.length;
      if (start < 0) {
        start = -start > length ? 0 : length + start;
      }
      end = end > length ? length : end;
      if (end < 0) {
        end += length;
      }
      length = start > end ? 0 : end - start >>> 0;
      start >>>= 0;
      var result = Array(length);
      while (++index < length) {
        result[index] = array[index + start];
      }
      return result;
    }
    function baseToString(value) {
      if (typeof value == "string") {
        return value;
      }
      if (isSymbol(value)) {
        return symbolToString ? symbolToString.call(value) : "";
      }
      var result = value + "";
      return result == "0" && 1 / value == -INFINITY ? "-0" : result;
    }
    function castSlice(array, start, end) {
      var length = array.length;
      end = end === void 0 ? length : end;
      return !start && end >= length ? array : baseSlice(array, start, end);
    }
    function createCaseFirst(methodName) {
      return function(string) {
        string = toString2(string);
        var strSymbols = hasUnicode(string) ? stringToArray(string) : void 0;
        var chr = strSymbols ? strSymbols[0] : string.charAt(0);
        var trailing = strSymbols ? castSlice(strSymbols, 1).join("") : string.slice(1);
        return chr[methodName]() + trailing;
      };
    }
    function createCompounder(callback) {
      return function(string) {
        return arrayReduce(words(deburr(string).replace(reApos, "")), callback, "");
      };
    }
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    function isSymbol(value) {
      return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
    }
    function toString2(value) {
      return value == null ? "" : baseToString(value);
    }
    var camelCase = createCompounder(function(result, word, index) {
      word = word.toLowerCase();
      return result + (index ? capitalize(word) : word);
    });
    function capitalize(string) {
      return upperFirst(toString2(string).toLowerCase());
    }
    function deburr(string) {
      string = toString2(string);
      return string && string.replace(reLatin, deburrLetter).replace(reComboMark, "");
    }
    var upperFirst = createCaseFirst("toUpperCase");
    function words(string, pattern, guard) {
      string = toString2(string);
      pattern = guard ? void 0 : pattern;
      if (pattern === void 0) {
        return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
      }
      return string.match(pattern) || [];
    }
    module2.exports = camelCase;
  }
});

// node_modules/command-line-args/dist/index.js
var require_dist = __commonJS({
  "node_modules/command-line-args/dist/index.js"(exports2, module2) {
    "use strict";
    function _interopDefault(ex) {
      return ex && typeof ex === "object" && "default" in ex ? ex["default"] : ex;
    }
    var camelCase = _interopDefault(require_lodash());
    function isObject5(input) {
      return typeof input === "object" && input !== null;
    }
    function isArrayLike(input) {
      return isObject5(input) && typeof input.length === "number";
    }
    function arrayify(input) {
      if (Array.isArray(input)) {
        return input;
      }
      if (input === void 0) {
        return [];
      }
      if (isArrayLike(input) || input instanceof Set) {
        return Array.from(input);
      }
      return [input];
    }
    function isObject$1(input) {
      return typeof input === "object" && input !== null;
    }
    function isArrayLike$1(input) {
      return isObject$1(input) && typeof input.length === "number";
    }
    function arrayify$1(input) {
      if (Array.isArray(input)) {
        return input;
      } else {
        if (input === void 0) {
          return [];
        } else if (isArrayLike$1(input)) {
          return Array.prototype.slice.call(input);
        } else {
          return [input];
        }
      }
    }
    function findReplace(array, testFn) {
      const found = [];
      const replaceWiths = arrayify$1(arguments);
      replaceWiths.splice(0, 2);
      arrayify$1(array).forEach((value, index) => {
        let expanded = [];
        replaceWiths.forEach((replaceWith) => {
          if (typeof replaceWith === "function") {
            expanded = expanded.concat(replaceWith(value));
          } else {
            expanded.push(replaceWith);
          }
        });
        if (testFn(value)) {
          found.push({
            index,
            replaceWithValue: expanded
          });
        }
      });
      found.reverse().forEach((item) => {
        const spliceArgs = [item.index, 1].concat(item.replaceWithValue);
        array.splice.apply(array, spliceArgs);
      });
      return array;
    }
    var re = {
      short: /^-([^\d-])$/,
      long: /^--(\S+)/,
      combinedShort: /^-[^\d-]{2,}$/,
      optEquals: /^(--\S+?)=(.*)/
    };
    var ArgvArray = class extends Array {
      /**
       * Clears the array has loads the supplied input.
       * @param {string[]} argv - The argv list to load. Defaults to `process.argv`.
       */
      load(argv) {
        this.clear();
        if (argv && argv !== process.argv) {
          argv = arrayify(argv);
        } else {
          argv = process.argv.slice(0);
          const deleteCount = process.execArgv.some(isExecArg) ? 1 : 2;
          argv.splice(0, deleteCount);
        }
        argv.forEach((arg) => this.push(String(arg)));
      }
      /**
       * Clear the array.
       */
      clear() {
        this.length = 0;
      }
      /**
       * expand ``--option=value` style args.
       */
      expandOptionEqualsNotation() {
        if (this.some((arg) => re.optEquals.test(arg))) {
          const expandedArgs = [];
          this.forEach((arg) => {
            const matches = arg.match(re.optEquals);
            if (matches) {
              expandedArgs.push(matches[1], matches[2]);
            } else {
              expandedArgs.push(arg);
            }
          });
          this.clear();
          this.load(expandedArgs);
        }
      }
      /**
       * expand getopt-style combinedShort options.
       */
      expandGetoptNotation() {
        if (this.hasCombinedShortOptions()) {
          findReplace(this, re.combinedShort, expandCombinedShortArg);
        }
      }
      /**
       * Returns true if the array contains combined short options (e.g. `-ab`).
       * @returns {boolean}
       */
      hasCombinedShortOptions() {
        return this.some((arg) => re.combinedShort.test(arg));
      }
      static from(argv) {
        const result = new this();
        result.load(argv);
        return result;
      }
    };
    function expandCombinedShortArg(arg) {
      arg = arg.slice(1);
      return arg.split("").map((letter) => "-" + letter);
    }
    function isOptionEqualsNotation(arg) {
      return re.optEquals.test(arg);
    }
    function isOption(arg) {
      return (re.short.test(arg) || re.long.test(arg)) && !re.optEquals.test(arg);
    }
    function isLongOption(arg) {
      return re.long.test(arg) && !isOptionEqualsNotation(arg);
    }
    function getOptionName(arg) {
      if (re.short.test(arg)) {
        return arg.match(re.short)[1];
      } else if (isLongOption(arg)) {
        return arg.match(re.long)[1];
      } else if (isOptionEqualsNotation(arg)) {
        return arg.match(re.optEquals)[1].replace(/^--/, "");
      } else {
        return null;
      }
    }
    function isValue(arg) {
      return !(isOption(arg) || re.combinedShort.test(arg) || re.optEquals.test(arg));
    }
    function isExecArg(arg) {
      return ["--eval", "-e"].indexOf(arg) > -1 || arg.startsWith("--eval=");
    }
    function isNumber(n) {
      return !isNaN(parseFloat(n)) && isFinite(n);
    }
    function isPlainObject(input) {
      return input !== null && typeof input === "object" && input.constructor === Object;
    }
    function isArrayLike$2(input) {
      return isObject$2(input) && typeof input.length === "number";
    }
    function isObject$2(input) {
      return typeof input === "object" && input !== null;
    }
    function isDefined(input) {
      return typeof input !== "undefined";
    }
    function isString(input) {
      return typeof input === "string";
    }
    function isBoolean2(input) {
      return typeof input === "boolean";
    }
    function isFunction(input) {
      return typeof input === "function";
    }
    function isClass(input) {
      if (isFunction(input)) {
        return /^class /.test(Function.prototype.toString.call(input));
      } else {
        return false;
      }
    }
    function isPrimitive3(input) {
      if (input === null) return true;
      switch (typeof input) {
        case "string":
        case "number":
        case "symbol":
        case "undefined":
        case "boolean":
          return true;
        default:
          return false;
      }
    }
    function isPromise(input) {
      if (input) {
        const isPromise2 = isDefined(Promise) && input instanceof Promise;
        const isThenable = input.then && typeof input.then === "function";
        return !!(isPromise2 || isThenable);
      } else {
        return false;
      }
    }
    function isIterable(input) {
      if (input === null || !isDefined(input)) {
        return false;
      } else {
        return typeof input[Symbol.iterator] === "function" || typeof input[Symbol.asyncIterator] === "function";
      }
    }
    var t = {
      isNumber,
      isString,
      isBoolean: isBoolean2,
      isPlainObject,
      isArrayLike: isArrayLike$2,
      isObject: isObject$2,
      isDefined,
      isFunction,
      isClass,
      isPrimitive: isPrimitive3,
      isPromise,
      isIterable
    };
    var OptionDefinition = class {
      constructor(definition) {
        this.name = definition.name;
        this.type = definition.type || String;
        this.alias = definition.alias;
        this.multiple = definition.multiple;
        this.lazyMultiple = definition.lazyMultiple;
        this.defaultOption = definition.defaultOption;
        this.defaultValue = definition.defaultValue;
        this.group = definition.group;
        for (const prop in definition) {
          if (!this[prop]) this[prop] = definition[prop];
        }
      }
      isBoolean() {
        return this.type === Boolean || t.isFunction(this.type) && this.type.name === "Boolean";
      }
      isMultiple() {
        return this.multiple || this.lazyMultiple;
      }
      static create(def) {
        const result = new this(def);
        return result;
      }
    };
    var Definitions = class extends Array {
      /**
       * validate option definitions
       * @param {boolean} [caseInsensitive=false] - whether arguments will be parsed in a case insensitive manner
       * @returns {string}
       */
      validate(caseInsensitive) {
        const someHaveNoName = this.some((def) => !def.name);
        if (someHaveNoName) {
          halt(
            "INVALID_DEFINITIONS",
            "Invalid option definitions: the `name` property is required on each definition"
          );
        }
        const someDontHaveFunctionType = this.some((def) => def.type && typeof def.type !== "function");
        if (someDontHaveFunctionType) {
          halt(
            "INVALID_DEFINITIONS",
            "Invalid option definitions: the `type` property must be a setter fuction (default: `Boolean`)"
          );
        }
        let invalidOption;
        const numericAlias = this.some((def) => {
          invalidOption = def;
          return t.isDefined(def.alias) && t.isNumber(def.alias);
        });
        if (numericAlias) {
          halt(
            "INVALID_DEFINITIONS",
            "Invalid option definition: to avoid ambiguity an alias cannot be numeric [--" + invalidOption.name + " alias is -" + invalidOption.alias + "]"
          );
        }
        const multiCharacterAlias = this.some((def) => {
          invalidOption = def;
          return t.isDefined(def.alias) && def.alias.length !== 1;
        });
        if (multiCharacterAlias) {
          halt(
            "INVALID_DEFINITIONS",
            "Invalid option definition: an alias must be a single character"
          );
        }
        const hypenAlias = this.some((def) => {
          invalidOption = def;
          return def.alias === "-";
        });
        if (hypenAlias) {
          halt(
            "INVALID_DEFINITIONS",
            'Invalid option definition: an alias cannot be "-"'
          );
        }
        const duplicateName = hasDuplicates(this.map((def) => caseInsensitive ? def.name.toLowerCase() : def.name));
        if (duplicateName) {
          halt(
            "INVALID_DEFINITIONS",
            "Two or more option definitions have the same name"
          );
        }
        const duplicateAlias = hasDuplicates(this.map((def) => caseInsensitive && t.isDefined(def.alias) ? def.alias.toLowerCase() : def.alias));
        if (duplicateAlias) {
          halt(
            "INVALID_DEFINITIONS",
            "Two or more option definitions have the same alias"
          );
        }
        const duplicateDefaultOption = this.filter((def) => def.defaultOption === true).length > 1;
        if (duplicateDefaultOption) {
          halt(
            "INVALID_DEFINITIONS",
            "Only one option definition can be the defaultOption"
          );
        }
        const defaultBoolean = this.some((def) => {
          invalidOption = def;
          return def.isBoolean() && def.defaultOption;
        });
        if (defaultBoolean) {
          halt(
            "INVALID_DEFINITIONS",
            `A boolean option ["${invalidOption.name}"] can not also be the defaultOption.`
          );
        }
      }
      /**
       * Get definition by option arg (e.g. `--one` or `-o`)
       * @param {string} [arg] the argument name to get the definition for
       * @param {boolean} [caseInsensitive] whether to use case insensitive comparisons when finding the appropriate definition
       * @returns {Definition}
       */
      get(arg, caseInsensitive) {
        if (isOption(arg)) {
          if (re.short.test(arg)) {
            const shortOptionName = getOptionName(arg);
            if (caseInsensitive) {
              const lowercaseShortOptionName = shortOptionName.toLowerCase();
              return this.find((def) => t.isDefined(def.alias) && def.alias.toLowerCase() === lowercaseShortOptionName);
            } else {
              return this.find((def) => def.alias === shortOptionName);
            }
          } else {
            const optionName = getOptionName(arg);
            if (caseInsensitive) {
              const lowercaseOptionName = optionName.toLowerCase();
              return this.find((def) => def.name.toLowerCase() === lowercaseOptionName);
            } else {
              return this.find((def) => def.name === optionName);
            }
          }
        } else {
          return this.find((def) => def.name === arg);
        }
      }
      getDefault() {
        return this.find((def) => def.defaultOption === true);
      }
      isGrouped() {
        return this.some((def) => def.group);
      }
      whereGrouped() {
        return this.filter(containsValidGroup);
      }
      whereNotGrouped() {
        return this.filter((def) => !containsValidGroup(def));
      }
      whereDefaultValueSet() {
        return this.filter((def) => t.isDefined(def.defaultValue));
      }
      static from(definitions, caseInsensitive) {
        if (definitions instanceof this) return definitions;
        const result = super.from(arrayify(definitions), (def) => OptionDefinition.create(def));
        result.validate(caseInsensitive);
        return result;
      }
    };
    function halt(name, message) {
      const err = new Error(message);
      err.name = name;
      throw err;
    }
    function containsValidGroup(def) {
      return arrayify(def.group).some((group) => group);
    }
    function hasDuplicates(array) {
      const items = {};
      for (let i = 0; i < array.length; i++) {
        const value = array[i];
        if (items[value]) {
          return true;
        } else {
          if (t.isDefined(value)) items[value] = true;
        }
      }
    }
    var ArgvParser = class {
      /**
       * @param {OptionDefinitions} - Definitions array
       * @param {object} [options] - Options
       * @param {string[]} [options.argv] - Overrides `process.argv`
       * @param {boolean} [options.stopAtFirstUnknown] -
       * @param {boolean} [options.caseInsensitive] - Arguments will be parsed in a case insensitive manner. Defaults to false.
       */
      constructor(definitions, options) {
        this.options = Object.assign({}, options);
        this.definitions = Definitions.from(definitions, this.options.caseInsensitive);
        this.argv = ArgvArray.from(this.options.argv);
        if (this.argv.hasCombinedShortOptions()) {
          findReplace(this.argv, re.combinedShort.test.bind(re.combinedShort), (arg) => {
            arg = arg.slice(1);
            return arg.split("").map((letter) => ({ origArg: `-${arg}`, arg: "-" + letter }));
          });
        }
      }
      /**
       * Yields one `{ event, name, value, arg, def }` argInfo object for each arg in `process.argv` (or `options.argv`).
       */
      *[Symbol.iterator]() {
        const definitions = this.definitions;
        let def;
        let value;
        let name;
        let event;
        let singularDefaultSet = false;
        let unknownFound = false;
        let origArg;
        for (let arg of this.argv) {
          if (t.isPlainObject(arg)) {
            origArg = arg.origArg;
            arg = arg.arg;
          }
          if (unknownFound && this.options.stopAtFirstUnknown) {
            yield { event: "unknown_value", arg, name: "_unknown", value: void 0 };
            continue;
          }
          if (isOption(arg)) {
            def = definitions.get(arg, this.options.caseInsensitive);
            value = void 0;
            if (def) {
              value = def.isBoolean() ? true : null;
              event = "set";
            } else {
              event = "unknown_option";
            }
          } else if (isOptionEqualsNotation(arg)) {
            const matches = arg.match(re.optEquals);
            def = definitions.get(matches[1], this.options.caseInsensitive);
            if (def) {
              if (def.isBoolean()) {
                yield { event: "unknown_value", arg, name: "_unknown", value, def };
                event = "set";
                value = true;
              } else {
                event = "set";
                value = matches[2];
              }
            } else {
              event = "unknown_option";
            }
          } else if (isValue(arg)) {
            if (def) {
              value = arg;
              event = "set";
            } else {
              def = this.definitions.getDefault();
              if (def && !singularDefaultSet) {
                value = arg;
                event = "set";
              } else {
                event = "unknown_value";
                def = void 0;
              }
            }
          }
          name = def ? def.name : "_unknown";
          const argInfo = { event, arg, name, value, def };
          if (origArg) {
            argInfo.subArg = arg;
            argInfo.arg = origArg;
          }
          yield argInfo;
          if (name === "_unknown") unknownFound = true;
          if (def && def.defaultOption && !def.isMultiple() && event === "set") singularDefaultSet = true;
          if (def && def.isBoolean()) def = void 0;
          if (def && !def.multiple && t.isDefined(value) && value !== null) {
            def = void 0;
          }
          value = void 0;
          event = void 0;
          name = void 0;
          origArg = void 0;
        }
      }
    };
    var _value = /* @__PURE__ */ new WeakMap();
    var Option = class {
      constructor(definition) {
        this.definition = new OptionDefinition(definition);
        this.state = null;
        this.resetToDefault();
      }
      get() {
        return _value.get(this);
      }
      set(val) {
        this._set(val, "set");
      }
      _set(val, state) {
        const def = this.definition;
        if (def.isMultiple()) {
          if (val !== null && val !== void 0) {
            const arr = this.get();
            if (this.state === "default") arr.length = 0;
            arr.push(def.type(val));
            this.state = state;
          }
        } else {
          if (!def.isMultiple() && this.state === "set") {
            const err = new Error(`Singular option already set [${this.definition.name}=${this.get()}]`);
            err.name = "ALREADY_SET";
            err.value = val;
            err.optionName = def.name;
            throw err;
          } else if (val === null || val === void 0) {
            _value.set(this, val);
          } else {
            _value.set(this, def.type(val));
            this.state = state;
          }
        }
      }
      resetToDefault() {
        if (t.isDefined(this.definition.defaultValue)) {
          if (this.definition.isMultiple()) {
            _value.set(this, arrayify(this.definition.defaultValue).slice());
          } else {
            _value.set(this, this.definition.defaultValue);
          }
        } else {
          if (this.definition.isMultiple()) {
            _value.set(this, []);
          } else {
            _value.set(this, null);
          }
        }
        this.state = "default";
      }
      static create(definition) {
        definition = new OptionDefinition(definition);
        if (definition.isBoolean()) {
          return FlagOption.create(definition);
        } else {
          return new this(definition);
        }
      }
    };
    var FlagOption = class extends Option {
      set(val) {
        super.set(true);
      }
      static create(def) {
        return new this(def);
      }
    };
    var Output = class extends Map {
      constructor(definitions) {
        super();
        this.definitions = Definitions.from(definitions);
        this.set("_unknown", Option.create({ name: "_unknown", multiple: true }));
        for (const def of this.definitions.whereDefaultValueSet()) {
          this.set(def.name, Option.create(def));
        }
      }
      toObject(options) {
        options = options || {};
        const output = {};
        for (const item of this) {
          const name = options.camelCase && item[0] !== "_unknown" ? camelCase(item[0]) : item[0];
          const option = item[1];
          if (name === "_unknown" && !option.get().length) continue;
          output[name] = option.get();
        }
        if (options.skipUnknown) delete output._unknown;
        return output;
      }
    };
    var GroupedOutput = class extends Output {
      toObject(options) {
        const superOutputNoCamel = super.toObject({ skipUnknown: options.skipUnknown });
        const superOutput = super.toObject(options);
        const unknown = superOutput._unknown;
        delete superOutput._unknown;
        const grouped = {
          _all: superOutput
        };
        if (unknown && unknown.length) grouped._unknown = unknown;
        this.definitions.whereGrouped().forEach((def) => {
          const name = options.camelCase ? camelCase(def.name) : def.name;
          const outputValue = superOutputNoCamel[def.name];
          for (const groupName of arrayify(def.group)) {
            grouped[groupName] = grouped[groupName] || {};
            if (t.isDefined(outputValue)) {
              grouped[groupName][name] = outputValue;
            }
          }
        });
        this.definitions.whereNotGrouped().forEach((def) => {
          const name = options.camelCase ? camelCase(def.name) : def.name;
          const outputValue = superOutputNoCamel[def.name];
          if (t.isDefined(outputValue)) {
            if (!grouped._none) grouped._none = {};
            grouped._none[name] = outputValue;
          }
        });
        return grouped;
      }
    };
    function commandLineArgs2(optionDefinitions, options) {
      options = options || {};
      if (options.stopAtFirstUnknown) options.partial = true;
      optionDefinitions = Definitions.from(optionDefinitions, options.caseInsensitive);
      const parser = new ArgvParser(optionDefinitions, {
        argv: options.argv,
        stopAtFirstUnknown: options.stopAtFirstUnknown,
        caseInsensitive: options.caseInsensitive
      });
      const OutputClass = optionDefinitions.isGrouped() ? GroupedOutput : Output;
      const output = new OutputClass(optionDefinitions);
      for (const argInfo of parser) {
        const arg = argInfo.subArg || argInfo.arg;
        if (!options.partial) {
          if (argInfo.event === "unknown_value") {
            const err = new Error(`Unknown value: ${arg}`);
            err.name = "UNKNOWN_VALUE";
            err.value = arg;
            throw err;
          } else if (argInfo.event === "unknown_option") {
            const err = new Error(`Unknown option: ${arg}`);
            err.name = "UNKNOWN_OPTION";
            err.optionName = arg;
            throw err;
          }
        }
        let option;
        if (output.has(argInfo.name)) {
          option = output.get(argInfo.name);
        } else {
          option = Option.create(argInfo.def);
          output.set(argInfo.name, option);
        }
        if (argInfo.name === "_unknown") {
          option.set(arg);
        } else {
          option.set(argInfo.value);
        }
      }
      return output.toObject({ skipUnknown: !options.partial, camelCase: options.camelCase });
    }
    module2.exports = commandLineArgs2;
  }
});

// node_modules/is-regexp/index.js
var require_is_regexp = __commonJS({
  "node_modules/is-regexp/index.js"(exports2, module2) {
    "use strict";
    module2.exports = function(re) {
      return Object.prototype.toString.call(re) === "[object RegExp]";
    };
  }
});

// node_modules/is-obj/index.js
var require_is_obj = __commonJS({
  "node_modules/is-obj/index.js"(exports2, module2) {
    "use strict";
    module2.exports = function(x) {
      var type2 = typeof x;
      return x !== null && (type2 === "object" || type2 === "function");
    };
  }
});

// node_modules/get-own-enumerable-property-symbols/lib/index.js
var require_lib = __commonJS({
  "node_modules/get-own-enumerable-property-symbols/lib/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.default = (object) => Object.getOwnPropertySymbols(object).filter((keySymbol) => Object.prototype.propertyIsEnumerable.call(object, keySymbol));
  }
});

// node_modules/stringify-object/index.js
var require_stringify_object = __commonJS({
  "node_modules/stringify-object/index.js"(exports2, module2) {
    "use strict";
    var isRegexp = require_is_regexp();
    var isObj = require_is_obj();
    var getOwnEnumPropSymbols = require_lib().default;
    module2.exports = (val, opts, pad) => {
      const seen = [];
      return function stringify3(val2, opts2, pad2) {
        opts2 = opts2 || {};
        opts2.indent = opts2.indent || "	";
        pad2 = pad2 || "";
        let tokens;
        if (opts2.inlineCharacterLimit === void 0) {
          tokens = {
            newLine: "\n",
            newLineOrSpace: "\n",
            pad: pad2,
            indent: pad2 + opts2.indent
          };
        } else {
          tokens = {
            newLine: "@@__STRINGIFY_OBJECT_NEW_LINE__@@",
            newLineOrSpace: "@@__STRINGIFY_OBJECT_NEW_LINE_OR_SPACE__@@",
            pad: "@@__STRINGIFY_OBJECT_PAD__@@",
            indent: "@@__STRINGIFY_OBJECT_INDENT__@@"
          };
        }
        const expandWhiteSpace = (string) => {
          if (opts2.inlineCharacterLimit === void 0) {
            return string;
          }
          const oneLined = string.replace(new RegExp(tokens.newLine, "g"), "").replace(new RegExp(tokens.newLineOrSpace, "g"), " ").replace(new RegExp(tokens.pad + "|" + tokens.indent, "g"), "");
          if (oneLined.length <= opts2.inlineCharacterLimit) {
            return oneLined;
          }
          return string.replace(new RegExp(tokens.newLine + "|" + tokens.newLineOrSpace, "g"), "\n").replace(new RegExp(tokens.pad, "g"), pad2).replace(new RegExp(tokens.indent, "g"), pad2 + opts2.indent);
        };
        if (seen.indexOf(val2) !== -1) {
          return '"[Circular]"';
        }
        if (val2 === null || val2 === void 0 || typeof val2 === "number" || typeof val2 === "boolean" || typeof val2 === "function" || typeof val2 === "symbol" || isRegexp(val2)) {
          return String(val2);
        }
        if (val2 instanceof Date) {
          return `new Date('${val2.toISOString()}')`;
        }
        if (Array.isArray(val2)) {
          if (val2.length === 0) {
            return "[]";
          }
          seen.push(val2);
          const ret = "[" + tokens.newLine + val2.map((el, i) => {
            const eol = val2.length - 1 === i ? tokens.newLine : "," + tokens.newLineOrSpace;
            let value = stringify3(el, opts2, pad2 + opts2.indent);
            if (opts2.transform) {
              value = opts2.transform(val2, i, value);
            }
            return tokens.indent + value + eol;
          }).join("") + tokens.pad + "]";
          seen.pop();
          return expandWhiteSpace(ret);
        }
        if (isObj(val2)) {
          let objKeys = Object.keys(val2).concat(getOwnEnumPropSymbols(val2));
          if (opts2.filter) {
            objKeys = objKeys.filter((el) => opts2.filter(val2, el));
          }
          if (objKeys.length === 0) {
            return "{}";
          }
          seen.push(val2);
          const ret = "{" + tokens.newLine + objKeys.map((el, i) => {
            const eol = objKeys.length - 1 === i ? tokens.newLine : "," + tokens.newLineOrSpace;
            const isSymbol = typeof el === "symbol";
            const isClassic = !isSymbol && /^[a-z$_][a-z$_0-9]*$/i.test(el);
            const key = isSymbol || isClassic ? el : stringify3(el, opts2);
            let value = stringify3(val2[el], opts2, pad2 + opts2.indent);
            if (opts2.transform) {
              value = opts2.transform(val2, el, value);
            }
            return tokens.indent + String(key) + ": " + value + eol;
          }).join("") + tokens.pad + "}";
          seen.pop();
          return expandWhiteSpace(ret);
        }
        val2 = String(val2).replace(/[\r\n]/g, (x) => x === "\n" ? "\\n" : "\\r");
        if (opts2.singleQuotes === false) {
          val2 = val2.replace(/"/g, '\\"');
          return `"${val2}"`;
        }
        val2 = val2.replace(/\\?'/g, "\\'");
        return `'${val2}'`;
      }(val, opts, pad);
    };
  }
});

// node_modules/jsonpointer/jsonpointer.js
var require_jsonpointer = __commonJS({
  "node_modules/jsonpointer/jsonpointer.js"(exports2) {
    var hasExcape = /~/;
    var escapeMatcher = /~[01]/g;
    function escapeReplacer(m) {
      switch (m) {
        case "~1":
          return "/";
        case "~0":
          return "~";
      }
      throw new Error("Invalid tilde escape: " + m);
    }
    function untilde(str2) {
      if (!hasExcape.test(str2)) return str2;
      return str2.replace(escapeMatcher, escapeReplacer);
    }
    function setter(obj, pointer, value) {
      var part;
      var hasNextPart;
      for (var p = 1, len = pointer.length; p < len; ) {
        if (pointer[p] === "constructor" || pointer[p] === "prototype" || pointer[p] === "__proto__") return obj;
        part = untilde(pointer[p++]);
        hasNextPart = len > p;
        if (typeof obj[part] === "undefined") {
          if (Array.isArray(obj) && part === "-") {
            part = obj.length;
          }
          if (hasNextPart) {
            if (pointer[p] !== "" && pointer[p] < Infinity || pointer[p] === "-") obj[part] = [];
            else obj[part] = {};
          }
        }
        if (!hasNextPart) break;
        obj = obj[part];
      }
      var oldValue = obj[part];
      if (value === void 0) delete obj[part];
      else obj[part] = value;
      return oldValue;
    }
    function compilePointer(pointer) {
      if (typeof pointer === "string") {
        pointer = pointer.split("/");
        if (pointer[0] === "") return pointer;
        throw new Error("Invalid JSON pointer.");
      } else if (Array.isArray(pointer)) {
        for (const part of pointer) {
          if (typeof part !== "string" && typeof part !== "number") {
            throw new Error("Invalid JSON pointer. Must be of type string or number.");
          }
        }
        return pointer;
      }
      throw new Error("Invalid JSON pointer.");
    }
    function get2(obj, pointer) {
      if (typeof obj !== "object") throw new Error("Invalid input object.");
      pointer = compilePointer(pointer);
      var len = pointer.length;
      if (len === 1) return obj;
      for (var p = 1; p < len; ) {
        obj = obj[untilde(pointer[p++])];
        if (len === p) return obj;
        if (typeof obj !== "object" || obj === null) return void 0;
      }
    }
    function set3(obj, pointer, value) {
      if (typeof obj !== "object") throw new Error("Invalid input object.");
      pointer = compilePointer(pointer);
      if (pointer.length === 0) throw new Error("Invalid JSON pointer for set.");
      return setter(obj, pointer, value);
    }
    function compile(pointer) {
      var compiled = compilePointer(pointer);
      return {
        get: function(object) {
          return get2(object, compiled);
        },
        set: function(object, value) {
          return set3(object, compiled, value);
        }
      };
    }
    exports2.get = get2;
    exports2.set = set3;
    exports2.compile = compile;
  }
});

// node_modules/lodash/_listCacheClear.js
var require_listCacheClear = __commonJS({
  "node_modules/lodash/_listCacheClear.js"(exports2, module2) {
    function listCacheClear() {
      this.__data__ = [];
      this.size = 0;
    }
    module2.exports = listCacheClear;
  }
});

// node_modules/lodash/eq.js
var require_eq = __commonJS({
  "node_modules/lodash/eq.js"(exports2, module2) {
    function eq(value, other) {
      return value === other || value !== value && other !== other;
    }
    module2.exports = eq;
  }
});

// node_modules/lodash/_assocIndexOf.js
var require_assocIndexOf = __commonJS({
  "node_modules/lodash/_assocIndexOf.js"(exports2, module2) {
    var eq = require_eq();
    function assocIndexOf(array, key) {
      var length = array.length;
      while (length--) {
        if (eq(array[length][0], key)) {
          return length;
        }
      }
      return -1;
    }
    module2.exports = assocIndexOf;
  }
});

// node_modules/lodash/_listCacheDelete.js
var require_listCacheDelete = __commonJS({
  "node_modules/lodash/_listCacheDelete.js"(exports2, module2) {
    var assocIndexOf = require_assocIndexOf();
    var arrayProto = Array.prototype;
    var splice = arrayProto.splice;
    function listCacheDelete(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        return false;
      }
      var lastIndex = data.length - 1;
      if (index == lastIndex) {
        data.pop();
      } else {
        splice.call(data, index, 1);
      }
      --this.size;
      return true;
    }
    module2.exports = listCacheDelete;
  }
});

// node_modules/lodash/_listCacheGet.js
var require_listCacheGet = __commonJS({
  "node_modules/lodash/_listCacheGet.js"(exports2, module2) {
    var assocIndexOf = require_assocIndexOf();
    function listCacheGet(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      return index < 0 ? void 0 : data[index][1];
    }
    module2.exports = listCacheGet;
  }
});

// node_modules/lodash/_listCacheHas.js
var require_listCacheHas = __commonJS({
  "node_modules/lodash/_listCacheHas.js"(exports2, module2) {
    var assocIndexOf = require_assocIndexOf();
    function listCacheHas(key) {
      return assocIndexOf(this.__data__, key) > -1;
    }
    module2.exports = listCacheHas;
  }
});

// node_modules/lodash/_listCacheSet.js
var require_listCacheSet = __commonJS({
  "node_modules/lodash/_listCacheSet.js"(exports2, module2) {
    var assocIndexOf = require_assocIndexOf();
    function listCacheSet(key, value) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        ++this.size;
        data.push([key, value]);
      } else {
        data[index][1] = value;
      }
      return this;
    }
    module2.exports = listCacheSet;
  }
});

// node_modules/lodash/_ListCache.js
var require_ListCache = __commonJS({
  "node_modules/lodash/_ListCache.js"(exports2, module2) {
    var listCacheClear = require_listCacheClear();
    var listCacheDelete = require_listCacheDelete();
    var listCacheGet = require_listCacheGet();
    var listCacheHas = require_listCacheHas();
    var listCacheSet = require_listCacheSet();
    function ListCache(entries) {
      var index = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype["delete"] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;
    module2.exports = ListCache;
  }
});

// node_modules/lodash/_stackClear.js
var require_stackClear = __commonJS({
  "node_modules/lodash/_stackClear.js"(exports2, module2) {
    var ListCache = require_ListCache();
    function stackClear() {
      this.__data__ = new ListCache();
      this.size = 0;
    }
    module2.exports = stackClear;
  }
});

// node_modules/lodash/_stackDelete.js
var require_stackDelete = __commonJS({
  "node_modules/lodash/_stackDelete.js"(exports2, module2) {
    function stackDelete(key) {
      var data = this.__data__, result = data["delete"](key);
      this.size = data.size;
      return result;
    }
    module2.exports = stackDelete;
  }
});

// node_modules/lodash/_stackGet.js
var require_stackGet = __commonJS({
  "node_modules/lodash/_stackGet.js"(exports2, module2) {
    function stackGet(key) {
      return this.__data__.get(key);
    }
    module2.exports = stackGet;
  }
});

// node_modules/lodash/_stackHas.js
var require_stackHas = __commonJS({
  "node_modules/lodash/_stackHas.js"(exports2, module2) {
    function stackHas(key) {
      return this.__data__.has(key);
    }
    module2.exports = stackHas;
  }
});

// node_modules/lodash/_freeGlobal.js
var require_freeGlobal = __commonJS({
  "node_modules/lodash/_freeGlobal.js"(exports2, module2) {
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    module2.exports = freeGlobal;
  }
});

// node_modules/lodash/_root.js
var require_root = __commonJS({
  "node_modules/lodash/_root.js"(exports2, module2) {
    var freeGlobal = require_freeGlobal();
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    module2.exports = root;
  }
});

// node_modules/lodash/_Symbol.js
var require_Symbol = __commonJS({
  "node_modules/lodash/_Symbol.js"(exports2, module2) {
    var root = require_root();
    var Symbol2 = root.Symbol;
    module2.exports = Symbol2;
  }
});

// node_modules/lodash/_getRawTag.js
var require_getRawTag = __commonJS({
  "node_modules/lodash/_getRawTag.js"(exports2, module2) {
    var Symbol2 = require_Symbol();
    var objectProto = Object.prototype;
    var hasOwnProperty2 = objectProto.hasOwnProperty;
    var nativeObjectToString = objectProto.toString;
    var symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
    function getRawTag(value) {
      var isOwn = hasOwnProperty2.call(value, symToStringTag), tag = value[symToStringTag];
      try {
        value[symToStringTag] = void 0;
        var unmasked = true;
      } catch (e) {
      }
      var result = nativeObjectToString.call(value);
      if (unmasked) {
        if (isOwn) {
          value[symToStringTag] = tag;
        } else {
          delete value[symToStringTag];
        }
      }
      return result;
    }
    module2.exports = getRawTag;
  }
});

// node_modules/lodash/_objectToString.js
var require_objectToString = __commonJS({
  "node_modules/lodash/_objectToString.js"(exports2, module2) {
    var objectProto = Object.prototype;
    var nativeObjectToString = objectProto.toString;
    function objectToString(value) {
      return nativeObjectToString.call(value);
    }
    module2.exports = objectToString;
  }
});

// node_modules/lodash/_baseGetTag.js
var require_baseGetTag = __commonJS({
  "node_modules/lodash/_baseGetTag.js"(exports2, module2) {
    var Symbol2 = require_Symbol();
    var getRawTag = require_getRawTag();
    var objectToString = require_objectToString();
    var nullTag = "[object Null]";
    var undefinedTag = "[object Undefined]";
    var symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
    function baseGetTag(value) {
      if (value == null) {
        return value === void 0 ? undefinedTag : nullTag;
      }
      return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
    }
    module2.exports = baseGetTag;
  }
});

// node_modules/lodash/isObject.js
var require_isObject = __commonJS({
  "node_modules/lodash/isObject.js"(exports2, module2) {
    function isObject5(value) {
      var type2 = typeof value;
      return value != null && (type2 == "object" || type2 == "function");
    }
    module2.exports = isObject5;
  }
});

// node_modules/lodash/isFunction.js
var require_isFunction = __commonJS({
  "node_modules/lodash/isFunction.js"(exports2, module2) {
    var baseGetTag = require_baseGetTag();
    var isObject5 = require_isObject();
    var asyncTag = "[object AsyncFunction]";
    var funcTag = "[object Function]";
    var genTag = "[object GeneratorFunction]";
    var proxyTag = "[object Proxy]";
    function isFunction(value) {
      if (!isObject5(value)) {
        return false;
      }
      var tag = baseGetTag(value);
      return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
    }
    module2.exports = isFunction;
  }
});

// node_modules/lodash/_coreJsData.js
var require_coreJsData = __commonJS({
  "node_modules/lodash/_coreJsData.js"(exports2, module2) {
    var root = require_root();
    var coreJsData = root["__core-js_shared__"];
    module2.exports = coreJsData;
  }
});

// node_modules/lodash/_isMasked.js
var require_isMasked = __commonJS({
  "node_modules/lodash/_isMasked.js"(exports2, module2) {
    var coreJsData = require_coreJsData();
    var maskSrcKey = function() {
      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
      return uid ? "Symbol(src)_1." + uid : "";
    }();
    function isMasked(func) {
      return !!maskSrcKey && maskSrcKey in func;
    }
    module2.exports = isMasked;
  }
});

// node_modules/lodash/_toSource.js
var require_toSource = __commonJS({
  "node_modules/lodash/_toSource.js"(exports2, module2) {
    var funcProto = Function.prototype;
    var funcToString = funcProto.toString;
    function toSource(func) {
      if (func != null) {
        try {
          return funcToString.call(func);
        } catch (e) {
        }
        try {
          return func + "";
        } catch (e) {
        }
      }
      return "";
    }
    module2.exports = toSource;
  }
});

// node_modules/lodash/_baseIsNative.js
var require_baseIsNative = __commonJS({
  "node_modules/lodash/_baseIsNative.js"(exports2, module2) {
    var isFunction = require_isFunction();
    var isMasked = require_isMasked();
    var isObject5 = require_isObject();
    var toSource = require_toSource();
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var funcProto = Function.prototype;
    var objectProto = Object.prototype;
    var funcToString = funcProto.toString;
    var hasOwnProperty2 = objectProto.hasOwnProperty;
    var reIsNative = RegExp(
      "^" + funcToString.call(hasOwnProperty2).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
    );
    function baseIsNative(value) {
      if (!isObject5(value) || isMasked(value)) {
        return false;
      }
      var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
      return pattern.test(toSource(value));
    }
    module2.exports = baseIsNative;
  }
});

// node_modules/lodash/_getValue.js
var require_getValue = __commonJS({
  "node_modules/lodash/_getValue.js"(exports2, module2) {
    function getValue(object, key) {
      return object == null ? void 0 : object[key];
    }
    module2.exports = getValue;
  }
});

// node_modules/lodash/_getNative.js
var require_getNative = __commonJS({
  "node_modules/lodash/_getNative.js"(exports2, module2) {
    var baseIsNative = require_baseIsNative();
    var getValue = require_getValue();
    function getNative(object, key) {
      var value = getValue(object, key);
      return baseIsNative(value) ? value : void 0;
    }
    module2.exports = getNative;
  }
});

// node_modules/lodash/_Map.js
var require_Map = __commonJS({
  "node_modules/lodash/_Map.js"(exports2, module2) {
    var getNative = require_getNative();
    var root = require_root();
    var Map2 = getNative(root, "Map");
    module2.exports = Map2;
  }
});

// node_modules/lodash/_nativeCreate.js
var require_nativeCreate = __commonJS({
  "node_modules/lodash/_nativeCreate.js"(exports2, module2) {
    var getNative = require_getNative();
    var nativeCreate = getNative(Object, "create");
    module2.exports = nativeCreate;
  }
});

// node_modules/lodash/_hashClear.js
var require_hashClear = __commonJS({
  "node_modules/lodash/_hashClear.js"(exports2, module2) {
    var nativeCreate = require_nativeCreate();
    function hashClear() {
      this.__data__ = nativeCreate ? nativeCreate(null) : {};
      this.size = 0;
    }
    module2.exports = hashClear;
  }
});

// node_modules/lodash/_hashDelete.js
var require_hashDelete = __commonJS({
  "node_modules/lodash/_hashDelete.js"(exports2, module2) {
    function hashDelete(key) {
      var result = this.has(key) && delete this.__data__[key];
      this.size -= result ? 1 : 0;
      return result;
    }
    module2.exports = hashDelete;
  }
});

// node_modules/lodash/_hashGet.js
var require_hashGet = __commonJS({
  "node_modules/lodash/_hashGet.js"(exports2, module2) {
    var nativeCreate = require_nativeCreate();
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    var objectProto = Object.prototype;
    var hasOwnProperty2 = objectProto.hasOwnProperty;
    function hashGet(key) {
      var data = this.__data__;
      if (nativeCreate) {
        var result = data[key];
        return result === HASH_UNDEFINED ? void 0 : result;
      }
      return hasOwnProperty2.call(data, key) ? data[key] : void 0;
    }
    module2.exports = hashGet;
  }
});

// node_modules/lodash/_hashHas.js
var require_hashHas = __commonJS({
  "node_modules/lodash/_hashHas.js"(exports2, module2) {
    var nativeCreate = require_nativeCreate();
    var objectProto = Object.prototype;
    var hasOwnProperty2 = objectProto.hasOwnProperty;
    function hashHas(key) {
      var data = this.__data__;
      return nativeCreate ? data[key] !== void 0 : hasOwnProperty2.call(data, key);
    }
    module2.exports = hashHas;
  }
});

// node_modules/lodash/_hashSet.js
var require_hashSet = __commonJS({
  "node_modules/lodash/_hashSet.js"(exports2, module2) {
    var nativeCreate = require_nativeCreate();
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    function hashSet(key, value) {
      var data = this.__data__;
      this.size += this.has(key) ? 0 : 1;
      data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
      return this;
    }
    module2.exports = hashSet;
  }
});

// node_modules/lodash/_Hash.js
var require_Hash = __commonJS({
  "node_modules/lodash/_Hash.js"(exports2, module2) {
    var hashClear = require_hashClear();
    var hashDelete = require_hashDelete();
    var hashGet = require_hashGet();
    var hashHas = require_hashHas();
    var hashSet = require_hashSet();
    function Hash(entries) {
      var index = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    Hash.prototype.clear = hashClear;
    Hash.prototype["delete"] = hashDelete;
    Hash.prototype.get = hashGet;
    Hash.prototype.has = hashHas;
    Hash.prototype.set = hashSet;
    module2.exports = Hash;
  }
});

// node_modules/lodash/_mapCacheClear.js
var require_mapCacheClear = __commonJS({
  "node_modules/lodash/_mapCacheClear.js"(exports2, module2) {
    var Hash = require_Hash();
    var ListCache = require_ListCache();
    var Map2 = require_Map();
    function mapCacheClear() {
      this.size = 0;
      this.__data__ = {
        "hash": new Hash(),
        "map": new (Map2 || ListCache)(),
        "string": new Hash()
      };
    }
    module2.exports = mapCacheClear;
  }
});

// node_modules/lodash/_isKeyable.js
var require_isKeyable = __commonJS({
  "node_modules/lodash/_isKeyable.js"(exports2, module2) {
    function isKeyable(value) {
      var type2 = typeof value;
      return type2 == "string" || type2 == "number" || type2 == "symbol" || type2 == "boolean" ? value !== "__proto__" : value === null;
    }
    module2.exports = isKeyable;
  }
});

// node_modules/lodash/_getMapData.js
var require_getMapData = __commonJS({
  "node_modules/lodash/_getMapData.js"(exports2, module2) {
    var isKeyable = require_isKeyable();
    function getMapData(map2, key) {
      var data = map2.__data__;
      return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
    }
    module2.exports = getMapData;
  }
});

// node_modules/lodash/_mapCacheDelete.js
var require_mapCacheDelete = __commonJS({
  "node_modules/lodash/_mapCacheDelete.js"(exports2, module2) {
    var getMapData = require_getMapData();
    function mapCacheDelete(key) {
      var result = getMapData(this, key)["delete"](key);
      this.size -= result ? 1 : 0;
      return result;
    }
    module2.exports = mapCacheDelete;
  }
});

// node_modules/lodash/_mapCacheGet.js
var require_mapCacheGet = __commonJS({
  "node_modules/lodash/_mapCacheGet.js"(exports2, module2) {
    var getMapData = require_getMapData();
    function mapCacheGet(key) {
      return getMapData(this, key).get(key);
    }
    module2.exports = mapCacheGet;
  }
});

// node_modules/lodash/_mapCacheHas.js
var require_mapCacheHas = __commonJS({
  "node_modules/lodash/_mapCacheHas.js"(exports2, module2) {
    var getMapData = require_getMapData();
    function mapCacheHas(key) {
      return getMapData(this, key).has(key);
    }
    module2.exports = mapCacheHas;
  }
});

// node_modules/lodash/_mapCacheSet.js
var require_mapCacheSet = __commonJS({
  "node_modules/lodash/_mapCacheSet.js"(exports2, module2) {
    var getMapData = require_getMapData();
    function mapCacheSet(key, value) {
      var data = getMapData(this, key), size = data.size;
      data.set(key, value);
      this.size += data.size == size ? 0 : 1;
      return this;
    }
    module2.exports = mapCacheSet;
  }
});

// node_modules/lodash/_MapCache.js
var require_MapCache = __commonJS({
  "node_modules/lodash/_MapCache.js"(exports2, module2) {
    var mapCacheClear = require_mapCacheClear();
    var mapCacheDelete = require_mapCacheDelete();
    var mapCacheGet = require_mapCacheGet();
    var mapCacheHas = require_mapCacheHas();
    var mapCacheSet = require_mapCacheSet();
    function MapCache(entries) {
      var index = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype["delete"] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;
    module2.exports = MapCache;
  }
});

// node_modules/lodash/_stackSet.js
var require_stackSet = __commonJS({
  "node_modules/lodash/_stackSet.js"(exports2, module2) {
    var ListCache = require_ListCache();
    var Map2 = require_Map();
    var MapCache = require_MapCache();
    var LARGE_ARRAY_SIZE = 200;
    function stackSet(key, value) {
      var data = this.__data__;
      if (data instanceof ListCache) {
        var pairs2 = data.__data__;
        if (!Map2 || pairs2.length < LARGE_ARRAY_SIZE - 1) {
          pairs2.push([key, value]);
          this.size = ++data.size;
          return this;
        }
        data = this.__data__ = new MapCache(pairs2);
      }
      data.set(key, value);
      this.size = data.size;
      return this;
    }
    module2.exports = stackSet;
  }
});

// node_modules/lodash/_Stack.js
var require_Stack = __commonJS({
  "node_modules/lodash/_Stack.js"(exports2, module2) {
    var ListCache = require_ListCache();
    var stackClear = require_stackClear();
    var stackDelete = require_stackDelete();
    var stackGet = require_stackGet();
    var stackHas = require_stackHas();
    var stackSet = require_stackSet();
    function Stack(entries) {
      var data = this.__data__ = new ListCache(entries);
      this.size = data.size;
    }
    Stack.prototype.clear = stackClear;
    Stack.prototype["delete"] = stackDelete;
    Stack.prototype.get = stackGet;
    Stack.prototype.has = stackHas;
    Stack.prototype.set = stackSet;
    module2.exports = Stack;
  }
});

// node_modules/lodash/_arrayEach.js
var require_arrayEach = __commonJS({
  "node_modules/lodash/_arrayEach.js"(exports2, module2) {
    function arrayEach(array, iteratee) {
      var index = -1, length = array == null ? 0 : array.length;
      while (++index < length) {
        if (iteratee(array[index], index, array) === false) {
          break;
        }
      }
      return array;
    }
    module2.exports = arrayEach;
  }
});

// node_modules/lodash/_defineProperty.js
var require_defineProperty = __commonJS({
  "node_modules/lodash/_defineProperty.js"(exports2, module2) {
    var getNative = require_getNative();
    var defineProperty = function() {
      try {
        var func = getNative(Object, "defineProperty");
        func({}, "", {});
        return func;
      } catch (e) {
      }
    }();
    module2.exports = defineProperty;
  }
});

// node_modules/lodash/_baseAssignValue.js
var require_baseAssignValue = __commonJS({
  "node_modules/lodash/_baseAssignValue.js"(exports2, module2) {
    var defineProperty = require_defineProperty();
    function baseAssignValue(object, key, value) {
      if (key == "__proto__" && defineProperty) {
        defineProperty(object, key, {
          "configurable": true,
          "enumerable": true,
          "value": value,
          "writable": true
        });
      } else {
        object[key] = value;
      }
    }
    module2.exports = baseAssignValue;
  }
});

// node_modules/lodash/_assignValue.js
var require_assignValue = __commonJS({
  "node_modules/lodash/_assignValue.js"(exports2, module2) {
    var baseAssignValue = require_baseAssignValue();
    var eq = require_eq();
    var objectProto = Object.prototype;
    var hasOwnProperty2 = objectProto.hasOwnProperty;
    function assignValue(object, key, value) {
      var objValue = object[key];
      if (!(hasOwnProperty2.call(object, key) && eq(objValue, value)) || value === void 0 && !(key in object)) {
        baseAssignValue(object, key, value);
      }
    }
    module2.exports = assignValue;
  }
});

// node_modules/lodash/_copyObject.js
var require_copyObject = __commonJS({
  "node_modules/lodash/_copyObject.js"(exports2, module2) {
    var assignValue = require_assignValue();
    var baseAssignValue = require_baseAssignValue();
    function copyObject(source, props, object, customizer) {
      var isNew = !object;
      object || (object = {});
      var index = -1, length = props.length;
      while (++index < length) {
        var key = props[index];
        var newValue = customizer ? customizer(object[key], source[key], key, object, source) : void 0;
        if (newValue === void 0) {
          newValue = source[key];
        }
        if (isNew) {
          baseAssignValue(object, key, newValue);
        } else {
          assignValue(object, key, newValue);
        }
      }
      return object;
    }
    module2.exports = copyObject;
  }
});

// node_modules/lodash/_baseTimes.js
var require_baseTimes = __commonJS({
  "node_modules/lodash/_baseTimes.js"(exports2, module2) {
    function baseTimes(n, iteratee) {
      var index = -1, result = Array(n);
      while (++index < n) {
        result[index] = iteratee(index);
      }
      return result;
    }
    module2.exports = baseTimes;
  }
});

// node_modules/lodash/isObjectLike.js
var require_isObjectLike = __commonJS({
  "node_modules/lodash/isObjectLike.js"(exports2, module2) {
    function isObjectLike(value) {
      return value != null && typeof value == "object";
    }
    module2.exports = isObjectLike;
  }
});

// node_modules/lodash/_baseIsArguments.js
var require_baseIsArguments = __commonJS({
  "node_modules/lodash/_baseIsArguments.js"(exports2, module2) {
    var baseGetTag = require_baseGetTag();
    var isObjectLike = require_isObjectLike();
    var argsTag = "[object Arguments]";
    function baseIsArguments(value) {
      return isObjectLike(value) && baseGetTag(value) == argsTag;
    }
    module2.exports = baseIsArguments;
  }
});

// node_modules/lodash/isArguments.js
var require_isArguments = __commonJS({
  "node_modules/lodash/isArguments.js"(exports2, module2) {
    var baseIsArguments = require_baseIsArguments();
    var isObjectLike = require_isObjectLike();
    var objectProto = Object.prototype;
    var hasOwnProperty2 = objectProto.hasOwnProperty;
    var propertyIsEnumerable = objectProto.propertyIsEnumerable;
    var isArguments = baseIsArguments(/* @__PURE__ */ function() {
      return arguments;
    }()) ? baseIsArguments : function(value) {
      return isObjectLike(value) && hasOwnProperty2.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
    };
    module2.exports = isArguments;
  }
});

// node_modules/lodash/isArray.js
var require_isArray = __commonJS({
  "node_modules/lodash/isArray.js"(exports2, module2) {
    var isArray = Array.isArray;
    module2.exports = isArray;
  }
});

// node_modules/lodash/stubFalse.js
var require_stubFalse = __commonJS({
  "node_modules/lodash/stubFalse.js"(exports2, module2) {
    function stubFalse() {
      return false;
    }
    module2.exports = stubFalse;
  }
});

// node_modules/lodash/isBuffer.js
var require_isBuffer = __commonJS({
  "node_modules/lodash/isBuffer.js"(exports2, module2) {
    var root = require_root();
    var stubFalse = require_stubFalse();
    var freeExports = typeof exports2 == "object" && exports2 && !exports2.nodeType && exports2;
    var freeModule = freeExports && typeof module2 == "object" && module2 && !module2.nodeType && module2;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var Buffer2 = moduleExports ? root.Buffer : void 0;
    var nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : void 0;
    var isBuffer2 = nativeIsBuffer || stubFalse;
    module2.exports = isBuffer2;
  }
});

// node_modules/lodash/_isIndex.js
var require_isIndex = __commonJS({
  "node_modules/lodash/_isIndex.js"(exports2, module2) {
    var MAX_SAFE_INTEGER = 9007199254740991;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    function isIndex(value, length) {
      var type2 = typeof value;
      length = length == null ? MAX_SAFE_INTEGER : length;
      return !!length && (type2 == "number" || type2 != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
    }
    module2.exports = isIndex;
  }
});

// node_modules/lodash/isLength.js
var require_isLength = __commonJS({
  "node_modules/lodash/isLength.js"(exports2, module2) {
    var MAX_SAFE_INTEGER = 9007199254740991;
    function isLength(value) {
      return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }
    module2.exports = isLength;
  }
});

// node_modules/lodash/_baseIsTypedArray.js
var require_baseIsTypedArray = __commonJS({
  "node_modules/lodash/_baseIsTypedArray.js"(exports2, module2) {
    var baseGetTag = require_baseGetTag();
    var isLength = require_isLength();
    var isObjectLike = require_isObjectLike();
    var argsTag = "[object Arguments]";
    var arrayTag = "[object Array]";
    var boolTag = "[object Boolean]";
    var dateTag = "[object Date]";
    var errorTag = "[object Error]";
    var funcTag = "[object Function]";
    var mapTag = "[object Map]";
    var numberTag = "[object Number]";
    var objectTag = "[object Object]";
    var regexpTag = "[object RegExp]";
    var setTag = "[object Set]";
    var stringTag = "[object String]";
    var weakMapTag = "[object WeakMap]";
    var arrayBufferTag = "[object ArrayBuffer]";
    var dataViewTag = "[object DataView]";
    var float32Tag = "[object Float32Array]";
    var float64Tag = "[object Float64Array]";
    var int8Tag = "[object Int8Array]";
    var int16Tag = "[object Int16Array]";
    var int32Tag = "[object Int32Array]";
    var uint8Tag = "[object Uint8Array]";
    var uint8ClampedTag = "[object Uint8ClampedArray]";
    var uint16Tag = "[object Uint16Array]";
    var uint32Tag = "[object Uint32Array]";
    var typedArrayTags = {};
    typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
    typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
    function baseIsTypedArray(value) {
      return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
    }
    module2.exports = baseIsTypedArray;
  }
});

// node_modules/lodash/_baseUnary.js
var require_baseUnary = __commonJS({
  "node_modules/lodash/_baseUnary.js"(exports2, module2) {
    function baseUnary(func) {
      return function(value) {
        return func(value);
      };
    }
    module2.exports = baseUnary;
  }
});

// node_modules/lodash/_nodeUtil.js
var require_nodeUtil = __commonJS({
  "node_modules/lodash/_nodeUtil.js"(exports2, module2) {
    var freeGlobal = require_freeGlobal();
    var freeExports = typeof exports2 == "object" && exports2 && !exports2.nodeType && exports2;
    var freeModule = freeExports && typeof module2 == "object" && module2 && !module2.nodeType && module2;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var freeProcess = moduleExports && freeGlobal.process;
    var nodeUtil = function() {
      try {
        var types3 = freeModule && freeModule.require && freeModule.require("util").types;
        if (types3) {
          return types3;
        }
        return freeProcess && freeProcess.binding && freeProcess.binding("util");
      } catch (e) {
      }
    }();
    module2.exports = nodeUtil;
  }
});

// node_modules/lodash/isTypedArray.js
var require_isTypedArray = __commonJS({
  "node_modules/lodash/isTypedArray.js"(exports2, module2) {
    var baseIsTypedArray = require_baseIsTypedArray();
    var baseUnary = require_baseUnary();
    var nodeUtil = require_nodeUtil();
    var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
    var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
    module2.exports = isTypedArray;
  }
});

// node_modules/lodash/_arrayLikeKeys.js
var require_arrayLikeKeys = __commonJS({
  "node_modules/lodash/_arrayLikeKeys.js"(exports2, module2) {
    var baseTimes = require_baseTimes();
    var isArguments = require_isArguments();
    var isArray = require_isArray();
    var isBuffer2 = require_isBuffer();
    var isIndex = require_isIndex();
    var isTypedArray = require_isTypedArray();
    var objectProto = Object.prototype;
    var hasOwnProperty2 = objectProto.hasOwnProperty;
    function arrayLikeKeys(value, inherited) {
      var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer2(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;
      for (var key in value) {
        if ((inherited || hasOwnProperty2.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
        (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
        isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
        isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
        isIndex(key, length)))) {
          result.push(key);
        }
      }
      return result;
    }
    module2.exports = arrayLikeKeys;
  }
});

// node_modules/lodash/_isPrototype.js
var require_isPrototype = __commonJS({
  "node_modules/lodash/_isPrototype.js"(exports2, module2) {
    var objectProto = Object.prototype;
    function isPrototype(value) {
      var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
      return value === proto;
    }
    module2.exports = isPrototype;
  }
});

// node_modules/lodash/_overArg.js
var require_overArg = __commonJS({
  "node_modules/lodash/_overArg.js"(exports2, module2) {
    function overArg(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }
    module2.exports = overArg;
  }
});

// node_modules/lodash/_nativeKeys.js
var require_nativeKeys = __commonJS({
  "node_modules/lodash/_nativeKeys.js"(exports2, module2) {
    var overArg = require_overArg();
    var nativeKeys = overArg(Object.keys, Object);
    module2.exports = nativeKeys;
  }
});

// node_modules/lodash/_baseKeys.js
var require_baseKeys = __commonJS({
  "node_modules/lodash/_baseKeys.js"(exports2, module2) {
    var isPrototype = require_isPrototype();
    var nativeKeys = require_nativeKeys();
    var objectProto = Object.prototype;
    var hasOwnProperty2 = objectProto.hasOwnProperty;
    function baseKeys(object) {
      if (!isPrototype(object)) {
        return nativeKeys(object);
      }
      var result = [];
      for (var key in Object(object)) {
        if (hasOwnProperty2.call(object, key) && key != "constructor") {
          result.push(key);
        }
      }
      return result;
    }
    module2.exports = baseKeys;
  }
});

// node_modules/lodash/isArrayLike.js
var require_isArrayLike = __commonJS({
  "node_modules/lodash/isArrayLike.js"(exports2, module2) {
    var isFunction = require_isFunction();
    var isLength = require_isLength();
    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction(value);
    }
    module2.exports = isArrayLike;
  }
});

// node_modules/lodash/keys.js
var require_keys = __commonJS({
  "node_modules/lodash/keys.js"(exports2, module2) {
    var arrayLikeKeys = require_arrayLikeKeys();
    var baseKeys = require_baseKeys();
    var isArrayLike = require_isArrayLike();
    function keys(object) {
      return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
    }
    module2.exports = keys;
  }
});

// node_modules/lodash/_baseAssign.js
var require_baseAssign = __commonJS({
  "node_modules/lodash/_baseAssign.js"(exports2, module2) {
    var copyObject = require_copyObject();
    var keys = require_keys();
    function baseAssign(object, source) {
      return object && copyObject(source, keys(source), object);
    }
    module2.exports = baseAssign;
  }
});

// node_modules/lodash/_nativeKeysIn.js
var require_nativeKeysIn = __commonJS({
  "node_modules/lodash/_nativeKeysIn.js"(exports2, module2) {
    function nativeKeysIn(object) {
      var result = [];
      if (object != null) {
        for (var key in Object(object)) {
          result.push(key);
        }
      }
      return result;
    }
    module2.exports = nativeKeysIn;
  }
});

// node_modules/lodash/_baseKeysIn.js
var require_baseKeysIn = __commonJS({
  "node_modules/lodash/_baseKeysIn.js"(exports2, module2) {
    var isObject5 = require_isObject();
    var isPrototype = require_isPrototype();
    var nativeKeysIn = require_nativeKeysIn();
    var objectProto = Object.prototype;
    var hasOwnProperty2 = objectProto.hasOwnProperty;
    function baseKeysIn(object) {
      if (!isObject5(object)) {
        return nativeKeysIn(object);
      }
      var isProto = isPrototype(object), result = [];
      for (var key in object) {
        if (!(key == "constructor" && (isProto || !hasOwnProperty2.call(object, key)))) {
          result.push(key);
        }
      }
      return result;
    }
    module2.exports = baseKeysIn;
  }
});

// node_modules/lodash/keysIn.js
var require_keysIn = __commonJS({
  "node_modules/lodash/keysIn.js"(exports2, module2) {
    var arrayLikeKeys = require_arrayLikeKeys();
    var baseKeysIn = require_baseKeysIn();
    var isArrayLike = require_isArrayLike();
    function keysIn(object) {
      return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
    }
    module2.exports = keysIn;
  }
});

// node_modules/lodash/_baseAssignIn.js
var require_baseAssignIn = __commonJS({
  "node_modules/lodash/_baseAssignIn.js"(exports2, module2) {
    var copyObject = require_copyObject();
    var keysIn = require_keysIn();
    function baseAssignIn(object, source) {
      return object && copyObject(source, keysIn(source), object);
    }
    module2.exports = baseAssignIn;
  }
});

// node_modules/lodash/_cloneBuffer.js
var require_cloneBuffer = __commonJS({
  "node_modules/lodash/_cloneBuffer.js"(exports2, module2) {
    var root = require_root();
    var freeExports = typeof exports2 == "object" && exports2 && !exports2.nodeType && exports2;
    var freeModule = freeExports && typeof module2 == "object" && module2 && !module2.nodeType && module2;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var Buffer2 = moduleExports ? root.Buffer : void 0;
    var allocUnsafe = Buffer2 ? Buffer2.allocUnsafe : void 0;
    function cloneBuffer(buffer, isDeep) {
      if (isDeep) {
        return buffer.slice();
      }
      var length = buffer.length, result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
      buffer.copy(result);
      return result;
    }
    module2.exports = cloneBuffer;
  }
});

// node_modules/lodash/_copyArray.js
var require_copyArray = __commonJS({
  "node_modules/lodash/_copyArray.js"(exports2, module2) {
    function copyArray(source, array) {
      var index = -1, length = source.length;
      array || (array = Array(length));
      while (++index < length) {
        array[index] = source[index];
      }
      return array;
    }
    module2.exports = copyArray;
  }
});

// node_modules/lodash/_arrayFilter.js
var require_arrayFilter = __commonJS({
  "node_modules/lodash/_arrayFilter.js"(exports2, module2) {
    function arrayFilter(array, predicate) {
      var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
      while (++index < length) {
        var value = array[index];
        if (predicate(value, index, array)) {
          result[resIndex++] = value;
        }
      }
      return result;
    }
    module2.exports = arrayFilter;
  }
});

// node_modules/lodash/stubArray.js
var require_stubArray = __commonJS({
  "node_modules/lodash/stubArray.js"(exports2, module2) {
    function stubArray() {
      return [];
    }
    module2.exports = stubArray;
  }
});

// node_modules/lodash/_getSymbols.js
var require_getSymbols = __commonJS({
  "node_modules/lodash/_getSymbols.js"(exports2, module2) {
    var arrayFilter = require_arrayFilter();
    var stubArray = require_stubArray();
    var objectProto = Object.prototype;
    var propertyIsEnumerable = objectProto.propertyIsEnumerable;
    var nativeGetSymbols = Object.getOwnPropertySymbols;
    var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
      if (object == null) {
        return [];
      }
      object = Object(object);
      return arrayFilter(nativeGetSymbols(object), function(symbol) {
        return propertyIsEnumerable.call(object, symbol);
      });
    };
    module2.exports = getSymbols;
  }
});

// node_modules/lodash/_copySymbols.js
var require_copySymbols = __commonJS({
  "node_modules/lodash/_copySymbols.js"(exports2, module2) {
    var copyObject = require_copyObject();
    var getSymbols = require_getSymbols();
    function copySymbols(source, object) {
      return copyObject(source, getSymbols(source), object);
    }
    module2.exports = copySymbols;
  }
});

// node_modules/lodash/_arrayPush.js
var require_arrayPush = __commonJS({
  "node_modules/lodash/_arrayPush.js"(exports2, module2) {
    function arrayPush(array, values) {
      var index = -1, length = values.length, offset = array.length;
      while (++index < length) {
        array[offset + index] = values[index];
      }
      return array;
    }
    module2.exports = arrayPush;
  }
});

// node_modules/lodash/_getPrototype.js
var require_getPrototype = __commonJS({
  "node_modules/lodash/_getPrototype.js"(exports2, module2) {
    var overArg = require_overArg();
    var getPrototype = overArg(Object.getPrototypeOf, Object);
    module2.exports = getPrototype;
  }
});

// node_modules/lodash/_getSymbolsIn.js
var require_getSymbolsIn = __commonJS({
  "node_modules/lodash/_getSymbolsIn.js"(exports2, module2) {
    var arrayPush = require_arrayPush();
    var getPrototype = require_getPrototype();
    var getSymbols = require_getSymbols();
    var stubArray = require_stubArray();
    var nativeGetSymbols = Object.getOwnPropertySymbols;
    var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
      var result = [];
      while (object) {
        arrayPush(result, getSymbols(object));
        object = getPrototype(object);
      }
      return result;
    };
    module2.exports = getSymbolsIn;
  }
});

// node_modules/lodash/_copySymbolsIn.js
var require_copySymbolsIn = __commonJS({
  "node_modules/lodash/_copySymbolsIn.js"(exports2, module2) {
    var copyObject = require_copyObject();
    var getSymbolsIn = require_getSymbolsIn();
    function copySymbolsIn(source, object) {
      return copyObject(source, getSymbolsIn(source), object);
    }
    module2.exports = copySymbolsIn;
  }
});

// node_modules/lodash/_baseGetAllKeys.js
var require_baseGetAllKeys = __commonJS({
  "node_modules/lodash/_baseGetAllKeys.js"(exports2, module2) {
    var arrayPush = require_arrayPush();
    var isArray = require_isArray();
    function baseGetAllKeys(object, keysFunc, symbolsFunc) {
      var result = keysFunc(object);
      return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
    }
    module2.exports = baseGetAllKeys;
  }
});

// node_modules/lodash/_getAllKeys.js
var require_getAllKeys = __commonJS({
  "node_modules/lodash/_getAllKeys.js"(exports2, module2) {
    var baseGetAllKeys = require_baseGetAllKeys();
    var getSymbols = require_getSymbols();
    var keys = require_keys();
    function getAllKeys(object) {
      return baseGetAllKeys(object, keys, getSymbols);
    }
    module2.exports = getAllKeys;
  }
});

// node_modules/lodash/_getAllKeysIn.js
var require_getAllKeysIn = __commonJS({
  "node_modules/lodash/_getAllKeysIn.js"(exports2, module2) {
    var baseGetAllKeys = require_baseGetAllKeys();
    var getSymbolsIn = require_getSymbolsIn();
    var keysIn = require_keysIn();
    function getAllKeysIn(object) {
      return baseGetAllKeys(object, keysIn, getSymbolsIn);
    }
    module2.exports = getAllKeysIn;
  }
});

// node_modules/lodash/_DataView.js
var require_DataView = __commonJS({
  "node_modules/lodash/_DataView.js"(exports2, module2) {
    var getNative = require_getNative();
    var root = require_root();
    var DataView2 = getNative(root, "DataView");
    module2.exports = DataView2;
  }
});

// node_modules/lodash/_Promise.js
var require_Promise = __commonJS({
  "node_modules/lodash/_Promise.js"(exports2, module2) {
    var getNative = require_getNative();
    var root = require_root();
    var Promise2 = getNative(root, "Promise");
    module2.exports = Promise2;
  }
});

// node_modules/lodash/_Set.js
var require_Set = __commonJS({
  "node_modules/lodash/_Set.js"(exports2, module2) {
    var getNative = require_getNative();
    var root = require_root();
    var Set2 = getNative(root, "Set");
    module2.exports = Set2;
  }
});

// node_modules/lodash/_WeakMap.js
var require_WeakMap = __commonJS({
  "node_modules/lodash/_WeakMap.js"(exports2, module2) {
    var getNative = require_getNative();
    var root = require_root();
    var WeakMap2 = getNative(root, "WeakMap");
    module2.exports = WeakMap2;
  }
});

// node_modules/lodash/_getTag.js
var require_getTag = __commonJS({
  "node_modules/lodash/_getTag.js"(exports2, module2) {
    var DataView2 = require_DataView();
    var Map2 = require_Map();
    var Promise2 = require_Promise();
    var Set2 = require_Set();
    var WeakMap2 = require_WeakMap();
    var baseGetTag = require_baseGetTag();
    var toSource = require_toSource();
    var mapTag = "[object Map]";
    var objectTag = "[object Object]";
    var promiseTag = "[object Promise]";
    var setTag = "[object Set]";
    var weakMapTag = "[object WeakMap]";
    var dataViewTag = "[object DataView]";
    var dataViewCtorString = toSource(DataView2);
    var mapCtorString = toSource(Map2);
    var promiseCtorString = toSource(Promise2);
    var setCtorString = toSource(Set2);
    var weakMapCtorString = toSource(WeakMap2);
    var getTag = baseGetTag;
    if (DataView2 && getTag(new DataView2(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap2 && getTag(new WeakMap2()) != weakMapTag) {
      getTag = function(value) {
        var result = baseGetTag(value), Ctor = result == objectTag ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : "";
        if (ctorString) {
          switch (ctorString) {
            case dataViewCtorString:
              return dataViewTag;
            case mapCtorString:
              return mapTag;
            case promiseCtorString:
              return promiseTag;
            case setCtorString:
              return setTag;
            case weakMapCtorString:
              return weakMapTag;
          }
        }
        return result;
      };
    }
    module2.exports = getTag;
  }
});

// node_modules/lodash/_initCloneArray.js
var require_initCloneArray = __commonJS({
  "node_modules/lodash/_initCloneArray.js"(exports2, module2) {
    var objectProto = Object.prototype;
    var hasOwnProperty2 = objectProto.hasOwnProperty;
    function initCloneArray(array) {
      var length = array.length, result = new array.constructor(length);
      if (length && typeof array[0] == "string" && hasOwnProperty2.call(array, "index")) {
        result.index = array.index;
        result.input = array.input;
      }
      return result;
    }
    module2.exports = initCloneArray;
  }
});

// node_modules/lodash/_Uint8Array.js
var require_Uint8Array = __commonJS({
  "node_modules/lodash/_Uint8Array.js"(exports2, module2) {
    var root = require_root();
    var Uint8Array2 = root.Uint8Array;
    module2.exports = Uint8Array2;
  }
});

// node_modules/lodash/_cloneArrayBuffer.js
var require_cloneArrayBuffer = __commonJS({
  "node_modules/lodash/_cloneArrayBuffer.js"(exports2, module2) {
    var Uint8Array2 = require_Uint8Array();
    function cloneArrayBuffer(arrayBuffer) {
      var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
      new Uint8Array2(result).set(new Uint8Array2(arrayBuffer));
      return result;
    }
    module2.exports = cloneArrayBuffer;
  }
});

// node_modules/lodash/_cloneDataView.js
var require_cloneDataView = __commonJS({
  "node_modules/lodash/_cloneDataView.js"(exports2, module2) {
    var cloneArrayBuffer = require_cloneArrayBuffer();
    function cloneDataView(dataView, isDeep) {
      var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
      return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
    }
    module2.exports = cloneDataView;
  }
});

// node_modules/lodash/_cloneRegExp.js
var require_cloneRegExp = __commonJS({
  "node_modules/lodash/_cloneRegExp.js"(exports2, module2) {
    var reFlags = /\w*$/;
    function cloneRegExp(regexp) {
      var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
      result.lastIndex = regexp.lastIndex;
      return result;
    }
    module2.exports = cloneRegExp;
  }
});

// node_modules/lodash/_cloneSymbol.js
var require_cloneSymbol = __commonJS({
  "node_modules/lodash/_cloneSymbol.js"(exports2, module2) {
    var Symbol2 = require_Symbol();
    var symbolProto = Symbol2 ? Symbol2.prototype : void 0;
    var symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
    function cloneSymbol(symbol) {
      return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
    }
    module2.exports = cloneSymbol;
  }
});

// node_modules/lodash/_cloneTypedArray.js
var require_cloneTypedArray = __commonJS({
  "node_modules/lodash/_cloneTypedArray.js"(exports2, module2) {
    var cloneArrayBuffer = require_cloneArrayBuffer();
    function cloneTypedArray(typedArray, isDeep) {
      var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
      return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
    }
    module2.exports = cloneTypedArray;
  }
});

// node_modules/lodash/_initCloneByTag.js
var require_initCloneByTag = __commonJS({
  "node_modules/lodash/_initCloneByTag.js"(exports2, module2) {
    var cloneArrayBuffer = require_cloneArrayBuffer();
    var cloneDataView = require_cloneDataView();
    var cloneRegExp = require_cloneRegExp();
    var cloneSymbol = require_cloneSymbol();
    var cloneTypedArray = require_cloneTypedArray();
    var boolTag = "[object Boolean]";
    var dateTag = "[object Date]";
    var mapTag = "[object Map]";
    var numberTag = "[object Number]";
    var regexpTag = "[object RegExp]";
    var setTag = "[object Set]";
    var stringTag = "[object String]";
    var symbolTag = "[object Symbol]";
    var arrayBufferTag = "[object ArrayBuffer]";
    var dataViewTag = "[object DataView]";
    var float32Tag = "[object Float32Array]";
    var float64Tag = "[object Float64Array]";
    var int8Tag = "[object Int8Array]";
    var int16Tag = "[object Int16Array]";
    var int32Tag = "[object Int32Array]";
    var uint8Tag = "[object Uint8Array]";
    var uint8ClampedTag = "[object Uint8ClampedArray]";
    var uint16Tag = "[object Uint16Array]";
    var uint32Tag = "[object Uint32Array]";
    function initCloneByTag(object, tag, isDeep) {
      var Ctor = object.constructor;
      switch (tag) {
        case arrayBufferTag:
          return cloneArrayBuffer(object);
        case boolTag:
        case dateTag:
          return new Ctor(+object);
        case dataViewTag:
          return cloneDataView(object, isDeep);
        case float32Tag:
        case float64Tag:
        case int8Tag:
        case int16Tag:
        case int32Tag:
        case uint8Tag:
        case uint8ClampedTag:
        case uint16Tag:
        case uint32Tag:
          return cloneTypedArray(object, isDeep);
        case mapTag:
          return new Ctor();
        case numberTag:
        case stringTag:
          return new Ctor(object);
        case regexpTag:
          return cloneRegExp(object);
        case setTag:
          return new Ctor();
        case symbolTag:
          return cloneSymbol(object);
      }
    }
    module2.exports = initCloneByTag;
  }
});

// node_modules/lodash/_baseCreate.js
var require_baseCreate = __commonJS({
  "node_modules/lodash/_baseCreate.js"(exports2, module2) {
    var isObject5 = require_isObject();
    var objectCreate = Object.create;
    var baseCreate = /* @__PURE__ */ function() {
      function object() {
      }
      return function(proto) {
        if (!isObject5(proto)) {
          return {};
        }
        if (objectCreate) {
          return objectCreate(proto);
        }
        object.prototype = proto;
        var result = new object();
        object.prototype = void 0;
        return result;
      };
    }();
    module2.exports = baseCreate;
  }
});

// node_modules/lodash/_initCloneObject.js
var require_initCloneObject = __commonJS({
  "node_modules/lodash/_initCloneObject.js"(exports2, module2) {
    var baseCreate = require_baseCreate();
    var getPrototype = require_getPrototype();
    var isPrototype = require_isPrototype();
    function initCloneObject(object) {
      return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
    }
    module2.exports = initCloneObject;
  }
});

// node_modules/lodash/_baseIsMap.js
var require_baseIsMap = __commonJS({
  "node_modules/lodash/_baseIsMap.js"(exports2, module2) {
    var getTag = require_getTag();
    var isObjectLike = require_isObjectLike();
    var mapTag = "[object Map]";
    function baseIsMap(value) {
      return isObjectLike(value) && getTag(value) == mapTag;
    }
    module2.exports = baseIsMap;
  }
});

// node_modules/lodash/isMap.js
var require_isMap = __commonJS({
  "node_modules/lodash/isMap.js"(exports2, module2) {
    var baseIsMap = require_baseIsMap();
    var baseUnary = require_baseUnary();
    var nodeUtil = require_nodeUtil();
    var nodeIsMap = nodeUtil && nodeUtil.isMap;
    var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
    module2.exports = isMap;
  }
});

// node_modules/lodash/_baseIsSet.js
var require_baseIsSet = __commonJS({
  "node_modules/lodash/_baseIsSet.js"(exports2, module2) {
    var getTag = require_getTag();
    var isObjectLike = require_isObjectLike();
    var setTag = "[object Set]";
    function baseIsSet(value) {
      return isObjectLike(value) && getTag(value) == setTag;
    }
    module2.exports = baseIsSet;
  }
});

// node_modules/lodash/isSet.js
var require_isSet = __commonJS({
  "node_modules/lodash/isSet.js"(exports2, module2) {
    var baseIsSet = require_baseIsSet();
    var baseUnary = require_baseUnary();
    var nodeUtil = require_nodeUtil();
    var nodeIsSet = nodeUtil && nodeUtil.isSet;
    var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
    module2.exports = isSet;
  }
});

// node_modules/lodash/_baseClone.js
var require_baseClone = __commonJS({
  "node_modules/lodash/_baseClone.js"(exports2, module2) {
    var Stack = require_Stack();
    var arrayEach = require_arrayEach();
    var assignValue = require_assignValue();
    var baseAssign = require_baseAssign();
    var baseAssignIn = require_baseAssignIn();
    var cloneBuffer = require_cloneBuffer();
    var copyArray = require_copyArray();
    var copySymbols = require_copySymbols();
    var copySymbolsIn = require_copySymbolsIn();
    var getAllKeys = require_getAllKeys();
    var getAllKeysIn = require_getAllKeysIn();
    var getTag = require_getTag();
    var initCloneArray = require_initCloneArray();
    var initCloneByTag = require_initCloneByTag();
    var initCloneObject = require_initCloneObject();
    var isArray = require_isArray();
    var isBuffer2 = require_isBuffer();
    var isMap = require_isMap();
    var isObject5 = require_isObject();
    var isSet = require_isSet();
    var keys = require_keys();
    var keysIn = require_keysIn();
    var CLONE_DEEP_FLAG = 1;
    var CLONE_FLAT_FLAG = 2;
    var CLONE_SYMBOLS_FLAG = 4;
    var argsTag = "[object Arguments]";
    var arrayTag = "[object Array]";
    var boolTag = "[object Boolean]";
    var dateTag = "[object Date]";
    var errorTag = "[object Error]";
    var funcTag = "[object Function]";
    var genTag = "[object GeneratorFunction]";
    var mapTag = "[object Map]";
    var numberTag = "[object Number]";
    var objectTag = "[object Object]";
    var regexpTag = "[object RegExp]";
    var setTag = "[object Set]";
    var stringTag = "[object String]";
    var symbolTag = "[object Symbol]";
    var weakMapTag = "[object WeakMap]";
    var arrayBufferTag = "[object ArrayBuffer]";
    var dataViewTag = "[object DataView]";
    var float32Tag = "[object Float32Array]";
    var float64Tag = "[object Float64Array]";
    var int8Tag = "[object Int8Array]";
    var int16Tag = "[object Int16Array]";
    var int32Tag = "[object Int32Array]";
    var uint8Tag = "[object Uint8Array]";
    var uint8ClampedTag = "[object Uint8ClampedArray]";
    var uint16Tag = "[object Uint16Array]";
    var uint32Tag = "[object Uint32Array]";
    var cloneableTags = {};
    cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
    cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
    function baseClone(value, bitmask, customizer, key, object, stack) {
      var result, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG;
      if (customizer) {
        result = object ? customizer(value, key, object, stack) : customizer(value);
      }
      if (result !== void 0) {
        return result;
      }
      if (!isObject5(value)) {
        return value;
      }
      var isArr = isArray(value);
      if (isArr) {
        result = initCloneArray(value);
        if (!isDeep) {
          return copyArray(value, result);
        }
      } else {
        var tag = getTag(value), isFunc2 = tag == funcTag || tag == genTag;
        if (isBuffer2(value)) {
          return cloneBuffer(value, isDeep);
        }
        if (tag == objectTag || tag == argsTag || isFunc2 && !object) {
          result = isFlat || isFunc2 ? {} : initCloneObject(value);
          if (!isDeep) {
            return isFlat ? copySymbolsIn(value, baseAssignIn(result, value)) : copySymbols(value, baseAssign(result, value));
          }
        } else {
          if (!cloneableTags[tag]) {
            return object ? value : {};
          }
          result = initCloneByTag(value, tag, isDeep);
        }
      }
      stack || (stack = new Stack());
      var stacked = stack.get(value);
      if (stacked) {
        return stacked;
      }
      stack.set(value, result);
      if (isSet(value)) {
        value.forEach(function(subValue) {
          result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
        });
      } else if (isMap(value)) {
        value.forEach(function(subValue, key2) {
          result.set(key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
        });
      }
      var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys;
      var props = isArr ? void 0 : keysFunc(value);
      arrayEach(props || value, function(subValue, key2) {
        if (props) {
          key2 = subValue;
          subValue = value[key2];
        }
        assignValue(result, key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
      });
      return result;
    }
    module2.exports = baseClone;
  }
});

// node_modules/lodash/cloneDeep.js
var require_cloneDeep = __commonJS({
  "node_modules/lodash/cloneDeep.js"(exports2, module2) {
    var baseClone = require_baseClone();
    var CLONE_DEEP_FLAG = 1;
    var CLONE_SYMBOLS_FLAG = 4;
    function cloneDeep(value) {
      return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
    }
    module2.exports = cloneDeep;
  }
});

// node_modules/lodash/_setCacheAdd.js
var require_setCacheAdd = __commonJS({
  "node_modules/lodash/_setCacheAdd.js"(exports2, module2) {
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    function setCacheAdd(value) {
      this.__data__.set(value, HASH_UNDEFINED);
      return this;
    }
    module2.exports = setCacheAdd;
  }
});

// node_modules/lodash/_setCacheHas.js
var require_setCacheHas = __commonJS({
  "node_modules/lodash/_setCacheHas.js"(exports2, module2) {
    function setCacheHas(value) {
      return this.__data__.has(value);
    }
    module2.exports = setCacheHas;
  }
});

// node_modules/lodash/_SetCache.js
var require_SetCache = __commonJS({
  "node_modules/lodash/_SetCache.js"(exports2, module2) {
    var MapCache = require_MapCache();
    var setCacheAdd = require_setCacheAdd();
    var setCacheHas = require_setCacheHas();
    function SetCache(values) {
      var index = -1, length = values == null ? 0 : values.length;
      this.__data__ = new MapCache();
      while (++index < length) {
        this.add(values[index]);
      }
    }
    SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
    SetCache.prototype.has = setCacheHas;
    module2.exports = SetCache;
  }
});

// node_modules/lodash/_arraySome.js
var require_arraySome = __commonJS({
  "node_modules/lodash/_arraySome.js"(exports2, module2) {
    function arraySome(array, predicate) {
      var index = -1, length = array == null ? 0 : array.length;
      while (++index < length) {
        if (predicate(array[index], index, array)) {
          return true;
        }
      }
      return false;
    }
    module2.exports = arraySome;
  }
});

// node_modules/lodash/_cacheHas.js
var require_cacheHas = __commonJS({
  "node_modules/lodash/_cacheHas.js"(exports2, module2) {
    function cacheHas(cache, key) {
      return cache.has(key);
    }
    module2.exports = cacheHas;
  }
});

// node_modules/lodash/_equalArrays.js
var require_equalArrays = __commonJS({
  "node_modules/lodash/_equalArrays.js"(exports2, module2) {
    var SetCache = require_SetCache();
    var arraySome = require_arraySome();
    var cacheHas = require_cacheHas();
    var COMPARE_PARTIAL_FLAG = 1;
    var COMPARE_UNORDERED_FLAG = 2;
    function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array.length, othLength = other.length;
      if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
        return false;
      }
      var arrStacked = stack.get(array);
      var othStacked = stack.get(other);
      if (arrStacked && othStacked) {
        return arrStacked == other && othStacked == array;
      }
      var index = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : void 0;
      stack.set(array, other);
      stack.set(other, array);
      while (++index < arrLength) {
        var arrValue = array[index], othValue = other[index];
        if (customizer) {
          var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
        }
        if (compared !== void 0) {
          if (compared) {
            continue;
          }
          result = false;
          break;
        }
        if (seen) {
          if (!arraySome(other, function(othValue2, othIndex) {
            if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
              return seen.push(othIndex);
            }
          })) {
            result = false;
            break;
          }
        } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
          result = false;
          break;
        }
      }
      stack["delete"](array);
      stack["delete"](other);
      return result;
    }
    module2.exports = equalArrays;
  }
});

// node_modules/lodash/_mapToArray.js
var require_mapToArray = __commonJS({
  "node_modules/lodash/_mapToArray.js"(exports2, module2) {
    function mapToArray(map2) {
      var index = -1, result = Array(map2.size);
      map2.forEach(function(value, key) {
        result[++index] = [key, value];
      });
      return result;
    }
    module2.exports = mapToArray;
  }
});

// node_modules/lodash/_setToArray.js
var require_setToArray = __commonJS({
  "node_modules/lodash/_setToArray.js"(exports2, module2) {
    function setToArray(set3) {
      var index = -1, result = Array(set3.size);
      set3.forEach(function(value) {
        result[++index] = value;
      });
      return result;
    }
    module2.exports = setToArray;
  }
});

// node_modules/lodash/_equalByTag.js
var require_equalByTag = __commonJS({
  "node_modules/lodash/_equalByTag.js"(exports2, module2) {
    var Symbol2 = require_Symbol();
    var Uint8Array2 = require_Uint8Array();
    var eq = require_eq();
    var equalArrays = require_equalArrays();
    var mapToArray = require_mapToArray();
    var setToArray = require_setToArray();
    var COMPARE_PARTIAL_FLAG = 1;
    var COMPARE_UNORDERED_FLAG = 2;
    var boolTag = "[object Boolean]";
    var dateTag = "[object Date]";
    var errorTag = "[object Error]";
    var mapTag = "[object Map]";
    var numberTag = "[object Number]";
    var regexpTag = "[object RegExp]";
    var setTag = "[object Set]";
    var stringTag = "[object String]";
    var symbolTag = "[object Symbol]";
    var arrayBufferTag = "[object ArrayBuffer]";
    var dataViewTag = "[object DataView]";
    var symbolProto = Symbol2 ? Symbol2.prototype : void 0;
    var symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
    function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
      switch (tag) {
        case dataViewTag:
          if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
            return false;
          }
          object = object.buffer;
          other = other.buffer;
        case arrayBufferTag:
          if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object), new Uint8Array2(other))) {
            return false;
          }
          return true;
        case boolTag:
        case dateTag:
        case numberTag:
          return eq(+object, +other);
        case errorTag:
          return object.name == other.name && object.message == other.message;
        case regexpTag:
        case stringTag:
          return object == other + "";
        case mapTag:
          var convert2 = mapToArray;
        case setTag:
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
          convert2 || (convert2 = setToArray);
          if (object.size != other.size && !isPartial) {
            return false;
          }
          var stacked = stack.get(object);
          if (stacked) {
            return stacked == other;
          }
          bitmask |= COMPARE_UNORDERED_FLAG;
          stack.set(object, other);
          var result = equalArrays(convert2(object), convert2(other), bitmask, customizer, equalFunc, stack);
          stack["delete"](object);
          return result;
        case symbolTag:
          if (symbolValueOf) {
            return symbolValueOf.call(object) == symbolValueOf.call(other);
          }
      }
      return false;
    }
    module2.exports = equalByTag;
  }
});

// node_modules/lodash/_equalObjects.js
var require_equalObjects = __commonJS({
  "node_modules/lodash/_equalObjects.js"(exports2, module2) {
    var getAllKeys = require_getAllKeys();
    var COMPARE_PARTIAL_FLAG = 1;
    var objectProto = Object.prototype;
    var hasOwnProperty2 = objectProto.hasOwnProperty;
    function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
      if (objLength != othLength && !isPartial) {
        return false;
      }
      var index = objLength;
      while (index--) {
        var key = objProps[index];
        if (!(isPartial ? key in other : hasOwnProperty2.call(other, key))) {
          return false;
        }
      }
      var objStacked = stack.get(object);
      var othStacked = stack.get(other);
      if (objStacked && othStacked) {
        return objStacked == other && othStacked == object;
      }
      var result = true;
      stack.set(object, other);
      stack.set(other, object);
      var skipCtor = isPartial;
      while (++index < objLength) {
        key = objProps[index];
        var objValue = object[key], othValue = other[key];
        if (customizer) {
          var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
        }
        if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
          result = false;
          break;
        }
        skipCtor || (skipCtor = key == "constructor");
      }
      if (result && !skipCtor) {
        var objCtor = object.constructor, othCtor = other.constructor;
        if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
          result = false;
        }
      }
      stack["delete"](object);
      stack["delete"](other);
      return result;
    }
    module2.exports = equalObjects;
  }
});

// node_modules/lodash/_baseIsEqualDeep.js
var require_baseIsEqualDeep = __commonJS({
  "node_modules/lodash/_baseIsEqualDeep.js"(exports2, module2) {
    var Stack = require_Stack();
    var equalArrays = require_equalArrays();
    var equalByTag = require_equalByTag();
    var equalObjects = require_equalObjects();
    var getTag = require_getTag();
    var isArray = require_isArray();
    var isBuffer2 = require_isBuffer();
    var isTypedArray = require_isTypedArray();
    var COMPARE_PARTIAL_FLAG = 1;
    var argsTag = "[object Arguments]";
    var arrayTag = "[object Array]";
    var objectTag = "[object Object]";
    var objectProto = Object.prototype;
    var hasOwnProperty2 = objectProto.hasOwnProperty;
    function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
      var objIsArr = isArray(object), othIsArr = isArray(other), objTag = objIsArr ? arrayTag : getTag(object), othTag = othIsArr ? arrayTag : getTag(other);
      objTag = objTag == argsTag ? objectTag : objTag;
      othTag = othTag == argsTag ? objectTag : othTag;
      var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
      if (isSameTag && isBuffer2(object)) {
        if (!isBuffer2(other)) {
          return false;
        }
        objIsArr = true;
        objIsObj = false;
      }
      if (isSameTag && !objIsObj) {
        stack || (stack = new Stack());
        return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
      }
      if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
        var objIsWrapped = objIsObj && hasOwnProperty2.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty2.call(other, "__wrapped__");
        if (objIsWrapped || othIsWrapped) {
          var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
          stack || (stack = new Stack());
          return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
        }
      }
      if (!isSameTag) {
        return false;
      }
      stack || (stack = new Stack());
      return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
    }
    module2.exports = baseIsEqualDeep;
  }
});

// node_modules/lodash/_baseIsEqual.js
var require_baseIsEqual = __commonJS({
  "node_modules/lodash/_baseIsEqual.js"(exports2, module2) {
    var baseIsEqualDeep = require_baseIsEqualDeep();
    var isObjectLike = require_isObjectLike();
    function baseIsEqual(value, other, bitmask, customizer, stack) {
      if (value === other) {
        return true;
      }
      if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
        return value !== value && other !== other;
      }
      return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
    }
    module2.exports = baseIsEqual;
  }
});

// node_modules/lodash/isEqual.js
var require_isEqual = __commonJS({
  "node_modules/lodash/isEqual.js"(exports2, module2) {
    var baseIsEqual = require_baseIsEqual();
    function isEqual(value, other) {
      return baseIsEqual(value, other);
    }
    module2.exports = isEqual;
  }
});

// node_modules/lodash/_isFlattenable.js
var require_isFlattenable = __commonJS({
  "node_modules/lodash/_isFlattenable.js"(exports2, module2) {
    var Symbol2 = require_Symbol();
    var isArguments = require_isArguments();
    var isArray = require_isArray();
    var spreadableSymbol = Symbol2 ? Symbol2.isConcatSpreadable : void 0;
    function isFlattenable(value) {
      return isArray(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
    }
    module2.exports = isFlattenable;
  }
});

// node_modules/lodash/_baseFlatten.js
var require_baseFlatten = __commonJS({
  "node_modules/lodash/_baseFlatten.js"(exports2, module2) {
    var arrayPush = require_arrayPush();
    var isFlattenable = require_isFlattenable();
    function baseFlatten(array, depth, predicate, isStrict, result) {
      var index = -1, length = array.length;
      predicate || (predicate = isFlattenable);
      result || (result = []);
      while (++index < length) {
        var value = array[index];
        if (depth > 0 && predicate(value)) {
          if (depth > 1) {
            baseFlatten(value, depth - 1, predicate, isStrict, result);
          } else {
            arrayPush(result, value);
          }
        } else if (!isStrict) {
          result[result.length] = value;
        }
      }
      return result;
    }
    module2.exports = baseFlatten;
  }
});

// node_modules/lodash/_arrayMap.js
var require_arrayMap = __commonJS({
  "node_modules/lodash/_arrayMap.js"(exports2, module2) {
    function arrayMap(array, iteratee) {
      var index = -1, length = array == null ? 0 : array.length, result = Array(length);
      while (++index < length) {
        result[index] = iteratee(array[index], index, array);
      }
      return result;
    }
    module2.exports = arrayMap;
  }
});

// node_modules/lodash/isSymbol.js
var require_isSymbol = __commonJS({
  "node_modules/lodash/isSymbol.js"(exports2, module2) {
    var baseGetTag = require_baseGetTag();
    var isObjectLike = require_isObjectLike();
    var symbolTag = "[object Symbol]";
    function isSymbol(value) {
      return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag;
    }
    module2.exports = isSymbol;
  }
});

// node_modules/lodash/_isKey.js
var require_isKey = __commonJS({
  "node_modules/lodash/_isKey.js"(exports2, module2) {
    var isArray = require_isArray();
    var isSymbol = require_isSymbol();
    var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/;
    var reIsPlainProp = /^\w*$/;
    function isKey(value, object) {
      if (isArray(value)) {
        return false;
      }
      var type2 = typeof value;
      if (type2 == "number" || type2 == "symbol" || type2 == "boolean" || value == null || isSymbol(value)) {
        return true;
      }
      return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
    }
    module2.exports = isKey;
  }
});

// node_modules/lodash/memoize.js
var require_memoize = __commonJS({
  "node_modules/lodash/memoize.js"(exports2, module2) {
    var MapCache = require_MapCache();
    var FUNC_ERROR_TEXT = "Expected a function";
    function memoize2(func, resolver) {
      if (typeof func != "function" || resolver != null && typeof resolver != "function") {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      var memoized = function() {
        var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
        if (cache.has(key)) {
          return cache.get(key);
        }
        var result = func.apply(this, args);
        memoized.cache = cache.set(key, result) || cache;
        return result;
      };
      memoized.cache = new (memoize2.Cache || MapCache)();
      return memoized;
    }
    memoize2.Cache = MapCache;
    module2.exports = memoize2;
  }
});

// node_modules/lodash/_memoizeCapped.js
var require_memoizeCapped = __commonJS({
  "node_modules/lodash/_memoizeCapped.js"(exports2, module2) {
    var memoize2 = require_memoize();
    var MAX_MEMOIZE_SIZE = 500;
    function memoizeCapped(func) {
      var result = memoize2(func, function(key) {
        if (cache.size === MAX_MEMOIZE_SIZE) {
          cache.clear();
        }
        return key;
      });
      var cache = result.cache;
      return result;
    }
    module2.exports = memoizeCapped;
  }
});

// node_modules/lodash/_stringToPath.js
var require_stringToPath = __commonJS({
  "node_modules/lodash/_stringToPath.js"(exports2, module2) {
    var memoizeCapped = require_memoizeCapped();
    var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
    var reEscapeChar = /\\(\\)?/g;
    var stringToPath = memoizeCapped(function(string) {
      var result = [];
      if (string.charCodeAt(0) === 46) {
        result.push("");
      }
      string.replace(rePropName, function(match2, number, quote2, subString) {
        result.push(quote2 ? subString.replace(reEscapeChar, "$1") : number || match2);
      });
      return result;
    });
    module2.exports = stringToPath;
  }
});

// node_modules/lodash/_baseToString.js
var require_baseToString = __commonJS({
  "node_modules/lodash/_baseToString.js"(exports2, module2) {
    var Symbol2 = require_Symbol();
    var arrayMap = require_arrayMap();
    var isArray = require_isArray();
    var isSymbol = require_isSymbol();
    var INFINITY = 1 / 0;
    var symbolProto = Symbol2 ? Symbol2.prototype : void 0;
    var symbolToString = symbolProto ? symbolProto.toString : void 0;
    function baseToString(value) {
      if (typeof value == "string") {
        return value;
      }
      if (isArray(value)) {
        return arrayMap(value, baseToString) + "";
      }
      if (isSymbol(value)) {
        return symbolToString ? symbolToString.call(value) : "";
      }
      var result = value + "";
      return result == "0" && 1 / value == -INFINITY ? "-0" : result;
    }
    module2.exports = baseToString;
  }
});

// node_modules/lodash/toString.js
var require_toString = __commonJS({
  "node_modules/lodash/toString.js"(exports2, module2) {
    var baseToString = require_baseToString();
    function toString2(value) {
      return value == null ? "" : baseToString(value);
    }
    module2.exports = toString2;
  }
});

// node_modules/lodash/_castPath.js
var require_castPath = __commonJS({
  "node_modules/lodash/_castPath.js"(exports2, module2) {
    var isArray = require_isArray();
    var isKey = require_isKey();
    var stringToPath = require_stringToPath();
    var toString2 = require_toString();
    function castPath(value, object) {
      if (isArray(value)) {
        return value;
      }
      return isKey(value, object) ? [value] : stringToPath(toString2(value));
    }
    module2.exports = castPath;
  }
});

// node_modules/lodash/_toKey.js
var require_toKey = __commonJS({
  "node_modules/lodash/_toKey.js"(exports2, module2) {
    var isSymbol = require_isSymbol();
    var INFINITY = 1 / 0;
    function toKey(value) {
      if (typeof value == "string" || isSymbol(value)) {
        return value;
      }
      var result = value + "";
      return result == "0" && 1 / value == -INFINITY ? "-0" : result;
    }
    module2.exports = toKey;
  }
});

// node_modules/lodash/_baseGet.js
var require_baseGet = __commonJS({
  "node_modules/lodash/_baseGet.js"(exports2, module2) {
    var castPath = require_castPath();
    var toKey = require_toKey();
    function baseGet(object, path) {
      path = castPath(path, object);
      var index = 0, length = path.length;
      while (object != null && index < length) {
        object = object[toKey(path[index++])];
      }
      return index && index == length ? object : void 0;
    }
    module2.exports = baseGet;
  }
});

// node_modules/lodash/_baseIsMatch.js
var require_baseIsMatch = __commonJS({
  "node_modules/lodash/_baseIsMatch.js"(exports2, module2) {
    var Stack = require_Stack();
    var baseIsEqual = require_baseIsEqual();
    var COMPARE_PARTIAL_FLAG = 1;
    var COMPARE_UNORDERED_FLAG = 2;
    function baseIsMatch(object, source, matchData, customizer) {
      var index = matchData.length, length = index, noCustomizer = !customizer;
      if (object == null) {
        return !length;
      }
      object = Object(object);
      while (index--) {
        var data = matchData[index];
        if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
          return false;
        }
      }
      while (++index < length) {
        data = matchData[index];
        var key = data[0], objValue = object[key], srcValue = data[1];
        if (noCustomizer && data[2]) {
          if (objValue === void 0 && !(key in object)) {
            return false;
          }
        } else {
          var stack = new Stack();
          if (customizer) {
            var result = customizer(objValue, srcValue, key, object, source, stack);
          }
          if (!(result === void 0 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack) : result)) {
            return false;
          }
        }
      }
      return true;
    }
    module2.exports = baseIsMatch;
  }
});

// node_modules/lodash/_isStrictComparable.js
var require_isStrictComparable = __commonJS({
  "node_modules/lodash/_isStrictComparable.js"(exports2, module2) {
    var isObject5 = require_isObject();
    function isStrictComparable(value) {
      return value === value && !isObject5(value);
    }
    module2.exports = isStrictComparable;
  }
});

// node_modules/lodash/_getMatchData.js
var require_getMatchData = __commonJS({
  "node_modules/lodash/_getMatchData.js"(exports2, module2) {
    var isStrictComparable = require_isStrictComparable();
    var keys = require_keys();
    function getMatchData(object) {
      var result = keys(object), length = result.length;
      while (length--) {
        var key = result[length], value = object[key];
        result[length] = [key, value, isStrictComparable(value)];
      }
      return result;
    }
    module2.exports = getMatchData;
  }
});

// node_modules/lodash/_matchesStrictComparable.js
var require_matchesStrictComparable = __commonJS({
  "node_modules/lodash/_matchesStrictComparable.js"(exports2, module2) {
    function matchesStrictComparable(key, srcValue) {
      return function(object) {
        if (object == null) {
          return false;
        }
        return object[key] === srcValue && (srcValue !== void 0 || key in Object(object));
      };
    }
    module2.exports = matchesStrictComparable;
  }
});

// node_modules/lodash/_baseMatches.js
var require_baseMatches = __commonJS({
  "node_modules/lodash/_baseMatches.js"(exports2, module2) {
    var baseIsMatch = require_baseIsMatch();
    var getMatchData = require_getMatchData();
    var matchesStrictComparable = require_matchesStrictComparable();
    function baseMatches(source) {
      var matchData = getMatchData(source);
      if (matchData.length == 1 && matchData[0][2]) {
        return matchesStrictComparable(matchData[0][0], matchData[0][1]);
      }
      return function(object) {
        return object === source || baseIsMatch(object, source, matchData);
      };
    }
    module2.exports = baseMatches;
  }
});

// node_modules/lodash/get.js
var require_get = __commonJS({
  "node_modules/lodash/get.js"(exports2, module2) {
    var baseGet = require_baseGet();
    function get2(object, path, defaultValue) {
      var result = object == null ? void 0 : baseGet(object, path);
      return result === void 0 ? defaultValue : result;
    }
    module2.exports = get2;
  }
});

// node_modules/lodash/_baseHasIn.js
var require_baseHasIn = __commonJS({
  "node_modules/lodash/_baseHasIn.js"(exports2, module2) {
    function baseHasIn(object, key) {
      return object != null && key in Object(object);
    }
    module2.exports = baseHasIn;
  }
});

// node_modules/lodash/_hasPath.js
var require_hasPath = __commonJS({
  "node_modules/lodash/_hasPath.js"(exports2, module2) {
    var castPath = require_castPath();
    var isArguments = require_isArguments();
    var isArray = require_isArray();
    var isIndex = require_isIndex();
    var isLength = require_isLength();
    var toKey = require_toKey();
    function hasPath(object, path, hasFunc) {
      path = castPath(path, object);
      var index = -1, length = path.length, result = false;
      while (++index < length) {
        var key = toKey(path[index]);
        if (!(result = object != null && hasFunc(object, key))) {
          break;
        }
        object = object[key];
      }
      if (result || ++index != length) {
        return result;
      }
      length = object == null ? 0 : object.length;
      return !!length && isLength(length) && isIndex(key, length) && (isArray(object) || isArguments(object));
    }
    module2.exports = hasPath;
  }
});

// node_modules/lodash/hasIn.js
var require_hasIn = __commonJS({
  "node_modules/lodash/hasIn.js"(exports2, module2) {
    var baseHasIn = require_baseHasIn();
    var hasPath = require_hasPath();
    function hasIn(object, path) {
      return object != null && hasPath(object, path, baseHasIn);
    }
    module2.exports = hasIn;
  }
});

// node_modules/lodash/_baseMatchesProperty.js
var require_baseMatchesProperty = __commonJS({
  "node_modules/lodash/_baseMatchesProperty.js"(exports2, module2) {
    var baseIsEqual = require_baseIsEqual();
    var get2 = require_get();
    var hasIn = require_hasIn();
    var isKey = require_isKey();
    var isStrictComparable = require_isStrictComparable();
    var matchesStrictComparable = require_matchesStrictComparable();
    var toKey = require_toKey();
    var COMPARE_PARTIAL_FLAG = 1;
    var COMPARE_UNORDERED_FLAG = 2;
    function baseMatchesProperty(path, srcValue) {
      if (isKey(path) && isStrictComparable(srcValue)) {
        return matchesStrictComparable(toKey(path), srcValue);
      }
      return function(object) {
        var objValue = get2(object, path);
        return objValue === void 0 && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
      };
    }
    module2.exports = baseMatchesProperty;
  }
});

// node_modules/lodash/identity.js
var require_identity = __commonJS({
  "node_modules/lodash/identity.js"(exports2, module2) {
    function identity(value) {
      return value;
    }
    module2.exports = identity;
  }
});

// node_modules/lodash/_baseProperty.js
var require_baseProperty = __commonJS({
  "node_modules/lodash/_baseProperty.js"(exports2, module2) {
    function baseProperty(key) {
      return function(object) {
        return object == null ? void 0 : object[key];
      };
    }
    module2.exports = baseProperty;
  }
});

// node_modules/lodash/_basePropertyDeep.js
var require_basePropertyDeep = __commonJS({
  "node_modules/lodash/_basePropertyDeep.js"(exports2, module2) {
    var baseGet = require_baseGet();
    function basePropertyDeep(path) {
      return function(object) {
        return baseGet(object, path);
      };
    }
    module2.exports = basePropertyDeep;
  }
});

// node_modules/lodash/property.js
var require_property = __commonJS({
  "node_modules/lodash/property.js"(exports2, module2) {
    var baseProperty = require_baseProperty();
    var basePropertyDeep = require_basePropertyDeep();
    var isKey = require_isKey();
    var toKey = require_toKey();
    function property(path) {
      return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
    }
    module2.exports = property;
  }
});

// node_modules/lodash/_baseIteratee.js
var require_baseIteratee = __commonJS({
  "node_modules/lodash/_baseIteratee.js"(exports2, module2) {
    var baseMatches = require_baseMatches();
    var baseMatchesProperty = require_baseMatchesProperty();
    var identity = require_identity();
    var isArray = require_isArray();
    var property = require_property();
    function baseIteratee(value) {
      if (typeof value == "function") {
        return value;
      }
      if (value == null) {
        return identity;
      }
      if (typeof value == "object") {
        return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
      }
      return property(value);
    }
    module2.exports = baseIteratee;
  }
});

// node_modules/lodash/_createBaseFor.js
var require_createBaseFor = __commonJS({
  "node_modules/lodash/_createBaseFor.js"(exports2, module2) {
    function createBaseFor(fromRight) {
      return function(object, iteratee, keysFunc) {
        var index = -1, iterable = Object(object), props = keysFunc(object), length = props.length;
        while (length--) {
          var key = props[fromRight ? length : ++index];
          if (iteratee(iterable[key], key, iterable) === false) {
            break;
          }
        }
        return object;
      };
    }
    module2.exports = createBaseFor;
  }
});

// node_modules/lodash/_baseFor.js
var require_baseFor = __commonJS({
  "node_modules/lodash/_baseFor.js"(exports2, module2) {
    var createBaseFor = require_createBaseFor();
    var baseFor = createBaseFor();
    module2.exports = baseFor;
  }
});

// node_modules/lodash/_baseForOwn.js
var require_baseForOwn = __commonJS({
  "node_modules/lodash/_baseForOwn.js"(exports2, module2) {
    var baseFor = require_baseFor();
    var keys = require_keys();
    function baseForOwn(object, iteratee) {
      return object && baseFor(object, iteratee, keys);
    }
    module2.exports = baseForOwn;
  }
});

// node_modules/lodash/_createBaseEach.js
var require_createBaseEach = __commonJS({
  "node_modules/lodash/_createBaseEach.js"(exports2, module2) {
    var isArrayLike = require_isArrayLike();
    function createBaseEach(eachFunc, fromRight) {
      return function(collection, iteratee) {
        if (collection == null) {
          return collection;
        }
        if (!isArrayLike(collection)) {
          return eachFunc(collection, iteratee);
        }
        var length = collection.length, index = fromRight ? length : -1, iterable = Object(collection);
        while (fromRight ? index-- : ++index < length) {
          if (iteratee(iterable[index], index, iterable) === false) {
            break;
          }
        }
        return collection;
      };
    }
    module2.exports = createBaseEach;
  }
});

// node_modules/lodash/_baseEach.js
var require_baseEach = __commonJS({
  "node_modules/lodash/_baseEach.js"(exports2, module2) {
    var baseForOwn = require_baseForOwn();
    var createBaseEach = require_createBaseEach();
    var baseEach = createBaseEach(baseForOwn);
    module2.exports = baseEach;
  }
});

// node_modules/lodash/_baseMap.js
var require_baseMap = __commonJS({
  "node_modules/lodash/_baseMap.js"(exports2, module2) {
    var baseEach = require_baseEach();
    var isArrayLike = require_isArrayLike();
    function baseMap(collection, iteratee) {
      var index = -1, result = isArrayLike(collection) ? Array(collection.length) : [];
      baseEach(collection, function(value, key, collection2) {
        result[++index] = iteratee(value, key, collection2);
      });
      return result;
    }
    module2.exports = baseMap;
  }
});

// node_modules/lodash/_baseSortBy.js
var require_baseSortBy = __commonJS({
  "node_modules/lodash/_baseSortBy.js"(exports2, module2) {
    function baseSortBy(array, comparer) {
      var length = array.length;
      array.sort(comparer);
      while (length--) {
        array[length] = array[length].value;
      }
      return array;
    }
    module2.exports = baseSortBy;
  }
});

// node_modules/lodash/_compareAscending.js
var require_compareAscending = __commonJS({
  "node_modules/lodash/_compareAscending.js"(exports2, module2) {
    var isSymbol = require_isSymbol();
    function compareAscending(value, other) {
      if (value !== other) {
        var valIsDefined = value !== void 0, valIsNull = value === null, valIsReflexive = value === value, valIsSymbol = isSymbol(value);
        var othIsDefined = other !== void 0, othIsNull = other === null, othIsReflexive = other === other, othIsSymbol = isSymbol(other);
        if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
          return 1;
        }
        if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
          return -1;
        }
      }
      return 0;
    }
    module2.exports = compareAscending;
  }
});

// node_modules/lodash/_compareMultiple.js
var require_compareMultiple = __commonJS({
  "node_modules/lodash/_compareMultiple.js"(exports2, module2) {
    var compareAscending = require_compareAscending();
    function compareMultiple(object, other, orders) {
      var index = -1, objCriteria = object.criteria, othCriteria = other.criteria, length = objCriteria.length, ordersLength = orders.length;
      while (++index < length) {
        var result = compareAscending(objCriteria[index], othCriteria[index]);
        if (result) {
          if (index >= ordersLength) {
            return result;
          }
          var order = orders[index];
          return result * (order == "desc" ? -1 : 1);
        }
      }
      return object.index - other.index;
    }
    module2.exports = compareMultiple;
  }
});

// node_modules/lodash/_baseOrderBy.js
var require_baseOrderBy = __commonJS({
  "node_modules/lodash/_baseOrderBy.js"(exports2, module2) {
    var arrayMap = require_arrayMap();
    var baseGet = require_baseGet();
    var baseIteratee = require_baseIteratee();
    var baseMap = require_baseMap();
    var baseSortBy = require_baseSortBy();
    var baseUnary = require_baseUnary();
    var compareMultiple = require_compareMultiple();
    var identity = require_identity();
    var isArray = require_isArray();
    function baseOrderBy(collection, iteratees, orders) {
      if (iteratees.length) {
        iteratees = arrayMap(iteratees, function(iteratee) {
          if (isArray(iteratee)) {
            return function(value) {
              return baseGet(value, iteratee.length === 1 ? iteratee[0] : iteratee);
            };
          }
          return iteratee;
        });
      } else {
        iteratees = [identity];
      }
      var index = -1;
      iteratees = arrayMap(iteratees, baseUnary(baseIteratee));
      var result = baseMap(collection, function(value, key, collection2) {
        var criteria = arrayMap(iteratees, function(iteratee) {
          return iteratee(value);
        });
        return { "criteria": criteria, "index": ++index, "value": value };
      });
      return baseSortBy(result, function(object, other) {
        return compareMultiple(object, other, orders);
      });
    }
    module2.exports = baseOrderBy;
  }
});

// node_modules/lodash/_apply.js
var require_apply = __commonJS({
  "node_modules/lodash/_apply.js"(exports2, module2) {
    function apply(func, thisArg, args) {
      switch (args.length) {
        case 0:
          return func.call(thisArg);
        case 1:
          return func.call(thisArg, args[0]);
        case 2:
          return func.call(thisArg, args[0], args[1]);
        case 3:
          return func.call(thisArg, args[0], args[1], args[2]);
      }
      return func.apply(thisArg, args);
    }
    module2.exports = apply;
  }
});

// node_modules/lodash/_overRest.js
var require_overRest = __commonJS({
  "node_modules/lodash/_overRest.js"(exports2, module2) {
    var apply = require_apply();
    var nativeMax = Math.max;
    function overRest(func, start, transform) {
      start = nativeMax(start === void 0 ? func.length - 1 : start, 0);
      return function() {
        var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array = Array(length);
        while (++index < length) {
          array[index] = args[start + index];
        }
        index = -1;
        var otherArgs = Array(start + 1);
        while (++index < start) {
          otherArgs[index] = args[index];
        }
        otherArgs[start] = transform(array);
        return apply(func, this, otherArgs);
      };
    }
    module2.exports = overRest;
  }
});

// node_modules/lodash/constant.js
var require_constant = __commonJS({
  "node_modules/lodash/constant.js"(exports2, module2) {
    function constant(value) {
      return function() {
        return value;
      };
    }
    module2.exports = constant;
  }
});

// node_modules/lodash/_baseSetToString.js
var require_baseSetToString = __commonJS({
  "node_modules/lodash/_baseSetToString.js"(exports2, module2) {
    var constant = require_constant();
    var defineProperty = require_defineProperty();
    var identity = require_identity();
    var baseSetToString = !defineProperty ? identity : function(func, string) {
      return defineProperty(func, "toString", {
        "configurable": true,
        "enumerable": false,
        "value": constant(string),
        "writable": true
      });
    };
    module2.exports = baseSetToString;
  }
});

// node_modules/lodash/_shortOut.js
var require_shortOut = __commonJS({
  "node_modules/lodash/_shortOut.js"(exports2, module2) {
    var HOT_COUNT = 800;
    var HOT_SPAN = 16;
    var nativeNow = Date.now;
    function shortOut(func) {
      var count = 0, lastCalled = 0;
      return function() {
        var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
        lastCalled = stamp;
        if (remaining > 0) {
          if (++count >= HOT_COUNT) {
            return arguments[0];
          }
        } else {
          count = 0;
        }
        return func.apply(void 0, arguments);
      };
    }
    module2.exports = shortOut;
  }
});

// node_modules/lodash/_setToString.js
var require_setToString = __commonJS({
  "node_modules/lodash/_setToString.js"(exports2, module2) {
    var baseSetToString = require_baseSetToString();
    var shortOut = require_shortOut();
    var setToString = shortOut(baseSetToString);
    module2.exports = setToString;
  }
});

// node_modules/lodash/_baseRest.js
var require_baseRest = __commonJS({
  "node_modules/lodash/_baseRest.js"(exports2, module2) {
    var identity = require_identity();
    var overRest = require_overRest();
    var setToString = require_setToString();
    function baseRest(func, start) {
      return setToString(overRest(func, start, identity), func + "");
    }
    module2.exports = baseRest;
  }
});

// node_modules/lodash/_isIterateeCall.js
var require_isIterateeCall = __commonJS({
  "node_modules/lodash/_isIterateeCall.js"(exports2, module2) {
    var eq = require_eq();
    var isArrayLike = require_isArrayLike();
    var isIndex = require_isIndex();
    var isObject5 = require_isObject();
    function isIterateeCall(value, index, object) {
      if (!isObject5(object)) {
        return false;
      }
      var type2 = typeof index;
      if (type2 == "number" ? isArrayLike(object) && isIndex(index, object.length) : type2 == "string" && index in object) {
        return eq(object[index], value);
      }
      return false;
    }
    module2.exports = isIterateeCall;
  }
});

// node_modules/lodash/sortBy.js
var require_sortBy = __commonJS({
  "node_modules/lodash/sortBy.js"(exports2, module2) {
    var baseFlatten = require_baseFlatten();
    var baseOrderBy = require_baseOrderBy();
    var baseRest = require_baseRest();
    var isIterateeCall = require_isIterateeCall();
    var sortBy = baseRest(function(collection, iteratees) {
      if (collection == null) {
        return [];
      }
      var length = iteratees.length;
      if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
        iteratees = [];
      } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
        iteratees = [iteratees[0]];
      }
      return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
    });
    module2.exports = sortBy;
  }
});

// node_modules/lodash/_baseFindIndex.js
var require_baseFindIndex = __commonJS({
  "node_modules/lodash/_baseFindIndex.js"(exports2, module2) {
    function baseFindIndex(array, predicate, fromIndex, fromRight) {
      var length = array.length, index = fromIndex + (fromRight ? 1 : -1);
      while (fromRight ? index-- : ++index < length) {
        if (predicate(array[index], index, array)) {
          return index;
        }
      }
      return -1;
    }
    module2.exports = baseFindIndex;
  }
});

// node_modules/lodash/_baseIsNaN.js
var require_baseIsNaN = __commonJS({
  "node_modules/lodash/_baseIsNaN.js"(exports2, module2) {
    function baseIsNaN(value) {
      return value !== value;
    }
    module2.exports = baseIsNaN;
  }
});

// node_modules/lodash/_strictIndexOf.js
var require_strictIndexOf = __commonJS({
  "node_modules/lodash/_strictIndexOf.js"(exports2, module2) {
    function strictIndexOf(array, value, fromIndex) {
      var index = fromIndex - 1, length = array.length;
      while (++index < length) {
        if (array[index] === value) {
          return index;
        }
      }
      return -1;
    }
    module2.exports = strictIndexOf;
  }
});

// node_modules/lodash/_baseIndexOf.js
var require_baseIndexOf = __commonJS({
  "node_modules/lodash/_baseIndexOf.js"(exports2, module2) {
    var baseFindIndex = require_baseFindIndex();
    var baseIsNaN = require_baseIsNaN();
    var strictIndexOf = require_strictIndexOf();
    function baseIndexOf(array, value, fromIndex) {
      return value === value ? strictIndexOf(array, value, fromIndex) : baseFindIndex(array, baseIsNaN, fromIndex);
    }
    module2.exports = baseIndexOf;
  }
});

// node_modules/lodash/_arrayIncludes.js
var require_arrayIncludes = __commonJS({
  "node_modules/lodash/_arrayIncludes.js"(exports2, module2) {
    var baseIndexOf = require_baseIndexOf();
    function arrayIncludes(array, value) {
      var length = array == null ? 0 : array.length;
      return !!length && baseIndexOf(array, value, 0) > -1;
    }
    module2.exports = arrayIncludes;
  }
});

// node_modules/lodash/_arrayIncludesWith.js
var require_arrayIncludesWith = __commonJS({
  "node_modules/lodash/_arrayIncludesWith.js"(exports2, module2) {
    function arrayIncludesWith(array, value, comparator) {
      var index = -1, length = array == null ? 0 : array.length;
      while (++index < length) {
        if (comparator(value, array[index])) {
          return true;
        }
      }
      return false;
    }
    module2.exports = arrayIncludesWith;
  }
});

// node_modules/lodash/noop.js
var require_noop = __commonJS({
  "node_modules/lodash/noop.js"(exports2, module2) {
    function noop() {
    }
    module2.exports = noop;
  }
});

// node_modules/lodash/_createSet.js
var require_createSet = __commonJS({
  "node_modules/lodash/_createSet.js"(exports2, module2) {
    var Set2 = require_Set();
    var noop = require_noop();
    var setToArray = require_setToArray();
    var INFINITY = 1 / 0;
    var createSet = !(Set2 && 1 / setToArray(new Set2([, -0]))[1] == INFINITY) ? noop : function(values) {
      return new Set2(values);
    };
    module2.exports = createSet;
  }
});

// node_modules/lodash/_baseUniq.js
var require_baseUniq = __commonJS({
  "node_modules/lodash/_baseUniq.js"(exports2, module2) {
    var SetCache = require_SetCache();
    var arrayIncludes = require_arrayIncludes();
    var arrayIncludesWith = require_arrayIncludesWith();
    var cacheHas = require_cacheHas();
    var createSet = require_createSet();
    var setToArray = require_setToArray();
    var LARGE_ARRAY_SIZE = 200;
    function baseUniq(array, iteratee, comparator) {
      var index = -1, includes = arrayIncludes, length = array.length, isCommon = true, result = [], seen = result;
      if (comparator) {
        isCommon = false;
        includes = arrayIncludesWith;
      } else if (length >= LARGE_ARRAY_SIZE) {
        var set3 = iteratee ? null : createSet(array);
        if (set3) {
          return setToArray(set3);
        }
        isCommon = false;
        includes = cacheHas;
        seen = new SetCache();
      } else {
        seen = iteratee ? [] : result;
      }
      outer:
        while (++index < length) {
          var value = array[index], computed = iteratee ? iteratee(value) : value;
          value = comparator || value !== 0 ? value : 0;
          if (isCommon && computed === computed) {
            var seenIndex = seen.length;
            while (seenIndex--) {
              if (seen[seenIndex] === computed) {
                continue outer;
              }
            }
            if (iteratee) {
              seen.push(computed);
            }
            result.push(value);
          } else if (!includes(seen, computed, comparator)) {
            if (seen !== result) {
              seen.push(computed);
            }
            result.push(value);
          }
        }
      return result;
    }
    module2.exports = baseUniq;
  }
});

// node_modules/lodash/uniq.js
var require_uniq = __commonJS({
  "node_modules/lodash/uniq.js"(exports2, module2) {
    var baseUniq = require_baseUniq();
    function uniq(array) {
      return array && array.length ? baseUniq(array) : [];
    }
    module2.exports = uniq;
  }
});

// node_modules/lodash/uniqWith.js
var require_uniqWith = __commonJS({
  "node_modules/lodash/uniqWith.js"(exports2, module2) {
    var baseUniq = require_baseUniq();
    function uniqWith(array, comparator) {
      comparator = typeof comparator == "function" ? comparator : void 0;
      return array && array.length ? baseUniq(array, void 0, comparator) : [];
    }
    module2.exports = uniqWith;
  }
});

// node_modules/lodash/defaults.js
var require_defaults = __commonJS({
  "node_modules/lodash/defaults.js"(exports2, module2) {
    var baseRest = require_baseRest();
    var eq = require_eq();
    var isIterateeCall = require_isIterateeCall();
    var keysIn = require_keysIn();
    var objectProto = Object.prototype;
    var hasOwnProperty2 = objectProto.hasOwnProperty;
    var defaults = baseRest(function(object, sources) {
      object = Object(object);
      var index = -1;
      var length = sources.length;
      var guard = length > 2 ? sources[2] : void 0;
      if (guard && isIterateeCall(sources[0], sources[1], guard)) {
        length = 1;
      }
      while (++index < length) {
        var source = sources[index];
        var props = keysIn(source);
        var propsIndex = -1;
        var propsLength = props.length;
        while (++propsIndex < propsLength) {
          var key = props[propsIndex];
          var value = object[key];
          if (value === void 0 || eq(value, objectProto[key]) && !hasOwnProperty2.call(object, key)) {
            object[key] = source[key];
          }
        }
      }
      return object;
    });
    module2.exports = defaults;
  }
});

// node_modules/lodash/_baseIntersection.js
var require_baseIntersection = __commonJS({
  "node_modules/lodash/_baseIntersection.js"(exports2, module2) {
    var SetCache = require_SetCache();
    var arrayIncludes = require_arrayIncludes();
    var arrayIncludesWith = require_arrayIncludesWith();
    var arrayMap = require_arrayMap();
    var baseUnary = require_baseUnary();
    var cacheHas = require_cacheHas();
    var nativeMin = Math.min;
    function baseIntersection(arrays, iteratee, comparator) {
      var includes = comparator ? arrayIncludesWith : arrayIncludes, length = arrays[0].length, othLength = arrays.length, othIndex = othLength, caches = Array(othLength), maxLength = Infinity, result = [];
      while (othIndex--) {
        var array = arrays[othIndex];
        if (othIndex && iteratee) {
          array = arrayMap(array, baseUnary(iteratee));
        }
        maxLength = nativeMin(array.length, maxLength);
        caches[othIndex] = !comparator && (iteratee || length >= 120 && array.length >= 120) ? new SetCache(othIndex && array) : void 0;
      }
      array = arrays[0];
      var index = -1, seen = caches[0];
      outer:
        while (++index < length && result.length < maxLength) {
          var value = array[index], computed = iteratee ? iteratee(value) : value;
          value = comparator || value !== 0 ? value : 0;
          if (!(seen ? cacheHas(seen, computed) : includes(result, computed, comparator))) {
            othIndex = othLength;
            while (--othIndex) {
              var cache = caches[othIndex];
              if (!(cache ? cacheHas(cache, computed) : includes(arrays[othIndex], computed, comparator))) {
                continue outer;
              }
            }
            if (seen) {
              seen.push(computed);
            }
            result.push(value);
          }
        }
      return result;
    }
    module2.exports = baseIntersection;
  }
});

// node_modules/lodash/isArrayLikeObject.js
var require_isArrayLikeObject = __commonJS({
  "node_modules/lodash/isArrayLikeObject.js"(exports2, module2) {
    var isArrayLike = require_isArrayLike();
    var isObjectLike = require_isObjectLike();
    function isArrayLikeObject(value) {
      return isObjectLike(value) && isArrayLike(value);
    }
    module2.exports = isArrayLikeObject;
  }
});

// node_modules/lodash/_castArrayLikeObject.js
var require_castArrayLikeObject = __commonJS({
  "node_modules/lodash/_castArrayLikeObject.js"(exports2, module2) {
    var isArrayLikeObject = require_isArrayLikeObject();
    function castArrayLikeObject(value) {
      return isArrayLikeObject(value) ? value : [];
    }
    module2.exports = castArrayLikeObject;
  }
});

// node_modules/lodash/last.js
var require_last = __commonJS({
  "node_modules/lodash/last.js"(exports2, module2) {
    function last(array) {
      var length = array == null ? 0 : array.length;
      return length ? array[length - 1] : void 0;
    }
    module2.exports = last;
  }
});

// node_modules/lodash/intersectionWith.js
var require_intersectionWith = __commonJS({
  "node_modules/lodash/intersectionWith.js"(exports2, module2) {
    var arrayMap = require_arrayMap();
    var baseIntersection = require_baseIntersection();
    var baseRest = require_baseRest();
    var castArrayLikeObject = require_castArrayLikeObject();
    var last = require_last();
    var intersectionWith = baseRest(function(arrays) {
      var comparator = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
      comparator = typeof comparator == "function" ? comparator : void 0;
      if (comparator) {
        mapped.pop();
      }
      return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, void 0, comparator) : [];
    });
    module2.exports = intersectionWith;
  }
});

// node_modules/lodash/isPlainObject.js
var require_isPlainObject = __commonJS({
  "node_modules/lodash/isPlainObject.js"(exports2, module2) {
    var baseGetTag = require_baseGetTag();
    var getPrototype = require_getPrototype();
    var isObjectLike = require_isObjectLike();
    var objectTag = "[object Object]";
    var funcProto = Function.prototype;
    var objectProto = Object.prototype;
    var funcToString = funcProto.toString;
    var hasOwnProperty2 = objectProto.hasOwnProperty;
    var objectCtorString = funcToString.call(Object);
    function isPlainObject(value) {
      if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
        return false;
      }
      var proto = getPrototype(value);
      if (proto === null) {
        return true;
      }
      var Ctor = hasOwnProperty2.call(proto, "constructor") && proto.constructor;
      return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
    }
    module2.exports = isPlainObject;
  }
});

// node_modules/lodash/isBoolean.js
var require_isBoolean = __commonJS({
  "node_modules/lodash/isBoolean.js"(exports2, module2) {
    var baseGetTag = require_baseGetTag();
    var isObjectLike = require_isObjectLike();
    var boolTag = "[object Boolean]";
    function isBoolean2(value) {
      return value === true || value === false || isObjectLike(value) && baseGetTag(value) == boolTag;
    }
    module2.exports = isBoolean2;
  }
});

// node_modules/json-schema-compare/src/index.js
var require_src = __commonJS({
  "node_modules/json-schema-compare/src/index.js"(exports2, module2) {
    var isEqual = require_isEqual();
    var sortBy = require_sortBy();
    var uniq = require_uniq();
    var uniqWith = require_uniqWith();
    var defaults = require_defaults();
    var intersectionWith = require_intersectionWith();
    var isPlainObject = require_isPlainObject();
    var isBoolean2 = require_isBoolean();
    var normalizeArray2 = (val) => Array.isArray(val) ? val : [val];
    var undef = (val) => val === void 0;
    var keys = (obj) => isPlainObject(obj) || Array.isArray(obj) ? Object.keys(obj) : [];
    var has = (obj, key) => obj.hasOwnProperty(key);
    var stringArray = (arr) => sortBy(uniq(arr));
    var undefEmpty = (val) => undef(val) || Array.isArray(val) && val.length === 0;
    var keyValEqual = (a, b, key, compare2) => b && has(b, key) && a && has(a, key) && compare2(a[key], b[key]);
    var undefAndZero = (a, b) => undef(a) && b === 0 || undef(b) && a === 0 || isEqual(a, b);
    var falseUndefined = (a, b) => undef(a) && b === false || undef(b) && a === false || isEqual(a, b);
    var emptySchema = (schema2) => undef(schema2) || isEqual(schema2, {}) || schema2 === true;
    var emptyObjUndef = (schema2) => undef(schema2) || isEqual(schema2, {});
    var isSchema2 = (val) => undef(val) || isPlainObject(val) || val === true || val === false;
    function undefArrayEqual(a, b) {
      if (undefEmpty(a) && undefEmpty(b)) {
        return true;
      } else {
        return isEqual(stringArray(a), stringArray(b));
      }
    }
    function unsortedNormalizedArray(a, b) {
      a = normalizeArray2(a);
      b = normalizeArray2(b);
      return isEqual(stringArray(a), stringArray(b));
    }
    function schemaGroup(a, b, key, compare2) {
      var allProps = uniq(keys(a).concat(keys(b)));
      if (emptyObjUndef(a) && emptyObjUndef(b)) {
        return true;
      } else if (emptyObjUndef(a) && keys(b).length) {
        return false;
      } else if (emptyObjUndef(b) && keys(a).length) {
        return false;
      }
      return allProps.every(function(key2) {
        var aVal = a[key2];
        var bVal = b[key2];
        if (Array.isArray(aVal) && Array.isArray(bVal)) {
          return isEqual(stringArray(a), stringArray(b));
        } else if (Array.isArray(aVal) && !Array.isArray(bVal)) {
          return false;
        } else if (Array.isArray(bVal) && !Array.isArray(aVal)) {
          return false;
        }
        return keyValEqual(a, b, key2, compare2);
      });
    }
    function items(a, b, key, compare2) {
      if (isPlainObject(a) && isPlainObject(b)) {
        return compare2(a, b);
      } else if (Array.isArray(a) && Array.isArray(b)) {
        return schemaGroup(a, b, key, compare2);
      } else {
        return isEqual(a, b);
      }
    }
    function unsortedArray(a, b, key, compare2) {
      var uniqueA = uniqWith(a, compare2);
      var uniqueB = uniqWith(b, compare2);
      var inter = intersectionWith(uniqueA, uniqueB, compare2);
      return inter.length === Math.max(uniqueA.length, uniqueB.length);
    }
    var comparers = {
      title: isEqual,
      uniqueItems: falseUndefined,
      minLength: undefAndZero,
      minItems: undefAndZero,
      minProperties: undefAndZero,
      required: undefArrayEqual,
      enum: undefArrayEqual,
      type: unsortedNormalizedArray,
      items,
      anyOf: unsortedArray,
      allOf: unsortedArray,
      oneOf: unsortedArray,
      properties: schemaGroup,
      patternProperties: schemaGroup,
      dependencies: schemaGroup
    };
    var acceptsUndefined = [
      "properties",
      "patternProperties",
      "dependencies",
      "uniqueItems",
      "minLength",
      "minItems",
      "minProperties",
      "required"
    ];
    var schemaProps = ["additionalProperties", "additionalItems", "contains", "propertyNames", "not"];
    function compare(a, b, options) {
      options = defaults(options, {
        ignore: []
      });
      if (emptySchema(a) && emptySchema(b)) {
        return true;
      }
      if (!isSchema2(a) || !isSchema2(b)) {
        throw new Error("Either of the values are not a JSON schema.");
      }
      if (a === b) {
        return true;
      }
      if (isBoolean2(a) && isBoolean2(b)) {
        return a === b;
      }
      if (a === void 0 && b === false || b === void 0 && a === false) {
        return false;
      }
      if (undef(a) && !undef(b) || !undef(a) && undef(b)) {
        return false;
      }
      var allKeys = uniq(Object.keys(a).concat(Object.keys(b)));
      if (options.ignore.length) {
        allKeys = allKeys.filter((k) => options.ignore.indexOf(k) === -1);
      }
      if (!allKeys.length) {
        return true;
      }
      function innerCompare(a2, b2) {
        return compare(a2, b2, options);
      }
      return allKeys.every(function(key) {
        var aValue = a[key];
        var bValue = b[key];
        if (schemaProps.indexOf(key) !== -1) {
          return compare(aValue, bValue, options);
        }
        var comparer = comparers[key];
        if (!comparer) {
          comparer = isEqual;
        }
        if (isEqual(aValue, bValue)) {
          return true;
        }
        if (acceptsUndefined.indexOf(key) === -1) {
          if (!has(a, key) && has(b, key) || has(a, key) && !has(b, key)) {
            return aValue === bValue;
          }
        }
        var result = comparer(aValue, bValue, key, innerCompare);
        if (!isBoolean2(result)) {
          throw new Error("Comparer must return true or false");
        }
        return result;
      });
    }
    module2.exports = compare;
  }
});

// node_modules/validate.io-array/lib/index.js
var require_lib2 = __commonJS({
  "node_modules/validate.io-array/lib/index.js"(exports2, module2) {
    "use strict";
    function isArray(value) {
      return Object.prototype.toString.call(value) === "[object Array]";
    }
    module2.exports = Array.isArray || isArray;
  }
});

// node_modules/validate.io-number/lib/index.js
var require_lib3 = __commonJS({
  "node_modules/validate.io-number/lib/index.js"(exports2, module2) {
    "use strict";
    function isNumber(value) {
      return (typeof value === "number" || Object.prototype.toString.call(value) === "[object Number]") && value.valueOf() === value.valueOf();
    }
    module2.exports = isNumber;
  }
});

// node_modules/validate.io-integer/lib/index.js
var require_lib4 = __commonJS({
  "node_modules/validate.io-integer/lib/index.js"(exports2, module2) {
    "use strict";
    var isNumber = require_lib3();
    function isInteger2(value) {
      return isNumber(value) && value % 1 === 0;
    }
    module2.exports = isInteger2;
  }
});

// node_modules/validate.io-integer-array/lib/index.js
var require_lib5 = __commonJS({
  "node_modules/validate.io-integer-array/lib/index.js"(exports2, module2) {
    "use strict";
    var isArray = require_lib2();
    var isInteger2 = require_lib4();
    function isIntegerArray(value) {
      var len;
      if (!isArray(value)) {
        return false;
      }
      len = value.length;
      if (!len) {
        return false;
      }
      for (var i = 0; i < len; i++) {
        if (!isInteger2(value[i])) {
          return false;
        }
      }
      return true;
    }
    module2.exports = isIntegerArray;
  }
});

// node_modules/validate.io-function/lib/index.js
var require_lib6 = __commonJS({
  "node_modules/validate.io-function/lib/index.js"(exports2, module2) {
    "use strict";
    function isFunction(value) {
      return typeof value === "function";
    }
    module2.exports = isFunction;
  }
});

// node_modules/compute-gcd/lib/index.js
var require_lib7 = __commonJS({
  "node_modules/compute-gcd/lib/index.js"(exports2, module2) {
    "use strict";
    var isArray = require_lib2();
    var isIntegerArray = require_lib5();
    var isFunction = require_lib6();
    var MAXINT = Math.pow(2, 31) - 1;
    function gcd(a, b) {
      var k = 1, t;
      if (a === 0) {
        return b;
      }
      if (b === 0) {
        return a;
      }
      while (a % 2 === 0 && b % 2 === 0) {
        a = a / 2;
        b = b / 2;
        k = k * 2;
      }
      while (a % 2 === 0) {
        a = a / 2;
      }
      while (b) {
        while (b % 2 === 0) {
          b = b / 2;
        }
        if (a > b) {
          t = b;
          b = a;
          a = t;
        }
        b = b - a;
      }
      return k * a;
    }
    function bitwise(a, b) {
      var k = 0, t;
      if (a === 0) {
        return b;
      }
      if (b === 0) {
        return a;
      }
      while ((a & 1) === 0 && (b & 1) === 0) {
        a >>>= 1;
        b >>>= 1;
        k++;
      }
      while ((a & 1) === 0) {
        a >>>= 1;
      }
      while (b) {
        while ((b & 1) === 0) {
          b >>>= 1;
        }
        if (a > b) {
          t = b;
          b = a;
          a = t;
        }
        b = b - a;
      }
      return a << k;
    }
    function compute() {
      var nargs = arguments.length, args, clbk, arr, len, a, b, i;
      args = new Array(nargs);
      for (i = 0; i < nargs; i++) {
        args[i] = arguments[i];
      }
      if (isIntegerArray(args)) {
        if (nargs === 2) {
          a = args[0];
          b = args[1];
          if (a < 0) {
            a = -a;
          }
          if (b < 0) {
            b = -b;
          }
          if (a <= MAXINT && b <= MAXINT) {
            return bitwise(a, b);
          } else {
            return gcd(a, b);
          }
        }
        arr = args;
      } else if (!isArray(args[0])) {
        throw new TypeError("gcd()::invalid input argument. Must provide an array of integers. Value: `" + args[0] + "`.");
      } else if (nargs > 1) {
        arr = args[0];
        clbk = args[1];
        if (!isFunction(clbk)) {
          throw new TypeError("gcd()::invalid input argument. Accessor must be a function. Value: `" + clbk + "`.");
        }
      } else {
        arr = args[0];
      }
      len = arr.length;
      if (len < 2) {
        return null;
      }
      if (clbk) {
        a = new Array(len);
        for (i = 0; i < len; i++) {
          a[i] = clbk(arr[i], i);
        }
        arr = a;
      }
      if (nargs < 3) {
        if (!isIntegerArray(arr)) {
          throw new TypeError("gcd()::invalid input argument. Accessed array values must be integers. Value: `" + arr + "`.");
        }
      }
      for (i = 0; i < len; i++) {
        a = arr[i];
        if (a < 0) {
          arr[i] = -a;
        }
      }
      a = arr[0];
      for (i = 1; i < len; i++) {
        b = arr[i];
        if (b <= MAXINT && a <= MAXINT) {
          a = bitwise(a, b);
        } else {
          a = gcd(a, b);
        }
      }
      return a;
    }
    module2.exports = compute;
  }
});

// node_modules/compute-lcm/lib/index.js
var require_lib8 = __commonJS({
  "node_modules/compute-lcm/lib/index.js"(exports2, module2) {
    "use strict";
    var gcd = require_lib7();
    var isArray = require_lib2();
    var isIntegerArray = require_lib5();
    var isFunction = require_lib6();
    function lcm() {
      var nargs = arguments.length, args, clbk, arr, len, a, b, i;
      args = new Array(nargs);
      for (i = 0; i < nargs; i++) {
        args[i] = arguments[i];
      }
      if (isIntegerArray(args)) {
        if (nargs === 2) {
          a = args[0];
          b = args[1];
          if (a < 0) {
            a = -a;
          }
          if (b < 0) {
            b = -b;
          }
          if (a === 0 || b === 0) {
            return 0;
          }
          return a / gcd(a, b) * b;
        }
        arr = args;
      } else if (!isArray(args[0])) {
        throw new TypeError("lcm()::invalid input argument. Must provide an array of integers. Value: `" + args[0] + "`.");
      } else if (nargs > 1) {
        arr = args[0];
        clbk = args[1];
        if (!isFunction(clbk)) {
          throw new TypeError("lcm()::invalid input argument. Accessor must be a function. Value: `" + clbk + "`.");
        }
      } else {
        arr = args[0];
      }
      len = arr.length;
      if (len < 2) {
        return null;
      }
      if (clbk) {
        a = new Array(len);
        for (i = 0; i < len; i++) {
          a[i] = clbk(arr[i], i);
        }
        arr = a;
      }
      if (nargs < 3) {
        if (!isIntegerArray(arr)) {
          throw new TypeError("lcm()::invalid input argument. Accessed array values must be integers. Value: `" + arr + "`.");
        }
      }
      for (i = 0; i < len; i++) {
        a = arr[i];
        if (a < 0) {
          arr[i] = -a;
        }
      }
      a = arr[0];
      for (i = 1; i < len; i++) {
        b = arr[i];
        if (a === 0 || b === 0) {
          return 0;
        }
        a = a / gcd(a, b) * b;
      }
      return a;
    }
    module2.exports = lcm;
  }
});

// node_modules/lodash/_assignMergeValue.js
var require_assignMergeValue = __commonJS({
  "node_modules/lodash/_assignMergeValue.js"(exports2, module2) {
    var baseAssignValue = require_baseAssignValue();
    var eq = require_eq();
    function assignMergeValue(object, key, value) {
      if (value !== void 0 && !eq(object[key], value) || value === void 0 && !(key in object)) {
        baseAssignValue(object, key, value);
      }
    }
    module2.exports = assignMergeValue;
  }
});

// node_modules/lodash/_safeGet.js
var require_safeGet = __commonJS({
  "node_modules/lodash/_safeGet.js"(exports2, module2) {
    function safeGet(object, key) {
      if (key === "constructor" && typeof object[key] === "function") {
        return;
      }
      if (key == "__proto__") {
        return;
      }
      return object[key];
    }
    module2.exports = safeGet;
  }
});

// node_modules/lodash/toPlainObject.js
var require_toPlainObject = __commonJS({
  "node_modules/lodash/toPlainObject.js"(exports2, module2) {
    var copyObject = require_copyObject();
    var keysIn = require_keysIn();
    function toPlainObject(value) {
      return copyObject(value, keysIn(value));
    }
    module2.exports = toPlainObject;
  }
});

// node_modules/lodash/_baseMergeDeep.js
var require_baseMergeDeep = __commonJS({
  "node_modules/lodash/_baseMergeDeep.js"(exports2, module2) {
    var assignMergeValue = require_assignMergeValue();
    var cloneBuffer = require_cloneBuffer();
    var cloneTypedArray = require_cloneTypedArray();
    var copyArray = require_copyArray();
    var initCloneObject = require_initCloneObject();
    var isArguments = require_isArguments();
    var isArray = require_isArray();
    var isArrayLikeObject = require_isArrayLikeObject();
    var isBuffer2 = require_isBuffer();
    var isFunction = require_isFunction();
    var isObject5 = require_isObject();
    var isPlainObject = require_isPlainObject();
    var isTypedArray = require_isTypedArray();
    var safeGet = require_safeGet();
    var toPlainObject = require_toPlainObject();
    function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
      var objValue = safeGet(object, key), srcValue = safeGet(source, key), stacked = stack.get(srcValue);
      if (stacked) {
        assignMergeValue(object, key, stacked);
        return;
      }
      var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack) : void 0;
      var isCommon = newValue === void 0;
      if (isCommon) {
        var isArr = isArray(srcValue), isBuff = !isArr && isBuffer2(srcValue), isTyped = !isArr && !isBuff && isTypedArray(srcValue);
        newValue = srcValue;
        if (isArr || isBuff || isTyped) {
          if (isArray(objValue)) {
            newValue = objValue;
          } else if (isArrayLikeObject(objValue)) {
            newValue = copyArray(objValue);
          } else if (isBuff) {
            isCommon = false;
            newValue = cloneBuffer(srcValue, true);
          } else if (isTyped) {
            isCommon = false;
            newValue = cloneTypedArray(srcValue, true);
          } else {
            newValue = [];
          }
        } else if (isPlainObject(srcValue) || isArguments(srcValue)) {
          newValue = objValue;
          if (isArguments(objValue)) {
            newValue = toPlainObject(objValue);
          } else if (!isObject5(objValue) || isFunction(objValue)) {
            newValue = initCloneObject(srcValue);
          }
        } else {
          isCommon = false;
        }
      }
      if (isCommon) {
        stack.set(srcValue, newValue);
        mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
        stack["delete"](srcValue);
      }
      assignMergeValue(object, key, newValue);
    }
    module2.exports = baseMergeDeep;
  }
});

// node_modules/lodash/_baseMerge.js
var require_baseMerge = __commonJS({
  "node_modules/lodash/_baseMerge.js"(exports2, module2) {
    var Stack = require_Stack();
    var assignMergeValue = require_assignMergeValue();
    var baseFor = require_baseFor();
    var baseMergeDeep = require_baseMergeDeep();
    var isObject5 = require_isObject();
    var keysIn = require_keysIn();
    var safeGet = require_safeGet();
    function baseMerge(object, source, srcIndex, customizer, stack) {
      if (object === source) {
        return;
      }
      baseFor(source, function(srcValue, key) {
        stack || (stack = new Stack());
        if (isObject5(srcValue)) {
          baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
        } else {
          var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + "", object, source, stack) : void 0;
          if (newValue === void 0) {
            newValue = srcValue;
          }
          assignMergeValue(object, key, newValue);
        }
      }, keysIn);
    }
    module2.exports = baseMerge;
  }
});

// node_modules/lodash/_customDefaultsMerge.js
var require_customDefaultsMerge = __commonJS({
  "node_modules/lodash/_customDefaultsMerge.js"(exports2, module2) {
    var baseMerge = require_baseMerge();
    var isObject5 = require_isObject();
    function customDefaultsMerge(objValue, srcValue, key, object, source, stack) {
      if (isObject5(objValue) && isObject5(srcValue)) {
        stack.set(srcValue, objValue);
        baseMerge(objValue, srcValue, void 0, customDefaultsMerge, stack);
        stack["delete"](srcValue);
      }
      return objValue;
    }
    module2.exports = customDefaultsMerge;
  }
});

// node_modules/lodash/_createAssigner.js
var require_createAssigner = __commonJS({
  "node_modules/lodash/_createAssigner.js"(exports2, module2) {
    var baseRest = require_baseRest();
    var isIterateeCall = require_isIterateeCall();
    function createAssigner(assigner) {
      return baseRest(function(object, sources) {
        var index = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : void 0, guard = length > 2 ? sources[2] : void 0;
        customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : void 0;
        if (guard && isIterateeCall(sources[0], sources[1], guard)) {
          customizer = length < 3 ? void 0 : customizer;
          length = 1;
        }
        object = Object(object);
        while (++index < length) {
          var source = sources[index];
          if (source) {
            assigner(object, source, index, customizer);
          }
        }
        return object;
      });
    }
    module2.exports = createAssigner;
  }
});

// node_modules/lodash/mergeWith.js
var require_mergeWith = __commonJS({
  "node_modules/lodash/mergeWith.js"(exports2, module2) {
    var baseMerge = require_baseMerge();
    var createAssigner = require_createAssigner();
    var mergeWith = createAssigner(function(object, source, srcIndex, customizer) {
      baseMerge(object, source, srcIndex, customizer);
    });
    module2.exports = mergeWith;
  }
});

// node_modules/lodash/defaultsDeep.js
var require_defaultsDeep = __commonJS({
  "node_modules/lodash/defaultsDeep.js"(exports2, module2) {
    var apply = require_apply();
    var baseRest = require_baseRest();
    var customDefaultsMerge = require_customDefaultsMerge();
    var mergeWith = require_mergeWith();
    var defaultsDeep = baseRest(function(args) {
      args.push(void 0, customDefaultsMerge);
      return apply(mergeWith, void 0, args);
    });
    module2.exports = defaultsDeep;
  }
});

// node_modules/lodash/flatten.js
var require_flatten = __commonJS({
  "node_modules/lodash/flatten.js"(exports2, module2) {
    var baseFlatten = require_baseFlatten();
    function flatten(array) {
      var length = array == null ? 0 : array.length;
      return length ? baseFlatten(array, 1) : [];
    }
    module2.exports = flatten;
  }
});

// node_modules/lodash/flattenDeep.js
var require_flattenDeep = __commonJS({
  "node_modules/lodash/flattenDeep.js"(exports2, module2) {
    var baseFlatten = require_baseFlatten();
    var INFINITY = 1 / 0;
    function flattenDeep(array) {
      var length = array == null ? 0 : array.length;
      return length ? baseFlatten(array, INFINITY) : [];
    }
    module2.exports = flattenDeep;
  }
});

// node_modules/lodash/intersection.js
var require_intersection = __commonJS({
  "node_modules/lodash/intersection.js"(exports2, module2) {
    var arrayMap = require_arrayMap();
    var baseIntersection = require_baseIntersection();
    var baseRest = require_baseRest();
    var castArrayLikeObject = require_castArrayLikeObject();
    var intersection = baseRest(function(arrays) {
      var mapped = arrayMap(arrays, castArrayLikeObject);
      return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped) : [];
    });
    module2.exports = intersection;
  }
});

// node_modules/lodash/_baseIndexOfWith.js
var require_baseIndexOfWith = __commonJS({
  "node_modules/lodash/_baseIndexOfWith.js"(exports2, module2) {
    function baseIndexOfWith(array, value, fromIndex, comparator) {
      var index = fromIndex - 1, length = array.length;
      while (++index < length) {
        if (comparator(array[index], value)) {
          return index;
        }
      }
      return -1;
    }
    module2.exports = baseIndexOfWith;
  }
});

// node_modules/lodash/_basePullAll.js
var require_basePullAll = __commonJS({
  "node_modules/lodash/_basePullAll.js"(exports2, module2) {
    var arrayMap = require_arrayMap();
    var baseIndexOf = require_baseIndexOf();
    var baseIndexOfWith = require_baseIndexOfWith();
    var baseUnary = require_baseUnary();
    var copyArray = require_copyArray();
    var arrayProto = Array.prototype;
    var splice = arrayProto.splice;
    function basePullAll(array, values, iteratee, comparator) {
      var indexOf = comparator ? baseIndexOfWith : baseIndexOf, index = -1, length = values.length, seen = array;
      if (array === values) {
        values = copyArray(values);
      }
      if (iteratee) {
        seen = arrayMap(array, baseUnary(iteratee));
      }
      while (++index < length) {
        var fromIndex = 0, value = values[index], computed = iteratee ? iteratee(value) : value;
        while ((fromIndex = indexOf(seen, computed, fromIndex, comparator)) > -1) {
          if (seen !== array) {
            splice.call(seen, fromIndex, 1);
          }
          splice.call(array, fromIndex, 1);
        }
      }
      return array;
    }
    module2.exports = basePullAll;
  }
});

// node_modules/lodash/pullAll.js
var require_pullAll = __commonJS({
  "node_modules/lodash/pullAll.js"(exports2, module2) {
    var basePullAll = require_basePullAll();
    function pullAll(array, values) {
      return array && array.length && values && values.length ? basePullAll(array, values) : array;
    }
    module2.exports = pullAll;
  }
});

// node_modules/lodash/_castFunction.js
var require_castFunction = __commonJS({
  "node_modules/lodash/_castFunction.js"(exports2, module2) {
    var identity = require_identity();
    function castFunction(value) {
      return typeof value == "function" ? value : identity;
    }
    module2.exports = castFunction;
  }
});

// node_modules/lodash/forEach.js
var require_forEach = __commonJS({
  "node_modules/lodash/forEach.js"(exports2, module2) {
    var arrayEach = require_arrayEach();
    var baseEach = require_baseEach();
    var castFunction = require_castFunction();
    var isArray = require_isArray();
    function forEach(collection, iteratee) {
      var func = isArray(collection) ? arrayEach : baseEach;
      return func(collection, castFunction(iteratee));
    }
    module2.exports = forEach;
  }
});

// node_modules/lodash/_baseDifference.js
var require_baseDifference = __commonJS({
  "node_modules/lodash/_baseDifference.js"(exports2, module2) {
    var SetCache = require_SetCache();
    var arrayIncludes = require_arrayIncludes();
    var arrayIncludesWith = require_arrayIncludesWith();
    var arrayMap = require_arrayMap();
    var baseUnary = require_baseUnary();
    var cacheHas = require_cacheHas();
    var LARGE_ARRAY_SIZE = 200;
    function baseDifference(array, values, iteratee, comparator) {
      var index = -1, includes = arrayIncludes, isCommon = true, length = array.length, result = [], valuesLength = values.length;
      if (!length) {
        return result;
      }
      if (iteratee) {
        values = arrayMap(values, baseUnary(iteratee));
      }
      if (comparator) {
        includes = arrayIncludesWith;
        isCommon = false;
      } else if (values.length >= LARGE_ARRAY_SIZE) {
        includes = cacheHas;
        isCommon = false;
        values = new SetCache(values);
      }
      outer:
        while (++index < length) {
          var value = array[index], computed = iteratee == null ? value : iteratee(value);
          value = comparator || value !== 0 ? value : 0;
          if (isCommon && computed === computed) {
            var valuesIndex = valuesLength;
            while (valuesIndex--) {
              if (values[valuesIndex] === computed) {
                continue outer;
              }
            }
            result.push(value);
          } else if (!includes(values, computed, comparator)) {
            result.push(value);
          }
        }
      return result;
    }
    module2.exports = baseDifference;
  }
});

// node_modules/lodash/without.js
var require_without = __commonJS({
  "node_modules/lodash/without.js"(exports2, module2) {
    var baseDifference = require_baseDifference();
    var baseRest = require_baseRest();
    var isArrayLikeObject = require_isArrayLikeObject();
    var without = baseRest(function(array, values) {
      return isArrayLikeObject(array) ? baseDifference(array, values) : [];
    });
    module2.exports = without;
  }
});

// node_modules/json-schema-merge-allof/src/common.js
var require_common = __commonJS({
  "node_modules/json-schema-merge-allof/src/common.js"(exports2, module2) {
    var flatten = require_flatten();
    var flattenDeep = require_flattenDeep();
    var isPlainObject = require_isPlainObject();
    var uniq = require_uniq();
    var uniqWith = require_uniqWith();
    var without = require_without();
    function deleteUndefinedProps(returnObject) {
      for (const prop in returnObject) {
        if (has(returnObject, prop) && isEmptySchema(returnObject[prop])) {
          delete returnObject[prop];
        }
      }
      return returnObject;
    }
    var allUniqueKeys = (arr) => uniq(flattenDeep(arr.map(keys)));
    var getValues = (schemas, key) => schemas.map((schema2) => schema2 && schema2[key]);
    var has = (obj, propName) => Object.prototype.hasOwnProperty.call(obj, propName);
    var keys = (obj) => {
      if (isPlainObject(obj) || Array.isArray(obj)) {
        return Object.keys(obj);
      } else {
        return [];
      }
    };
    var notUndefined = (val) => val !== void 0;
    var isSchema2 = (val) => isPlainObject(val) || val === true || val === false;
    var isEmptySchema = (obj) => !keys(obj).length && obj !== false && obj !== true;
    var withoutArr = (arr, ...rest) => without.apply(null, [arr].concat(flatten(rest)));
    module2.exports = {
      allUniqueKeys,
      deleteUndefinedProps,
      getValues,
      has,
      isEmptySchema,
      isSchema: isSchema2,
      keys,
      notUndefined,
      uniqWith,
      withoutArr
    };
  }
});

// node_modules/json-schema-merge-allof/src/complex-resolvers/properties.js
var require_properties = __commonJS({
  "node_modules/json-schema-merge-allof/src/complex-resolvers/properties.js"(exports2, module2) {
    var compare = require_src();
    var forEach = require_forEach();
    var {
      allUniqueKeys,
      deleteUndefinedProps,
      getValues,
      keys,
      notUndefined,
      uniqWith,
      withoutArr
    } = require_common();
    function removeFalseSchemas(target) {
      forEach(target, function(schema2, prop) {
        if (schema2 === false) {
          delete target[prop];
        }
      });
    }
    function mergeSchemaGroup(group, mergeSchemas) {
      const allKeys = allUniqueKeys(group);
      return allKeys.reduce(function(all, key) {
        const schemas = getValues(group, key);
        const compacted = uniqWith(schemas.filter(notUndefined), compare);
        all[key] = mergeSchemas(compacted, key);
        return all;
      }, {});
    }
    module2.exports = {
      keywords: ["properties", "patternProperties", "additionalProperties"],
      resolver(values, parents, mergers, options) {
        if (!options.ignoreAdditionalProperties) {
          values.forEach(function(subSchema) {
            const otherSubSchemas = values.filter((s) => s !== subSchema);
            const ownKeys = keys(subSchema.properties);
            const ownPatternKeys = keys(subSchema.patternProperties);
            const ownPatterns = ownPatternKeys.map((k) => new RegExp(k));
            otherSubSchemas.forEach(function(other) {
              const allOtherKeys = keys(other.properties);
              const keysMatchingPattern = allOtherKeys.filter((k) => ownPatterns.some((pk) => pk.test(k)));
              const additionalKeys = withoutArr(allOtherKeys, ownKeys, keysMatchingPattern);
              additionalKeys.forEach(function(key) {
                other.properties[key] = mergers.properties([
                  other.properties[key],
                  subSchema.additionalProperties
                ], key);
              });
            });
          });
          values.forEach(function(subSchema) {
            const otherSubSchemas = values.filter((s) => s !== subSchema);
            const ownPatternKeys = keys(subSchema.patternProperties);
            if (subSchema.additionalProperties === false) {
              otherSubSchemas.forEach(function(other) {
                const allOtherPatterns = keys(other.patternProperties);
                const additionalPatternKeys = withoutArr(allOtherPatterns, ownPatternKeys);
                additionalPatternKeys.forEach((key) => delete other.patternProperties[key]);
              });
            }
          });
        }
        const returnObject = {
          additionalProperties: mergers.additionalProperties(values.map((s) => s.additionalProperties)),
          patternProperties: mergeSchemaGroup(values.map((s) => s.patternProperties), mergers.patternProperties),
          properties: mergeSchemaGroup(values.map((s) => s.properties), mergers.properties)
        };
        if (returnObject.additionalProperties === false) {
          removeFalseSchemas(returnObject.properties);
        }
        return deleteUndefinedProps(returnObject);
      }
    };
  }
});

// node_modules/json-schema-merge-allof/src/complex-resolvers/items.js
var require_items = __commonJS({
  "node_modules/json-schema-merge-allof/src/complex-resolvers/items.js"(exports2, module2) {
    var compare = require_src();
    var forEach = require_forEach();
    var {
      allUniqueKeys,
      deleteUndefinedProps,
      has,
      isSchema: isSchema2,
      notUndefined,
      uniqWith
    } = require_common();
    function removeFalseSchemasFromArray(target) {
      forEach(target, function(schema2, index) {
        if (schema2 === false) {
          target.splice(index, 1);
        }
      });
    }
    function getItemSchemas(subSchemas, key) {
      return subSchemas.map(function(sub) {
        if (!sub) {
          return void 0;
        }
        if (Array.isArray(sub.items)) {
          const schemaAtPos = sub.items[key];
          if (isSchema2(schemaAtPos)) {
            return schemaAtPos;
          } else if (has(sub, "additionalItems")) {
            return sub.additionalItems;
          }
        } else {
          return sub.items;
        }
        return void 0;
      });
    }
    function getAdditionalSchemas(subSchemas) {
      return subSchemas.map(function(sub) {
        if (!sub) {
          return void 0;
        }
        if (Array.isArray(sub.items)) {
          return sub.additionalItems;
        }
        return sub.items;
      });
    }
    function mergeItems(group, mergeSchemas, items) {
      const allKeys = allUniqueKeys(items);
      return allKeys.reduce(function(all, key) {
        const schemas = getItemSchemas(group, key);
        const compacted = uniqWith(schemas.filter(notUndefined), compare);
        all[key] = mergeSchemas(compacted, key);
        return all;
      }, []);
    }
    module2.exports = {
      keywords: ["items", "additionalItems"],
      resolver(values, parents, mergers) {
        const items = values.map((s) => s.items);
        const itemsCompacted = items.filter(notUndefined);
        const returnObject = {};
        if (itemsCompacted.every(isSchema2)) {
          returnObject.items = mergers.items(items);
        } else {
          returnObject.items = mergeItems(values, mergers.items, items);
        }
        let schemasAtLastPos;
        if (itemsCompacted.every(Array.isArray)) {
          schemasAtLastPos = values.map((s) => s.additionalItems);
        } else if (itemsCompacted.some(Array.isArray)) {
          schemasAtLastPos = getAdditionalSchemas(values);
        }
        if (schemasAtLastPos) {
          returnObject.additionalItems = mergers.additionalItems(schemasAtLastPos);
        }
        if (returnObject.additionalItems === false && Array.isArray(returnObject.items)) {
          removeFalseSchemasFromArray(returnObject.items);
        }
        return deleteUndefinedProps(returnObject);
      }
    };
  }
});

// node_modules/json-schema-merge-allof/src/index.js
var require_src2 = __commonJS({
  "node_modules/json-schema-merge-allof/src/index.js"(exports2, module2) {
    var cloneDeep = require_cloneDeep();
    var compare = require_src();
    var computeLcm = require_lib8();
    var defaultsDeep = require_defaultsDeep();
    var flatten = require_flatten();
    var flattenDeep = require_flattenDeep();
    var intersection = require_intersection();
    var intersectionWith = require_intersectionWith();
    var isEqual = require_isEqual();
    var isPlainObject = require_isPlainObject();
    var pullAll = require_pullAll();
    var sortBy = require_sortBy();
    var uniq = require_uniq();
    var uniqWith = require_uniqWith();
    var propertiesResolver = require_properties();
    var itemsResolver = require_items();
    var contains2 = (arr, val) => arr.indexOf(val) !== -1;
    var isSchema2 = (val) => isPlainObject(val) || val === true || val === false;
    var isFalse = (val) => val === false;
    var isTrue = (val) => val === true;
    var schemaResolver = (compacted, key, mergeSchemas) => mergeSchemas(compacted);
    var stringArray = (values) => sortBy(uniq(flattenDeep(values)));
    var notUndefined = (val) => val !== void 0;
    var allUniqueKeys = (arr) => uniq(flattenDeep(arr.map(keys)));
    var first = (compacted) => compacted[0];
    var required = (compacted) => stringArray(compacted);
    var maximumValue = (compacted) => Math.max.apply(Math, compacted);
    var minimumValue = (compacted) => Math.min.apply(Math, compacted);
    var uniqueItems = (compacted) => compacted.some(isTrue);
    var examples = (compacted) => uniqWith(flatten(compacted), isEqual);
    function compareProp(key) {
      return function(a, b) {
        return compare({
          [key]: a
        }, { [key]: b });
      };
    }
    function getAllOf(schema2) {
      let { allOf = [], ...copy } = schema2;
      copy = isPlainObject(schema2) ? copy : schema2;
      return [copy, ...allOf.map(getAllOf)];
    }
    function getValues(schemas, key) {
      return schemas.map((schema2) => schema2 && schema2[key]);
    }
    function tryMergeSchemaGroups(schemaGroups, mergeSchemas) {
      return schemaGroups.map(function(schemas, index) {
        try {
          return mergeSchemas(schemas, index);
        } catch (e) {
          return void 0;
        }
      }).filter(notUndefined);
    }
    function keys(obj) {
      if (isPlainObject(obj) || Array.isArray(obj)) {
        return Object.keys(obj);
      } else {
        return [];
      }
    }
    function getAnyOfCombinations(arrOfArrays, combinations) {
      combinations = combinations || [];
      if (!arrOfArrays.length) {
        return combinations;
      }
      const values = arrOfArrays.slice(0).shift();
      const rest = arrOfArrays.slice(1);
      if (combinations.length) {
        return getAnyOfCombinations(rest, flatten(combinations.map((combination) => values.map((item) => [item].concat(combination)))));
      }
      return getAnyOfCombinations(rest, values.map((item) => item));
    }
    function throwIncompatible(values, paths) {
      let asJSON;
      try {
        asJSON = values.map(function(val) {
          return JSON.stringify(val, null, 2);
        }).join("\n");
      } catch (variable) {
        asJSON = values.join(", ");
      }
      throw new Error('Could not resolve values for path:"' + paths.join(".") + '". They are probably incompatible. Values: \n' + asJSON);
    }
    function callGroupResolver(complexKeywords, resolverName, schemas, mergeSchemas, options, parents) {
      if (complexKeywords.length) {
        const resolverConfig = options.complexResolvers[resolverName];
        if (!resolverConfig || !resolverConfig.resolver) {
          throw new Error("No resolver found for " + resolverName);
        }
        const extractedKeywordsOnly = schemas.map((schema2) => complexKeywords.reduce((all, key) => {
          if (schema2[key] !== void 0) all[key] = schema2[key];
          return all;
        }, {}));
        const unique = uniqWith(extractedKeywordsOnly, compare);
        const mergers = resolverConfig.keywords.reduce((all, key) => ({
          ...all,
          [key]: (schemas2, extraKey = []) => mergeSchemas(schemas2, null, parents.concat(key, extraKey))
        }), {});
        const result = resolverConfig.resolver(unique, parents.concat(resolverName), mergers, options);
        if (!isPlainObject(result)) {
          throwIncompatible(unique, parents.concat(resolverName));
        }
        return result;
      }
    }
    function createRequiredMetaArray(arr) {
      return { required: arr };
    }
    var schemaGroupProps = ["properties", "patternProperties", "definitions", "dependencies"];
    var schemaArrays = ["anyOf", "oneOf"];
    var schemaProps = [
      "additionalProperties",
      "additionalItems",
      "contains",
      "propertyNames",
      "not",
      "items"
    ];
    var defaultResolvers = {
      type(compacted) {
        if (compacted.some(Array.isArray)) {
          const normalized = compacted.map(function(val) {
            return Array.isArray(val) ? val : [val];
          });
          const common2 = intersection.apply(null, normalized);
          if (common2.length === 1) {
            return common2[0];
          } else if (common2.length > 1) {
            return uniq(common2);
          }
        }
      },
      dependencies(compacted, paths, mergeSchemas) {
        const allChildren = allUniqueKeys(compacted);
        return allChildren.reduce(function(all, childKey) {
          const childSchemas = getValues(compacted, childKey);
          let innerCompacted = uniqWith(childSchemas.filter(notUndefined), isEqual);
          const innerArrays = innerCompacted.filter(Array.isArray);
          if (innerArrays.length) {
            if (innerArrays.length === innerCompacted.length) {
              all[childKey] = stringArray(innerCompacted);
            } else {
              const innerSchemas = innerCompacted.filter(isSchema2);
              const arrayMetaScheams = innerArrays.map(createRequiredMetaArray);
              all[childKey] = mergeSchemas(innerSchemas.concat(arrayMetaScheams), childKey);
            }
            return all;
          }
          innerCompacted = uniqWith(innerCompacted, compare);
          all[childKey] = mergeSchemas(innerCompacted, childKey);
          return all;
        }, {});
      },
      oneOf(compacted, paths, mergeSchemas) {
        const combinations = getAnyOfCombinations(cloneDeep(compacted));
        const result = tryMergeSchemaGroups(combinations, mergeSchemas);
        const unique = uniqWith(result, compare);
        if (unique.length) {
          return unique;
        }
      },
      not(compacted) {
        return { anyOf: compacted };
      },
      pattern(compacted) {
        return compacted.map((r2) => "(?=" + r2 + ")").join("");
      },
      multipleOf(compacted) {
        let integers = compacted.slice(0);
        let factor = 1;
        while (integers.some((n) => !Number.isInteger(n))) {
          integers = integers.map((n) => n * 10);
          factor = factor * 10;
        }
        return computeLcm(integers) / factor;
      },
      enum(compacted) {
        const enums = intersectionWith.apply(null, compacted.concat(isEqual));
        if (enums.length) {
          return sortBy(enums);
        }
      }
    };
    defaultResolvers.$id = first;
    defaultResolvers.$ref = first;
    defaultResolvers.$schema = first;
    defaultResolvers.additionalItems = schemaResolver;
    defaultResolvers.additionalProperties = schemaResolver;
    defaultResolvers.anyOf = defaultResolvers.oneOf;
    defaultResolvers.contains = schemaResolver;
    defaultResolvers.default = first;
    defaultResolvers.definitions = defaultResolvers.dependencies;
    defaultResolvers.description = first;
    defaultResolvers.examples = examples;
    defaultResolvers.exclusiveMaximum = minimumValue;
    defaultResolvers.exclusiveMinimum = maximumValue;
    defaultResolvers.items = itemsResolver;
    defaultResolvers.maximum = minimumValue;
    defaultResolvers.maxItems = minimumValue;
    defaultResolvers.maxLength = minimumValue;
    defaultResolvers.maxProperties = minimumValue;
    defaultResolvers.minimum = maximumValue;
    defaultResolvers.minItems = maximumValue;
    defaultResolvers.minLength = maximumValue;
    defaultResolvers.minProperties = maximumValue;
    defaultResolvers.properties = propertiesResolver;
    defaultResolvers.propertyNames = schemaResolver;
    defaultResolvers.required = required;
    defaultResolvers.title = first;
    defaultResolvers.uniqueItems = uniqueItems;
    var defaultComplexResolvers = {
      properties: propertiesResolver,
      items: itemsResolver
    };
    function merger(rootSchema, options, totalSchemas) {
      totalSchemas = totalSchemas || [];
      options = defaultsDeep(options, {
        ignoreAdditionalProperties: false,
        resolvers: defaultResolvers,
        complexResolvers: defaultComplexResolvers,
        deep: true
      });
      const complexResolvers = Object.entries(options.complexResolvers);
      function mergeSchemas(schemas, base, parents) {
        schemas = cloneDeep(schemas.filter(notUndefined));
        parents = parents || [];
        const merged2 = isPlainObject(base) ? base : {};
        if (!schemas.length) {
          return;
        }
        if (schemas.some(isFalse)) {
          return false;
        }
        if (schemas.every(isTrue)) {
          return true;
        }
        schemas = schemas.filter(isPlainObject);
        const allKeys = allUniqueKeys(schemas);
        if (options.deep && contains2(allKeys, "allOf")) {
          return merger({
            allOf: schemas
          }, options, totalSchemas);
        }
        const complexKeysArr = complexResolvers.map(([mainKeyWord, resolverConf]) => allKeys.filter((k) => resolverConf.keywords.includes(k)));
        complexKeysArr.forEach((keys2) => pullAll(allKeys, keys2));
        allKeys.forEach(function(key) {
          const values = getValues(schemas, key);
          const compacted = uniqWith(values.filter(notUndefined), compareProp(key));
          if (compacted.length === 1 && contains2(schemaArrays, key)) {
            merged2[key] = compacted[0].map((schema2) => mergeSchemas([schema2], schema2));
          } else if (compacted.length === 1 && !contains2(schemaGroupProps, key) && !contains2(schemaProps, key)) {
            merged2[key] = compacted[0];
          } else {
            const resolver = options.resolvers[key] || options.resolvers.defaultResolver;
            if (!resolver) throw new Error("No resolver found for key " + key + ". You can provide a resolver for this keyword in the options, or provide a default resolver.");
            const merger2 = (schemas2, extraKey = []) => mergeSchemas(schemas2, null, parents.concat(key, extraKey));
            merged2[key] = resolver(compacted, parents.concat(key), merger2, options);
            if (merged2[key] === void 0) {
              throwIncompatible(compacted, parents.concat(key));
            } else if (merged2[key] === void 0) {
              delete merged2[key];
            }
          }
        });
        return complexResolvers.reduce((all, [resolverKeyword, config], index) => ({
          ...all,
          ...callGroupResolver(complexKeysArr[index], resolverKeyword, schemas, mergeSchemas, options, parents)
        }), merged2);
      }
      const allSchemas = flattenDeep(getAllOf(rootSchema));
      const merged = mergeSchemas(allSchemas);
      return merged;
    }
    merger.options = {
      resolvers: defaultResolvers
    };
    module2.exports = merger;
  }
});

// node_modules/es5-ext/function/noop.js
var require_noop2 = __commonJS({
  "node_modules/es5-ext/function/noop.js"(exports2, module2) {
    "use strict";
    module2.exports = function() {
    };
  }
});

// node_modules/es5-ext/object/is-value.js
var require_is_value = __commonJS({
  "node_modules/es5-ext/object/is-value.js"(exports2, module2) {
    "use strict";
    var _undefined = require_noop2()();
    module2.exports = function(val) {
      return val !== _undefined && val !== null;
    };
  }
});

// node_modules/es5-ext/object/normalize-options.js
var require_normalize_options = __commonJS({
  "node_modules/es5-ext/object/normalize-options.js"(exports2, module2) {
    "use strict";
    var isValue = require_is_value();
    var forEach = Array.prototype.forEach;
    var create = Object.create;
    var process2 = function(src, obj) {
      var key;
      for (key in src) obj[key] = src[key];
    };
    module2.exports = function(opts1) {
      var result = create(null);
      forEach.call(arguments, function(options) {
        if (!isValue(options)) return;
        process2(Object(options), result);
      });
      return result;
    };
  }
});

// node_modules/es5-ext/math/sign/is-implemented.js
var require_is_implemented = __commonJS({
  "node_modules/es5-ext/math/sign/is-implemented.js"(exports2, module2) {
    "use strict";
    module2.exports = function() {
      var sign = Math.sign;
      if (typeof sign !== "function") return false;
      return sign(10) === 1 && sign(-20) === -1;
    };
  }
});

// node_modules/es5-ext/math/sign/shim.js
var require_shim = __commonJS({
  "node_modules/es5-ext/math/sign/shim.js"(exports2, module2) {
    "use strict";
    module2.exports = function(value) {
      value = Number(value);
      if (isNaN(value) || value === 0) return value;
      return value > 0 ? 1 : -1;
    };
  }
});

// node_modules/es5-ext/math/sign/index.js
var require_sign = __commonJS({
  "node_modules/es5-ext/math/sign/index.js"(exports2, module2) {
    "use strict";
    module2.exports = require_is_implemented()() ? Math.sign : require_shim();
  }
});

// node_modules/es5-ext/number/to-integer.js
var require_to_integer = __commonJS({
  "node_modules/es5-ext/number/to-integer.js"(exports2, module2) {
    "use strict";
    var sign = require_sign();
    var abs = Math.abs;
    var floor = Math.floor;
    module2.exports = function(value) {
      if (isNaN(value)) return 0;
      value = Number(value);
      if (value === 0 || !isFinite(value)) return value;
      return sign(value) * floor(abs(value));
    };
  }
});

// node_modules/es5-ext/number/to-pos-integer.js
var require_to_pos_integer = __commonJS({
  "node_modules/es5-ext/number/to-pos-integer.js"(exports2, module2) {
    "use strict";
    var toInteger = require_to_integer();
    var max = Math.max;
    module2.exports = function(value) {
      return max(0, toInteger(value));
    };
  }
});

// node_modules/memoizee/lib/resolve-length.js
var require_resolve_length = __commonJS({
  "node_modules/memoizee/lib/resolve-length.js"(exports2, module2) {
    "use strict";
    var toPosInt = require_to_pos_integer();
    module2.exports = function(optsLength, fnLength, isAsync) {
      var length;
      if (isNaN(optsLength)) {
        length = fnLength;
        if (!(length >= 0)) return 1;
        if (isAsync && length) return length - 1;
        return length;
      }
      if (optsLength === false) return false;
      return toPosInt(optsLength);
    };
  }
});

// node_modules/es5-ext/object/valid-callable.js
var require_valid_callable = __commonJS({
  "node_modules/es5-ext/object/valid-callable.js"(exports2, module2) {
    "use strict";
    module2.exports = function(fn) {
      if (typeof fn !== "function") throw new TypeError(fn + " is not a function");
      return fn;
    };
  }
});

// node_modules/es5-ext/object/valid-value.js
var require_valid_value = __commonJS({
  "node_modules/es5-ext/object/valid-value.js"(exports2, module2) {
    "use strict";
    var isValue = require_is_value();
    module2.exports = function(value) {
      if (!isValue(value)) throw new TypeError("Cannot use null or undefined");
      return value;
    };
  }
});

// node_modules/es5-ext/object/_iterate.js
var require_iterate = __commonJS({
  "node_modules/es5-ext/object/_iterate.js"(exports2, module2) {
    "use strict";
    var callable = require_valid_callable();
    var value = require_valid_value();
    var bind = Function.prototype.bind;
    var call = Function.prototype.call;
    var keys = Object.keys;
    var objPropertyIsEnumerable = Object.prototype.propertyIsEnumerable;
    module2.exports = function(method, defVal) {
      return function(obj, cb) {
        var list, thisArg = arguments[2], compareFn = arguments[3];
        obj = Object(value(obj));
        callable(cb);
        list = keys(obj);
        if (compareFn) {
          list.sort(typeof compareFn === "function" ? bind.call(compareFn, obj) : void 0);
        }
        if (typeof method !== "function") method = list[method];
        return call.call(method, list, function(key, index) {
          if (!objPropertyIsEnumerable.call(obj, key)) return defVal;
          return call.call(cb, thisArg, obj[key], key, obj, index);
        });
      };
    };
  }
});

// node_modules/es5-ext/object/for-each.js
var require_for_each = __commonJS({
  "node_modules/es5-ext/object/for-each.js"(exports2, module2) {
    "use strict";
    module2.exports = require_iterate()("forEach");
  }
});

// node_modules/memoizee/lib/registered-extensions.js
var require_registered_extensions = __commonJS({
  "node_modules/memoizee/lib/registered-extensions.js"() {
    "use strict";
  }
});

// node_modules/es5-ext/object/assign/is-implemented.js
var require_is_implemented2 = __commonJS({
  "node_modules/es5-ext/object/assign/is-implemented.js"(exports2, module2) {
    "use strict";
    module2.exports = function() {
      var assign = Object.assign, obj;
      if (typeof assign !== "function") return false;
      obj = { foo: "raz" };
      assign(obj, { bar: "dwa" }, { trzy: "trzy" });
      return obj.foo + obj.bar + obj.trzy === "razdwatrzy";
    };
  }
});

// node_modules/es5-ext/object/keys/is-implemented.js
var require_is_implemented3 = __commonJS({
  "node_modules/es5-ext/object/keys/is-implemented.js"(exports2, module2) {
    "use strict";
    module2.exports = function() {
      try {
        Object.keys("primitive");
        return true;
      } catch (e) {
        return false;
      }
    };
  }
});

// node_modules/es5-ext/object/keys/shim.js
var require_shim2 = __commonJS({
  "node_modules/es5-ext/object/keys/shim.js"(exports2, module2) {
    "use strict";
    var isValue = require_is_value();
    var keys = Object.keys;
    module2.exports = function(object) {
      return keys(isValue(object) ? Object(object) : object);
    };
  }
});

// node_modules/es5-ext/object/keys/index.js
var require_keys2 = __commonJS({
  "node_modules/es5-ext/object/keys/index.js"(exports2, module2) {
    "use strict";
    module2.exports = require_is_implemented3()() ? Object.keys : require_shim2();
  }
});

// node_modules/es5-ext/object/assign/shim.js
var require_shim3 = __commonJS({
  "node_modules/es5-ext/object/assign/shim.js"(exports2, module2) {
    "use strict";
    var keys = require_keys2();
    var value = require_valid_value();
    var max = Math.max;
    module2.exports = function(dest, src) {
      var error, i, length = max(arguments.length, 2), assign;
      dest = Object(value(dest));
      assign = function(key) {
        try {
          dest[key] = src[key];
        } catch (e) {
          if (!error) error = e;
        }
      };
      for (i = 1; i < length; ++i) {
        src = arguments[i];
        keys(src).forEach(assign);
      }
      if (error !== void 0) throw error;
      return dest;
    };
  }
});

// node_modules/es5-ext/object/assign/index.js
var require_assign = __commonJS({
  "node_modules/es5-ext/object/assign/index.js"(exports2, module2) {
    "use strict";
    module2.exports = require_is_implemented2()() ? Object.assign : require_shim3();
  }
});

// node_modules/es5-ext/object/is-object.js
var require_is_object = __commonJS({
  "node_modules/es5-ext/object/is-object.js"(exports2, module2) {
    "use strict";
    var isValue = require_is_value();
    var map2 = { function: true, object: true };
    module2.exports = function(value) {
      return isValue(value) && map2[typeof value] || false;
    };
  }
});

// node_modules/es5-ext/error/custom.js
var require_custom = __commonJS({
  "node_modules/es5-ext/error/custom.js"(exports2, module2) {
    "use strict";
    var assign = require_assign();
    var isObject5 = require_is_object();
    var isValue = require_is_value();
    var captureStackTrace = Error.captureStackTrace;
    module2.exports = function(message) {
      var err = new Error(message), code = arguments[1], ext = arguments[2];
      if (!isValue(ext)) {
        if (isObject5(code)) {
          ext = code;
          code = null;
        }
      }
      if (isValue(ext)) assign(err, ext);
      if (isValue(code)) err.code = code;
      if (captureStackTrace) captureStackTrace(err, module2.exports);
      return err;
    };
  }
});

// node_modules/es5-ext/object/mixin.js
var require_mixin = __commonJS({
  "node_modules/es5-ext/object/mixin.js"(exports2, module2) {
    "use strict";
    var value = require_valid_value();
    var defineProperty = Object.defineProperty;
    var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
    var getOwnPropertyNames = Object.getOwnPropertyNames;
    var getOwnPropertySymbols = Object.getOwnPropertySymbols;
    module2.exports = function(target, source) {
      var error, sourceObject = Object(value(source));
      target = Object(value(target));
      getOwnPropertyNames(sourceObject).forEach(function(name) {
        try {
          defineProperty(target, name, getOwnPropertyDescriptor(source, name));
        } catch (e) {
          error = e;
        }
      });
      if (typeof getOwnPropertySymbols === "function") {
        getOwnPropertySymbols(sourceObject).forEach(function(symbol) {
          try {
            defineProperty(target, symbol, getOwnPropertyDescriptor(source, symbol));
          } catch (e) {
            error = e;
          }
        });
      }
      if (error !== void 0) throw error;
      return target;
    };
  }
});

// node_modules/es5-ext/function/_define-length.js
var require_define_length = __commonJS({
  "node_modules/es5-ext/function/_define-length.js"(exports2, module2) {
    "use strict";
    var toPosInt = require_to_pos_integer();
    var test = function(arg1, arg2) {
      return arg2;
    };
    var desc;
    var defineProperty;
    var generate;
    var mixin;
    try {
      Object.defineProperty(test, "length", {
        configurable: true,
        writable: false,
        enumerable: false,
        value: 1
      });
    } catch (ignore) {
    }
    if (test.length === 1) {
      desc = { configurable: true, writable: false, enumerable: false };
      defineProperty = Object.defineProperty;
      module2.exports = function(fn, length) {
        length = toPosInt(length);
        if (fn.length === length) return fn;
        desc.value = length;
        return defineProperty(fn, "length", desc);
      };
    } else {
      mixin = require_mixin();
      generate = /* @__PURE__ */ function() {
        var cache = [];
        return function(length) {
          var args, i = 0;
          if (cache[length]) return cache[length];
          args = [];
          while (length--) args.push("a" + (++i).toString(36));
          return new Function(
            "fn",
            "return function (" + args.join(", ") + ") { return fn.apply(this, arguments); };"
          );
        };
      }();
      module2.exports = function(src, length) {
        var target;
        length = toPosInt(length);
        if (src.length === length) return src;
        target = generate(length)(src);
        try {
          mixin(target, src);
        } catch (ignore) {
        }
        return target;
      };
    }
  }
});

// node_modules/type/value/is.js
var require_is = __commonJS({
  "node_modules/type/value/is.js"(exports2, module2) {
    "use strict";
    var _undefined = void 0;
    module2.exports = function(value) {
      return value !== _undefined && value !== null;
    };
  }
});

// node_modules/type/object/is.js
var require_is2 = __commonJS({
  "node_modules/type/object/is.js"(exports2, module2) {
    "use strict";
    var isValue = require_is();
    var possibleTypes = {
      "object": true,
      "function": true,
      "undefined": true
      /* document.all */
    };
    module2.exports = function(value) {
      if (!isValue(value)) return false;
      return hasOwnProperty.call(possibleTypes, typeof value);
    };
  }
});

// node_modules/type/prototype/is.js
var require_is3 = __commonJS({
  "node_modules/type/prototype/is.js"(exports2, module2) {
    "use strict";
    var isObject5 = require_is2();
    module2.exports = function(value) {
      if (!isObject5(value)) return false;
      try {
        if (!value.constructor) return false;
        return value.constructor.prototype === value;
      } catch (error) {
        return false;
      }
    };
  }
});

// node_modules/type/function/is.js
var require_is4 = __commonJS({
  "node_modules/type/function/is.js"(exports2, module2) {
    "use strict";
    var isPrototype = require_is3();
    module2.exports = function(value) {
      if (typeof value !== "function") return false;
      if (!hasOwnProperty.call(value, "length")) return false;
      try {
        if (typeof value.length !== "number") return false;
        if (typeof value.call !== "function") return false;
        if (typeof value.apply !== "function") return false;
      } catch (error) {
        return false;
      }
      return !isPrototype(value);
    };
  }
});

// node_modules/type/plain-function/is.js
var require_is5 = __commonJS({
  "node_modules/type/plain-function/is.js"(exports2, module2) {
    "use strict";
    var isFunction = require_is4();
    var classRe = /^\s*class[\s{/}]/;
    var functionToString = Function.prototype.toString;
    module2.exports = function(value) {
      if (!isFunction(value)) return false;
      if (classRe.test(functionToString.call(value))) return false;
      return true;
    };
  }
});

// node_modules/es5-ext/string/#/contains/is-implemented.js
var require_is_implemented4 = __commonJS({
  "node_modules/es5-ext/string/#/contains/is-implemented.js"(exports2, module2) {
    "use strict";
    var str2 = "razdwatrzy";
    module2.exports = function() {
      if (typeof str2.contains !== "function") return false;
      return str2.contains("dwa") === true && str2.contains("foo") === false;
    };
  }
});

// node_modules/es5-ext/string/#/contains/shim.js
var require_shim4 = __commonJS({
  "node_modules/es5-ext/string/#/contains/shim.js"(exports2, module2) {
    "use strict";
    var indexOf = String.prototype.indexOf;
    module2.exports = function(searchString) {
      return indexOf.call(this, searchString, arguments[1]) > -1;
    };
  }
});

// node_modules/es5-ext/string/#/contains/index.js
var require_contains = __commonJS({
  "node_modules/es5-ext/string/#/contains/index.js"(exports2, module2) {
    "use strict";
    module2.exports = require_is_implemented4()() ? String.prototype.contains : require_shim4();
  }
});

// node_modules/d/index.js
var require_d = __commonJS({
  "node_modules/d/index.js"(exports2, module2) {
    "use strict";
    var isValue = require_is();
    var isPlainFunction = require_is5();
    var assign = require_assign();
    var normalizeOpts = require_normalize_options();
    var contains2 = require_contains();
    var d = module2.exports = function(dscr, value) {
      var c2, e, w, options, desc;
      if (arguments.length < 2 || typeof dscr !== "string") {
        options = value;
        value = dscr;
        dscr = null;
      } else {
        options = arguments[2];
      }
      if (isValue(dscr)) {
        c2 = contains2.call(dscr, "c");
        e = contains2.call(dscr, "e");
        w = contains2.call(dscr, "w");
      } else {
        c2 = w = true;
        e = false;
      }
      desc = { value, configurable: c2, enumerable: e, writable: w };
      return !options ? desc : assign(normalizeOpts(options), desc);
    };
    d.gs = function(dscr, get2, set3) {
      var c2, e, options, desc;
      if (typeof dscr !== "string") {
        options = set3;
        set3 = get2;
        get2 = dscr;
        dscr = null;
      } else {
        options = arguments[3];
      }
      if (!isValue(get2)) {
        get2 = void 0;
      } else if (!isPlainFunction(get2)) {
        options = get2;
        get2 = set3 = void 0;
      } else if (!isValue(set3)) {
        set3 = void 0;
      } else if (!isPlainFunction(set3)) {
        options = set3;
        set3 = void 0;
      }
      if (isValue(dscr)) {
        c2 = contains2.call(dscr, "c");
        e = contains2.call(dscr, "e");
      } else {
        c2 = true;
        e = false;
      }
      desc = { get: get2, set: set3, configurable: c2, enumerable: e };
      return !options ? desc : assign(normalizeOpts(options), desc);
    };
  }
});

// node_modules/event-emitter/index.js
var require_event_emitter = __commonJS({
  "node_modules/event-emitter/index.js"(exports2, module2) {
    "use strict";
    var d = require_d();
    var callable = require_valid_callable();
    var apply = Function.prototype.apply;
    var call = Function.prototype.call;
    var create = Object.create;
    var defineProperty = Object.defineProperty;
    var defineProperties = Object.defineProperties;
    var hasOwnProperty2 = Object.prototype.hasOwnProperty;
    var descriptor = { configurable: true, enumerable: false, writable: true };
    var on;
    var once;
    var off;
    var emit;
    var methods;
    var descriptors;
    var base;
    on = function(type2, listener) {
      var data;
      callable(listener);
      if (!hasOwnProperty2.call(this, "__ee__")) {
        data = descriptor.value = create(null);
        defineProperty(this, "__ee__", descriptor);
        descriptor.value = null;
      } else {
        data = this.__ee__;
      }
      if (!data[type2]) data[type2] = listener;
      else if (typeof data[type2] === "object") data[type2].push(listener);
      else data[type2] = [data[type2], listener];
      return this;
    };
    once = function(type2, listener) {
      var once2, self2;
      callable(listener);
      self2 = this;
      on.call(this, type2, once2 = function() {
        off.call(self2, type2, once2);
        apply.call(listener, this, arguments);
      });
      once2.__eeOnceListener__ = listener;
      return this;
    };
    off = function(type2, listener) {
      var data, listeners, candidate, i;
      callable(listener);
      if (!hasOwnProperty2.call(this, "__ee__")) return this;
      data = this.__ee__;
      if (!data[type2]) return this;
      listeners = data[type2];
      if (typeof listeners === "object") {
        for (i = 0; candidate = listeners[i]; ++i) {
          if (candidate === listener || candidate.__eeOnceListener__ === listener) {
            if (listeners.length === 2) data[type2] = listeners[i ? 0 : 1];
            else listeners.splice(i, 1);
          }
        }
      } else {
        if (listeners === listener || listeners.__eeOnceListener__ === listener) {
          delete data[type2];
        }
      }
      return this;
    };
    emit = function(type2) {
      var i, l, listener, listeners, args;
      if (!hasOwnProperty2.call(this, "__ee__")) return;
      listeners = this.__ee__[type2];
      if (!listeners) return;
      if (typeof listeners === "object") {
        l = arguments.length;
        args = new Array(l - 1);
        for (i = 1; i < l; ++i) args[i - 1] = arguments[i];
        listeners = listeners.slice();
        for (i = 0; listener = listeners[i]; ++i) {
          apply.call(listener, this, args);
        }
      } else {
        switch (arguments.length) {
          case 1:
            call.call(listeners, this);
            break;
          case 2:
            call.call(listeners, this, arguments[1]);
            break;
          case 3:
            call.call(listeners, this, arguments[1], arguments[2]);
            break;
          default:
            l = arguments.length;
            args = new Array(l - 1);
            for (i = 1; i < l; ++i) {
              args[i - 1] = arguments[i];
            }
            apply.call(listeners, this, args);
        }
      }
    };
    methods = {
      on,
      once,
      off,
      emit
    };
    descriptors = {
      on: d(on),
      once: d(once),
      off: d(off),
      emit: d(emit)
    };
    base = defineProperties({}, descriptors);
    module2.exports = exports2 = function(o) {
      return o == null ? create(base) : defineProperties(Object(o), descriptors);
    };
    exports2.methods = methods;
  }
});

// node_modules/es5-ext/array/from/is-implemented.js
var require_is_implemented5 = __commonJS({
  "node_modules/es5-ext/array/from/is-implemented.js"(exports2, module2) {
    "use strict";
    module2.exports = function() {
      var from = Array.from, arr, result;
      if (typeof from !== "function") return false;
      arr = ["raz", "dwa"];
      result = from(arr);
      return Boolean(result && result !== arr && result[1] === "dwa");
    };
  }
});

// node_modules/ext/global-this/is-implemented.js
var require_is_implemented6 = __commonJS({
  "node_modules/ext/global-this/is-implemented.js"(exports2, module2) {
    "use strict";
    module2.exports = function() {
      if (typeof globalThis !== "object") return false;
      if (!globalThis) return false;
      return globalThis.Array === Array;
    };
  }
});

// node_modules/ext/global-this/implementation.js
var require_implementation = __commonJS({
  "node_modules/ext/global-this/implementation.js"(exports2, module2) {
    var naiveFallback = function() {
      if (typeof self === "object" && self) return self;
      if (typeof window === "object" && window) return window;
      throw new Error("Unable to resolve global `this`");
    };
    module2.exports = function() {
      if (this) return this;
      try {
        Object.defineProperty(Object.prototype, "__global__", {
          get: function() {
            return this;
          },
          configurable: true
        });
      } catch (error) {
        return naiveFallback();
      }
      try {
        if (!__global__) return naiveFallback();
        return __global__;
      } finally {
        delete Object.prototype.__global__;
      }
    }();
  }
});

// node_modules/ext/global-this/index.js
var require_global_this = __commonJS({
  "node_modules/ext/global-this/index.js"(exports2, module2) {
    "use strict";
    module2.exports = require_is_implemented6()() ? globalThis : require_implementation();
  }
});

// node_modules/es6-symbol/is-implemented.js
var require_is_implemented7 = __commonJS({
  "node_modules/es6-symbol/is-implemented.js"(exports2, module2) {
    "use strict";
    var global2 = require_global_this();
    var validTypes = { object: true, symbol: true };
    module2.exports = function() {
      var Symbol2 = global2.Symbol;
      var symbol;
      if (typeof Symbol2 !== "function") return false;
      symbol = Symbol2("test symbol");
      try {
        String(symbol);
      } catch (e) {
        return false;
      }
      if (!validTypes[typeof Symbol2.iterator]) return false;
      if (!validTypes[typeof Symbol2.toPrimitive]) return false;
      if (!validTypes[typeof Symbol2.toStringTag]) return false;
      return true;
    };
  }
});

// node_modules/es6-symbol/is-symbol.js
var require_is_symbol = __commonJS({
  "node_modules/es6-symbol/is-symbol.js"(exports2, module2) {
    "use strict";
    module2.exports = function(value) {
      if (!value) return false;
      if (typeof value === "symbol") return true;
      if (!value.constructor) return false;
      if (value.constructor.name !== "Symbol") return false;
      return value[value.constructor.toStringTag] === "Symbol";
    };
  }
});

// node_modules/es6-symbol/validate-symbol.js
var require_validate_symbol = __commonJS({
  "node_modules/es6-symbol/validate-symbol.js"(exports2, module2) {
    "use strict";
    var isSymbol = require_is_symbol();
    module2.exports = function(value) {
      if (!isSymbol(value)) throw new TypeError(value + " is not a symbol");
      return value;
    };
  }
});

// node_modules/es6-symbol/lib/private/generate-name.js
var require_generate_name = __commonJS({
  "node_modules/es6-symbol/lib/private/generate-name.js"(exports2, module2) {
    "use strict";
    var d = require_d();
    var create = Object.create;
    var defineProperty = Object.defineProperty;
    var objPrototype = Object.prototype;
    var created = create(null);
    module2.exports = function(desc) {
      var postfix = 0, name, ie11BugWorkaround;
      while (created[desc + (postfix || "")]) ++postfix;
      desc += postfix || "";
      created[desc] = true;
      name = "@@" + desc;
      defineProperty(
        objPrototype,
        name,
        d.gs(null, function(value) {
          if (ie11BugWorkaround) return;
          ie11BugWorkaround = true;
          defineProperty(this, name, d(value));
          ie11BugWorkaround = false;
        })
      );
      return name;
    };
  }
});

// node_modules/es6-symbol/lib/private/setup/standard-symbols.js
var require_standard_symbols = __commonJS({
  "node_modules/es6-symbol/lib/private/setup/standard-symbols.js"(exports2, module2) {
    "use strict";
    var d = require_d();
    var NativeSymbol = require_global_this().Symbol;
    module2.exports = function(SymbolPolyfill) {
      return Object.defineProperties(SymbolPolyfill, {
        // To ensure proper interoperability with other native functions (e.g. Array.from)
        // fallback to eventual native implementation of given symbol
        hasInstance: d(
          "",
          NativeSymbol && NativeSymbol.hasInstance || SymbolPolyfill("hasInstance")
        ),
        isConcatSpreadable: d(
          "",
          NativeSymbol && NativeSymbol.isConcatSpreadable || SymbolPolyfill("isConcatSpreadable")
        ),
        iterator: d("", NativeSymbol && NativeSymbol.iterator || SymbolPolyfill("iterator")),
        match: d("", NativeSymbol && NativeSymbol.match || SymbolPolyfill("match")),
        replace: d("", NativeSymbol && NativeSymbol.replace || SymbolPolyfill("replace")),
        search: d("", NativeSymbol && NativeSymbol.search || SymbolPolyfill("search")),
        species: d("", NativeSymbol && NativeSymbol.species || SymbolPolyfill("species")),
        split: d("", NativeSymbol && NativeSymbol.split || SymbolPolyfill("split")),
        toPrimitive: d(
          "",
          NativeSymbol && NativeSymbol.toPrimitive || SymbolPolyfill("toPrimitive")
        ),
        toStringTag: d(
          "",
          NativeSymbol && NativeSymbol.toStringTag || SymbolPolyfill("toStringTag")
        ),
        unscopables: d(
          "",
          NativeSymbol && NativeSymbol.unscopables || SymbolPolyfill("unscopables")
        )
      });
    };
  }
});

// node_modules/es6-symbol/lib/private/setup/symbol-registry.js
var require_symbol_registry = __commonJS({
  "node_modules/es6-symbol/lib/private/setup/symbol-registry.js"(exports2, module2) {
    "use strict";
    var d = require_d();
    var validateSymbol = require_validate_symbol();
    var registry = /* @__PURE__ */ Object.create(null);
    module2.exports = function(SymbolPolyfill) {
      return Object.defineProperties(SymbolPolyfill, {
        for: d(function(key) {
          if (registry[key]) return registry[key];
          return registry[key] = SymbolPolyfill(String(key));
        }),
        keyFor: d(function(symbol) {
          var key;
          validateSymbol(symbol);
          for (key in registry) {
            if (registry[key] === symbol) return key;
          }
          return void 0;
        })
      });
    };
  }
});

// node_modules/es6-symbol/polyfill.js
var require_polyfill = __commonJS({
  "node_modules/es6-symbol/polyfill.js"(exports2, module2) {
    "use strict";
    var d = require_d();
    var validateSymbol = require_validate_symbol();
    var NativeSymbol = require_global_this().Symbol;
    var generateName = require_generate_name();
    var setupStandardSymbols = require_standard_symbols();
    var setupSymbolRegistry = require_symbol_registry();
    var create = Object.create;
    var defineProperties = Object.defineProperties;
    var defineProperty = Object.defineProperty;
    var SymbolPolyfill;
    var HiddenSymbol;
    var isNativeSafe;
    if (typeof NativeSymbol === "function") {
      try {
        String(NativeSymbol());
        isNativeSafe = true;
      } catch (ignore) {
      }
    } else {
      NativeSymbol = null;
    }
    HiddenSymbol = function Symbol2(description) {
      if (this instanceof HiddenSymbol) throw new TypeError("Symbol is not a constructor");
      return SymbolPolyfill(description);
    };
    module2.exports = SymbolPolyfill = function Symbol2(description) {
      var symbol;
      if (this instanceof Symbol2) throw new TypeError("Symbol is not a constructor");
      if (isNativeSafe) return NativeSymbol(description);
      symbol = create(HiddenSymbol.prototype);
      description = description === void 0 ? "" : String(description);
      return defineProperties(symbol, {
        __description__: d("", description),
        __name__: d("", generateName(description))
      });
    };
    setupStandardSymbols(SymbolPolyfill);
    setupSymbolRegistry(SymbolPolyfill);
    defineProperties(HiddenSymbol.prototype, {
      constructor: d(SymbolPolyfill),
      toString: d("", function() {
        return this.__name__;
      })
    });
    defineProperties(SymbolPolyfill.prototype, {
      toString: d(function() {
        return "Symbol (" + validateSymbol(this).__description__ + ")";
      }),
      valueOf: d(function() {
        return validateSymbol(this);
      })
    });
    defineProperty(
      SymbolPolyfill.prototype,
      SymbolPolyfill.toPrimitive,
      d("", function() {
        var symbol = validateSymbol(this);
        if (typeof symbol === "symbol") return symbol;
        return symbol.toString();
      })
    );
    defineProperty(SymbolPolyfill.prototype, SymbolPolyfill.toStringTag, d("c", "Symbol"));
    defineProperty(
      HiddenSymbol.prototype,
      SymbolPolyfill.toStringTag,
      d("c", SymbolPolyfill.prototype[SymbolPolyfill.toStringTag])
    );
    defineProperty(
      HiddenSymbol.prototype,
      SymbolPolyfill.toPrimitive,
      d("c", SymbolPolyfill.prototype[SymbolPolyfill.toPrimitive])
    );
  }
});

// node_modules/es6-symbol/index.js
var require_es6_symbol = __commonJS({
  "node_modules/es6-symbol/index.js"(exports2, module2) {
    "use strict";
    module2.exports = require_is_implemented7()() ? require_global_this().Symbol : require_polyfill();
  }
});

// node_modules/es5-ext/function/is-arguments.js
var require_is_arguments = __commonJS({
  "node_modules/es5-ext/function/is-arguments.js"(exports2, module2) {
    "use strict";
    var objToString = Object.prototype.toString;
    var id = objToString.call(/* @__PURE__ */ function() {
      return arguments;
    }());
    module2.exports = function(value) {
      return objToString.call(value) === id;
    };
  }
});

// node_modules/es5-ext/function/is-function.js
var require_is_function = __commonJS({
  "node_modules/es5-ext/function/is-function.js"(exports2, module2) {
    "use strict";
    var objToString = Object.prototype.toString;
    var isFunctionStringTag = RegExp.prototype.test.bind(/^[object [A-Za-z0-9]*Function]$/);
    module2.exports = function(value) {
      return typeof value === "function" && isFunctionStringTag(objToString.call(value));
    };
  }
});

// node_modules/es5-ext/string/is-string.js
var require_is_string = __commonJS({
  "node_modules/es5-ext/string/is-string.js"(exports2, module2) {
    "use strict";
    var objToString = Object.prototype.toString;
    var id = objToString.call("");
    module2.exports = function(value) {
      return typeof value === "string" || value && typeof value === "object" && (value instanceof String || objToString.call(value) === id) || false;
    };
  }
});

// node_modules/es5-ext/array/from/shim.js
var require_shim5 = __commonJS({
  "node_modules/es5-ext/array/from/shim.js"(exports2, module2) {
    "use strict";
    var iteratorSymbol = require_es6_symbol().iterator;
    var isArguments = require_is_arguments();
    var isFunction = require_is_function();
    var toPosInt = require_to_pos_integer();
    var callable = require_valid_callable();
    var validValue = require_valid_value();
    var isValue = require_is_value();
    var isString = require_is_string();
    var isArray = Array.isArray;
    var call = Function.prototype.call;
    var desc = { configurable: true, enumerable: true, writable: true, value: null };
    var defineProperty = Object.defineProperty;
    module2.exports = function(arrayLike) {
      var mapFn = arguments[1], thisArg = arguments[2], Context, i, j, arr, length, code, iterator, result, getIterator, value;
      arrayLike = Object(validValue(arrayLike));
      if (isValue(mapFn)) callable(mapFn);
      if (!this || this === Array || !isFunction(this)) {
        if (!mapFn) {
          if (isArguments(arrayLike)) {
            length = arrayLike.length;
            if (length !== 1) return Array.apply(null, arrayLike);
            arr = new Array(1);
            arr[0] = arrayLike[0];
            return arr;
          }
          if (isArray(arrayLike)) {
            arr = new Array(length = arrayLike.length);
            for (i = 0; i < length; ++i) arr[i] = arrayLike[i];
            return arr;
          }
        }
        arr = [];
      } else {
        Context = this;
      }
      if (!isArray(arrayLike)) {
        if ((getIterator = arrayLike[iteratorSymbol]) !== void 0) {
          iterator = callable(getIterator).call(arrayLike);
          if (Context) arr = new Context();
          result = iterator.next();
          i = 0;
          while (!result.done) {
            value = mapFn ? call.call(mapFn, thisArg, result.value, i) : result.value;
            if (Context) {
              desc.value = value;
              defineProperty(arr, i, desc);
            } else {
              arr[i] = value;
            }
            result = iterator.next();
            ++i;
          }
          length = i;
        } else if (isString(arrayLike)) {
          length = arrayLike.length;
          if (Context) arr = new Context();
          for (i = 0, j = 0; i < length; ++i) {
            value = arrayLike[i];
            if (i + 1 < length) {
              code = value.charCodeAt(0);
              if (code >= 55296 && code <= 56319) value += arrayLike[++i];
            }
            value = mapFn ? call.call(mapFn, thisArg, value, j) : value;
            if (Context) {
              desc.value = value;
              defineProperty(arr, j, desc);
            } else {
              arr[j] = value;
            }
            ++j;
          }
          length = j;
        }
      }
      if (length === void 0) {
        length = toPosInt(arrayLike.length);
        if (Context) arr = new Context(length);
        for (i = 0; i < length; ++i) {
          value = mapFn ? call.call(mapFn, thisArg, arrayLike[i], i) : arrayLike[i];
          if (Context) {
            desc.value = value;
            defineProperty(arr, i, desc);
          } else {
            arr[i] = value;
          }
        }
      }
      if (Context) {
        desc.value = null;
        arr.length = length;
      }
      return arr;
    };
  }
});

// node_modules/es5-ext/array/from/index.js
var require_from = __commonJS({
  "node_modules/es5-ext/array/from/index.js"(exports2, module2) {
    "use strict";
    module2.exports = require_is_implemented5()() ? Array.from : require_shim5();
  }
});

// node_modules/es5-ext/array/to-array.js
var require_to_array = __commonJS({
  "node_modules/es5-ext/array/to-array.js"(exports2, module2) {
    "use strict";
    var from = require_from();
    var isArray = Array.isArray;
    module2.exports = function(arrayLike) {
      return isArray(arrayLike) ? arrayLike : from(arrayLike);
    };
  }
});

// node_modules/memoizee/lib/resolve-resolve.js
var require_resolve_resolve = __commonJS({
  "node_modules/memoizee/lib/resolve-resolve.js"(exports2, module2) {
    "use strict";
    var toArray2 = require_to_array();
    var isValue = require_is_value();
    var callable = require_valid_callable();
    var slice = Array.prototype.slice;
    var resolveArgs;
    resolveArgs = function(args) {
      return this.map(function(resolve, i) {
        return resolve ? resolve(args[i]) : args[i];
      }).concat(
        slice.call(args, this.length)
      );
    };
    module2.exports = function(resolvers) {
      resolvers = toArray2(resolvers);
      resolvers.forEach(function(resolve) {
        if (isValue(resolve)) callable(resolve);
      });
      return resolveArgs.bind(resolvers);
    };
  }
});

// node_modules/memoizee/lib/resolve-normalize.js
var require_resolve_normalize = __commonJS({
  "node_modules/memoizee/lib/resolve-normalize.js"(exports2, module2) {
    "use strict";
    var callable = require_valid_callable();
    module2.exports = function(userNormalizer) {
      var normalizer;
      if (typeof userNormalizer === "function") return { set: userNormalizer, get: userNormalizer };
      normalizer = { get: callable(userNormalizer.get) };
      if (userNormalizer.set !== void 0) {
        normalizer.set = callable(userNormalizer.set);
        if (userNormalizer.delete) normalizer.delete = callable(userNormalizer.delete);
        if (userNormalizer.clear) normalizer.clear = callable(userNormalizer.clear);
        return normalizer;
      }
      normalizer.set = normalizer.get;
      return normalizer;
    };
  }
});

// node_modules/memoizee/lib/configure-map.js
var require_configure_map = __commonJS({
  "node_modules/memoizee/lib/configure-map.js"(exports2, module2) {
    "use strict";
    var customError = require_custom();
    var defineLength = require_define_length();
    var d = require_d();
    var ee = require_event_emitter().methods;
    var resolveResolve = require_resolve_resolve();
    var resolveNormalize = require_resolve_normalize();
    var apply = Function.prototype.apply;
    var call = Function.prototype.call;
    var create = Object.create;
    var defineProperties = Object.defineProperties;
    var on = ee.on;
    var emit = ee.emit;
    module2.exports = function(original, length, options) {
      var cache = create(null), conf, memLength, get2, set3, del, clear, extDel, extGet, extHas, normalizer, getListeners, setListeners, deleteListeners, memoized, resolve;
      if (length !== false) memLength = length;
      else if (isNaN(original.length)) memLength = 1;
      else memLength = original.length;
      if (options.normalizer) {
        normalizer = resolveNormalize(options.normalizer);
        get2 = normalizer.get;
        set3 = normalizer.set;
        del = normalizer.delete;
        clear = normalizer.clear;
      }
      if (options.resolvers != null) resolve = resolveResolve(options.resolvers);
      if (get2) {
        memoized = defineLength(function(arg) {
          var id, result, args = arguments;
          if (resolve) args = resolve(args);
          id = get2(args);
          if (id !== null) {
            if (hasOwnProperty.call(cache, id)) {
              if (getListeners) conf.emit("get", id, args, this);
              return cache[id];
            }
          }
          if (args.length === 1) result = call.call(original, this, args[0]);
          else result = apply.call(original, this, args);
          if (id === null) {
            id = get2(args);
            if (id !== null) throw customError("Circular invocation", "CIRCULAR_INVOCATION");
            id = set3(args);
          } else if (hasOwnProperty.call(cache, id)) {
            throw customError("Circular invocation", "CIRCULAR_INVOCATION");
          }
          cache[id] = result;
          if (setListeners) conf.emit("set", id, null, result);
          return result;
        }, memLength);
      } else if (length === 0) {
        memoized = function() {
          var result;
          if (hasOwnProperty.call(cache, "data")) {
            if (getListeners) conf.emit("get", "data", arguments, this);
            return cache.data;
          }
          if (arguments.length) result = apply.call(original, this, arguments);
          else result = call.call(original, this);
          if (hasOwnProperty.call(cache, "data")) {
            throw customError("Circular invocation", "CIRCULAR_INVOCATION");
          }
          cache.data = result;
          if (setListeners) conf.emit("set", "data", null, result);
          return result;
        };
      } else {
        memoized = function(arg) {
          var result, args = arguments, id;
          if (resolve) args = resolve(arguments);
          id = String(args[0]);
          if (hasOwnProperty.call(cache, id)) {
            if (getListeners) conf.emit("get", id, args, this);
            return cache[id];
          }
          if (args.length === 1) result = call.call(original, this, args[0]);
          else result = apply.call(original, this, args);
          if (hasOwnProperty.call(cache, id)) {
            throw customError("Circular invocation", "CIRCULAR_INVOCATION");
          }
          cache[id] = result;
          if (setListeners) conf.emit("set", id, null, result);
          return result;
        };
      }
      conf = {
        original,
        memoized,
        profileName: options.profileName,
        get: function(args) {
          if (resolve) args = resolve(args);
          if (get2) return get2(args);
          return String(args[0]);
        },
        has: function(id) {
          return hasOwnProperty.call(cache, id);
        },
        delete: function(id) {
          var result;
          if (!hasOwnProperty.call(cache, id)) return;
          if (del) del(id);
          result = cache[id];
          delete cache[id];
          if (deleteListeners) conf.emit("delete", id, result);
        },
        clear: function() {
          var oldCache = cache;
          if (clear) clear();
          cache = create(null);
          conf.emit("clear", oldCache);
        },
        on: function(type2, listener) {
          if (type2 === "get") getListeners = true;
          else if (type2 === "set") setListeners = true;
          else if (type2 === "delete") deleteListeners = true;
          return on.call(this, type2, listener);
        },
        emit,
        updateEnv: function() {
          original = conf.original;
        }
      };
      if (get2) {
        extDel = defineLength(function(arg) {
          var id, args = arguments;
          if (resolve) args = resolve(args);
          id = get2(args);
          if (id === null) return;
          conf.delete(id);
        }, memLength);
      } else if (length === 0) {
        extDel = function() {
          return conf.delete("data");
        };
      } else {
        extDel = function(arg) {
          if (resolve) arg = resolve(arguments)[0];
          return conf.delete(arg);
        };
      }
      extGet = defineLength(function() {
        var id, args = arguments;
        if (length === 0) return cache.data;
        if (resolve) args = resolve(args);
        if (get2) id = get2(args);
        else id = String(args[0]);
        return cache[id];
      });
      extHas = defineLength(function() {
        var id, args = arguments;
        if (length === 0) return conf.has("data");
        if (resolve) args = resolve(args);
        if (get2) id = get2(args);
        else id = String(args[0]);
        if (id === null) return false;
        return conf.has(id);
      });
      defineProperties(memoized, {
        __memoized__: d(true),
        delete: d(extDel),
        clear: d(conf.clear),
        _get: d(extGet),
        _has: d(extHas)
      });
      return conf;
    };
  }
});

// node_modules/memoizee/plain.js
var require_plain = __commonJS({
  "node_modules/memoizee/plain.js"(exports2, module2) {
    "use strict";
    var callable = require_valid_callable();
    var forEach = require_for_each();
    var extensions = require_registered_extensions();
    var configure = require_configure_map();
    var resolveLength = require_resolve_length();
    module2.exports = function self2(fn) {
      var options, length, conf;
      callable(fn);
      options = Object(arguments[1]);
      if (options.async && options.promise) {
        throw new Error("Options 'async' and 'promise' cannot be used together");
      }
      if (hasOwnProperty.call(fn, "__memoized__") && !options.force) return fn;
      length = resolveLength(options.length, fn.length, options.async && extensions.async);
      conf = configure(fn, length, options);
      forEach(extensions, function(extFn, name) {
        if (options[name]) extFn(options[name], conf, options);
      });
      if (self2.__profiler__) self2.__profiler__(conf);
      conf.updateEnv();
      return conf.memoized;
    };
  }
});

// node_modules/memoizee/normalizers/primitive.js
var require_primitive = __commonJS({
  "node_modules/memoizee/normalizers/primitive.js"(exports2, module2) {
    "use strict";
    module2.exports = function(args) {
      var id, i, length = args.length;
      if (!length) return "";
      id = String(args[i = 0]);
      while (--length) id += "" + args[++i];
      return id;
    };
  }
});

// node_modules/memoizee/normalizers/get-primitive-fixed.js
var require_get_primitive_fixed = __commonJS({
  "node_modules/memoizee/normalizers/get-primitive-fixed.js"(exports2, module2) {
    "use strict";
    module2.exports = function(length) {
      if (!length) {
        return function() {
          return "";
        };
      }
      return function(args) {
        var id = String(args[0]), i = 0, currentLength = length;
        while (--currentLength) {
          id += "" + args[++i];
        }
        return id;
      };
    };
  }
});

// node_modules/es5-ext/number/is-nan/is-implemented.js
var require_is_implemented8 = __commonJS({
  "node_modules/es5-ext/number/is-nan/is-implemented.js"(exports2, module2) {
    "use strict";
    module2.exports = function() {
      var numberIsNaN = Number.isNaN;
      if (typeof numberIsNaN !== "function") return false;
      return !numberIsNaN({}) && numberIsNaN(NaN) && !numberIsNaN(34);
    };
  }
});

// node_modules/es5-ext/number/is-nan/shim.js
var require_shim6 = __commonJS({
  "node_modules/es5-ext/number/is-nan/shim.js"(exports2, module2) {
    "use strict";
    module2.exports = function(value) {
      return value !== value;
    };
  }
});

// node_modules/es5-ext/number/is-nan/index.js
var require_is_nan = __commonJS({
  "node_modules/es5-ext/number/is-nan/index.js"(exports2, module2) {
    "use strict";
    module2.exports = require_is_implemented8()() ? Number.isNaN : require_shim6();
  }
});

// node_modules/es5-ext/array/#/e-index-of.js
var require_e_index_of = __commonJS({
  "node_modules/es5-ext/array/#/e-index-of.js"(exports2, module2) {
    "use strict";
    var numberIsNaN = require_is_nan();
    var toPosInt = require_to_pos_integer();
    var value = require_valid_value();
    var indexOf = Array.prototype.indexOf;
    var objHasOwnProperty = Object.prototype.hasOwnProperty;
    var abs = Math.abs;
    var floor = Math.floor;
    module2.exports = function(searchElement) {
      var i, length, fromIndex, val;
      if (!numberIsNaN(searchElement)) return indexOf.apply(this, arguments);
      length = toPosInt(value(this).length);
      fromIndex = arguments[1];
      if (isNaN(fromIndex)) fromIndex = 0;
      else if (fromIndex >= 0) fromIndex = floor(fromIndex);
      else fromIndex = toPosInt(this.length) - floor(abs(fromIndex));
      for (i = fromIndex; i < length; ++i) {
        if (objHasOwnProperty.call(this, i)) {
          val = this[i];
          if (numberIsNaN(val)) return i;
        }
      }
      return -1;
    };
  }
});

// node_modules/memoizee/normalizers/get.js
var require_get2 = __commonJS({
  "node_modules/memoizee/normalizers/get.js"(exports2, module2) {
    "use strict";
    var indexOf = require_e_index_of();
    var create = Object.create;
    module2.exports = function() {
      var lastId = 0, map2 = [], cache = create(null);
      return {
        get: function(args) {
          var index = 0, set3 = map2, i, length = args.length;
          if (length === 0) return set3[length] || null;
          if (set3 = set3[length]) {
            while (index < length - 1) {
              i = indexOf.call(set3[0], args[index]);
              if (i === -1) return null;
              set3 = set3[1][i];
              ++index;
            }
            i = indexOf.call(set3[0], args[index]);
            if (i === -1) return null;
            return set3[1][i] || null;
          }
          return null;
        },
        set: function(args) {
          var index = 0, set3 = map2, i, length = args.length;
          if (length === 0) {
            set3[length] = ++lastId;
          } else {
            if (!set3[length]) {
              set3[length] = [[], []];
            }
            set3 = set3[length];
            while (index < length - 1) {
              i = indexOf.call(set3[0], args[index]);
              if (i === -1) {
                i = set3[0].push(args[index]) - 1;
                set3[1].push([[], []]);
              }
              set3 = set3[1][i];
              ++index;
            }
            i = indexOf.call(set3[0], args[index]);
            if (i === -1) {
              i = set3[0].push(args[index]) - 1;
            }
            set3[1][i] = ++lastId;
          }
          cache[lastId] = args;
          return lastId;
        },
        delete: function(id) {
          var index = 0, set3 = map2, i, args = cache[id], length = args.length, path = [];
          if (length === 0) {
            delete set3[length];
          } else if (set3 = set3[length]) {
            while (index < length - 1) {
              i = indexOf.call(set3[0], args[index]);
              if (i === -1) {
                return;
              }
              path.push(set3, i);
              set3 = set3[1][i];
              ++index;
            }
            i = indexOf.call(set3[0], args[index]);
            if (i === -1) {
              return;
            }
            id = set3[1][i];
            set3[0].splice(i, 1);
            set3[1].splice(i, 1);
            while (!set3[0].length && path.length) {
              i = path.pop();
              set3 = path.pop();
              set3[0].splice(i, 1);
              set3[1].splice(i, 1);
            }
          }
          delete cache[id];
        },
        clear: function() {
          map2 = [];
          cache = create(null);
        }
      };
    };
  }
});

// node_modules/memoizee/normalizers/get-1.js
var require_get_1 = __commonJS({
  "node_modules/memoizee/normalizers/get-1.js"(exports2, module2) {
    "use strict";
    var indexOf = require_e_index_of();
    module2.exports = function() {
      var lastId = 0, argsMap = [], cache = [];
      return {
        get: function(args) {
          var index = indexOf.call(argsMap, args[0]);
          return index === -1 ? null : cache[index];
        },
        set: function(args) {
          argsMap.push(args[0]);
          cache.push(++lastId);
          return lastId;
        },
        delete: function(id) {
          var index = indexOf.call(cache, id);
          if (index !== -1) {
            argsMap.splice(index, 1);
            cache.splice(index, 1);
          }
        },
        clear: function() {
          argsMap = [];
          cache = [];
        }
      };
    };
  }
});

// node_modules/memoizee/normalizers/get-fixed.js
var require_get_fixed = __commonJS({
  "node_modules/memoizee/normalizers/get-fixed.js"(exports2, module2) {
    "use strict";
    var indexOf = require_e_index_of();
    var create = Object.create;
    module2.exports = function(length) {
      var lastId = 0, map2 = [[], []], cache = create(null);
      return {
        get: function(args) {
          var index = 0, set3 = map2, i;
          while (index < length - 1) {
            i = indexOf.call(set3[0], args[index]);
            if (i === -1) return null;
            set3 = set3[1][i];
            ++index;
          }
          i = indexOf.call(set3[0], args[index]);
          if (i === -1) return null;
          return set3[1][i] || null;
        },
        set: function(args) {
          var index = 0, set3 = map2, i;
          while (index < length - 1) {
            i = indexOf.call(set3[0], args[index]);
            if (i === -1) {
              i = set3[0].push(args[index]) - 1;
              set3[1].push([[], []]);
            }
            set3 = set3[1][i];
            ++index;
          }
          i = indexOf.call(set3[0], args[index]);
          if (i === -1) {
            i = set3[0].push(args[index]) - 1;
          }
          set3[1][i] = ++lastId;
          cache[lastId] = args;
          return lastId;
        },
        delete: function(id) {
          var index = 0, set3 = map2, i, path = [], args = cache[id];
          while (index < length - 1) {
            i = indexOf.call(set3[0], args[index]);
            if (i === -1) {
              return;
            }
            path.push(set3, i);
            set3 = set3[1][i];
            ++index;
          }
          i = indexOf.call(set3[0], args[index]);
          if (i === -1) {
            return;
          }
          id = set3[1][i];
          set3[0].splice(i, 1);
          set3[1].splice(i, 1);
          while (!set3[0].length && path.length) {
            i = path.pop();
            set3 = path.pop();
            set3[0].splice(i, 1);
            set3[1].splice(i, 1);
          }
          delete cache[id];
        },
        clear: function() {
          map2 = [[], []];
          cache = create(null);
        }
      };
    };
  }
});

// node_modules/es5-ext/object/map.js
var require_map = __commonJS({
  "node_modules/es5-ext/object/map.js"(exports2, module2) {
    "use strict";
    var callable = require_valid_callable();
    var forEach = require_for_each();
    var call = Function.prototype.call;
    module2.exports = function(obj, cb) {
      var result = {}, thisArg = arguments[2];
      callable(cb);
      forEach(obj, function(value, key, targetObj, index) {
        result[key] = call.call(cb, thisArg, value, key, targetObj, index);
      });
      return result;
    };
  }
});

// node_modules/next-tick/index.js
var require_next_tick = __commonJS({
  "node_modules/next-tick/index.js"(exports2, module2) {
    "use strict";
    var ensureCallable = function(fn) {
      if (typeof fn !== "function") throw new TypeError(fn + " is not a function");
      return fn;
    };
    var byObserver = function(Observer) {
      var node2 = document.createTextNode(""), queue, currentQueue, i = 0;
      new Observer(function() {
        var callback;
        if (!queue) {
          if (!currentQueue) return;
          queue = currentQueue;
        } else if (currentQueue) {
          queue = currentQueue.concat(queue);
        }
        currentQueue = queue;
        queue = null;
        if (typeof currentQueue === "function") {
          callback = currentQueue;
          currentQueue = null;
          callback();
          return;
        }
        node2.data = i = ++i % 2;
        while (currentQueue) {
          callback = currentQueue.shift();
          if (!currentQueue.length) currentQueue = null;
          callback();
        }
      }).observe(node2, { characterData: true });
      return function(fn) {
        ensureCallable(fn);
        if (queue) {
          if (typeof queue === "function") queue = [queue, fn];
          else queue.push(fn);
          return;
        }
        queue = fn;
        node2.data = i = ++i % 2;
      };
    };
    module2.exports = function() {
      if (typeof process === "object" && process && typeof process.nextTick === "function") {
        return process.nextTick;
      }
      if (typeof queueMicrotask === "function") {
        return function(cb) {
          queueMicrotask(ensureCallable(cb));
        };
      }
      if (typeof document === "object" && document) {
        if (typeof MutationObserver === "function") return byObserver(MutationObserver);
        if (typeof WebKitMutationObserver === "function") return byObserver(WebKitMutationObserver);
      }
      if (typeof setImmediate === "function") {
        return function(cb) {
          setImmediate(ensureCallable(cb));
        };
      }
      if (typeof setTimeout === "function" || typeof setTimeout === "object") {
        return function(cb) {
          setTimeout(ensureCallable(cb), 0);
        };
      }
      return null;
    }();
  }
});

// node_modules/memoizee/ext/async.js
var require_async = __commonJS({
  "node_modules/memoizee/ext/async.js"() {
    "use strict";
    var aFrom = require_from();
    var objectMap = require_map();
    var mixin = require_mixin();
    var defineLength = require_define_length();
    var nextTick = require_next_tick();
    var slice = Array.prototype.slice;
    var apply = Function.prototype.apply;
    var create = Object.create;
    require_registered_extensions().async = function(tbi, conf) {
      var waiting = create(null), cache = create(null), base = conf.memoized, original = conf.original, currentCallback, currentContext, currentArgs;
      conf.memoized = defineLength(function(arg) {
        var args = arguments, last = args[args.length - 1];
        if (typeof last === "function") {
          currentCallback = last;
          args = slice.call(args, 0, -1);
        }
        return base.apply(currentContext = this, currentArgs = args);
      }, base);
      try {
        mixin(conf.memoized, base);
      } catch (ignore) {
      }
      conf.on("get", function(id) {
        var cb, context, args;
        if (!currentCallback) return;
        if (waiting[id]) {
          if (typeof waiting[id] === "function") waiting[id] = [waiting[id], currentCallback];
          else waiting[id].push(currentCallback);
          currentCallback = null;
          return;
        }
        cb = currentCallback;
        context = currentContext;
        args = currentArgs;
        currentCallback = currentContext = currentArgs = null;
        nextTick(function() {
          var data;
          if (hasOwnProperty.call(cache, id)) {
            data = cache[id];
            conf.emit("getasync", id, args, context);
            apply.call(cb, data.context, data.args);
          } else {
            currentCallback = cb;
            currentContext = context;
            currentArgs = args;
            base.apply(context, args);
          }
        });
      });
      conf.original = function() {
        var args, cb, origCb, result;
        if (!currentCallback) return apply.call(original, this, arguments);
        args = aFrom(arguments);
        cb = function self2(err) {
          var cb2, args2, id = self2.id;
          if (id == null) {
            nextTick(apply.bind(self2, this, arguments));
            return void 0;
          }
          delete self2.id;
          cb2 = waiting[id];
          delete waiting[id];
          if (!cb2) {
            return void 0;
          }
          args2 = aFrom(arguments);
          if (conf.has(id)) {
            if (err) {
              conf.delete(id);
            } else {
              cache[id] = { context: this, args: args2 };
              conf.emit("setasync", id, typeof cb2 === "function" ? 1 : cb2.length);
            }
          }
          if (typeof cb2 === "function") {
            result = apply.call(cb2, this, args2);
          } else {
            cb2.forEach(function(cb3) {
              result = apply.call(cb3, this, args2);
            }, this);
          }
          return result;
        };
        origCb = currentCallback;
        currentCallback = currentContext = currentArgs = null;
        args.push(cb);
        result = apply.call(original, this, args);
        cb.cb = origCb;
        currentCallback = cb;
        return result;
      };
      conf.on("set", function(id) {
        if (!currentCallback) {
          conf.delete(id);
          return;
        }
        if (waiting[id]) {
          if (typeof waiting[id] === "function") waiting[id] = [waiting[id], currentCallback.cb];
          else waiting[id].push(currentCallback.cb);
        } else {
          waiting[id] = currentCallback.cb;
        }
        delete currentCallback.cb;
        currentCallback.id = id;
        currentCallback = null;
      });
      conf.on("delete", function(id) {
        var result;
        if (hasOwnProperty.call(waiting, id)) return;
        if (!cache[id]) return;
        result = cache[id];
        delete cache[id];
        conf.emit("deleteasync", id, slice.call(result.args, 1));
      });
      conf.on("clear", function() {
        var oldCache = cache;
        cache = create(null);
        conf.emit(
          "clearasync",
          objectMap(oldCache, function(data) {
            return slice.call(data.args, 1);
          })
        );
      });
    };
  }
});

// node_modules/es5-ext/object/primitive-set.js
var require_primitive_set = __commonJS({
  "node_modules/es5-ext/object/primitive-set.js"(exports2, module2) {
    "use strict";
    var forEach = Array.prototype.forEach;
    var create = Object.create;
    module2.exports = function(arg) {
      var set3 = create(null);
      forEach.call(arguments, function(name) {
        set3[name] = true;
      });
      return set3;
    };
  }
});

// node_modules/es5-ext/object/is-callable.js
var require_is_callable = __commonJS({
  "node_modules/es5-ext/object/is-callable.js"(exports2, module2) {
    "use strict";
    module2.exports = function(obj) {
      return typeof obj === "function";
    };
  }
});

// node_modules/es5-ext/object/validate-stringifiable.js
var require_validate_stringifiable = __commonJS({
  "node_modules/es5-ext/object/validate-stringifiable.js"(exports2, module2) {
    "use strict";
    var isCallable = require_is_callable();
    module2.exports = function(stringifiable) {
      try {
        if (stringifiable && isCallable(stringifiable.toString)) return stringifiable.toString();
        return String(stringifiable);
      } catch (e) {
        throw new TypeError("Passed argument cannot be stringifed");
      }
    };
  }
});

// node_modules/es5-ext/object/validate-stringifiable-value.js
var require_validate_stringifiable_value = __commonJS({
  "node_modules/es5-ext/object/validate-stringifiable-value.js"(exports2, module2) {
    "use strict";
    var ensureValue = require_valid_value();
    var stringifiable = require_validate_stringifiable();
    module2.exports = function(value) {
      return stringifiable(ensureValue(value));
    };
  }
});

// node_modules/es5-ext/safe-to-string.js
var require_safe_to_string = __commonJS({
  "node_modules/es5-ext/safe-to-string.js"(exports2, module2) {
    "use strict";
    var isCallable = require_is_callable();
    module2.exports = function(value) {
      try {
        if (value && isCallable(value.toString)) return value.toString();
        return String(value);
      } catch (e) {
        return "<Non-coercible to string value>";
      }
    };
  }
});

// node_modules/es5-ext/to-short-string-representation.js
var require_to_short_string_representation = __commonJS({
  "node_modules/es5-ext/to-short-string-representation.js"(exports2, module2) {
    "use strict";
    var safeToString = require_safe_to_string();
    var reNewLine = /[\n\r\u2028\u2029]/g;
    module2.exports = function(value) {
      var string = safeToString(value);
      if (string.length > 100) string = string.slice(0, 99) + "\u2026";
      string = string.replace(reNewLine, function(char) {
        return JSON.stringify(char).slice(1, -1);
      });
      return string;
    };
  }
});

// node_modules/is-promise/index.js
var require_is_promise = __commonJS({
  "node_modules/is-promise/index.js"(exports2, module2) {
    module2.exports = isPromise;
    module2.exports.default = isPromise;
    function isPromise(obj) {
      return !!obj && (typeof obj === "object" || typeof obj === "function") && typeof obj.then === "function";
    }
  }
});

// node_modules/memoizee/ext/promise.js
var require_promise = __commonJS({
  "node_modules/memoizee/ext/promise.js"() {
    "use strict";
    var objectMap = require_map();
    var primitiveSet = require_primitive_set();
    var ensureString = require_validate_stringifiable_value();
    var toShortString = require_to_short_string_representation();
    var isPromise = require_is_promise();
    var nextTick = require_next_tick();
    var create = Object.create;
    var supportedModes = primitiveSet("then", "then:finally", "done", "done:finally");
    require_registered_extensions().promise = function(mode, conf) {
      var waiting = create(null), cache = create(null), promises = create(null);
      if (mode === true) {
        mode = null;
      } else {
        mode = ensureString(mode);
        if (!supportedModes[mode]) {
          throw new TypeError("'" + toShortString(mode) + "' is not valid promise mode");
        }
      }
      conf.on("set", function(id, ignore, promise) {
        var isFailed = false;
        if (!isPromise(promise)) {
          cache[id] = promise;
          conf.emit("setasync", id, 1);
          return;
        }
        waiting[id] = 1;
        promises[id] = promise;
        var onSuccess = function(result) {
          var count = waiting[id];
          if (isFailed) {
            throw new Error(
              "Memoizee error: Detected unordered then|done & finally resolution, which in turn makes proper detection of success/failure impossible (when in 'done:finally' mode)\nConsider to rely on 'then' or 'done' mode instead."
            );
          }
          if (!count) return;
          delete waiting[id];
          cache[id] = result;
          conf.emit("setasync", id, count);
        };
        var onFailure = function() {
          isFailed = true;
          if (!waiting[id]) return;
          delete waiting[id];
          delete promises[id];
          conf.delete(id);
        };
        var resolvedMode = mode;
        if (!resolvedMode) resolvedMode = "then";
        if (resolvedMode === "then") {
          var nextTickFailure = function() {
            nextTick(onFailure);
          };
          promise = promise.then(function(result) {
            nextTick(onSuccess.bind(this, result));
          }, nextTickFailure);
          if (typeof promise.finally === "function") {
            promise.finally(nextTickFailure);
          }
        } else if (resolvedMode === "done") {
          if (typeof promise.done !== "function") {
            throw new Error(
              "Memoizee error: Retrieved promise does not implement 'done' in 'done' mode"
            );
          }
          promise.done(onSuccess, onFailure);
        } else if (resolvedMode === "done:finally") {
          if (typeof promise.done !== "function") {
            throw new Error(
              "Memoizee error: Retrieved promise does not implement 'done' in 'done:finally' mode"
            );
          }
          if (typeof promise.finally !== "function") {
            throw new Error(
              "Memoizee error: Retrieved promise does not implement 'finally' in 'done:finally' mode"
            );
          }
          promise.done(onSuccess);
          promise.finally(onFailure);
        }
      });
      conf.on("get", function(id, args, context) {
        var promise;
        if (waiting[id]) {
          ++waiting[id];
          return;
        }
        promise = promises[id];
        var emit = function() {
          conf.emit("getasync", id, args, context);
        };
        if (isPromise(promise)) {
          if (typeof promise.done === "function") promise.done(emit);
          else {
            promise.then(function() {
              nextTick(emit);
            });
          }
        } else {
          emit();
        }
      });
      conf.on("delete", function(id) {
        delete promises[id];
        if (waiting[id]) {
          delete waiting[id];
          return;
        }
        if (!hasOwnProperty.call(cache, id)) return;
        var result = cache[id];
        delete cache[id];
        conf.emit("deleteasync", id, [result]);
      });
      conf.on("clear", function() {
        var oldCache = cache;
        cache = create(null);
        waiting = create(null);
        promises = create(null);
        conf.emit("clearasync", objectMap(oldCache, function(data) {
          return [data];
        }));
      });
    };
  }
});

// node_modules/memoizee/ext/dispose.js
var require_dispose = __commonJS({
  "node_modules/memoizee/ext/dispose.js"() {
    "use strict";
    var callable = require_valid_callable();
    var forEach = require_for_each();
    var extensions = require_registered_extensions();
    var apply = Function.prototype.apply;
    extensions.dispose = function(dispose, conf, options) {
      var del;
      callable(dispose);
      if (options.async && extensions.async || options.promise && extensions.promise) {
        conf.on(
          "deleteasync",
          del = function(id, resultArray) {
            apply.call(dispose, null, resultArray);
          }
        );
        conf.on("clearasync", function(cache) {
          forEach(cache, function(result, id) {
            del(id, result);
          });
        });
        return;
      }
      conf.on("delete", del = function(id, result) {
        dispose(result);
      });
      conf.on("clear", function(cache) {
        forEach(cache, function(result, id) {
          del(id, result);
        });
      });
    };
  }
});

// node_modules/timers-ext/max-timeout.js
var require_max_timeout = __commonJS({
  "node_modules/timers-ext/max-timeout.js"(exports2, module2) {
    "use strict";
    module2.exports = 2147483647;
  }
});

// node_modules/timers-ext/valid-timeout.js
var require_valid_timeout = __commonJS({
  "node_modules/timers-ext/valid-timeout.js"(exports2, module2) {
    "use strict";
    var toPosInt = require_to_pos_integer();
    var maxTimeout = require_max_timeout();
    module2.exports = function(value) {
      value = toPosInt(value);
      if (value > maxTimeout) throw new TypeError(value + " exceeds maximum possible timeout");
      return value;
    };
  }
});

// node_modules/memoizee/ext/max-age.js
var require_max_age = __commonJS({
  "node_modules/memoizee/ext/max-age.js"() {
    "use strict";
    var aFrom = require_from();
    var forEach = require_for_each();
    var nextTick = require_next_tick();
    var isPromise = require_is_promise();
    var timeout = require_valid_timeout();
    var extensions = require_registered_extensions();
    var noop = Function.prototype;
    var max = Math.max;
    var min = Math.min;
    var create = Object.create;
    extensions.maxAge = function(maxAge, conf, options) {
      var timeouts, postfix, preFetchAge, preFetchTimeouts;
      maxAge = timeout(maxAge);
      if (!maxAge) return;
      timeouts = create(null);
      postfix = options.async && extensions.async || options.promise && extensions.promise ? "async" : "";
      conf.on("set" + postfix, function(id) {
        timeouts[id] = setTimeout(function() {
          conf.delete(id);
        }, maxAge);
        if (typeof timeouts[id].unref === "function") timeouts[id].unref();
        if (!preFetchTimeouts) return;
        if (preFetchTimeouts[id]) {
          if (preFetchTimeouts[id] !== "nextTick") clearTimeout(preFetchTimeouts[id]);
        }
        preFetchTimeouts[id] = setTimeout(function() {
          delete preFetchTimeouts[id];
        }, preFetchAge);
        if (typeof preFetchTimeouts[id].unref === "function") preFetchTimeouts[id].unref();
      });
      conf.on("delete" + postfix, function(id) {
        clearTimeout(timeouts[id]);
        delete timeouts[id];
        if (!preFetchTimeouts) return;
        if (preFetchTimeouts[id] !== "nextTick") clearTimeout(preFetchTimeouts[id]);
        delete preFetchTimeouts[id];
      });
      if (options.preFetch) {
        if (options.preFetch === true || isNaN(options.preFetch)) {
          preFetchAge = 0.333;
        } else {
          preFetchAge = max(min(Number(options.preFetch), 1), 0);
        }
        if (preFetchAge) {
          preFetchTimeouts = {};
          preFetchAge = (1 - preFetchAge) * maxAge;
          conf.on("get" + postfix, function(id, args, context) {
            if (!preFetchTimeouts[id]) {
              preFetchTimeouts[id] = "nextTick";
              nextTick(function() {
                var result;
                if (preFetchTimeouts[id] !== "nextTick") return;
                delete preFetchTimeouts[id];
                conf.delete(id);
                if (options.async) {
                  args = aFrom(args);
                  args.push(noop);
                }
                result = conf.memoized.apply(context, args);
                if (options.promise) {
                  if (isPromise(result)) {
                    if (typeof result.done === "function") result.done(noop, noop);
                    else result.then(noop, noop);
                  }
                }
              });
            }
          });
        }
      }
      conf.on("clear" + postfix, function() {
        forEach(timeouts, function(id) {
          clearTimeout(id);
        });
        timeouts = {};
        if (preFetchTimeouts) {
          forEach(preFetchTimeouts, function(id) {
            if (id !== "nextTick") clearTimeout(id);
          });
          preFetchTimeouts = {};
        }
      });
    };
  }
});

// node_modules/lru-queue/index.js
var require_lru_queue = __commonJS({
  "node_modules/lru-queue/index.js"(exports2, module2) {
    "use strict";
    var toPosInt = require_to_pos_integer();
    var create = Object.create;
    var hasOwnProperty2 = Object.prototype.hasOwnProperty;
    module2.exports = function(limit) {
      var size = 0, base = 1, queue = create(null), map2 = create(null), index = 0, del;
      limit = toPosInt(limit);
      return {
        hit: function(id) {
          var oldIndex = map2[id], nuIndex = ++index;
          queue[nuIndex] = id;
          map2[id] = nuIndex;
          if (!oldIndex) {
            ++size;
            if (size <= limit) return;
            id = queue[base];
            del(id);
            return id;
          }
          delete queue[oldIndex];
          if (base !== oldIndex) return;
          while (!hasOwnProperty2.call(queue, ++base)) continue;
        },
        delete: del = function(id) {
          var oldIndex = map2[id];
          if (!oldIndex) return;
          delete queue[oldIndex];
          delete map2[id];
          --size;
          if (base !== oldIndex) return;
          if (!size) {
            index = 0;
            base = 1;
            return;
          }
          while (!hasOwnProperty2.call(queue, ++base)) continue;
        },
        clear: function() {
          size = 0;
          base = 1;
          queue = create(null);
          map2 = create(null);
          index = 0;
        }
      };
    };
  }
});

// node_modules/memoizee/ext/max.js
var require_max = __commonJS({
  "node_modules/memoizee/ext/max.js"() {
    "use strict";
    var toPosInteger = require_to_pos_integer();
    var lruQueue = require_lru_queue();
    var extensions = require_registered_extensions();
    extensions.max = function(max, conf, options) {
      var postfix, queue, hit;
      max = toPosInteger(max);
      if (!max) return;
      queue = lruQueue(max);
      postfix = options.async && extensions.async || options.promise && extensions.promise ? "async" : "";
      conf.on(
        "set" + postfix,
        hit = function(id) {
          id = queue.hit(id);
          if (id === void 0) return;
          conf.delete(id);
        }
      );
      conf.on("get" + postfix, hit);
      conf.on("delete" + postfix, queue.delete);
      conf.on("clear" + postfix, queue.clear);
    };
  }
});

// node_modules/memoizee/ext/ref-counter.js
var require_ref_counter = __commonJS({
  "node_modules/memoizee/ext/ref-counter.js"() {
    "use strict";
    var d = require_d();
    var extensions = require_registered_extensions();
    var create = Object.create;
    var defineProperties = Object.defineProperties;
    extensions.refCounter = function(ignore, conf, options) {
      var cache, postfix;
      cache = create(null);
      postfix = options.async && extensions.async || options.promise && extensions.promise ? "async" : "";
      conf.on("set" + postfix, function(id, length) {
        cache[id] = length || 1;
      });
      conf.on("get" + postfix, function(id) {
        ++cache[id];
      });
      conf.on("delete" + postfix, function(id) {
        delete cache[id];
      });
      conf.on("clear" + postfix, function() {
        cache = {};
      });
      defineProperties(conf.memoized, {
        deleteRef: d(function() {
          var id = conf.get(arguments);
          if (id === null) return null;
          if (!cache[id]) return null;
          if (!--cache[id]) {
            conf.delete(id);
            return true;
          }
          return false;
        }),
        getRefCount: d(function() {
          var id = conf.get(arguments);
          if (id === null) return 0;
          if (!cache[id]) return 0;
          return cache[id];
        })
      });
    };
  }
});

// node_modules/memoizee/index.js
var require_memoizee = __commonJS({
  "node_modules/memoizee/index.js"(exports2, module2) {
    "use strict";
    var normalizeOpts = require_normalize_options();
    var resolveLength = require_resolve_length();
    var plain = require_plain();
    module2.exports = function(fn) {
      var options = normalizeOpts(arguments[1]), length;
      if (!options.normalizer) {
        length = options.length = resolveLength(options.length, fn.length, options.async);
        if (length !== 0) {
          if (options.primitive) {
            if (length === false) {
              options.normalizer = require_primitive();
            } else if (length > 1) {
              options.normalizer = require_get_primitive_fixed()(length);
            }
          } else if (length === false) options.normalizer = require_get2()();
          else if (length === 1) options.normalizer = require_get_1()();
          else options.normalizer = require_get_fixed()(length);
        }
      }
      if (options.async) require_async();
      if (options.promise) require_promise();
      if (options.dispose) require_dispose();
      if (options.maxAge) require_max_age();
      if (options.max) require_max();
      if (options.refCounter) require_ref_counter();
      return plain(fn, options);
    };
  }
});

// node_modules/@jsdevtools/ono/esm/to-json.js
function toJSON() {
  let pojo = {};
  let error = this;
  for (let key of getDeepKeys(error)) {
    if (typeof key === "string") {
      let value = error[key];
      let type2 = typeof value;
      if (!nonJsonTypes.includes(type2)) {
        pojo[key] = value;
      }
    }
  }
  return pojo;
}
function getDeepKeys(obj, omit = []) {
  let keys = [];
  while (obj && obj !== objectPrototype) {
    keys = keys.concat(Object.getOwnPropertyNames(obj), Object.getOwnPropertySymbols(obj));
    obj = Object.getPrototypeOf(obj);
  }
  let uniqueKeys = new Set(keys);
  for (let key of omit.concat(protectedProps)) {
    uniqueKeys.delete(key);
  }
  return uniqueKeys;
}
var nonJsonTypes, protectedProps, objectPrototype;
var init_to_json = __esm({
  "node_modules/@jsdevtools/ono/esm/to-json.js"() {
    nonJsonTypes = ["function", "symbol", "undefined"];
    protectedProps = ["constructor", "prototype", "__proto__"];
    objectPrototype = Object.getPrototypeOf({});
  }
});

// node_modules/@jsdevtools/ono/esm/isomorphic.node.js
function addInspectMethod(newError) {
  newError[inspectMethod] = inspect2;
}
function inspect2() {
  let pojo = {};
  let error = this;
  for (let key of getDeepKeys(error)) {
    let value = error[key];
    pojo[key] = value;
  }
  delete pojo[inspectMethod];
  return pojo;
}
var util, inspectMethod, format2;
var init_isomorphic_node = __esm({
  "node_modules/@jsdevtools/ono/esm/isomorphic.node.js"() {
    util = __toESM(require("util"));
    init_to_json();
    inspectMethod = util.inspect.custom || Symbol.for("nodejs.util.inspect.custom");
    format2 = util.format;
  }
});

// node_modules/@jsdevtools/ono/esm/stack.js
function isLazyStack(stackProp) {
  return Boolean(stackProp && stackProp.configurable && typeof stackProp.get === "function");
}
function isWritableStack(stackProp) {
  return Boolean(
    // If there is no stack property, then it's writable, since assigning it will create it
    !stackProp || stackProp.writable || typeof stackProp.set === "function"
  );
}
function joinStacks(newError, originalError) {
  let newStack = popStack(newError.stack);
  let originalStack = originalError ? originalError.stack : void 0;
  if (newStack && originalStack) {
    return newStack + "\n\n" + originalStack;
  } else {
    return newStack || originalStack;
  }
}
function lazyJoinStacks(lazyStack, newError, originalError) {
  if (originalError) {
    Object.defineProperty(newError, "stack", {
      get: () => {
        let newStack = lazyStack.get.apply(newError);
        return joinStacks({ stack: newStack }, originalError);
      },
      enumerable: false,
      configurable: true
    });
  } else {
    lazyPopStack(newError, lazyStack);
  }
}
function popStack(stack) {
  if (stack) {
    let lines = stack.split(newline);
    let onoStart;
    for (let i = 0; i < lines.length; i++) {
      let line = lines[i];
      if (onoCall.test(line)) {
        if (onoStart === void 0) {
          onoStart = i;
        }
      } else if (onoStart !== void 0) {
        lines.splice(onoStart, i - onoStart);
        break;
      }
    }
    if (lines.length > 0) {
      return lines.join("\n");
    }
  }
  return stack;
}
function lazyPopStack(error, lazyStack) {
  Object.defineProperty(error, "stack", {
    get: () => popStack(lazyStack.get.apply(error)),
    enumerable: false,
    configurable: true
  });
}
var newline, onoCall;
var init_stack = __esm({
  "node_modules/@jsdevtools/ono/esm/stack.js"() {
    newline = /\r?\n/;
    onoCall = /\bono[ @]/;
  }
});

// node_modules/@jsdevtools/ono/esm/extend-error.js
function extendError(error, originalError, props) {
  let onoError = error;
  extendStack(onoError, originalError);
  if (originalError && typeof originalError === "object") {
    mergeErrors(onoError, originalError);
  }
  onoError.toJSON = toJSON;
  if (addInspectMethod) {
    addInspectMethod(onoError);
  }
  if (props && typeof props === "object") {
    Object.assign(onoError, props);
  }
  return onoError;
}
function extendStack(newError, originalError) {
  let stackProp = Object.getOwnPropertyDescriptor(newError, "stack");
  if (isLazyStack(stackProp)) {
    lazyJoinStacks(stackProp, newError, originalError);
  } else if (isWritableStack(stackProp)) {
    newError.stack = joinStacks(newError, originalError);
  }
}
function mergeErrors(newError, originalError) {
  let keys = getDeepKeys(originalError, protectedProps2);
  let _newError = newError;
  let _originalError = originalError;
  for (let key of keys) {
    if (_newError[key] === void 0) {
      try {
        _newError[key] = _originalError[key];
      } catch (e) {
      }
    }
  }
}
var protectedProps2;
var init_extend_error = __esm({
  "node_modules/@jsdevtools/ono/esm/extend-error.js"() {
    init_isomorphic_node();
    init_stack();
    init_to_json();
    protectedProps2 = ["name", "message", "stack"];
  }
});

// node_modules/@jsdevtools/ono/esm/normalize.js
function normalizeOptions(options) {
  options = options || {};
  return {
    concatMessages: options.concatMessages === void 0 ? true : Boolean(options.concatMessages),
    format: options.format === void 0 ? format2 : typeof options.format === "function" ? options.format : false
  };
}
function normalizeArgs(args, options) {
  let originalError;
  let props;
  let formatArgs;
  let message = "";
  if (typeof args[0] === "string") {
    formatArgs = args;
  } else if (typeof args[1] === "string") {
    if (args[0] instanceof Error) {
      originalError = args[0];
    } else {
      props = args[0];
    }
    formatArgs = args.slice(1);
  } else {
    originalError = args[0];
    props = args[1];
    formatArgs = args.slice(2);
  }
  if (formatArgs.length > 0) {
    if (options.format) {
      message = options.format.apply(void 0, formatArgs);
    } else {
      message = formatArgs.join(" ");
    }
  }
  if (options.concatMessages && originalError && originalError.message) {
    message += (message ? " \n" : "") + originalError.message;
  }
  return { originalError, props, message };
}
var init_normalize = __esm({
  "node_modules/@jsdevtools/ono/esm/normalize.js"() {
    init_isomorphic_node();
  }
});

// node_modules/@jsdevtools/ono/esm/constructor.js
function Ono(ErrorConstructor, options) {
  options = normalizeOptions(options);
  function ono2(...args) {
    let { originalError, props, message } = normalizeArgs(args, options);
    let newError = new ErrorConstructor(message);
    return extendError(newError, originalError, props);
  }
  ono2[Symbol.species] = ErrorConstructor;
  return ono2;
}
var constructor;
var init_constructor = __esm({
  "node_modules/@jsdevtools/ono/esm/constructor.js"() {
    init_extend_error();
    init_normalize();
    init_to_json();
    constructor = Ono;
    Ono.toJSON = function toJSON2(error) {
      return toJSON.call(error);
    };
    Ono.extend = function extend(error, originalError, props) {
      if (props || originalError instanceof Error) {
        return extendError(error, originalError, props);
      } else if (originalError) {
        return extendError(error, void 0, originalError);
      } else {
        return extendError(error);
      }
    };
  }
});

// node_modules/@jsdevtools/ono/esm/singleton.js
function ono(...args) {
  let originalError = args[0];
  if (typeof originalError === "object" && typeof originalError.name === "string") {
    for (let typedOno of Object.values(onoMap)) {
      if (typeof typedOno === "function" && typedOno.name === "ono") {
        let species = typedOno[Symbol.species];
        if (species && species !== Error && (originalError instanceof species || originalError.name === species.name)) {
          return typedOno.apply(void 0, args);
        }
      }
    }
  }
  return ono.error.apply(void 0, args);
}
var singleton, onoMap;
var init_singleton = __esm({
  "node_modules/@jsdevtools/ono/esm/singleton.js"() {
    init_constructor();
    singleton = ono;
    ono.error = new constructor(Error);
    ono.eval = new constructor(EvalError);
    ono.range = new constructor(RangeError);
    ono.reference = new constructor(ReferenceError);
    ono.syntax = new constructor(SyntaxError);
    ono.type = new constructor(TypeError);
    ono.uri = new constructor(URIError);
    onoMap = ono;
  }
});

// node_modules/@jsdevtools/ono/esm/types.js
var init_types = __esm({
  "node_modules/@jsdevtools/ono/esm/types.js"() {
  }
});

// node_modules/@jsdevtools/ono/esm/index.js
var esm_exports = {};
__export(esm_exports, {
  Ono: () => constructor,
  default: () => esm_default,
  ono: () => singleton
});
var esm_default;
var init_esm = __esm({
  "node_modules/@jsdevtools/ono/esm/index.js"() {
    init_singleton();
    init_constructor();
    init_types();
    esm_default = singleton;
    if (typeof module === "object" && typeof module.exports === "object" && typeof module.exports.default == "object") {
      module.exports = Object.assign(module.exports.default, module.exports);
    }
  }
});

// node_modules/call-me-maybe/src/next.js
var require_next = __commonJS({
  "node_modules/call-me-maybe/src/next.js"(exports2, module2) {
    "use strict";
    function makeNext() {
      if (typeof process === "object" && typeof process.nextTick === "function") {
        return process.nextTick;
      } else if (typeof setImmediate === "function") {
        return setImmediate;
      } else {
        return function next(f) {
          setTimeout(f, 0);
        };
      }
    }
    module2.exports = makeNext();
  }
});

// node_modules/call-me-maybe/src/maybe.js
var require_maybe = __commonJS({
  "node_modules/call-me-maybe/src/maybe.js"(exports2, module2) {
    "use strict";
    var next = require_next();
    module2.exports = function maybe(cb, promise) {
      if (cb) {
        promise.then(function(result) {
          next(function() {
            cb(null, result);
          });
        }, function(err) {
          next(function() {
            cb(err);
          });
        });
        return void 0;
      } else {
        return promise;
      }
    };
  }
});

// node_modules/@readme/json-schema-ref-parser/lib/util/url.js
var require_url = __commonJS({
  "node_modules/@readme/json-schema-ref-parser/lib/util/url.js"(exports2, module2) {
    var isWindows = /^win/.test(process.platform);
    var forwardSlashPattern = /\//g;
    var protocolPattern = /^(\w{2,}):\/\//i;
    var url = module2.exports;
    var jsonPointerSlash = /~1/g;
    var jsonPointerTilde = /~0/g;
    var urlEncodePatterns = [
      /\?/g,
      "%3F",
      /#/g,
      "%23"
    ];
    var urlDecodePatterns = [
      /%23/g,
      "#",
      /%24/g,
      "$",
      /%26/g,
      "&",
      /%2C/g,
      ",",
      /%40/g,
      "@"
    ];
    exports2.parse = require("url").parse;
    exports2.resolve = require("url").resolve;
    exports2.cwd = function cwd() {
      if (process.browser) {
        return location.href;
      }
      const path = process.cwd();
      const lastChar = path.slice(-1);
      if (lastChar === "/" || lastChar === "\\") {
        return path;
      }
      return `${path}/`;
    };
    exports2.getProtocol = function getProtocol(path) {
      const match2 = protocolPattern.exec(path);
      if (match2) {
        return match2[1].toLowerCase();
      }
    };
    exports2.getExtension = function getExtension2(path) {
      const lastDot = path.lastIndexOf(".");
      if (lastDot >= 0) {
        return url.stripQuery(path.substr(lastDot).toLowerCase());
      }
      return "";
    };
    exports2.stripQuery = function stripQuery(path) {
      const queryIndex = path.indexOf("?");
      if (queryIndex >= 0) {
        path = path.substr(0, queryIndex);
      }
      return path;
    };
    exports2.getHash = function getHash(path) {
      const hashIndex = path.indexOf("#");
      if (hashIndex >= 0) {
        return path.substr(hashIndex);
      }
      return "#";
    };
    exports2.stripHash = function stripHash(path) {
      const hashIndex = path.indexOf("#");
      if (hashIndex >= 0) {
        return path.substr(0, hashIndex);
      }
      return path;
    };
    exports2.isHttp = function isHttp(path) {
      const protocol = url.getProtocol(path);
      if (protocol === "http" || protocol === "https") {
        return true;
      } else if (protocol === void 0) {
        return process.browser;
      }
      return false;
    };
    exports2.isFileSystemPath = function isFileSystemPath(path) {
      if (process.browser) {
        return false;
      }
      const protocol = url.getProtocol(path);
      return protocol === void 0 || protocol === "file";
    };
    exports2.fromFileSystemPath = function fromFileSystemPath(path) {
      if (isWindows) {
        path = path.replace(/\\/g, "/");
      }
      path = encodeURI(path);
      for (let i = 0; i < urlEncodePatterns.length; i += 2) {
        path = path.replace(urlEncodePatterns[i], urlEncodePatterns[i + 1]);
      }
      return path;
    };
    exports2.toFileSystemPath = function toFileSystemPath(path, keepFileProtocol) {
      path = decodeURI(path);
      for (let i = 0; i < urlDecodePatterns.length; i += 2) {
        path = path.replace(urlDecodePatterns[i], urlDecodePatterns[i + 1]);
      }
      let isFileUrl = path.substr(0, 7).toLowerCase() === "file://";
      if (isFileUrl) {
        path = path[7] === "/" ? path.substr(8) : path.substr(7);
        if (isWindows && path[1] === "/") {
          path = `${path[0]}:${path.substr(1)}`;
        }
        if (keepFileProtocol) {
          path = `file:///${path}`;
        } else {
          isFileUrl = false;
          path = isWindows ? path : `/${path}`;
        }
      }
      if (isWindows && !isFileUrl) {
        path = path.replace(forwardSlashPattern, "\\");
        if (path.substr(1, 2) === ":\\") {
          path = path[0].toUpperCase() + path.substr(1);
        }
      }
      return path;
    };
    exports2.safePointerToPath = function safePointerToPath(pointer) {
      if (pointer.length <= 1 || pointer[0] !== "#" || pointer[1] !== "/") {
        return [];
      }
      return pointer.slice(2).split("/").map((value) => {
        return decodeURIComponent(value).replace(jsonPointerSlash, "/").replace(jsonPointerTilde, "~");
      });
    };
  }
});

// node_modules/@readme/json-schema-ref-parser/lib/util/errors.js
var require_errors = __commonJS({
  "node_modules/@readme/json-schema-ref-parser/lib/util/errors.js"(exports2) {
    var { Ono: Ono2 } = (init_esm(), __toCommonJS(esm_exports));
    var { stripHash, toFileSystemPath } = require_url();
    function setErrorName(err) {
      Object.defineProperty(err.prototype, "name", {
        value: err.name,
        enumerable: true
      });
    }
    var JSONParserError = class JSONParserError extends Error {
      constructor(message, source) {
        super();
        this.code = "EUNKNOWN";
        this.message = message;
        this.source = source;
        this.path = null;
        Ono2.extend(this);
      }
      get footprint() {
        return `${this.path}+${this.source}+${this.code}+${this.message}`;
      }
    };
    exports2.JSONParserError = JSONParserError;
    setErrorName(JSONParserError);
    var JSONParserErrorGroup = class JSONParserErrorGroup2 extends Error {
      constructor(parser) {
        super();
        this.files = parser;
        this.message = `${this.errors.length} error${this.errors.length > 1 ? "s" : ""} occurred while reading '${toFileSystemPath(parser.$refs._root$Ref.path)}'`;
        Ono2.extend(this);
      }
      static getParserErrors(parser) {
        const errors = [];
        for (const $ref of Object.values(parser.$refs._$refs)) {
          if ($ref.errors) {
            errors.push(...$ref.errors);
          }
        }
        return errors;
      }
      get errors() {
        return JSONParserErrorGroup2.getParserErrors(this.files);
      }
    };
    exports2.JSONParserErrorGroup = JSONParserErrorGroup;
    setErrorName(JSONParserErrorGroup);
    var ParserError = class ParserError extends JSONParserError {
      constructor(message, source) {
        super(`Error parsing ${source}: ${message}`, source);
        this.code = "EPARSER";
      }
    };
    exports2.ParserError = ParserError;
    setErrorName(ParserError);
    var UnmatchedParserError = class UnmatchedParserError extends JSONParserError {
      constructor(source) {
        super(`Could not find parser for "${source}"`, source);
        this.code = "EUNMATCHEDPARSER";
      }
    };
    exports2.UnmatchedParserError = UnmatchedParserError;
    setErrorName(UnmatchedParserError);
    var ResolverError = class ResolverError extends JSONParserError {
      constructor(ex, source) {
        super(ex.message || `Error reading file "${source}"`, source);
        this.code = "ERESOLVER";
        if ("code" in ex) {
          this.ioErrorCode = String(ex.code);
        }
      }
    };
    exports2.ResolverError = ResolverError;
    setErrorName(ResolverError);
    var UnmatchedResolverError = class UnmatchedResolverError extends JSONParserError {
      constructor(source) {
        super(`Could not find resolver for "${source}"`, source);
        this.code = "EUNMATCHEDRESOLVER";
      }
    };
    exports2.UnmatchedResolverError = UnmatchedResolverError;
    setErrorName(UnmatchedResolverError);
    var MissingPointerError = class MissingPointerError extends JSONParserError {
      constructor(token, path) {
        super(`Token "${token}" does not exist.`, stripHash(path));
        this.code = "EMISSINGPOINTER";
      }
    };
    exports2.MissingPointerError = MissingPointerError;
    setErrorName(MissingPointerError);
    var InvalidPointerError = class InvalidPointerError extends JSONParserError {
      constructor(pointer, path) {
        super(`Invalid $ref pointer "${pointer}". Pointers must begin with "#/"`, stripHash(path));
        this.code = "EINVALIDPOINTER";
      }
    };
    exports2.InvalidPointerError = InvalidPointerError;
    setErrorName(InvalidPointerError);
    exports2.isHandledError = function(err) {
      return err instanceof JSONParserError || err instanceof JSONParserErrorGroup;
    };
    exports2.normalizeError = function(err) {
      if (err.path === null) {
        err.path = [];
      }
      return err;
    };
  }
});

// node_modules/@readme/json-schema-ref-parser/lib/pointer.js
var require_pointer = __commonJS({
  "node_modules/@readme/json-schema-ref-parser/lib/pointer.js"(exports2, module2) {
    var $Ref = require_ref();
    var { JSONParserError, InvalidPointerError, MissingPointerError, isHandledError } = require_errors();
    var url = require_url();
    var slashes = /\//g;
    var tildes = /~/g;
    var escapedSlash = /~1/g;
    var escapedTilde = /~0/g;
    module2.exports = Pointer;
    function Pointer($ref, path, friendlyPath) {
      this.$ref = $ref;
      this.path = path;
      this.originalPath = friendlyPath || path;
      this.value = void 0;
      this.circular = false;
      this.indirections = 0;
    }
    Pointer.prototype.resolve = function(obj, options, pathFromRoot) {
      const tokens = Pointer.parse(this.path, this.originalPath);
      this.value = unwrapOrThrow(obj);
      for (let i = 0; i < tokens.length; i++) {
        if (resolveIf$Ref(this, options)) {
          this.path = Pointer.join(this.path, tokens.slice(i));
        }
        if (typeof this.value === "object" && this.value !== null && "$ref" in this.value) {
          return this;
        }
        const token = tokens[i];
        if (this.value[token] === void 0 || this.value[token] === null) {
          this.value = null;
          throw new MissingPointerError(token, this.originalPath);
        } else {
          this.value = this.value[token];
        }
      }
      if (!this.value || this.value.$ref && url.resolve(this.path, this.value.$ref) !== pathFromRoot) {
        resolveIf$Ref(this, options);
      }
      return this;
    };
    Pointer.prototype.set = function(obj, value, options) {
      const tokens = Pointer.parse(this.path);
      let token;
      if (tokens.length === 0) {
        this.value = value;
        return value;
      }
      this.value = unwrapOrThrow(obj);
      for (let i = 0; i < tokens.length - 1; i++) {
        resolveIf$Ref(this, options);
        token = tokens[i];
        if (this.value && this.value[token] !== void 0) {
          this.value = this.value[token];
        } else {
          this.value = setValue(this, token, {});
        }
      }
      resolveIf$Ref(this, options);
      token = tokens[tokens.length - 1];
      setValue(this, token, value);
      return obj;
    };
    Pointer.parse = function(path, originalPath) {
      let pointer = url.getHash(path).substr(1);
      if (!pointer) {
        return [];
      }
      pointer = pointer.split("/");
      for (let i = 0; i < pointer.length; i++) {
        pointer[i] = decodeURIComponent(pointer[i].replace(escapedSlash, "/").replace(escapedTilde, "~"));
      }
      if (pointer[0] !== "") {
        throw new InvalidPointerError(pointer, originalPath === void 0 ? path : originalPath);
      }
      return pointer.slice(1);
    };
    Pointer.join = function(base, tokens) {
      if (base.indexOf("#") === -1) {
        base += "#";
      }
      tokens = Array.isArray(tokens) ? tokens : [tokens];
      for (let i = 0; i < tokens.length; i++) {
        const token = tokens[i];
        base += `/${encodeURIComponent(token.replace(tildes, "~0").replace(slashes, "~1"))}`;
      }
      return base;
    };
    function resolveIf$Ref(pointer, options) {
      if ($Ref.isAllowed$Ref(pointer.value, options)) {
        const $refPath = url.resolve(pointer.path, pointer.value.$ref);
        if ($refPath === pointer.path) {
          pointer.circular = true;
        } else {
          const resolved = pointer.$ref.$refs._resolve($refPath, pointer.path, options);
          if (resolved === null) {
            return false;
          }
          pointer.indirections += resolved.indirections + 1;
          if ($Ref.isExtended$Ref(pointer.value)) {
            pointer.value = $Ref.dereference(pointer.value, resolved.value);
            return false;
          }
          pointer.$ref = resolved.$ref;
          pointer.path = resolved.path;
          pointer.value = resolved.value;
          return true;
        }
      }
    }
    function setValue(pointer, token, value) {
      if (pointer.value && typeof pointer.value === "object") {
        if (token === "-" && Array.isArray(pointer.value)) {
          pointer.value.push(value);
        } else {
          pointer.value[token] = value;
        }
      } else {
        throw new JSONParserError(
          `Error assigning $ref pointer "${pointer.path}". 
Cannot set "${token}" of a non-object.`
        );
      }
      return value;
    }
    function unwrapOrThrow(value) {
      if (isHandledError(value)) {
        throw value;
      }
      return value;
    }
  }
});

// node_modules/@readme/json-schema-ref-parser/lib/ref.js
var require_ref = __commonJS({
  "node_modules/@readme/json-schema-ref-parser/lib/ref.js"(exports2, module2) {
    module2.exports = $Ref;
    var Pointer = require_pointer();
    var { InvalidPointerError, isHandledError, normalizeError } = require_errors();
    var { safePointerToPath, stripHash, getHash } = require_url();
    function $Ref() {
      this.path = void 0;
      this.value = void 0;
      this.$refs = void 0;
      this.pathType = void 0;
      this.errors = void 0;
    }
    $Ref.prototype.addError = function(err) {
      if (this.errors === void 0) {
        this.errors = [];
      }
      const existingErrors = this.errors.map(({ footprint }) => footprint);
      if (Array.isArray(err.errors)) {
        this.errors.push(...err.errors.map(normalizeError).filter(({ footprint }) => !existingErrors.includes(footprint)));
      } else if (!existingErrors.includes(err.footprint)) {
        this.errors.push(normalizeError(err));
      }
    };
    $Ref.prototype.exists = function(path, options) {
      try {
        this.resolve(path, options);
        return true;
      } catch (e) {
        return false;
      }
    };
    $Ref.prototype.get = function(path, options) {
      return this.resolve(path, options).value;
    };
    $Ref.prototype.resolve = function(path, options, friendlyPath, pathFromRoot) {
      const pointer = new Pointer(this, path, friendlyPath);
      try {
        return pointer.resolve(this.value, options, pathFromRoot);
      } catch (err) {
        if (!options || !options.continueOnError || !isHandledError(err)) {
          throw err;
        }
        if (err.path === null) {
          err.path = safePointerToPath(getHash(pathFromRoot));
        }
        if (err instanceof InvalidPointerError) {
          err.source = stripHash(pathFromRoot);
        }
        this.addError(err);
        return null;
      }
    };
    $Ref.prototype.set = function(path, value) {
      const pointer = new Pointer(this, path);
      this.value = pointer.set(this.value, value);
    };
    $Ref.is$Ref = function(value) {
      return value && typeof value === "object" && typeof value.$ref === "string" && value.$ref.length > 0;
    };
    $Ref.isExternal$Ref = function(value) {
      return $Ref.is$Ref(value) && value.$ref[0] !== "#";
    };
    $Ref.isAllowed$Ref = function(value, options) {
      if ($Ref.is$Ref(value)) {
        if (value.$ref.substr(0, 2) === "#/" || value.$ref === "#") {
          return true;
        } else if (value.$ref[0] !== "#" && (!options || options.resolve.external)) {
          return true;
        }
      }
    };
    $Ref.isExtended$Ref = function(value) {
      return $Ref.is$Ref(value) && Object.keys(value).length > 1;
    };
    $Ref.dereference = function($ref, resolvedValue) {
      if (resolvedValue && typeof resolvedValue === "object" && $Ref.isExtended$Ref($ref)) {
        const merged = {};
        for (const key of Object.keys($ref)) {
          if (key !== "$ref") {
            merged[key] = $ref[key];
          }
        }
        for (const key of Object.keys(resolvedValue)) {
          if (!(key in merged)) {
            merged[key] = resolvedValue[key];
          }
        }
        return merged;
      }
      return resolvedValue;
    };
  }
});

// node_modules/@readme/json-schema-ref-parser/lib/bundle.js
var require_bundle = __commonJS({
  "node_modules/@readme/json-schema-ref-parser/lib/bundle.js"(exports2, module2) {
    var $Ref = require_ref();
    var Pointer = require_pointer();
    var url = require_url();
    module2.exports = function bundle(parser, options) {
      const inventory = [];
      crawl(parser, "schema", `${parser.$refs._root$Ref.path}#`, "#", 0, inventory, parser.$refs, options);
      remap(inventory);
    };
    function crawl(parent, key, path, pathFromRoot, indirections, inventory, $refs, options) {
      const obj = key === null ? parent : parent[key];
      if (obj && typeof obj === "object" && !ArrayBuffer.isView(obj)) {
        if ($Ref.isAllowed$Ref(obj)) {
          inventory$Ref(parent, key, path, pathFromRoot, indirections, inventory, $refs, options);
        } else {
          const keys = Object.keys(obj).sort((a, b) => {
            if (a === "definitions") {
              return -1;
            } else if (b === "definitions") {
              return 1;
            }
            return a.length - b.length;
          });
          for (const key2 of keys) {
            const keyPath = Pointer.join(path, key2);
            const keyPathFromRoot = Pointer.join(pathFromRoot, key2);
            const value = obj[key2];
            if ($Ref.isAllowed$Ref(value)) {
              inventory$Ref(obj, key2, path, keyPathFromRoot, indirections, inventory, $refs, options);
            } else {
              crawl(obj, key2, keyPath, keyPathFromRoot, indirections, inventory, $refs, options);
            }
          }
        }
      }
    }
    function inventory$Ref($refParent, $refKey, path, pathFromRoot, indirections, inventory, $refs, options) {
      const $ref = $refKey === null ? $refParent : $refParent[$refKey];
      const $refPath = url.resolve(path, $ref.$ref);
      const pointer = $refs._resolve($refPath, pathFromRoot, options);
      if (pointer === null) {
        return;
      }
      const depth = Pointer.parse(pathFromRoot).length;
      const file = url.stripHash(pointer.path);
      const hash = url.getHash(pointer.path);
      const external = file !== $refs._root$Ref.path;
      const extended = $Ref.isExtended$Ref($ref);
      indirections += pointer.indirections;
      const existingEntry = findInInventory(inventory, $refParent, $refKey);
      if (existingEntry) {
        if (depth < existingEntry.depth || indirections < existingEntry.indirections) {
          removeFromInventory(inventory, existingEntry);
        } else {
          return;
        }
      }
      inventory.push({
        $ref,
        // The JSON Reference (e.g. {$ref: string})
        parent: $refParent,
        // The object that contains this $ref pointer
        key: $refKey,
        // The key in `parent` that is the $ref pointer
        pathFromRoot,
        // The path to the $ref pointer, from the JSON Schema root
        depth,
        // How far from the JSON Schema root is this $ref pointer?
        file,
        // The file that the $ref pointer resolves to
        hash,
        // The hash within `file` that the $ref pointer resolves to
        value: pointer.value,
        // The resolved value of the $ref pointer
        circular: pointer.circular,
        // Is this $ref pointer DIRECTLY circular? (i.e. it references itself)
        extended,
        // Does this $ref extend its resolved value? (i.e. it has extra properties, in addition to "$ref")
        external,
        // Does this $ref pointer point to a file other than the main JSON Schema file?
        indirections
        // The number of indirect references that were traversed to resolve the value
      });
      if (!existingEntry) {
        crawl(pointer.value, null, pointer.path, pathFromRoot, indirections + 1, inventory, $refs, options);
      }
    }
    function remap(inventory) {
      inventory.sort((a, b) => {
        if (a.file !== b.file) {
          return a.file < b.file ? -1 : 1;
        } else if (a.hash !== b.hash) {
          return a.hash < b.hash ? -1 : 1;
        } else if (a.circular !== b.circular) {
          return a.circular ? -1 : 1;
        } else if (a.extended !== b.extended) {
          return a.extended ? 1 : -1;
        } else if (a.indirections !== b.indirections) {
          return a.indirections - b.indirections;
        } else if (a.depth !== b.depth) {
          return a.depth - b.depth;
        }
        const aDefinitionsIndex = a.pathFromRoot.lastIndexOf("/definitions");
        const bDefinitionsIndex = b.pathFromRoot.lastIndexOf("/definitions");
        if (aDefinitionsIndex !== bDefinitionsIndex) {
          return bDefinitionsIndex - aDefinitionsIndex;
        }
        return a.pathFromRoot.length - b.pathFromRoot.length;
      });
      let file;
      let hash;
      let pathFromRoot;
      for (const entry of inventory) {
        if (!entry.external) {
          entry.$ref.$ref = entry.hash;
        } else if (entry.file === file && entry.hash === hash) {
          entry.$ref.$ref = pathFromRoot;
        } else if (entry.file === file && entry.hash.indexOf(`${hash}/`) === 0) {
          entry.$ref.$ref = Pointer.join(pathFromRoot, Pointer.parse(entry.hash.replace(hash, "#")));
        } else {
          file = entry.file;
          hash = entry.hash;
          pathFromRoot = entry.pathFromRoot;
          entry.parent[entry.key] = $Ref.dereference(entry.$ref, entry.value);
          entry.$ref = entry.parent[entry.key];
          if (entry.circular) {
            entry.$ref.$ref = entry.pathFromRoot;
          }
        }
      }
    }
    function findInInventory(inventory, $refParent, $refKey) {
      for (let i = 0; i < inventory.length; i++) {
        const existingEntry = inventory[i];
        if (existingEntry.parent === $refParent && existingEntry.key === $refKey) {
          return existingEntry;
        }
      }
    }
    function removeFromInventory(inventory, entry) {
      const index = inventory.indexOf(entry);
      inventory.splice(index, 1);
    }
  }
});

// node_modules/@readme/json-schema-ref-parser/lib/dereference.js
var require_dereference = __commonJS({
  "node_modules/@readme/json-schema-ref-parser/lib/dereference.js"(exports2, module2) {
    var { ono: ono2 } = (init_esm(), __toCommonJS(esm_exports));
    var Pointer = require_pointer();
    var $Ref = require_ref();
    var url = require_url();
    module2.exports = function dereference(parser, options) {
      const dereferenced = crawl(
        parser.schema,
        parser.$refs._root$Ref.path,
        "#",
        /* @__PURE__ */ new Set(),
        /* @__PURE__ */ new Set(),
        /* @__PURE__ */ new Map(),
        parser.$refs,
        options
      );
      parser.$refs.circular = dereferenced.circular;
      parser.schema = dereferenced.value;
    };
    function crawl(obj, path, pathFromRoot, parents, processedObjects, dereferencedCache, $refs, options) {
      let dereferenced;
      const result = {
        value: obj,
        circular: false
      };
      if (options.dereference.circular === "ignore" || !processedObjects.has(obj)) {
        if (obj && typeof obj === "object" && !ArrayBuffer.isView(obj)) {
          parents.add(obj);
          processedObjects.add(obj);
          if ($Ref.isAllowed$Ref(obj, options)) {
            dereferenced = dereference$Ref(
              obj,
              path,
              pathFromRoot,
              parents,
              processedObjects,
              dereferencedCache,
              $refs,
              options
            );
            result.circular = dereferenced.circular;
            result.value = dereferenced.value;
            if (obj.description) {
              result.value.description = obj.description;
            }
            if (obj.summary) {
              result.value.summary = obj.summary;
            }
          } else {
            for (const key of Object.keys(obj)) {
              const keyPath = Pointer.join(path, key);
              const keyPathFromRoot = Pointer.join(pathFromRoot, key);
              const value = obj[key];
              let circular = false;
              if ($Ref.isAllowed$Ref(value, options)) {
                dereferenced = dereference$Ref(
                  value,
                  keyPath,
                  keyPathFromRoot,
                  parents,
                  processedObjects,
                  dereferencedCache,
                  $refs,
                  options
                );
                circular = dereferenced.circular;
                if (obj[key] !== dereferenced.value) {
                  obj[key] = dereferenced.value;
                  if (value.description) {
                    obj[key].description = value.description;
                  }
                  if (value.summary) {
                    obj[key].summary = value.summary;
                  }
                }
              } else if (!parents.has(value)) {
                dereferenced = crawl(
                  value,
                  keyPath,
                  keyPathFromRoot,
                  parents,
                  processedObjects,
                  dereferencedCache,
                  $refs,
                  options
                );
                circular = dereferenced.circular;
                if (obj[key] !== dereferenced.value) {
                  obj[key] = dereferenced.value;
                }
              } else {
                circular = foundCircularReference(keyPath, $refs, options);
              }
              result.circular = result.circular || circular;
            }
          }
          parents.delete(obj);
        }
      }
      return result;
    }
    function dereference$Ref($ref, path, pathFromRoot, parents, processedObjects, dereferencedCache, $refs, options) {
      const $refPath = url.resolve(path, $ref.$ref);
      const cache = dereferencedCache.get($refPath);
      if (cache) {
        const refKeys = Object.keys($ref);
        if (refKeys.length > 1) {
          const extraKeys = {};
          for (const key of refKeys) {
            if (key !== "$ref" && !(key in cache.value)) {
              extraKeys[key] = $ref[key];
            }
          }
          return {
            circular: cache.circular,
            value: { ...cache.value, ...extraKeys }
          };
        }
        return cache;
      }
      const pointer = $refs._resolve($refPath, path, options);
      if (pointer === null) {
        return {
          circular: false,
          value: null
        };
      }
      const directCircular = pointer.circular;
      let circular = directCircular || parents.has(pointer.value);
      circular && foundCircularReference(path, $refs, options);
      let dereferencedValue = $Ref.dereference($ref, pointer.value);
      if (!circular) {
        const dereferenced = crawl(
          dereferencedValue,
          pointer.path,
          pathFromRoot,
          parents,
          processedObjects,
          dereferencedCache,
          $refs,
          options
        );
        circular = dereferenced.circular;
        dereferencedValue = dereferenced.value;
      }
      if (circular && !directCircular && options.dereference.circular === "ignore") {
        dereferencedValue = $ref;
      }
      if (directCircular) {
        dereferencedValue.$ref = pathFromRoot;
      }
      const dereferencedObject = {
        circular,
        value: dereferencedValue
      };
      if (Object.keys($ref).length === 1) {
        dereferencedCache.set($refPath, dereferencedObject);
      }
      return dereferencedObject;
    }
    function foundCircularReference(keyPath, $refs, options) {
      $refs.circular = true;
      $refs.circularRefs.push(keyPath);
      if (!options.dereference.circular) {
        throw ono2.reference(`Circular $ref pointer found at ${keyPath}`);
      }
      return true;
    }
  }
});

// node_modules/@readme/json-schema-ref-parser/lib/parsers/binary.js
var require_binary = __commonJS({
  "node_modules/@readme/json-schema-ref-parser/lib/parsers/binary.js"(exports2, module2) {
    var BINARY_REGEXP = /\.(jpeg|jpg|gif|png|bmp|ico)$/i;
    module2.exports = {
      /**
       * The order that this parser will run, in relation to other parsers.
       *
       * @type {number}
       */
      order: 400,
      /**
       * Whether to allow "empty" files (zero bytes).
       *
       * @type {boolean}
       */
      allowEmpty: true,
      /**
       * Determines whether this parser can parse a given file reference.
       * Parsers that return true will be tried, in order, until one successfully parses the file.
       * Parsers that return false will be skipped, UNLESS all parsers returned false, in which case
       * every parser will be tried.
       *
       * @param {object} file           - An object containing information about the referenced file
       * @param {string} file.url       - The full URL of the referenced file
       * @param {string} file.extension - The lowercased file extension (e.g. ".txt", ".html", etc.)
       * @param {*}      file.data      - The file contents. This will be whatever data type was returned by the resolver
       * @returns {boolean}
       */
      canParse(file) {
        return Buffer.isBuffer(file.data) && BINARY_REGEXP.test(file.url);
      },
      /**
       * Parses the given data as a Buffer (byte array).
       *
       * @param {object} file           - An object containing information about the referenced file
       * @param {string} file.url       - The full URL of the referenced file
       * @param {string} file.extension - The lowercased file extension (e.g. ".txt", ".html", etc.)
       * @param {*}      file.data      - The file contents. This will be whatever data type was returned by the resolver
       * @returns {Buffer}
       */
      parse(file) {
        if (Buffer.isBuffer(file.data)) {
          return file.data;
        }
        return Buffer.from(file.data);
      }
    };
  }
});

// node_modules/@readme/json-schema-ref-parser/lib/parsers/json.js
var require_json = __commonJS({
  "node_modules/@readme/json-schema-ref-parser/lib/parsers/json.js"(exports2, module2) {
    var { ParserError } = require_errors();
    module2.exports = {
      /**
       * The order that this parser will run, in relation to other parsers.
       *
       * @type {number}
       */
      order: 100,
      /**
       * Whether to allow "empty" files. This includes zero-byte files, as well as empty JSON objects.
       *
       * @type {boolean}
       */
      allowEmpty: true,
      /**
       * Determines whether this parser can parse a given file reference.
       * Parsers that match will be tried, in order, until one successfully parses the file.
       * Parsers that don't match will be skipped, UNLESS none of the parsers match, in which case
       * every parser will be tried.
       *
       * @type {RegExp|string|string[]|function}
       */
      canParse: ".json",
      /**
       * Parses the given file as JSON
       *
       * @param {object} file           - An object containing information about the referenced file
       * @param {string} file.url       - The full URL of the referenced file
       * @param {string} file.extension - The lowercased file extension (e.g. ".txt", ".html", etc.)
       * @param {*}      file.data      - The file contents. This will be whatever data type was returned by the resolver
       * @returns {Promise}
       */
      // eslint-disable-next-line require-await
      async parse(file) {
        let data = file.data;
        if (Buffer.isBuffer(data)) {
          data = data.toString();
        }
        if (typeof data === "string") {
          if (data.trim().length === 0) {
            return;
          }
          try {
            return JSON.parse(data);
          } catch (e) {
            throw new ParserError(e.message, file.url);
          }
        }
        return data;
      }
    };
  }
});

// node_modules/@readme/json-schema-ref-parser/lib/parsers/text.js
var require_text = __commonJS({
  "node_modules/@readme/json-schema-ref-parser/lib/parsers/text.js"(exports2, module2) {
    var { ParserError } = require_errors();
    var TEXT_REGEXP = /\.(txt|htm|html|md|xml|js|min|map|css|scss|less|svg)$/i;
    module2.exports = {
      /**
       * The order that this parser will run, in relation to other parsers.
       *
       * @type {number}
       */
      order: 300,
      /**
       * Whether to allow "empty" files (zero bytes).
       *
       * @type {boolean}
       */
      allowEmpty: true,
      /**
       * The encoding that the text is expected to be in.
       *
       * @type {string}
       */
      encoding: "utf8",
      /**
       * Determines whether this parser can parse a given file reference.
       * Parsers that return true will be tried, in order, until one successfully parses the file.
       * Parsers that return false will be skipped, UNLESS all parsers returned false, in which case
       * every parser will be tried.
       *
       * @param {object} file           - An object containing information about the referenced file
       * @param {string} file.url       - The full URL of the referenced file
       * @param {string} file.extension - The lowercased file extension (e.g. ".txt", ".html", etc.)
       * @param {*}      file.data      - The file contents. This will be whatever data type was returned by the resolver
       * @returns {boolean}
       */
      canParse(file) {
        return (typeof file.data === "string" || Buffer.isBuffer(file.data)) && TEXT_REGEXP.test(file.url);
      },
      /**
       * Parses the given file as text
       *
       * @param {object} file           - An object containing information about the referenced file
       * @param {string} file.url       - The full URL of the referenced file
       * @param {string} file.extension - The lowercased file extension (e.g. ".txt", ".html", etc.)
       * @param {*}      file.data      - The file contents. This will be whatever data type was returned by the resolver
       * @returns {string}
       */
      parse(file) {
        if (typeof file.data === "string") {
          return file.data;
        } else if (Buffer.isBuffer(file.data)) {
          return file.data.toString(this.encoding);
        }
        throw new ParserError("data is not text", file.url);
      }
    };
  }
});

// node_modules/js-yaml/lib/common.js
var require_common2 = __commonJS({
  "node_modules/js-yaml/lib/common.js"(exports2, module2) {
    "use strict";
    function isNothing2(subject) {
      return typeof subject === "undefined" || subject === null;
    }
    function isObject5(subject) {
      return typeof subject === "object" && subject !== null;
    }
    function toArray2(sequence) {
      if (Array.isArray(sequence)) return sequence;
      else if (isNothing2(sequence)) return [];
      return [sequence];
    }
    function extend4(target, source) {
      var index, length, key, sourceKeys;
      if (source) {
        sourceKeys = Object.keys(source);
        for (index = 0, length = sourceKeys.length; index < length; index += 1) {
          key = sourceKeys[index];
          target[key] = source[key];
        }
      }
      return target;
    }
    function repeat3(string, count) {
      var result = "", cycle;
      for (cycle = 0; cycle < count; cycle += 1) {
        result += string;
      }
      return result;
    }
    function isNegativeZero2(number) {
      return number === 0 && Number.NEGATIVE_INFINITY === 1 / number;
    }
    module2.exports.isNothing = isNothing2;
    module2.exports.isObject = isObject5;
    module2.exports.toArray = toArray2;
    module2.exports.repeat = repeat3;
    module2.exports.isNegativeZero = isNegativeZero2;
    module2.exports.extend = extend4;
  }
});

// node_modules/js-yaml/lib/exception.js
var require_exception = __commonJS({
  "node_modules/js-yaml/lib/exception.js"(exports2, module2) {
    "use strict";
    function formatError2(exception2, compact) {
      var where = "", message = exception2.reason || "(unknown reason)";
      if (!exception2.mark) return message;
      if (exception2.mark.name) {
        where += 'in "' + exception2.mark.name + '" ';
      }
      where += "(" + (exception2.mark.line + 1) + ":" + (exception2.mark.column + 1) + ")";
      if (!compact && exception2.mark.snippet) {
        where += "\n\n" + exception2.mark.snippet;
      }
      return message + " " + where;
    }
    function YAMLException2(reason, mark) {
      Error.call(this);
      this.name = "YAMLException";
      this.reason = reason;
      this.mark = mark;
      this.message = formatError2(this, false);
      if (Error.captureStackTrace) {
        Error.captureStackTrace(this, this.constructor);
      } else {
        this.stack = new Error().stack || "";
      }
    }
    YAMLException2.prototype = Object.create(Error.prototype);
    YAMLException2.prototype.constructor = YAMLException2;
    YAMLException2.prototype.toString = function toString2(compact) {
      return this.name + ": " + formatError2(this, compact);
    };
    module2.exports = YAMLException2;
  }
});

// node_modules/js-yaml/lib/snippet.js
var require_snippet = __commonJS({
  "node_modules/js-yaml/lib/snippet.js"(exports2, module2) {
    "use strict";
    var common2 = require_common2();
    function getLine2(buffer, lineStart, lineEnd, position, maxLineLength) {
      var head = "";
      var tail = "";
      var maxHalfLength = Math.floor(maxLineLength / 2) - 1;
      if (position - lineStart > maxHalfLength) {
        head = " ... ";
        lineStart = position - maxHalfLength + head.length;
      }
      if (lineEnd - position > maxHalfLength) {
        tail = " ...";
        lineEnd = position + maxHalfLength - tail.length;
      }
      return {
        str: head + buffer.slice(lineStart, lineEnd).replace(/\t/g, "\u2192") + tail,
        pos: position - lineStart + head.length
        // relative position
      };
    }
    function padStart2(string, max) {
      return common2.repeat(" ", max - string.length) + string;
    }
    function makeSnippet2(mark, options) {
      options = Object.create(options || null);
      if (!mark.buffer) return null;
      if (!options.maxLength) options.maxLength = 79;
      if (typeof options.indent !== "number") options.indent = 1;
      if (typeof options.linesBefore !== "number") options.linesBefore = 3;
      if (typeof options.linesAfter !== "number") options.linesAfter = 2;
      var re = /\r?\n|\r|\0/g;
      var lineStarts = [0];
      var lineEnds = [];
      var match2;
      var foundLineNo = -1;
      while (match2 = re.exec(mark.buffer)) {
        lineEnds.push(match2.index);
        lineStarts.push(match2.index + match2[0].length);
        if (mark.position <= match2.index && foundLineNo < 0) {
          foundLineNo = lineStarts.length - 2;
        }
      }
      if (foundLineNo < 0) foundLineNo = lineStarts.length - 1;
      var result = "", i, line;
      var lineNoLength = Math.min(mark.line + options.linesAfter, lineEnds.length).toString().length;
      var maxLineLength = options.maxLength - (options.indent + lineNoLength + 3);
      for (i = 1; i <= options.linesBefore; i++) {
        if (foundLineNo - i < 0) break;
        line = getLine2(
          mark.buffer,
          lineStarts[foundLineNo - i],
          lineEnds[foundLineNo - i],
          mark.position - (lineStarts[foundLineNo] - lineStarts[foundLineNo - i]),
          maxLineLength
        );
        result = common2.repeat(" ", options.indent) + padStart2((mark.line - i + 1).toString(), lineNoLength) + " | " + line.str + "\n" + result;
      }
      line = getLine2(mark.buffer, lineStarts[foundLineNo], lineEnds[foundLineNo], mark.position, maxLineLength);
      result += common2.repeat(" ", options.indent) + padStart2((mark.line + 1).toString(), lineNoLength) + " | " + line.str + "\n";
      result += common2.repeat("-", options.indent + lineNoLength + 3 + line.pos) + "^\n";
      for (i = 1; i <= options.linesAfter; i++) {
        if (foundLineNo + i >= lineEnds.length) break;
        line = getLine2(
          mark.buffer,
          lineStarts[foundLineNo + i],
          lineEnds[foundLineNo + i],
          mark.position - (lineStarts[foundLineNo] - lineStarts[foundLineNo + i]),
          maxLineLength
        );
        result += common2.repeat(" ", options.indent) + padStart2((mark.line + i + 1).toString(), lineNoLength) + " | " + line.str + "\n";
      }
      return result.replace(/\n$/, "");
    }
    module2.exports = makeSnippet2;
  }
});

// node_modules/js-yaml/lib/type.js
var require_type = __commonJS({
  "node_modules/js-yaml/lib/type.js"(exports2, module2) {
    "use strict";
    var YAMLException2 = require_exception();
    var TYPE_CONSTRUCTOR_OPTIONS2 = [
      "kind",
      "multi",
      "resolve",
      "construct",
      "instanceOf",
      "predicate",
      "represent",
      "representName",
      "defaultStyle",
      "styleAliases"
    ];
    var YAML_NODE_KINDS2 = [
      "scalar",
      "sequence",
      "mapping"
    ];
    function compileStyleAliases2(map2) {
      var result = {};
      if (map2 !== null) {
        Object.keys(map2).forEach(function(style) {
          map2[style].forEach(function(alias) {
            result[String(alias)] = style;
          });
        });
      }
      return result;
    }
    function Type2(tag, options) {
      options = options || {};
      Object.keys(options).forEach(function(name) {
        if (TYPE_CONSTRUCTOR_OPTIONS2.indexOf(name) === -1) {
          throw new YAMLException2('Unknown option "' + name + '" is met in definition of "' + tag + '" YAML type.');
        }
      });
      this.options = options;
      this.tag = tag;
      this.kind = options["kind"] || null;
      this.resolve = options["resolve"] || function() {
        return true;
      };
      this.construct = options["construct"] || function(data) {
        return data;
      };
      this.instanceOf = options["instanceOf"] || null;
      this.predicate = options["predicate"] || null;
      this.represent = options["represent"] || null;
      this.representName = options["representName"] || null;
      this.defaultStyle = options["defaultStyle"] || null;
      this.multi = options["multi"] || false;
      this.styleAliases = compileStyleAliases2(options["styleAliases"] || null);
      if (YAML_NODE_KINDS2.indexOf(this.kind) === -1) {
        throw new YAMLException2('Unknown kind "' + this.kind + '" is specified for "' + tag + '" YAML type.');
      }
    }
    module2.exports = Type2;
  }
});

// node_modules/js-yaml/lib/schema.js
var require_schema = __commonJS({
  "node_modules/js-yaml/lib/schema.js"(exports2, module2) {
    "use strict";
    var YAMLException2 = require_exception();
    var Type2 = require_type();
    function compileList2(schema2, name) {
      var result = [];
      schema2[name].forEach(function(currentType) {
        var newIndex = result.length;
        result.forEach(function(previousType, previousIndex) {
          if (previousType.tag === currentType.tag && previousType.kind === currentType.kind && previousType.multi === currentType.multi) {
            newIndex = previousIndex;
          }
        });
        result[newIndex] = currentType;
      });
      return result;
    }
    function compileMap2() {
      var result = {
        scalar: {},
        sequence: {},
        mapping: {},
        fallback: {},
        multi: {
          scalar: [],
          sequence: [],
          mapping: [],
          fallback: []
        }
      }, index, length;
      function collectType(type2) {
        if (type2.multi) {
          result.multi[type2.kind].push(type2);
          result.multi["fallback"].push(type2);
        } else {
          result[type2.kind][type2.tag] = result["fallback"][type2.tag] = type2;
        }
      }
      for (index = 0, length = arguments.length; index < length; index += 1) {
        arguments[index].forEach(collectType);
      }
      return result;
    }
    function Schema2(definition) {
      return this.extend(definition);
    }
    Schema2.prototype.extend = function extend4(definition) {
      var implicit = [];
      var explicit = [];
      if (definition instanceof Type2) {
        explicit.push(definition);
      } else if (Array.isArray(definition)) {
        explicit = explicit.concat(definition);
      } else if (definition && (Array.isArray(definition.implicit) || Array.isArray(definition.explicit))) {
        if (definition.implicit) implicit = implicit.concat(definition.implicit);
        if (definition.explicit) explicit = explicit.concat(definition.explicit);
      } else {
        throw new YAMLException2("Schema.extend argument should be a Type, [ Type ], or a schema definition ({ implicit: [...], explicit: [...] })");
      }
      implicit.forEach(function(type2) {
        if (!(type2 instanceof Type2)) {
          throw new YAMLException2("Specified list of YAML types (or a single Type object) contains a non-Type object.");
        }
        if (type2.loadKind && type2.loadKind !== "scalar") {
          throw new YAMLException2("There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.");
        }
        if (type2.multi) {
          throw new YAMLException2("There is a multi type in the implicit list of a schema. Multi tags can only be listed as explicit.");
        }
      });
      explicit.forEach(function(type2) {
        if (!(type2 instanceof Type2)) {
          throw new YAMLException2("Specified list of YAML types (or a single Type object) contains a non-Type object.");
        }
      });
      var result = Object.create(Schema2.prototype);
      result.implicit = (this.implicit || []).concat(implicit);
      result.explicit = (this.explicit || []).concat(explicit);
      result.compiledImplicit = compileList2(result, "implicit");
      result.compiledExplicit = compileList2(result, "explicit");
      result.compiledTypeMap = compileMap2(result.compiledImplicit, result.compiledExplicit);
      return result;
    };
    module2.exports = Schema2;
  }
});

// node_modules/js-yaml/lib/type/str.js
var require_str = __commonJS({
  "node_modules/js-yaml/lib/type/str.js"(exports2, module2) {
    "use strict";
    var Type2 = require_type();
    module2.exports = new Type2("tag:yaml.org,2002:str", {
      kind: "scalar",
      construct: function(data) {
        return data !== null ? data : "";
      }
    });
  }
});

// node_modules/js-yaml/lib/type/seq.js
var require_seq = __commonJS({
  "node_modules/js-yaml/lib/type/seq.js"(exports2, module2) {
    "use strict";
    var Type2 = require_type();
    module2.exports = new Type2("tag:yaml.org,2002:seq", {
      kind: "sequence",
      construct: function(data) {
        return data !== null ? data : [];
      }
    });
  }
});

// node_modules/js-yaml/lib/type/map.js
var require_map2 = __commonJS({
  "node_modules/js-yaml/lib/type/map.js"(exports2, module2) {
    "use strict";
    var Type2 = require_type();
    module2.exports = new Type2("tag:yaml.org,2002:map", {
      kind: "mapping",
      construct: function(data) {
        return data !== null ? data : {};
      }
    });
  }
});

// node_modules/js-yaml/lib/schema/failsafe.js
var require_failsafe = __commonJS({
  "node_modules/js-yaml/lib/schema/failsafe.js"(exports2, module2) {
    "use strict";
    var Schema2 = require_schema();
    module2.exports = new Schema2({
      explicit: [
        require_str(),
        require_seq(),
        require_map2()
      ]
    });
  }
});

// node_modules/js-yaml/lib/type/null.js
var require_null = __commonJS({
  "node_modules/js-yaml/lib/type/null.js"(exports2, module2) {
    "use strict";
    var Type2 = require_type();
    function resolveYamlNull2(data) {
      if (data === null) return true;
      var max = data.length;
      return max === 1 && data === "~" || max === 4 && (data === "null" || data === "Null" || data === "NULL");
    }
    function constructYamlNull2() {
      return null;
    }
    function isNull2(object) {
      return object === null;
    }
    module2.exports = new Type2("tag:yaml.org,2002:null", {
      kind: "scalar",
      resolve: resolveYamlNull2,
      construct: constructYamlNull2,
      predicate: isNull2,
      represent: {
        canonical: function() {
          return "~";
        },
        lowercase: function() {
          return "null";
        },
        uppercase: function() {
          return "NULL";
        },
        camelcase: function() {
          return "Null";
        },
        empty: function() {
          return "";
        }
      },
      defaultStyle: "lowercase"
    });
  }
});

// node_modules/js-yaml/lib/type/bool.js
var require_bool = __commonJS({
  "node_modules/js-yaml/lib/type/bool.js"(exports2, module2) {
    "use strict";
    var Type2 = require_type();
    function resolveYamlBoolean2(data) {
      if (data === null) return false;
      var max = data.length;
      return max === 4 && (data === "true" || data === "True" || data === "TRUE") || max === 5 && (data === "false" || data === "False" || data === "FALSE");
    }
    function constructYamlBoolean2(data) {
      return data === "true" || data === "True" || data === "TRUE";
    }
    function isBoolean2(object) {
      return Object.prototype.toString.call(object) === "[object Boolean]";
    }
    module2.exports = new Type2("tag:yaml.org,2002:bool", {
      kind: "scalar",
      resolve: resolveYamlBoolean2,
      construct: constructYamlBoolean2,
      predicate: isBoolean2,
      represent: {
        lowercase: function(object) {
          return object ? "true" : "false";
        },
        uppercase: function(object) {
          return object ? "TRUE" : "FALSE";
        },
        camelcase: function(object) {
          return object ? "True" : "False";
        }
      },
      defaultStyle: "lowercase"
    });
  }
});

// node_modules/js-yaml/lib/type/int.js
var require_int = __commonJS({
  "node_modules/js-yaml/lib/type/int.js"(exports2, module2) {
    "use strict";
    var common2 = require_common2();
    var Type2 = require_type();
    function isHexCode2(c2) {
      return 48 <= c2 && c2 <= 57 || 65 <= c2 && c2 <= 70 || 97 <= c2 && c2 <= 102;
    }
    function isOctCode2(c2) {
      return 48 <= c2 && c2 <= 55;
    }
    function isDecCode2(c2) {
      return 48 <= c2 && c2 <= 57;
    }
    function resolveYamlInteger2(data) {
      if (data === null) return false;
      var max = data.length, index = 0, hasDigits = false, ch;
      if (!max) return false;
      ch = data[index];
      if (ch === "-" || ch === "+") {
        ch = data[++index];
      }
      if (ch === "0") {
        if (index + 1 === max) return true;
        ch = data[++index];
        if (ch === "b") {
          index++;
          for (; index < max; index++) {
            ch = data[index];
            if (ch === "_") continue;
            if (ch !== "0" && ch !== "1") return false;
            hasDigits = true;
          }
          return hasDigits && ch !== "_";
        }
        if (ch === "x") {
          index++;
          for (; index < max; index++) {
            ch = data[index];
            if (ch === "_") continue;
            if (!isHexCode2(data.charCodeAt(index))) return false;
            hasDigits = true;
          }
          return hasDigits && ch !== "_";
        }
        if (ch === "o") {
          index++;
          for (; index < max; index++) {
            ch = data[index];
            if (ch === "_") continue;
            if (!isOctCode2(data.charCodeAt(index))) return false;
            hasDigits = true;
          }
          return hasDigits && ch !== "_";
        }
      }
      if (ch === "_") return false;
      for (; index < max; index++) {
        ch = data[index];
        if (ch === "_") continue;
        if (!isDecCode2(data.charCodeAt(index))) {
          return false;
        }
        hasDigits = true;
      }
      if (!hasDigits || ch === "_") return false;
      return true;
    }
    function constructYamlInteger2(data) {
      var value = data, sign = 1, ch;
      if (value.indexOf("_") !== -1) {
        value = value.replace(/_/g, "");
      }
      ch = value[0];
      if (ch === "-" || ch === "+") {
        if (ch === "-") sign = -1;
        value = value.slice(1);
        ch = value[0];
      }
      if (value === "0") return 0;
      if (ch === "0") {
        if (value[1] === "b") return sign * parseInt(value.slice(2), 2);
        if (value[1] === "x") return sign * parseInt(value.slice(2), 16);
        if (value[1] === "o") return sign * parseInt(value.slice(2), 8);
      }
      return sign * parseInt(value, 10);
    }
    function isInteger2(object) {
      return Object.prototype.toString.call(object) === "[object Number]" && (object % 1 === 0 && !common2.isNegativeZero(object));
    }
    module2.exports = new Type2("tag:yaml.org,2002:int", {
      kind: "scalar",
      resolve: resolveYamlInteger2,
      construct: constructYamlInteger2,
      predicate: isInteger2,
      represent: {
        binary: function(obj) {
          return obj >= 0 ? "0b" + obj.toString(2) : "-0b" + obj.toString(2).slice(1);
        },
        octal: function(obj) {
          return obj >= 0 ? "0o" + obj.toString(8) : "-0o" + obj.toString(8).slice(1);
        },
        decimal: function(obj) {
          return obj.toString(10);
        },
        /* eslint-disable max-len */
        hexadecimal: function(obj) {
          return obj >= 0 ? "0x" + obj.toString(16).toUpperCase() : "-0x" + obj.toString(16).toUpperCase().slice(1);
        }
      },
      defaultStyle: "decimal",
      styleAliases: {
        binary: [2, "bin"],
        octal: [8, "oct"],
        decimal: [10, "dec"],
        hexadecimal: [16, "hex"]
      }
    });
  }
});

// node_modules/js-yaml/lib/type/float.js
var require_float = __commonJS({
  "node_modules/js-yaml/lib/type/float.js"(exports2, module2) {
    "use strict";
    var common2 = require_common2();
    var Type2 = require_type();
    var YAML_FLOAT_PATTERN2 = new RegExp(
      // 2.5e4, 2.5 and integers
      "^(?:[-+]?(?:[0-9][0-9_]*)(?:\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?|\\.[0-9_]+(?:[eE][-+]?[0-9]+)?|[-+]?\\.(?:inf|Inf|INF)|\\.(?:nan|NaN|NAN))$"
    );
    function resolveYamlFloat2(data) {
      if (data === null) return false;
      if (!YAML_FLOAT_PATTERN2.test(data) || // Quick hack to not allow integers end with `_`
      // Probably should update regexp & check speed
      data[data.length - 1] === "_") {
        return false;
      }
      return true;
    }
    function constructYamlFloat2(data) {
      var value, sign;
      value = data.replace(/_/g, "").toLowerCase();
      sign = value[0] === "-" ? -1 : 1;
      if ("+-".indexOf(value[0]) >= 0) {
        value = value.slice(1);
      }
      if (value === ".inf") {
        return sign === 1 ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;
      } else if (value === ".nan") {
        return NaN;
      }
      return sign * parseFloat(value, 10);
    }
    var SCIENTIFIC_WITHOUT_DOT2 = /^[-+]?[0-9]+e/;
    function representYamlFloat2(object, style) {
      var res;
      if (isNaN(object)) {
        switch (style) {
          case "lowercase":
            return ".nan";
          case "uppercase":
            return ".NAN";
          case "camelcase":
            return ".NaN";
        }
      } else if (Number.POSITIVE_INFINITY === object) {
        switch (style) {
          case "lowercase":
            return ".inf";
          case "uppercase":
            return ".INF";
          case "camelcase":
            return ".Inf";
        }
      } else if (Number.NEGATIVE_INFINITY === object) {
        switch (style) {
          case "lowercase":
            return "-.inf";
          case "uppercase":
            return "-.INF";
          case "camelcase":
            return "-.Inf";
        }
      } else if (common2.isNegativeZero(object)) {
        return "-0.0";
      }
      res = object.toString(10);
      return SCIENTIFIC_WITHOUT_DOT2.test(res) ? res.replace("e", ".e") : res;
    }
    function isFloat2(object) {
      return Object.prototype.toString.call(object) === "[object Number]" && (object % 1 !== 0 || common2.isNegativeZero(object));
    }
    module2.exports = new Type2("tag:yaml.org,2002:float", {
      kind: "scalar",
      resolve: resolveYamlFloat2,
      construct: constructYamlFloat2,
      predicate: isFloat2,
      represent: representYamlFloat2,
      defaultStyle: "lowercase"
    });
  }
});

// node_modules/js-yaml/lib/schema/json.js
var require_json2 = __commonJS({
  "node_modules/js-yaml/lib/schema/json.js"(exports2, module2) {
    "use strict";
    module2.exports = require_failsafe().extend({
      implicit: [
        require_null(),
        require_bool(),
        require_int(),
        require_float()
      ]
    });
  }
});

// node_modules/js-yaml/lib/schema/core.js
var require_core = __commonJS({
  "node_modules/js-yaml/lib/schema/core.js"(exports2, module2) {
    "use strict";
    module2.exports = require_json2();
  }
});

// node_modules/js-yaml/lib/type/timestamp.js
var require_timestamp = __commonJS({
  "node_modules/js-yaml/lib/type/timestamp.js"(exports2, module2) {
    "use strict";
    var Type2 = require_type();
    var YAML_DATE_REGEXP2 = new RegExp(
      "^([0-9][0-9][0-9][0-9])-([0-9][0-9])-([0-9][0-9])$"
    );
    var YAML_TIMESTAMP_REGEXP2 = new RegExp(
      "^([0-9][0-9][0-9][0-9])-([0-9][0-9]?)-([0-9][0-9]?)(?:[Tt]|[ \\t]+)([0-9][0-9]?):([0-9][0-9]):([0-9][0-9])(?:\\.([0-9]*))?(?:[ \\t]*(Z|([-+])([0-9][0-9]?)(?::([0-9][0-9]))?))?$"
    );
    function resolveYamlTimestamp2(data) {
      if (data === null) return false;
      if (YAML_DATE_REGEXP2.exec(data) !== null) return true;
      if (YAML_TIMESTAMP_REGEXP2.exec(data) !== null) return true;
      return false;
    }
    function constructYamlTimestamp2(data) {
      var match2, year, month, day, hour, minute, second, fraction = 0, delta = null, tz_hour, tz_minute, date;
      match2 = YAML_DATE_REGEXP2.exec(data);
      if (match2 === null) match2 = YAML_TIMESTAMP_REGEXP2.exec(data);
      if (match2 === null) throw new Error("Date resolve error");
      year = +match2[1];
      month = +match2[2] - 1;
      day = +match2[3];
      if (!match2[4]) {
        return new Date(Date.UTC(year, month, day));
      }
      hour = +match2[4];
      minute = +match2[5];
      second = +match2[6];
      if (match2[7]) {
        fraction = match2[7].slice(0, 3);
        while (fraction.length < 3) {
          fraction += "0";
        }
        fraction = +fraction;
      }
      if (match2[9]) {
        tz_hour = +match2[10];
        tz_minute = +(match2[11] || 0);
        delta = (tz_hour * 60 + tz_minute) * 6e4;
        if (match2[9] === "-") delta = -delta;
      }
      date = new Date(Date.UTC(year, month, day, hour, minute, second, fraction));
      if (delta) date.setTime(date.getTime() - delta);
      return date;
    }
    function representYamlTimestamp2(object) {
      return object.toISOString();
    }
    module2.exports = new Type2("tag:yaml.org,2002:timestamp", {
      kind: "scalar",
      resolve: resolveYamlTimestamp2,
      construct: constructYamlTimestamp2,
      instanceOf: Date,
      represent: representYamlTimestamp2
    });
  }
});

// node_modules/js-yaml/lib/type/merge.js
var require_merge = __commonJS({
  "node_modules/js-yaml/lib/type/merge.js"(exports2, module2) {
    "use strict";
    var Type2 = require_type();
    function resolveYamlMerge2(data) {
      return data === "<<" || data === null;
    }
    module2.exports = new Type2("tag:yaml.org,2002:merge", {
      kind: "scalar",
      resolve: resolveYamlMerge2
    });
  }
});

// node_modules/js-yaml/lib/type/binary.js
var require_binary2 = __commonJS({
  "node_modules/js-yaml/lib/type/binary.js"(exports2, module2) {
    "use strict";
    var Type2 = require_type();
    var BASE64_MAP2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\n\r";
    function resolveYamlBinary2(data) {
      if (data === null) return false;
      var code, idx, bitlen = 0, max = data.length, map2 = BASE64_MAP2;
      for (idx = 0; idx < max; idx++) {
        code = map2.indexOf(data.charAt(idx));
        if (code > 64) continue;
        if (code < 0) return false;
        bitlen += 6;
      }
      return bitlen % 8 === 0;
    }
    function constructYamlBinary2(data) {
      var idx, tailbits, input = data.replace(/[\r\n=]/g, ""), max = input.length, map2 = BASE64_MAP2, bits = 0, result = [];
      for (idx = 0; idx < max; idx++) {
        if (idx % 4 === 0 && idx) {
          result.push(bits >> 16 & 255);
          result.push(bits >> 8 & 255);
          result.push(bits & 255);
        }
        bits = bits << 6 | map2.indexOf(input.charAt(idx));
      }
      tailbits = max % 4 * 6;
      if (tailbits === 0) {
        result.push(bits >> 16 & 255);
        result.push(bits >> 8 & 255);
        result.push(bits & 255);
      } else if (tailbits === 18) {
        result.push(bits >> 10 & 255);
        result.push(bits >> 2 & 255);
      } else if (tailbits === 12) {
        result.push(bits >> 4 & 255);
      }
      return new Uint8Array(result);
    }
    function representYamlBinary2(object) {
      var result = "", bits = 0, idx, tail, max = object.length, map2 = BASE64_MAP2;
      for (idx = 0; idx < max; idx++) {
        if (idx % 3 === 0 && idx) {
          result += map2[bits >> 18 & 63];
          result += map2[bits >> 12 & 63];
          result += map2[bits >> 6 & 63];
          result += map2[bits & 63];
        }
        bits = (bits << 8) + object[idx];
      }
      tail = max % 3;
      if (tail === 0) {
        result += map2[bits >> 18 & 63];
        result += map2[bits >> 12 & 63];
        result += map2[bits >> 6 & 63];
        result += map2[bits & 63];
      } else if (tail === 2) {
        result += map2[bits >> 10 & 63];
        result += map2[bits >> 4 & 63];
        result += map2[bits << 2 & 63];
        result += map2[64];
      } else if (tail === 1) {
        result += map2[bits >> 2 & 63];
        result += map2[bits << 4 & 63];
        result += map2[64];
        result += map2[64];
      }
      return result;
    }
    function isBinary2(obj) {
      return Object.prototype.toString.call(obj) === "[object Uint8Array]";
    }
    module2.exports = new Type2("tag:yaml.org,2002:binary", {
      kind: "scalar",
      resolve: resolveYamlBinary2,
      construct: constructYamlBinary2,
      predicate: isBinary2,
      represent: representYamlBinary2
    });
  }
});

// node_modules/js-yaml/lib/type/omap.js
var require_omap = __commonJS({
  "node_modules/js-yaml/lib/type/omap.js"(exports2, module2) {
    "use strict";
    var Type2 = require_type();
    var _hasOwnProperty2 = Object.prototype.hasOwnProperty;
    var _toString2 = Object.prototype.toString;
    function resolveYamlOmap2(data) {
      if (data === null) return true;
      var objectKeys = [], index, length, pair, pairKey, pairHasKey, object = data;
      for (index = 0, length = object.length; index < length; index += 1) {
        pair = object[index];
        pairHasKey = false;
        if (_toString2.call(pair) !== "[object Object]") return false;
        for (pairKey in pair) {
          if (_hasOwnProperty2.call(pair, pairKey)) {
            if (!pairHasKey) pairHasKey = true;
            else return false;
          }
        }
        if (!pairHasKey) return false;
        if (objectKeys.indexOf(pairKey) === -1) objectKeys.push(pairKey);
        else return false;
      }
      return true;
    }
    function constructYamlOmap2(data) {
      return data !== null ? data : [];
    }
    module2.exports = new Type2("tag:yaml.org,2002:omap", {
      kind: "sequence",
      resolve: resolveYamlOmap2,
      construct: constructYamlOmap2
    });
  }
});

// node_modules/js-yaml/lib/type/pairs.js
var require_pairs = __commonJS({
  "node_modules/js-yaml/lib/type/pairs.js"(exports2, module2) {
    "use strict";
    var Type2 = require_type();
    var _toString2 = Object.prototype.toString;
    function resolveYamlPairs2(data) {
      if (data === null) return true;
      var index, length, pair, keys, result, object = data;
      result = new Array(object.length);
      for (index = 0, length = object.length; index < length; index += 1) {
        pair = object[index];
        if (_toString2.call(pair) !== "[object Object]") return false;
        keys = Object.keys(pair);
        if (keys.length !== 1) return false;
        result[index] = [keys[0], pair[keys[0]]];
      }
      return true;
    }
    function constructYamlPairs2(data) {
      if (data === null) return [];
      var index, length, pair, keys, result, object = data;
      result = new Array(object.length);
      for (index = 0, length = object.length; index < length; index += 1) {
        pair = object[index];
        keys = Object.keys(pair);
        result[index] = [keys[0], pair[keys[0]]];
      }
      return result;
    }
    module2.exports = new Type2("tag:yaml.org,2002:pairs", {
      kind: "sequence",
      resolve: resolveYamlPairs2,
      construct: constructYamlPairs2
    });
  }
});

// node_modules/js-yaml/lib/type/set.js
var require_set = __commonJS({
  "node_modules/js-yaml/lib/type/set.js"(exports2, module2) {
    "use strict";
    var Type2 = require_type();
    var _hasOwnProperty2 = Object.prototype.hasOwnProperty;
    function resolveYamlSet2(data) {
      if (data === null) return true;
      var key, object = data;
      for (key in object) {
        if (_hasOwnProperty2.call(object, key)) {
          if (object[key] !== null) return false;
        }
      }
      return true;
    }
    function constructYamlSet2(data) {
      return data !== null ? data : {};
    }
    module2.exports = new Type2("tag:yaml.org,2002:set", {
      kind: "mapping",
      resolve: resolveYamlSet2,
      construct: constructYamlSet2
    });
  }
});

// node_modules/js-yaml/lib/schema/default.js
var require_default = __commonJS({
  "node_modules/js-yaml/lib/schema/default.js"(exports2, module2) {
    "use strict";
    module2.exports = require_core().extend({
      implicit: [
        require_timestamp(),
        require_merge()
      ],
      explicit: [
        require_binary2(),
        require_omap(),
        require_pairs(),
        require_set()
      ]
    });
  }
});

// node_modules/js-yaml/lib/loader.js
var require_loader = __commonJS({
  "node_modules/js-yaml/lib/loader.js"(exports2, module2) {
    "use strict";
    var common2 = require_common2();
    var YAMLException2 = require_exception();
    var makeSnippet2 = require_snippet();
    var DEFAULT_SCHEMA2 = require_default();
    var _hasOwnProperty2 = Object.prototype.hasOwnProperty;
    var CONTEXT_FLOW_IN2 = 1;
    var CONTEXT_FLOW_OUT2 = 2;
    var CONTEXT_BLOCK_IN2 = 3;
    var CONTEXT_BLOCK_OUT2 = 4;
    var CHOMPING_CLIP2 = 1;
    var CHOMPING_STRIP2 = 2;
    var CHOMPING_KEEP2 = 3;
    var PATTERN_NON_PRINTABLE2 = /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
    var PATTERN_NON_ASCII_LINE_BREAKS2 = /[\x85\u2028\u2029]/;
    var PATTERN_FLOW_INDICATORS2 = /[,\[\]\{\}]/;
    var PATTERN_TAG_HANDLE2 = /^(?:!|!!|![a-z\-]+!)$/i;
    var PATTERN_TAG_URI2 = /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;
    function _class2(obj) {
      return Object.prototype.toString.call(obj);
    }
    function is_EOL2(c2) {
      return c2 === 10 || c2 === 13;
    }
    function is_WHITE_SPACE2(c2) {
      return c2 === 9 || c2 === 32;
    }
    function is_WS_OR_EOL2(c2) {
      return c2 === 9 || c2 === 32 || c2 === 10 || c2 === 13;
    }
    function is_FLOW_INDICATOR2(c2) {
      return c2 === 44 || c2 === 91 || c2 === 93 || c2 === 123 || c2 === 125;
    }
    function fromHexCode2(c2) {
      var lc;
      if (48 <= c2 && c2 <= 57) {
        return c2 - 48;
      }
      lc = c2 | 32;
      if (97 <= lc && lc <= 102) {
        return lc - 97 + 10;
      }
      return -1;
    }
    function escapedHexLen2(c2) {
      if (c2 === 120) {
        return 2;
      }
      if (c2 === 117) {
        return 4;
      }
      if (c2 === 85) {
        return 8;
      }
      return 0;
    }
    function fromDecimalCode2(c2) {
      if (48 <= c2 && c2 <= 57) {
        return c2 - 48;
      }
      return -1;
    }
    function simpleEscapeSequence2(c2) {
      return c2 === 48 ? "\0" : c2 === 97 ? "\x07" : c2 === 98 ? "\b" : c2 === 116 ? "	" : c2 === 9 ? "	" : c2 === 110 ? "\n" : c2 === 118 ? "\v" : c2 === 102 ? "\f" : c2 === 114 ? "\r" : c2 === 101 ? "\x1B" : c2 === 32 ? " " : c2 === 34 ? '"' : c2 === 47 ? "/" : c2 === 92 ? "\\" : c2 === 78 ? "\x85" : c2 === 95 ? "\xA0" : c2 === 76 ? "\u2028" : c2 === 80 ? "\u2029" : "";
    }
    function charFromCodepoint2(c2) {
      if (c2 <= 65535) {
        return String.fromCharCode(c2);
      }
      return String.fromCharCode(
        (c2 - 65536 >> 10) + 55296,
        (c2 - 65536 & 1023) + 56320
      );
    }
    var simpleEscapeCheck2 = new Array(256);
    var simpleEscapeMap2 = new Array(256);
    for (i = 0; i < 256; i++) {
      simpleEscapeCheck2[i] = simpleEscapeSequence2(i) ? 1 : 0;
      simpleEscapeMap2[i] = simpleEscapeSequence2(i);
    }
    var i;
    function State2(input, options) {
      this.input = input;
      this.filename = options["filename"] || null;
      this.schema = options["schema"] || DEFAULT_SCHEMA2;
      this.onWarning = options["onWarning"] || null;
      this.legacy = options["legacy"] || false;
      this.json = options["json"] || false;
      this.listener = options["listener"] || null;
      this.implicitTypes = this.schema.compiledImplicit;
      this.typeMap = this.schema.compiledTypeMap;
      this.length = input.length;
      this.position = 0;
      this.line = 0;
      this.lineStart = 0;
      this.lineIndent = 0;
      this.firstTabInLine = -1;
      this.documents = [];
    }
    function generateError2(state, message) {
      var mark = {
        name: state.filename,
        buffer: state.input.slice(0, -1),
        // omit trailing \0
        position: state.position,
        line: state.line,
        column: state.position - state.lineStart
      };
      mark.snippet = makeSnippet2(mark);
      return new YAMLException2(message, mark);
    }
    function throwError2(state, message) {
      throw generateError2(state, message);
    }
    function throwWarning2(state, message) {
      if (state.onWarning) {
        state.onWarning.call(null, generateError2(state, message));
      }
    }
    var directiveHandlers2 = {
      YAML: function handleYamlDirective2(state, name, args) {
        var match2, major, minor;
        if (state.version !== null) {
          throwError2(state, "duplication of %YAML directive");
        }
        if (args.length !== 1) {
          throwError2(state, "YAML directive accepts exactly one argument");
        }
        match2 = /^([0-9]+)\.([0-9]+)$/.exec(args[0]);
        if (match2 === null) {
          throwError2(state, "ill-formed argument of the YAML directive");
        }
        major = parseInt(match2[1], 10);
        minor = parseInt(match2[2], 10);
        if (major !== 1) {
          throwError2(state, "unacceptable YAML version of the document");
        }
        state.version = args[0];
        state.checkLineBreaks = minor < 2;
        if (minor !== 1 && minor !== 2) {
          throwWarning2(state, "unsupported YAML version of the document");
        }
      },
      TAG: function handleTagDirective2(state, name, args) {
        var handle, prefix;
        if (args.length !== 2) {
          throwError2(state, "TAG directive accepts exactly two arguments");
        }
        handle = args[0];
        prefix = args[1];
        if (!PATTERN_TAG_HANDLE2.test(handle)) {
          throwError2(state, "ill-formed tag handle (first argument) of the TAG directive");
        }
        if (_hasOwnProperty2.call(state.tagMap, handle)) {
          throwError2(state, 'there is a previously declared suffix for "' + handle + '" tag handle');
        }
        if (!PATTERN_TAG_URI2.test(prefix)) {
          throwError2(state, "ill-formed tag prefix (second argument) of the TAG directive");
        }
        try {
          prefix = decodeURIComponent(prefix);
        } catch (err) {
          throwError2(state, "tag prefix is malformed: " + prefix);
        }
        state.tagMap[handle] = prefix;
      }
    };
    function captureSegment2(state, start, end, checkJson) {
      var _position, _length, _character, _result;
      if (start < end) {
        _result = state.input.slice(start, end);
        if (checkJson) {
          for (_position = 0, _length = _result.length; _position < _length; _position += 1) {
            _character = _result.charCodeAt(_position);
            if (!(_character === 9 || 32 <= _character && _character <= 1114111)) {
              throwError2(state, "expected valid JSON character");
            }
          }
        } else if (PATTERN_NON_PRINTABLE2.test(_result)) {
          throwError2(state, "the stream contains non-printable characters");
        }
        state.result += _result;
      }
    }
    function mergeMappings2(state, destination, source, overridableKeys) {
      var sourceKeys, key, index, quantity;
      if (!common2.isObject(source)) {
        throwError2(state, "cannot merge mappings; the provided source object is unacceptable");
      }
      sourceKeys = Object.keys(source);
      for (index = 0, quantity = sourceKeys.length; index < quantity; index += 1) {
        key = sourceKeys[index];
        if (!_hasOwnProperty2.call(destination, key)) {
          destination[key] = source[key];
          overridableKeys[key] = true;
        }
      }
    }
    function storeMappingPair2(state, _result, overridableKeys, keyTag, keyNode, valueNode, startLine, startLineStart, startPos) {
      var index, quantity;
      if (Array.isArray(keyNode)) {
        keyNode = Array.prototype.slice.call(keyNode);
        for (index = 0, quantity = keyNode.length; index < quantity; index += 1) {
          if (Array.isArray(keyNode[index])) {
            throwError2(state, "nested arrays are not supported inside keys");
          }
          if (typeof keyNode === "object" && _class2(keyNode[index]) === "[object Object]") {
            keyNode[index] = "[object Object]";
          }
        }
      }
      if (typeof keyNode === "object" && _class2(keyNode) === "[object Object]") {
        keyNode = "[object Object]";
      }
      keyNode = String(keyNode);
      if (_result === null) {
        _result = {};
      }
      if (keyTag === "tag:yaml.org,2002:merge") {
        if (Array.isArray(valueNode)) {
          for (index = 0, quantity = valueNode.length; index < quantity; index += 1) {
            mergeMappings2(state, _result, valueNode[index], overridableKeys);
          }
        } else {
          mergeMappings2(state, _result, valueNode, overridableKeys);
        }
      } else {
        if (!state.json && !_hasOwnProperty2.call(overridableKeys, keyNode) && _hasOwnProperty2.call(_result, keyNode)) {
          state.line = startLine || state.line;
          state.lineStart = startLineStart || state.lineStart;
          state.position = startPos || state.position;
          throwError2(state, "duplicated mapping key");
        }
        if (keyNode === "__proto__") {
          Object.defineProperty(_result, keyNode, {
            configurable: true,
            enumerable: true,
            writable: true,
            value: valueNode
          });
        } else {
          _result[keyNode] = valueNode;
        }
        delete overridableKeys[keyNode];
      }
      return _result;
    }
    function readLineBreak2(state) {
      var ch;
      ch = state.input.charCodeAt(state.position);
      if (ch === 10) {
        state.position++;
      } else if (ch === 13) {
        state.position++;
        if (state.input.charCodeAt(state.position) === 10) {
          state.position++;
        }
      } else {
        throwError2(state, "a line break is expected");
      }
      state.line += 1;
      state.lineStart = state.position;
      state.firstTabInLine = -1;
    }
    function skipSeparationSpace2(state, allowComments, checkIndent) {
      var lineBreaks = 0, ch = state.input.charCodeAt(state.position);
      while (ch !== 0) {
        while (is_WHITE_SPACE2(ch)) {
          if (ch === 9 && state.firstTabInLine === -1) {
            state.firstTabInLine = state.position;
          }
          ch = state.input.charCodeAt(++state.position);
        }
        if (allowComments && ch === 35) {
          do {
            ch = state.input.charCodeAt(++state.position);
          } while (ch !== 10 && ch !== 13 && ch !== 0);
        }
        if (is_EOL2(ch)) {
          readLineBreak2(state);
          ch = state.input.charCodeAt(state.position);
          lineBreaks++;
          state.lineIndent = 0;
          while (ch === 32) {
            state.lineIndent++;
            ch = state.input.charCodeAt(++state.position);
          }
        } else {
          break;
        }
      }
      if (checkIndent !== -1 && lineBreaks !== 0 && state.lineIndent < checkIndent) {
        throwWarning2(state, "deficient indentation");
      }
      return lineBreaks;
    }
    function testDocumentSeparator2(state) {
      var _position = state.position, ch;
      ch = state.input.charCodeAt(_position);
      if ((ch === 45 || ch === 46) && ch === state.input.charCodeAt(_position + 1) && ch === state.input.charCodeAt(_position + 2)) {
        _position += 3;
        ch = state.input.charCodeAt(_position);
        if (ch === 0 || is_WS_OR_EOL2(ch)) {
          return true;
        }
      }
      return false;
    }
    function writeFoldedLines2(state, count) {
      if (count === 1) {
        state.result += " ";
      } else if (count > 1) {
        state.result += common2.repeat("\n", count - 1);
      }
    }
    function readPlainScalar2(state, nodeIndent, withinFlowCollection) {
      var preceding, following, captureStart, captureEnd, hasPendingContent, _line, _lineStart, _lineIndent, _kind = state.kind, _result = state.result, ch;
      ch = state.input.charCodeAt(state.position);
      if (is_WS_OR_EOL2(ch) || is_FLOW_INDICATOR2(ch) || ch === 35 || ch === 38 || ch === 42 || ch === 33 || ch === 124 || ch === 62 || ch === 39 || ch === 34 || ch === 37 || ch === 64 || ch === 96) {
        return false;
      }
      if (ch === 63 || ch === 45) {
        following = state.input.charCodeAt(state.position + 1);
        if (is_WS_OR_EOL2(following) || withinFlowCollection && is_FLOW_INDICATOR2(following)) {
          return false;
        }
      }
      state.kind = "scalar";
      state.result = "";
      captureStart = captureEnd = state.position;
      hasPendingContent = false;
      while (ch !== 0) {
        if (ch === 58) {
          following = state.input.charCodeAt(state.position + 1);
          if (is_WS_OR_EOL2(following) || withinFlowCollection && is_FLOW_INDICATOR2(following)) {
            break;
          }
        } else if (ch === 35) {
          preceding = state.input.charCodeAt(state.position - 1);
          if (is_WS_OR_EOL2(preceding)) {
            break;
          }
        } else if (state.position === state.lineStart && testDocumentSeparator2(state) || withinFlowCollection && is_FLOW_INDICATOR2(ch)) {
          break;
        } else if (is_EOL2(ch)) {
          _line = state.line;
          _lineStart = state.lineStart;
          _lineIndent = state.lineIndent;
          skipSeparationSpace2(state, false, -1);
          if (state.lineIndent >= nodeIndent) {
            hasPendingContent = true;
            ch = state.input.charCodeAt(state.position);
            continue;
          } else {
            state.position = captureEnd;
            state.line = _line;
            state.lineStart = _lineStart;
            state.lineIndent = _lineIndent;
            break;
          }
        }
        if (hasPendingContent) {
          captureSegment2(state, captureStart, captureEnd, false);
          writeFoldedLines2(state, state.line - _line);
          captureStart = captureEnd = state.position;
          hasPendingContent = false;
        }
        if (!is_WHITE_SPACE2(ch)) {
          captureEnd = state.position + 1;
        }
        ch = state.input.charCodeAt(++state.position);
      }
      captureSegment2(state, captureStart, captureEnd, false);
      if (state.result) {
        return true;
      }
      state.kind = _kind;
      state.result = _result;
      return false;
    }
    function readSingleQuotedScalar2(state, nodeIndent) {
      var ch, captureStart, captureEnd;
      ch = state.input.charCodeAt(state.position);
      if (ch !== 39) {
        return false;
      }
      state.kind = "scalar";
      state.result = "";
      state.position++;
      captureStart = captureEnd = state.position;
      while ((ch = state.input.charCodeAt(state.position)) !== 0) {
        if (ch === 39) {
          captureSegment2(state, captureStart, state.position, true);
          ch = state.input.charCodeAt(++state.position);
          if (ch === 39) {
            captureStart = state.position;
            state.position++;
            captureEnd = state.position;
          } else {
            return true;
          }
        } else if (is_EOL2(ch)) {
          captureSegment2(state, captureStart, captureEnd, true);
          writeFoldedLines2(state, skipSeparationSpace2(state, false, nodeIndent));
          captureStart = captureEnd = state.position;
        } else if (state.position === state.lineStart && testDocumentSeparator2(state)) {
          throwError2(state, "unexpected end of the document within a single quoted scalar");
        } else {
          state.position++;
          captureEnd = state.position;
        }
      }
      throwError2(state, "unexpected end of the stream within a single quoted scalar");
    }
    function readDoubleQuotedScalar2(state, nodeIndent) {
      var captureStart, captureEnd, hexLength, hexResult, tmp, ch;
      ch = state.input.charCodeAt(state.position);
      if (ch !== 34) {
        return false;
      }
      state.kind = "scalar";
      state.result = "";
      state.position++;
      captureStart = captureEnd = state.position;
      while ((ch = state.input.charCodeAt(state.position)) !== 0) {
        if (ch === 34) {
          captureSegment2(state, captureStart, state.position, true);
          state.position++;
          return true;
        } else if (ch === 92) {
          captureSegment2(state, captureStart, state.position, true);
          ch = state.input.charCodeAt(++state.position);
          if (is_EOL2(ch)) {
            skipSeparationSpace2(state, false, nodeIndent);
          } else if (ch < 256 && simpleEscapeCheck2[ch]) {
            state.result += simpleEscapeMap2[ch];
            state.position++;
          } else if ((tmp = escapedHexLen2(ch)) > 0) {
            hexLength = tmp;
            hexResult = 0;
            for (; hexLength > 0; hexLength--) {
              ch = state.input.charCodeAt(++state.position);
              if ((tmp = fromHexCode2(ch)) >= 0) {
                hexResult = (hexResult << 4) + tmp;
              } else {
                throwError2(state, "expected hexadecimal character");
              }
            }
            state.result += charFromCodepoint2(hexResult);
            state.position++;
          } else {
            throwError2(state, "unknown escape sequence");
          }
          captureStart = captureEnd = state.position;
        } else if (is_EOL2(ch)) {
          captureSegment2(state, captureStart, captureEnd, true);
          writeFoldedLines2(state, skipSeparationSpace2(state, false, nodeIndent));
          captureStart = captureEnd = state.position;
        } else if (state.position === state.lineStart && testDocumentSeparator2(state)) {
          throwError2(state, "unexpected end of the document within a double quoted scalar");
        } else {
          state.position++;
          captureEnd = state.position;
        }
      }
      throwError2(state, "unexpected end of the stream within a double quoted scalar");
    }
    function readFlowCollection2(state, nodeIndent) {
      var readNext = true, _line, _lineStart, _pos, _tag = state.tag, _result, _anchor = state.anchor, following, terminator, isPair, isExplicitPair, isMapping, overridableKeys = /* @__PURE__ */ Object.create(null), keyNode, keyTag, valueNode, ch;
      ch = state.input.charCodeAt(state.position);
      if (ch === 91) {
        terminator = 93;
        isMapping = false;
        _result = [];
      } else if (ch === 123) {
        terminator = 125;
        isMapping = true;
        _result = {};
      } else {
        return false;
      }
      if (state.anchor !== null) {
        state.anchorMap[state.anchor] = _result;
      }
      ch = state.input.charCodeAt(++state.position);
      while (ch !== 0) {
        skipSeparationSpace2(state, true, nodeIndent);
        ch = state.input.charCodeAt(state.position);
        if (ch === terminator) {
          state.position++;
          state.tag = _tag;
          state.anchor = _anchor;
          state.kind = isMapping ? "mapping" : "sequence";
          state.result = _result;
          return true;
        } else if (!readNext) {
          throwError2(state, "missed comma between flow collection entries");
        } else if (ch === 44) {
          throwError2(state, "expected the node content, but found ','");
        }
        keyTag = keyNode = valueNode = null;
        isPair = isExplicitPair = false;
        if (ch === 63) {
          following = state.input.charCodeAt(state.position + 1);
          if (is_WS_OR_EOL2(following)) {
            isPair = isExplicitPair = true;
            state.position++;
            skipSeparationSpace2(state, true, nodeIndent);
          }
        }
        _line = state.line;
        _lineStart = state.lineStart;
        _pos = state.position;
        composeNode2(state, nodeIndent, CONTEXT_FLOW_IN2, false, true);
        keyTag = state.tag;
        keyNode = state.result;
        skipSeparationSpace2(state, true, nodeIndent);
        ch = state.input.charCodeAt(state.position);
        if ((isExplicitPair || state.line === _line) && ch === 58) {
          isPair = true;
          ch = state.input.charCodeAt(++state.position);
          skipSeparationSpace2(state, true, nodeIndent);
          composeNode2(state, nodeIndent, CONTEXT_FLOW_IN2, false, true);
          valueNode = state.result;
        }
        if (isMapping) {
          storeMappingPair2(state, _result, overridableKeys, keyTag, keyNode, valueNode, _line, _lineStart, _pos);
        } else if (isPair) {
          _result.push(storeMappingPair2(state, null, overridableKeys, keyTag, keyNode, valueNode, _line, _lineStart, _pos));
        } else {
          _result.push(keyNode);
        }
        skipSeparationSpace2(state, true, nodeIndent);
        ch = state.input.charCodeAt(state.position);
        if (ch === 44) {
          readNext = true;
          ch = state.input.charCodeAt(++state.position);
        } else {
          readNext = false;
        }
      }
      throwError2(state, "unexpected end of the stream within a flow collection");
    }
    function readBlockScalar2(state, nodeIndent) {
      var captureStart, folding, chomping = CHOMPING_CLIP2, didReadContent = false, detectedIndent = false, textIndent = nodeIndent, emptyLines = 0, atMoreIndented = false, tmp, ch;
      ch = state.input.charCodeAt(state.position);
      if (ch === 124) {
        folding = false;
      } else if (ch === 62) {
        folding = true;
      } else {
        return false;
      }
      state.kind = "scalar";
      state.result = "";
      while (ch !== 0) {
        ch = state.input.charCodeAt(++state.position);
        if (ch === 43 || ch === 45) {
          if (CHOMPING_CLIP2 === chomping) {
            chomping = ch === 43 ? CHOMPING_KEEP2 : CHOMPING_STRIP2;
          } else {
            throwError2(state, "repeat of a chomping mode identifier");
          }
        } else if ((tmp = fromDecimalCode2(ch)) >= 0) {
          if (tmp === 0) {
            throwError2(state, "bad explicit indentation width of a block scalar; it cannot be less than one");
          } else if (!detectedIndent) {
            textIndent = nodeIndent + tmp - 1;
            detectedIndent = true;
          } else {
            throwError2(state, "repeat of an indentation width identifier");
          }
        } else {
          break;
        }
      }
      if (is_WHITE_SPACE2(ch)) {
        do {
          ch = state.input.charCodeAt(++state.position);
        } while (is_WHITE_SPACE2(ch));
        if (ch === 35) {
          do {
            ch = state.input.charCodeAt(++state.position);
          } while (!is_EOL2(ch) && ch !== 0);
        }
      }
      while (ch !== 0) {
        readLineBreak2(state);
        state.lineIndent = 0;
        ch = state.input.charCodeAt(state.position);
        while ((!detectedIndent || state.lineIndent < textIndent) && ch === 32) {
          state.lineIndent++;
          ch = state.input.charCodeAt(++state.position);
        }
        if (!detectedIndent && state.lineIndent > textIndent) {
          textIndent = state.lineIndent;
        }
        if (is_EOL2(ch)) {
          emptyLines++;
          continue;
        }
        if (state.lineIndent < textIndent) {
          if (chomping === CHOMPING_KEEP2) {
            state.result += common2.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
          } else if (chomping === CHOMPING_CLIP2) {
            if (didReadContent) {
              state.result += "\n";
            }
          }
          break;
        }
        if (folding) {
          if (is_WHITE_SPACE2(ch)) {
            atMoreIndented = true;
            state.result += common2.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
          } else if (atMoreIndented) {
            atMoreIndented = false;
            state.result += common2.repeat("\n", emptyLines + 1);
          } else if (emptyLines === 0) {
            if (didReadContent) {
              state.result += " ";
            }
          } else {
            state.result += common2.repeat("\n", emptyLines);
          }
        } else {
          state.result += common2.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
        }
        didReadContent = true;
        detectedIndent = true;
        emptyLines = 0;
        captureStart = state.position;
        while (!is_EOL2(ch) && ch !== 0) {
          ch = state.input.charCodeAt(++state.position);
        }
        captureSegment2(state, captureStart, state.position, false);
      }
      return true;
    }
    function readBlockSequence2(state, nodeIndent) {
      var _line, _tag = state.tag, _anchor = state.anchor, _result = [], following, detected = false, ch;
      if (state.firstTabInLine !== -1) return false;
      if (state.anchor !== null) {
        state.anchorMap[state.anchor] = _result;
      }
      ch = state.input.charCodeAt(state.position);
      while (ch !== 0) {
        if (state.firstTabInLine !== -1) {
          state.position = state.firstTabInLine;
          throwError2(state, "tab characters must not be used in indentation");
        }
        if (ch !== 45) {
          break;
        }
        following = state.input.charCodeAt(state.position + 1);
        if (!is_WS_OR_EOL2(following)) {
          break;
        }
        detected = true;
        state.position++;
        if (skipSeparationSpace2(state, true, -1)) {
          if (state.lineIndent <= nodeIndent) {
            _result.push(null);
            ch = state.input.charCodeAt(state.position);
            continue;
          }
        }
        _line = state.line;
        composeNode2(state, nodeIndent, CONTEXT_BLOCK_IN2, false, true);
        _result.push(state.result);
        skipSeparationSpace2(state, true, -1);
        ch = state.input.charCodeAt(state.position);
        if ((state.line === _line || state.lineIndent > nodeIndent) && ch !== 0) {
          throwError2(state, "bad indentation of a sequence entry");
        } else if (state.lineIndent < nodeIndent) {
          break;
        }
      }
      if (detected) {
        state.tag = _tag;
        state.anchor = _anchor;
        state.kind = "sequence";
        state.result = _result;
        return true;
      }
      return false;
    }
    function readBlockMapping2(state, nodeIndent, flowIndent) {
      var following, allowCompact, _line, _keyLine, _keyLineStart, _keyPos, _tag = state.tag, _anchor = state.anchor, _result = {}, overridableKeys = /* @__PURE__ */ Object.create(null), keyTag = null, keyNode = null, valueNode = null, atExplicitKey = false, detected = false, ch;
      if (state.firstTabInLine !== -1) return false;
      if (state.anchor !== null) {
        state.anchorMap[state.anchor] = _result;
      }
      ch = state.input.charCodeAt(state.position);
      while (ch !== 0) {
        if (!atExplicitKey && state.firstTabInLine !== -1) {
          state.position = state.firstTabInLine;
          throwError2(state, "tab characters must not be used in indentation");
        }
        following = state.input.charCodeAt(state.position + 1);
        _line = state.line;
        if ((ch === 63 || ch === 58) && is_WS_OR_EOL2(following)) {
          if (ch === 63) {
            if (atExplicitKey) {
              storeMappingPair2(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
              keyTag = keyNode = valueNode = null;
            }
            detected = true;
            atExplicitKey = true;
            allowCompact = true;
          } else if (atExplicitKey) {
            atExplicitKey = false;
            allowCompact = true;
          } else {
            throwError2(state, "incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line");
          }
          state.position += 1;
          ch = following;
        } else {
          _keyLine = state.line;
          _keyLineStart = state.lineStart;
          _keyPos = state.position;
          if (!composeNode2(state, flowIndent, CONTEXT_FLOW_OUT2, false, true)) {
            break;
          }
          if (state.line === _line) {
            ch = state.input.charCodeAt(state.position);
            while (is_WHITE_SPACE2(ch)) {
              ch = state.input.charCodeAt(++state.position);
            }
            if (ch === 58) {
              ch = state.input.charCodeAt(++state.position);
              if (!is_WS_OR_EOL2(ch)) {
                throwError2(state, "a whitespace character is expected after the key-value separator within a block mapping");
              }
              if (atExplicitKey) {
                storeMappingPair2(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
                keyTag = keyNode = valueNode = null;
              }
              detected = true;
              atExplicitKey = false;
              allowCompact = false;
              keyTag = state.tag;
              keyNode = state.result;
            } else if (detected) {
              throwError2(state, "can not read an implicit mapping pair; a colon is missed");
            } else {
              state.tag = _tag;
              state.anchor = _anchor;
              return true;
            }
          } else if (detected) {
            throwError2(state, "can not read a block mapping entry; a multiline key may not be an implicit key");
          } else {
            state.tag = _tag;
            state.anchor = _anchor;
            return true;
          }
        }
        if (state.line === _line || state.lineIndent > nodeIndent) {
          if (atExplicitKey) {
            _keyLine = state.line;
            _keyLineStart = state.lineStart;
            _keyPos = state.position;
          }
          if (composeNode2(state, nodeIndent, CONTEXT_BLOCK_OUT2, true, allowCompact)) {
            if (atExplicitKey) {
              keyNode = state.result;
            } else {
              valueNode = state.result;
            }
          }
          if (!atExplicitKey) {
            storeMappingPair2(state, _result, overridableKeys, keyTag, keyNode, valueNode, _keyLine, _keyLineStart, _keyPos);
            keyTag = keyNode = valueNode = null;
          }
          skipSeparationSpace2(state, true, -1);
          ch = state.input.charCodeAt(state.position);
        }
        if ((state.line === _line || state.lineIndent > nodeIndent) && ch !== 0) {
          throwError2(state, "bad indentation of a mapping entry");
        } else if (state.lineIndent < nodeIndent) {
          break;
        }
      }
      if (atExplicitKey) {
        storeMappingPair2(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
      }
      if (detected) {
        state.tag = _tag;
        state.anchor = _anchor;
        state.kind = "mapping";
        state.result = _result;
      }
      return detected;
    }
    function readTagProperty2(state) {
      var _position, isVerbatim = false, isNamed = false, tagHandle, tagName, ch;
      ch = state.input.charCodeAt(state.position);
      if (ch !== 33) return false;
      if (state.tag !== null) {
        throwError2(state, "duplication of a tag property");
      }
      ch = state.input.charCodeAt(++state.position);
      if (ch === 60) {
        isVerbatim = true;
        ch = state.input.charCodeAt(++state.position);
      } else if (ch === 33) {
        isNamed = true;
        tagHandle = "!!";
        ch = state.input.charCodeAt(++state.position);
      } else {
        tagHandle = "!";
      }
      _position = state.position;
      if (isVerbatim) {
        do {
          ch = state.input.charCodeAt(++state.position);
        } while (ch !== 0 && ch !== 62);
        if (state.position < state.length) {
          tagName = state.input.slice(_position, state.position);
          ch = state.input.charCodeAt(++state.position);
        } else {
          throwError2(state, "unexpected end of the stream within a verbatim tag");
        }
      } else {
        while (ch !== 0 && !is_WS_OR_EOL2(ch)) {
          if (ch === 33) {
            if (!isNamed) {
              tagHandle = state.input.slice(_position - 1, state.position + 1);
              if (!PATTERN_TAG_HANDLE2.test(tagHandle)) {
                throwError2(state, "named tag handle cannot contain such characters");
              }
              isNamed = true;
              _position = state.position + 1;
            } else {
              throwError2(state, "tag suffix cannot contain exclamation marks");
            }
          }
          ch = state.input.charCodeAt(++state.position);
        }
        tagName = state.input.slice(_position, state.position);
        if (PATTERN_FLOW_INDICATORS2.test(tagName)) {
          throwError2(state, "tag suffix cannot contain flow indicator characters");
        }
      }
      if (tagName && !PATTERN_TAG_URI2.test(tagName)) {
        throwError2(state, "tag name cannot contain such characters: " + tagName);
      }
      try {
        tagName = decodeURIComponent(tagName);
      } catch (err) {
        throwError2(state, "tag name is malformed: " + tagName);
      }
      if (isVerbatim) {
        state.tag = tagName;
      } else if (_hasOwnProperty2.call(state.tagMap, tagHandle)) {
        state.tag = state.tagMap[tagHandle] + tagName;
      } else if (tagHandle === "!") {
        state.tag = "!" + tagName;
      } else if (tagHandle === "!!") {
        state.tag = "tag:yaml.org,2002:" + tagName;
      } else {
        throwError2(state, 'undeclared tag handle "' + tagHandle + '"');
      }
      return true;
    }
    function readAnchorProperty2(state) {
      var _position, ch;
      ch = state.input.charCodeAt(state.position);
      if (ch !== 38) return false;
      if (state.anchor !== null) {
        throwError2(state, "duplication of an anchor property");
      }
      ch = state.input.charCodeAt(++state.position);
      _position = state.position;
      while (ch !== 0 && !is_WS_OR_EOL2(ch) && !is_FLOW_INDICATOR2(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }
      if (state.position === _position) {
        throwError2(state, "name of an anchor node must contain at least one character");
      }
      state.anchor = state.input.slice(_position, state.position);
      return true;
    }
    function readAlias2(state) {
      var _position, alias, ch;
      ch = state.input.charCodeAt(state.position);
      if (ch !== 42) return false;
      ch = state.input.charCodeAt(++state.position);
      _position = state.position;
      while (ch !== 0 && !is_WS_OR_EOL2(ch) && !is_FLOW_INDICATOR2(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }
      if (state.position === _position) {
        throwError2(state, "name of an alias node must contain at least one character");
      }
      alias = state.input.slice(_position, state.position);
      if (!_hasOwnProperty2.call(state.anchorMap, alias)) {
        throwError2(state, 'unidentified alias "' + alias + '"');
      }
      state.result = state.anchorMap[alias];
      skipSeparationSpace2(state, true, -1);
      return true;
    }
    function composeNode2(state, parentIndent, nodeContext, allowToSeek, allowCompact) {
      var allowBlockStyles, allowBlockScalars, allowBlockCollections, indentStatus = 1, atNewLine = false, hasContent = false, typeIndex, typeQuantity, typeList, type2, flowIndent, blockIndent;
      if (state.listener !== null) {
        state.listener("open", state);
      }
      state.tag = null;
      state.anchor = null;
      state.kind = null;
      state.result = null;
      allowBlockStyles = allowBlockScalars = allowBlockCollections = CONTEXT_BLOCK_OUT2 === nodeContext || CONTEXT_BLOCK_IN2 === nodeContext;
      if (allowToSeek) {
        if (skipSeparationSpace2(state, true, -1)) {
          atNewLine = true;
          if (state.lineIndent > parentIndent) {
            indentStatus = 1;
          } else if (state.lineIndent === parentIndent) {
            indentStatus = 0;
          } else if (state.lineIndent < parentIndent) {
            indentStatus = -1;
          }
        }
      }
      if (indentStatus === 1) {
        while (readTagProperty2(state) || readAnchorProperty2(state)) {
          if (skipSeparationSpace2(state, true, -1)) {
            atNewLine = true;
            allowBlockCollections = allowBlockStyles;
            if (state.lineIndent > parentIndent) {
              indentStatus = 1;
            } else if (state.lineIndent === parentIndent) {
              indentStatus = 0;
            } else if (state.lineIndent < parentIndent) {
              indentStatus = -1;
            }
          } else {
            allowBlockCollections = false;
          }
        }
      }
      if (allowBlockCollections) {
        allowBlockCollections = atNewLine || allowCompact;
      }
      if (indentStatus === 1 || CONTEXT_BLOCK_OUT2 === nodeContext) {
        if (CONTEXT_FLOW_IN2 === nodeContext || CONTEXT_FLOW_OUT2 === nodeContext) {
          flowIndent = parentIndent;
        } else {
          flowIndent = parentIndent + 1;
        }
        blockIndent = state.position - state.lineStart;
        if (indentStatus === 1) {
          if (allowBlockCollections && (readBlockSequence2(state, blockIndent) || readBlockMapping2(state, blockIndent, flowIndent)) || readFlowCollection2(state, flowIndent)) {
            hasContent = true;
          } else {
            if (allowBlockScalars && readBlockScalar2(state, flowIndent) || readSingleQuotedScalar2(state, flowIndent) || readDoubleQuotedScalar2(state, flowIndent)) {
              hasContent = true;
            } else if (readAlias2(state)) {
              hasContent = true;
              if (state.tag !== null || state.anchor !== null) {
                throwError2(state, "alias node should not have any properties");
              }
            } else if (readPlainScalar2(state, flowIndent, CONTEXT_FLOW_IN2 === nodeContext)) {
              hasContent = true;
              if (state.tag === null) {
                state.tag = "?";
              }
            }
            if (state.anchor !== null) {
              state.anchorMap[state.anchor] = state.result;
            }
          }
        } else if (indentStatus === 0) {
          hasContent = allowBlockCollections && readBlockSequence2(state, blockIndent);
        }
      }
      if (state.tag === null) {
        if (state.anchor !== null) {
          state.anchorMap[state.anchor] = state.result;
        }
      } else if (state.tag === "?") {
        if (state.result !== null && state.kind !== "scalar") {
          throwError2(state, 'unacceptable node kind for !<?> tag; it should be "scalar", not "' + state.kind + '"');
        }
        for (typeIndex = 0, typeQuantity = state.implicitTypes.length; typeIndex < typeQuantity; typeIndex += 1) {
          type2 = state.implicitTypes[typeIndex];
          if (type2.resolve(state.result)) {
            state.result = type2.construct(state.result);
            state.tag = type2.tag;
            if (state.anchor !== null) {
              state.anchorMap[state.anchor] = state.result;
            }
            break;
          }
        }
      } else if (state.tag !== "!") {
        if (_hasOwnProperty2.call(state.typeMap[state.kind || "fallback"], state.tag)) {
          type2 = state.typeMap[state.kind || "fallback"][state.tag];
        } else {
          type2 = null;
          typeList = state.typeMap.multi[state.kind || "fallback"];
          for (typeIndex = 0, typeQuantity = typeList.length; typeIndex < typeQuantity; typeIndex += 1) {
            if (state.tag.slice(0, typeList[typeIndex].tag.length) === typeList[typeIndex].tag) {
              type2 = typeList[typeIndex];
              break;
            }
          }
        }
        if (!type2) {
          throwError2(state, "unknown tag !<" + state.tag + ">");
        }
        if (state.result !== null && type2.kind !== state.kind) {
          throwError2(state, "unacceptable node kind for !<" + state.tag + '> tag; it should be "' + type2.kind + '", not "' + state.kind + '"');
        }
        if (!type2.resolve(state.result, state.tag)) {
          throwError2(state, "cannot resolve a node with !<" + state.tag + "> explicit tag");
        } else {
          state.result = type2.construct(state.result, state.tag);
          if (state.anchor !== null) {
            state.anchorMap[state.anchor] = state.result;
          }
        }
      }
      if (state.listener !== null) {
        state.listener("close", state);
      }
      return state.tag !== null || state.anchor !== null || hasContent;
    }
    function readDocument2(state) {
      var documentStart = state.position, _position, directiveName, directiveArgs, hasDirectives = false, ch;
      state.version = null;
      state.checkLineBreaks = state.legacy;
      state.tagMap = /* @__PURE__ */ Object.create(null);
      state.anchorMap = /* @__PURE__ */ Object.create(null);
      while ((ch = state.input.charCodeAt(state.position)) !== 0) {
        skipSeparationSpace2(state, true, -1);
        ch = state.input.charCodeAt(state.position);
        if (state.lineIndent > 0 || ch !== 37) {
          break;
        }
        hasDirectives = true;
        ch = state.input.charCodeAt(++state.position);
        _position = state.position;
        while (ch !== 0 && !is_WS_OR_EOL2(ch)) {
          ch = state.input.charCodeAt(++state.position);
        }
        directiveName = state.input.slice(_position, state.position);
        directiveArgs = [];
        if (directiveName.length < 1) {
          throwError2(state, "directive name must not be less than one character in length");
        }
        while (ch !== 0) {
          while (is_WHITE_SPACE2(ch)) {
            ch = state.input.charCodeAt(++state.position);
          }
          if (ch === 35) {
            do {
              ch = state.input.charCodeAt(++state.position);
            } while (ch !== 0 && !is_EOL2(ch));
            break;
          }
          if (is_EOL2(ch)) break;
          _position = state.position;
          while (ch !== 0 && !is_WS_OR_EOL2(ch)) {
            ch = state.input.charCodeAt(++state.position);
          }
          directiveArgs.push(state.input.slice(_position, state.position));
        }
        if (ch !== 0) readLineBreak2(state);
        if (_hasOwnProperty2.call(directiveHandlers2, directiveName)) {
          directiveHandlers2[directiveName](state, directiveName, directiveArgs);
        } else {
          throwWarning2(state, 'unknown document directive "' + directiveName + '"');
        }
      }
      skipSeparationSpace2(state, true, -1);
      if (state.lineIndent === 0 && state.input.charCodeAt(state.position) === 45 && state.input.charCodeAt(state.position + 1) === 45 && state.input.charCodeAt(state.position + 2) === 45) {
        state.position += 3;
        skipSeparationSpace2(state, true, -1);
      } else if (hasDirectives) {
        throwError2(state, "directives end mark is expected");
      }
      composeNode2(state, state.lineIndent - 1, CONTEXT_BLOCK_OUT2, false, true);
      skipSeparationSpace2(state, true, -1);
      if (state.checkLineBreaks && PATTERN_NON_ASCII_LINE_BREAKS2.test(state.input.slice(documentStart, state.position))) {
        throwWarning2(state, "non-ASCII line breaks are interpreted as content");
      }
      state.documents.push(state.result);
      if (state.position === state.lineStart && testDocumentSeparator2(state)) {
        if (state.input.charCodeAt(state.position) === 46) {
          state.position += 3;
          skipSeparationSpace2(state, true, -1);
        }
        return;
      }
      if (state.position < state.length - 1) {
        throwError2(state, "end of the stream or a document separator is expected");
      } else {
        return;
      }
    }
    function loadDocuments2(input, options) {
      input = String(input);
      options = options || {};
      if (input.length !== 0) {
        if (input.charCodeAt(input.length - 1) !== 10 && input.charCodeAt(input.length - 1) !== 13) {
          input += "\n";
        }
        if (input.charCodeAt(0) === 65279) {
          input = input.slice(1);
        }
      }
      var state = new State2(input, options);
      var nullpos = input.indexOf("\0");
      if (nullpos !== -1) {
        state.position = nullpos;
        throwError2(state, "null byte is not allowed in input");
      }
      state.input += "\0";
      while (state.input.charCodeAt(state.position) === 32) {
        state.lineIndent += 1;
        state.position += 1;
      }
      while (state.position < state.length - 1) {
        readDocument2(state);
      }
      return state.documents;
    }
    function loadAll2(input, iterator, options) {
      if (iterator !== null && typeof iterator === "object" && typeof options === "undefined") {
        options = iterator;
        iterator = null;
      }
      var documents = loadDocuments2(input, options);
      if (typeof iterator !== "function") {
        return documents;
      }
      for (var index = 0, length = documents.length; index < length; index += 1) {
        iterator(documents[index]);
      }
    }
    function load2(input, options) {
      var documents = loadDocuments2(input, options);
      if (documents.length === 0) {
        return void 0;
      } else if (documents.length === 1) {
        return documents[0];
      }
      throw new YAMLException2("expected a single document in the stream, but found more");
    }
    module2.exports.loadAll = loadAll2;
    module2.exports.load = load2;
  }
});

// node_modules/js-yaml/lib/dumper.js
var require_dumper = __commonJS({
  "node_modules/js-yaml/lib/dumper.js"(exports2, module2) {
    "use strict";
    var common2 = require_common2();
    var YAMLException2 = require_exception();
    var DEFAULT_SCHEMA2 = require_default();
    var _toString2 = Object.prototype.toString;
    var _hasOwnProperty2 = Object.prototype.hasOwnProperty;
    var CHAR_BOM2 = 65279;
    var CHAR_TAB2 = 9;
    var CHAR_LINE_FEED2 = 10;
    var CHAR_CARRIAGE_RETURN2 = 13;
    var CHAR_SPACE2 = 32;
    var CHAR_EXCLAMATION2 = 33;
    var CHAR_DOUBLE_QUOTE2 = 34;
    var CHAR_SHARP2 = 35;
    var CHAR_PERCENT2 = 37;
    var CHAR_AMPERSAND2 = 38;
    var CHAR_SINGLE_QUOTE2 = 39;
    var CHAR_ASTERISK2 = 42;
    var CHAR_COMMA2 = 44;
    var CHAR_MINUS2 = 45;
    var CHAR_COLON2 = 58;
    var CHAR_EQUALS2 = 61;
    var CHAR_GREATER_THAN2 = 62;
    var CHAR_QUESTION2 = 63;
    var CHAR_COMMERCIAL_AT2 = 64;
    var CHAR_LEFT_SQUARE_BRACKET2 = 91;
    var CHAR_RIGHT_SQUARE_BRACKET2 = 93;
    var CHAR_GRAVE_ACCENT2 = 96;
    var CHAR_LEFT_CURLY_BRACKET2 = 123;
    var CHAR_VERTICAL_LINE2 = 124;
    var CHAR_RIGHT_CURLY_BRACKET2 = 125;
    var ESCAPE_SEQUENCES2 = {};
    ESCAPE_SEQUENCES2[0] = "\\0";
    ESCAPE_SEQUENCES2[7] = "\\a";
    ESCAPE_SEQUENCES2[8] = "\\b";
    ESCAPE_SEQUENCES2[9] = "\\t";
    ESCAPE_SEQUENCES2[10] = "\\n";
    ESCAPE_SEQUENCES2[11] = "\\v";
    ESCAPE_SEQUENCES2[12] = "\\f";
    ESCAPE_SEQUENCES2[13] = "\\r";
    ESCAPE_SEQUENCES2[27] = "\\e";
    ESCAPE_SEQUENCES2[34] = '\\"';
    ESCAPE_SEQUENCES2[92] = "\\\\";
    ESCAPE_SEQUENCES2[133] = "\\N";
    ESCAPE_SEQUENCES2[160] = "\\_";
    ESCAPE_SEQUENCES2[8232] = "\\L";
    ESCAPE_SEQUENCES2[8233] = "\\P";
    var DEPRECATED_BOOLEANS_SYNTAX2 = [
      "y",
      "Y",
      "yes",
      "Yes",
      "YES",
      "on",
      "On",
      "ON",
      "n",
      "N",
      "no",
      "No",
      "NO",
      "off",
      "Off",
      "OFF"
    ];
    var DEPRECATED_BASE60_SYNTAX2 = /^[-+]?[0-9_]+(?::[0-9_]+)+(?:\.[0-9_]*)?$/;
    function compileStyleMap2(schema2, map2) {
      var result, keys, index, length, tag, style, type2;
      if (map2 === null) return {};
      result = {};
      keys = Object.keys(map2);
      for (index = 0, length = keys.length; index < length; index += 1) {
        tag = keys[index];
        style = String(map2[tag]);
        if (tag.slice(0, 2) === "!!") {
          tag = "tag:yaml.org,2002:" + tag.slice(2);
        }
        type2 = schema2.compiledTypeMap["fallback"][tag];
        if (type2 && _hasOwnProperty2.call(type2.styleAliases, style)) {
          style = type2.styleAliases[style];
        }
        result[tag] = style;
      }
      return result;
    }
    function encodeHex2(character) {
      var string, handle, length;
      string = character.toString(16).toUpperCase();
      if (character <= 255) {
        handle = "x";
        length = 2;
      } else if (character <= 65535) {
        handle = "u";
        length = 4;
      } else if (character <= 4294967295) {
        handle = "U";
        length = 8;
      } else {
        throw new YAMLException2("code point within a string may not be greater than 0xFFFFFFFF");
      }
      return "\\" + handle + common2.repeat("0", length - string.length) + string;
    }
    var QUOTING_TYPE_SINGLE2 = 1;
    var QUOTING_TYPE_DOUBLE2 = 2;
    function State2(options) {
      this.schema = options["schema"] || DEFAULT_SCHEMA2;
      this.indent = Math.max(1, options["indent"] || 2);
      this.noArrayIndent = options["noArrayIndent"] || false;
      this.skipInvalid = options["skipInvalid"] || false;
      this.flowLevel = common2.isNothing(options["flowLevel"]) ? -1 : options["flowLevel"];
      this.styleMap = compileStyleMap2(this.schema, options["styles"] || null);
      this.sortKeys = options["sortKeys"] || false;
      this.lineWidth = options["lineWidth"] || 80;
      this.noRefs = options["noRefs"] || false;
      this.noCompatMode = options["noCompatMode"] || false;
      this.condenseFlow = options["condenseFlow"] || false;
      this.quotingType = options["quotingType"] === '"' ? QUOTING_TYPE_DOUBLE2 : QUOTING_TYPE_SINGLE2;
      this.forceQuotes = options["forceQuotes"] || false;
      this.replacer = typeof options["replacer"] === "function" ? options["replacer"] : null;
      this.implicitTypes = this.schema.compiledImplicit;
      this.explicitTypes = this.schema.compiledExplicit;
      this.tag = null;
      this.result = "";
      this.duplicates = [];
      this.usedDuplicates = null;
    }
    function indentString2(string, spaces) {
      var ind = common2.repeat(" ", spaces), position = 0, next = -1, result = "", line, length = string.length;
      while (position < length) {
        next = string.indexOf("\n", position);
        if (next === -1) {
          line = string.slice(position);
          position = length;
        } else {
          line = string.slice(position, next + 1);
          position = next + 1;
        }
        if (line.length && line !== "\n") result += ind;
        result += line;
      }
      return result;
    }
    function generateNextLine2(state, level) {
      return "\n" + common2.repeat(" ", state.indent * level);
    }
    function testImplicitResolving2(state, str2) {
      var index, length, type2;
      for (index = 0, length = state.implicitTypes.length; index < length; index += 1) {
        type2 = state.implicitTypes[index];
        if (type2.resolve(str2)) {
          return true;
        }
      }
      return false;
    }
    function isWhitespace2(c2) {
      return c2 === CHAR_SPACE2 || c2 === CHAR_TAB2;
    }
    function isPrintable2(c2) {
      return 32 <= c2 && c2 <= 126 || 161 <= c2 && c2 <= 55295 && c2 !== 8232 && c2 !== 8233 || 57344 <= c2 && c2 <= 65533 && c2 !== CHAR_BOM2 || 65536 <= c2 && c2 <= 1114111;
    }
    function isNsCharOrWhitespace2(c2) {
      return isPrintable2(c2) && c2 !== CHAR_BOM2 && c2 !== CHAR_CARRIAGE_RETURN2 && c2 !== CHAR_LINE_FEED2;
    }
    function isPlainSafe2(c2, prev, inblock) {
      var cIsNsCharOrWhitespace = isNsCharOrWhitespace2(c2);
      var cIsNsChar = cIsNsCharOrWhitespace && !isWhitespace2(c2);
      return (
        // ns-plain-safe
        (inblock ? (
          // c = flow-in
          cIsNsCharOrWhitespace
        ) : cIsNsCharOrWhitespace && c2 !== CHAR_COMMA2 && c2 !== CHAR_LEFT_SQUARE_BRACKET2 && c2 !== CHAR_RIGHT_SQUARE_BRACKET2 && c2 !== CHAR_LEFT_CURLY_BRACKET2 && c2 !== CHAR_RIGHT_CURLY_BRACKET2) && c2 !== CHAR_SHARP2 && !(prev === CHAR_COLON2 && !cIsNsChar) || isNsCharOrWhitespace2(prev) && !isWhitespace2(prev) && c2 === CHAR_SHARP2 || prev === CHAR_COLON2 && cIsNsChar
      );
    }
    function isPlainSafeFirst2(c2) {
      return isPrintable2(c2) && c2 !== CHAR_BOM2 && !isWhitespace2(c2) && c2 !== CHAR_MINUS2 && c2 !== CHAR_QUESTION2 && c2 !== CHAR_COLON2 && c2 !== CHAR_COMMA2 && c2 !== CHAR_LEFT_SQUARE_BRACKET2 && c2 !== CHAR_RIGHT_SQUARE_BRACKET2 && c2 !== CHAR_LEFT_CURLY_BRACKET2 && c2 !== CHAR_RIGHT_CURLY_BRACKET2 && c2 !== CHAR_SHARP2 && c2 !== CHAR_AMPERSAND2 && c2 !== CHAR_ASTERISK2 && c2 !== CHAR_EXCLAMATION2 && c2 !== CHAR_VERTICAL_LINE2 && c2 !== CHAR_EQUALS2 && c2 !== CHAR_GREATER_THAN2 && c2 !== CHAR_SINGLE_QUOTE2 && c2 !== CHAR_DOUBLE_QUOTE2 && c2 !== CHAR_PERCENT2 && c2 !== CHAR_COMMERCIAL_AT2 && c2 !== CHAR_GRAVE_ACCENT2;
    }
    function isPlainSafeLast2(c2) {
      return !isWhitespace2(c2) && c2 !== CHAR_COLON2;
    }
    function codePointAt2(string, pos) {
      var first = string.charCodeAt(pos), second;
      if (first >= 55296 && first <= 56319 && pos + 1 < string.length) {
        second = string.charCodeAt(pos + 1);
        if (second >= 56320 && second <= 57343) {
          return (first - 55296) * 1024 + second - 56320 + 65536;
        }
      }
      return first;
    }
    function needIndentIndicator2(string) {
      var leadingSpaceRe = /^\n* /;
      return leadingSpaceRe.test(string);
    }
    var STYLE_PLAIN2 = 1;
    var STYLE_SINGLE2 = 2;
    var STYLE_LITERAL2 = 3;
    var STYLE_FOLDED2 = 4;
    var STYLE_DOUBLE2 = 5;
    function chooseScalarStyle2(string, singleLineOnly, indentPerLevel, lineWidth, testAmbiguousType, quotingType, forceQuotes, inblock) {
      var i;
      var char = 0;
      var prevChar = null;
      var hasLineBreak = false;
      var hasFoldableLine = false;
      var shouldTrackWidth = lineWidth !== -1;
      var previousLineBreak = -1;
      var plain = isPlainSafeFirst2(codePointAt2(string, 0)) && isPlainSafeLast2(codePointAt2(string, string.length - 1));
      if (singleLineOnly || forceQuotes) {
        for (i = 0; i < string.length; char >= 65536 ? i += 2 : i++) {
          char = codePointAt2(string, i);
          if (!isPrintable2(char)) {
            return STYLE_DOUBLE2;
          }
          plain = plain && isPlainSafe2(char, prevChar, inblock);
          prevChar = char;
        }
      } else {
        for (i = 0; i < string.length; char >= 65536 ? i += 2 : i++) {
          char = codePointAt2(string, i);
          if (char === CHAR_LINE_FEED2) {
            hasLineBreak = true;
            if (shouldTrackWidth) {
              hasFoldableLine = hasFoldableLine || // Foldable line = too long, and not more-indented.
              i - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== " ";
              previousLineBreak = i;
            }
          } else if (!isPrintable2(char)) {
            return STYLE_DOUBLE2;
          }
          plain = plain && isPlainSafe2(char, prevChar, inblock);
          prevChar = char;
        }
        hasFoldableLine = hasFoldableLine || shouldTrackWidth && (i - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== " ");
      }
      if (!hasLineBreak && !hasFoldableLine) {
        if (plain && !forceQuotes && !testAmbiguousType(string)) {
          return STYLE_PLAIN2;
        }
        return quotingType === QUOTING_TYPE_DOUBLE2 ? STYLE_DOUBLE2 : STYLE_SINGLE2;
      }
      if (indentPerLevel > 9 && needIndentIndicator2(string)) {
        return STYLE_DOUBLE2;
      }
      if (!forceQuotes) {
        return hasFoldableLine ? STYLE_FOLDED2 : STYLE_LITERAL2;
      }
      return quotingType === QUOTING_TYPE_DOUBLE2 ? STYLE_DOUBLE2 : STYLE_SINGLE2;
    }
    function writeScalar2(state, string, level, iskey, inblock) {
      state.dump = function() {
        if (string.length === 0) {
          return state.quotingType === QUOTING_TYPE_DOUBLE2 ? '""' : "''";
        }
        if (!state.noCompatMode) {
          if (DEPRECATED_BOOLEANS_SYNTAX2.indexOf(string) !== -1 || DEPRECATED_BASE60_SYNTAX2.test(string)) {
            return state.quotingType === QUOTING_TYPE_DOUBLE2 ? '"' + string + '"' : "'" + string + "'";
          }
        }
        var indent = state.indent * Math.max(1, level);
        var lineWidth = state.lineWidth === -1 ? -1 : Math.max(Math.min(state.lineWidth, 40), state.lineWidth - indent);
        var singleLineOnly = iskey || state.flowLevel > -1 && level >= state.flowLevel;
        function testAmbiguity(string2) {
          return testImplicitResolving2(state, string2);
        }
        switch (chooseScalarStyle2(
          string,
          singleLineOnly,
          state.indent,
          lineWidth,
          testAmbiguity,
          state.quotingType,
          state.forceQuotes && !iskey,
          inblock
        )) {
          case STYLE_PLAIN2:
            return string;
          case STYLE_SINGLE2:
            return "'" + string.replace(/'/g, "''") + "'";
          case STYLE_LITERAL2:
            return "|" + blockHeader2(string, state.indent) + dropEndingNewline2(indentString2(string, indent));
          case STYLE_FOLDED2:
            return ">" + blockHeader2(string, state.indent) + dropEndingNewline2(indentString2(foldString2(string, lineWidth), indent));
          case STYLE_DOUBLE2:
            return '"' + escapeString4(string, lineWidth) + '"';
          default:
            throw new YAMLException2("impossible error: invalid scalar style");
        }
      }();
    }
    function blockHeader2(string, indentPerLevel) {
      var indentIndicator = needIndentIndicator2(string) ? String(indentPerLevel) : "";
      var clip = string[string.length - 1] === "\n";
      var keep = clip && (string[string.length - 2] === "\n" || string === "\n");
      var chomp = keep ? "+" : clip ? "" : "-";
      return indentIndicator + chomp + "\n";
    }
    function dropEndingNewline2(string) {
      return string[string.length - 1] === "\n" ? string.slice(0, -1) : string;
    }
    function foldString2(string, width) {
      var lineRe = /(\n+)([^\n]*)/g;
      var result = function() {
        var nextLF = string.indexOf("\n");
        nextLF = nextLF !== -1 ? nextLF : string.length;
        lineRe.lastIndex = nextLF;
        return foldLine2(string.slice(0, nextLF), width);
      }();
      var prevMoreIndented = string[0] === "\n" || string[0] === " ";
      var moreIndented;
      var match2;
      while (match2 = lineRe.exec(string)) {
        var prefix = match2[1], line = match2[2];
        moreIndented = line[0] === " ";
        result += prefix + (!prevMoreIndented && !moreIndented && line !== "" ? "\n" : "") + foldLine2(line, width);
        prevMoreIndented = moreIndented;
      }
      return result;
    }
    function foldLine2(line, width) {
      if (line === "" || line[0] === " ") return line;
      var breakRe = / [^ ]/g;
      var match2;
      var start = 0, end, curr = 0, next = 0;
      var result = "";
      while (match2 = breakRe.exec(line)) {
        next = match2.index;
        if (next - start > width) {
          end = curr > start ? curr : next;
          result += "\n" + line.slice(start, end);
          start = end + 1;
        }
        curr = next;
      }
      result += "\n";
      if (line.length - start > width && curr > start) {
        result += line.slice(start, curr) + "\n" + line.slice(curr + 1);
      } else {
        result += line.slice(start);
      }
      return result.slice(1);
    }
    function escapeString4(string) {
      var result = "";
      var char = 0;
      var escapeSeq;
      for (var i = 0; i < string.length; char >= 65536 ? i += 2 : i++) {
        char = codePointAt2(string, i);
        escapeSeq = ESCAPE_SEQUENCES2[char];
        if (!escapeSeq && isPrintable2(char)) {
          result += string[i];
          if (char >= 65536) result += string[i + 1];
        } else {
          result += escapeSeq || encodeHex2(char);
        }
      }
      return result;
    }
    function writeFlowSequence2(state, level, object) {
      var _result = "", _tag = state.tag, index, length, value;
      for (index = 0, length = object.length; index < length; index += 1) {
        value = object[index];
        if (state.replacer) {
          value = state.replacer.call(object, String(index), value);
        }
        if (writeNode2(state, level, value, false, false) || typeof value === "undefined" && writeNode2(state, level, null, false, false)) {
          if (_result !== "") _result += "," + (!state.condenseFlow ? " " : "");
          _result += state.dump;
        }
      }
      state.tag = _tag;
      state.dump = "[" + _result + "]";
    }
    function writeBlockSequence2(state, level, object, compact) {
      var _result = "", _tag = state.tag, index, length, value;
      for (index = 0, length = object.length; index < length; index += 1) {
        value = object[index];
        if (state.replacer) {
          value = state.replacer.call(object, String(index), value);
        }
        if (writeNode2(state, level + 1, value, true, true, false, true) || typeof value === "undefined" && writeNode2(state, level + 1, null, true, true, false, true)) {
          if (!compact || _result !== "") {
            _result += generateNextLine2(state, level);
          }
          if (state.dump && CHAR_LINE_FEED2 === state.dump.charCodeAt(0)) {
            _result += "-";
          } else {
            _result += "- ";
          }
          _result += state.dump;
        }
      }
      state.tag = _tag;
      state.dump = _result || "[]";
    }
    function writeFlowMapping2(state, level, object) {
      var _result = "", _tag = state.tag, objectKeyList = Object.keys(object), index, length, objectKey, objectValue, pairBuffer;
      for (index = 0, length = objectKeyList.length; index < length; index += 1) {
        pairBuffer = "";
        if (_result !== "") pairBuffer += ", ";
        if (state.condenseFlow) pairBuffer += '"';
        objectKey = objectKeyList[index];
        objectValue = object[objectKey];
        if (state.replacer) {
          objectValue = state.replacer.call(object, objectKey, objectValue);
        }
        if (!writeNode2(state, level, objectKey, false, false)) {
          continue;
        }
        if (state.dump.length > 1024) pairBuffer += "? ";
        pairBuffer += state.dump + (state.condenseFlow ? '"' : "") + ":" + (state.condenseFlow ? "" : " ");
        if (!writeNode2(state, level, objectValue, false, false)) {
          continue;
        }
        pairBuffer += state.dump;
        _result += pairBuffer;
      }
      state.tag = _tag;
      state.dump = "{" + _result + "}";
    }
    function writeBlockMapping2(state, level, object, compact) {
      var _result = "", _tag = state.tag, objectKeyList = Object.keys(object), index, length, objectKey, objectValue, explicitPair, pairBuffer;
      if (state.sortKeys === true) {
        objectKeyList.sort();
      } else if (typeof state.sortKeys === "function") {
        objectKeyList.sort(state.sortKeys);
      } else if (state.sortKeys) {
        throw new YAMLException2("sortKeys must be a boolean or a function");
      }
      for (index = 0, length = objectKeyList.length; index < length; index += 1) {
        pairBuffer = "";
        if (!compact || _result !== "") {
          pairBuffer += generateNextLine2(state, level);
        }
        objectKey = objectKeyList[index];
        objectValue = object[objectKey];
        if (state.replacer) {
          objectValue = state.replacer.call(object, objectKey, objectValue);
        }
        if (!writeNode2(state, level + 1, objectKey, true, true, true)) {
          continue;
        }
        explicitPair = state.tag !== null && state.tag !== "?" || state.dump && state.dump.length > 1024;
        if (explicitPair) {
          if (state.dump && CHAR_LINE_FEED2 === state.dump.charCodeAt(0)) {
            pairBuffer += "?";
          } else {
            pairBuffer += "? ";
          }
        }
        pairBuffer += state.dump;
        if (explicitPair) {
          pairBuffer += generateNextLine2(state, level);
        }
        if (!writeNode2(state, level + 1, objectValue, true, explicitPair)) {
          continue;
        }
        if (state.dump && CHAR_LINE_FEED2 === state.dump.charCodeAt(0)) {
          pairBuffer += ":";
        } else {
          pairBuffer += ": ";
        }
        pairBuffer += state.dump;
        _result += pairBuffer;
      }
      state.tag = _tag;
      state.dump = _result || "{}";
    }
    function detectType2(state, object, explicit) {
      var _result, typeList, index, length, type2, style;
      typeList = explicit ? state.explicitTypes : state.implicitTypes;
      for (index = 0, length = typeList.length; index < length; index += 1) {
        type2 = typeList[index];
        if ((type2.instanceOf || type2.predicate) && (!type2.instanceOf || typeof object === "object" && object instanceof type2.instanceOf) && (!type2.predicate || type2.predicate(object))) {
          if (explicit) {
            if (type2.multi && type2.representName) {
              state.tag = type2.representName(object);
            } else {
              state.tag = type2.tag;
            }
          } else {
            state.tag = "?";
          }
          if (type2.represent) {
            style = state.styleMap[type2.tag] || type2.defaultStyle;
            if (_toString2.call(type2.represent) === "[object Function]") {
              _result = type2.represent(object, style);
            } else if (_hasOwnProperty2.call(type2.represent, style)) {
              _result = type2.represent[style](object, style);
            } else {
              throw new YAMLException2("!<" + type2.tag + '> tag resolver accepts not "' + style + '" style');
            }
            state.dump = _result;
          }
          return true;
        }
      }
      return false;
    }
    function writeNode2(state, level, object, block, compact, iskey, isblockseq) {
      state.tag = null;
      state.dump = object;
      if (!detectType2(state, object, false)) {
        detectType2(state, object, true);
      }
      var type2 = _toString2.call(state.dump);
      var inblock = block;
      var tagStr;
      if (block) {
        block = state.flowLevel < 0 || state.flowLevel > level;
      }
      var objectOrArray = type2 === "[object Object]" || type2 === "[object Array]", duplicateIndex, duplicate;
      if (objectOrArray) {
        duplicateIndex = state.duplicates.indexOf(object);
        duplicate = duplicateIndex !== -1;
      }
      if (state.tag !== null && state.tag !== "?" || duplicate || state.indent !== 2 && level > 0) {
        compact = false;
      }
      if (duplicate && state.usedDuplicates[duplicateIndex]) {
        state.dump = "*ref_" + duplicateIndex;
      } else {
        if (objectOrArray && duplicate && !state.usedDuplicates[duplicateIndex]) {
          state.usedDuplicates[duplicateIndex] = true;
        }
        if (type2 === "[object Object]") {
          if (block && Object.keys(state.dump).length !== 0) {
            writeBlockMapping2(state, level, state.dump, compact);
            if (duplicate) {
              state.dump = "&ref_" + duplicateIndex + state.dump;
            }
          } else {
            writeFlowMapping2(state, level, state.dump);
            if (duplicate) {
              state.dump = "&ref_" + duplicateIndex + " " + state.dump;
            }
          }
        } else if (type2 === "[object Array]") {
          if (block && state.dump.length !== 0) {
            if (state.noArrayIndent && !isblockseq && level > 0) {
              writeBlockSequence2(state, level - 1, state.dump, compact);
            } else {
              writeBlockSequence2(state, level, state.dump, compact);
            }
            if (duplicate) {
              state.dump = "&ref_" + duplicateIndex + state.dump;
            }
          } else {
            writeFlowSequence2(state, level, state.dump);
            if (duplicate) {
              state.dump = "&ref_" + duplicateIndex + " " + state.dump;
            }
          }
        } else if (type2 === "[object String]") {
          if (state.tag !== "?") {
            writeScalar2(state, state.dump, level, iskey, inblock);
          }
        } else if (type2 === "[object Undefined]") {
          return false;
        } else {
          if (state.skipInvalid) return false;
          throw new YAMLException2("unacceptable kind of an object to dump " + type2);
        }
        if (state.tag !== null && state.tag !== "?") {
          tagStr = encodeURI(
            state.tag[0] === "!" ? state.tag.slice(1) : state.tag
          ).replace(/!/g, "%21");
          if (state.tag[0] === "!") {
            tagStr = "!" + tagStr;
          } else if (tagStr.slice(0, 18) === "tag:yaml.org,2002:") {
            tagStr = "!!" + tagStr.slice(18);
          } else {
            tagStr = "!<" + tagStr + ">";
          }
          state.dump = tagStr + " " + state.dump;
        }
      }
      return true;
    }
    function getDuplicateReferences2(object, state) {
      var objects = [], duplicatesIndexes = [], index, length;
      inspectNode2(object, objects, duplicatesIndexes);
      for (index = 0, length = duplicatesIndexes.length; index < length; index += 1) {
        state.duplicates.push(objects[duplicatesIndexes[index]]);
      }
      state.usedDuplicates = new Array(length);
    }
    function inspectNode2(object, objects, duplicatesIndexes) {
      var objectKeyList, index, length;
      if (object !== null && typeof object === "object") {
        index = objects.indexOf(object);
        if (index !== -1) {
          if (duplicatesIndexes.indexOf(index) === -1) {
            duplicatesIndexes.push(index);
          }
        } else {
          objects.push(object);
          if (Array.isArray(object)) {
            for (index = 0, length = object.length; index < length; index += 1) {
              inspectNode2(object[index], objects, duplicatesIndexes);
            }
          } else {
            objectKeyList = Object.keys(object);
            for (index = 0, length = objectKeyList.length; index < length; index += 1) {
              inspectNode2(object[objectKeyList[index]], objects, duplicatesIndexes);
            }
          }
        }
      }
    }
    function dump2(input, options) {
      options = options || {};
      var state = new State2(options);
      if (!state.noRefs) getDuplicateReferences2(input, state);
      var value = input;
      if (state.replacer) {
        value = state.replacer.call({ "": value }, "", value);
      }
      if (writeNode2(state, 0, value, true, true)) return state.dump + "\n";
      return "";
    }
    module2.exports.dump = dump2;
  }
});

// node_modules/js-yaml/index.js
var require_js_yaml = __commonJS({
  "node_modules/js-yaml/index.js"(exports2, module2) {
    "use strict";
    var loader2 = require_loader();
    var dumper2 = require_dumper();
    function renamed2(from, to) {
      return function() {
        throw new Error("Function yaml." + from + " is removed in js-yaml 4. Use yaml." + to + " instead, which is now safe by default.");
      };
    }
    module2.exports.Type = require_type();
    module2.exports.Schema = require_schema();
    module2.exports.FAILSAFE_SCHEMA = require_failsafe();
    module2.exports.JSON_SCHEMA = require_json2();
    module2.exports.CORE_SCHEMA = require_core();
    module2.exports.DEFAULT_SCHEMA = require_default();
    module2.exports.load = loader2.load;
    module2.exports.loadAll = loader2.loadAll;
    module2.exports.dump = dumper2.dump;
    module2.exports.YAMLException = require_exception();
    module2.exports.types = {
      binary: require_binary2(),
      float: require_float(),
      map: require_map2(),
      null: require_null(),
      pairs: require_pairs(),
      set: require_set(),
      timestamp: require_timestamp(),
      bool: require_bool(),
      int: require_int(),
      merge: require_merge(),
      omap: require_omap(),
      seq: require_seq(),
      str: require_str()
    };
    module2.exports.safeLoad = renamed2("safeLoad", "load");
    module2.exports.safeLoadAll = renamed2("safeLoadAll", "loadAll");
    module2.exports.safeDump = renamed2("safeDump", "dump");
  }
});

// node_modules/@readme/json-schema-ref-parser/lib/parsers/yaml.js
var require_yaml = __commonJS({
  "node_modules/@readme/json-schema-ref-parser/lib/parsers/yaml.js"(exports2, module2) {
    var yaml = require_js_yaml();
    var { JSON_SCHEMA: JSON_SCHEMA2 } = require_js_yaml();
    var { ParserError } = require_errors();
    module2.exports = {
      /**
       * The order that this parser will run, in relation to other parsers.
       *
       * @type {number}
       */
      order: 200,
      /**
       * Whether to allow "empty" files. This includes zero-byte files, as well as empty JSON objects.
       *
       * @type {boolean}
       */
      allowEmpty: true,
      /**
       * Determines whether this parser can parse a given file reference.
       * Parsers that match will be tried, in order, until one successfully parses the file.
       * Parsers that don't match will be skipped, UNLESS none of the parsers match, in which case
       * every parser will be tried.
       *
       * @type {RegExp|string[]|function}
       */
      canParse: [".yaml", ".yml", ".json"],
      // JSON is valid YAML
      /**
       * Parses the given file as YAML
       *
       * @param {object} file           - An object containing information about the referenced file
       * @param {string} file.url       - The full URL of the referenced file
       * @param {string} file.extension - The lowercased file extension (e.g. ".txt", ".html", etc.)
       * @param {*}      file.data      - The file contents. This will be whatever data type was returned by the resolver
       * @returns {Promise}
       */
      // eslint-disable-next-line require-await
      async parse(file) {
        let data = file.data;
        if (Buffer.isBuffer(data)) {
          data = data.toString();
        }
        if (typeof data === "string") {
          try {
            return yaml.load(data, { schema: JSON_SCHEMA2 });
          } catch (e) {
            throw new ParserError(e.message, file.url);
          }
        }
        return data;
      }
    };
  }
});

// node_modules/@readme/json-schema-ref-parser/lib/resolvers/file.js
var require_file = __commonJS({
  "node_modules/@readme/json-schema-ref-parser/lib/resolvers/file.js"(exports2, module2) {
    var fs3 = require("fs");
    var { ono: ono2 } = (init_esm(), __toCommonJS(esm_exports));
    var { ResolverError } = require_errors();
    var url = require_url();
    module2.exports = {
      /**
       * The order that this resolver will run, in relation to other resolvers.
       *
       * @type {number}
       */
      order: 100,
      /**
       * Determines whether this resolver can read a given file reference.
       * Resolvers that return true will be tried, in order, until one successfully resolves the file.
       * Resolvers that return false will not be given a chance to resolve the file.
       *
       * @param {object} file           - An object containing information about the referenced file
       * @param {string} file.url       - The full URL of the referenced file
       * @param {string} file.extension - The lowercased file extension (e.g. ".txt", ".html", etc.)
       * @returns {boolean}
       */
      canRead(file) {
        return url.isFileSystemPath(file.url);
      },
      /**
       * Reads the given file and returns its raw contents as a Buffer.
       *
       * @param {object} file           - An object containing information about the referenced file
       * @param {string} file.url       - The full URL of the referenced file
       * @param {string} file.extension - The lowercased file extension (e.g. ".txt", ".html", etc.)
       * @returns {Promise<Buffer>}
       */
      read(file) {
        return new Promise((resolve, reject) => {
          let path;
          try {
            path = url.toFileSystemPath(file.url);
          } catch (err) {
            reject(new ResolverError(ono2.uri(err, `Malformed URI: ${file.url}`), file.url));
          }
          try {
            fs3.readFile(path, (err, data) => {
              if (err) {
                reject(new ResolverError(ono2(err, `Error opening file "${path}"`), path));
              } else {
                resolve(data);
              }
            });
          } catch (err) {
            reject(new ResolverError(ono2(err, `Error opening file "${path}"`), path));
          }
        });
      }
    };
  }
});

// node_modules/@readme/json-schema-ref-parser/lib/resolvers/http.js
var require_http = __commonJS({
  "node_modules/@readme/json-schema-ref-parser/lib/resolvers/http.js"(exports2, module2) {
    var http4 = require("http");
    var https = require("https");
    var { ono: ono2 } = (init_esm(), __toCommonJS(esm_exports));
    var { ResolverError } = require_errors();
    var url = require_url();
    function get2(u, httpOptions) {
      return new Promise((resolve, reject) => {
        const protocol = u.protocol === "https:" ? https : http4;
        const req = protocol.get({
          hostname: u.hostname,
          port: u.port,
          path: u.path,
          auth: u.auth,
          protocol: u.protocol,
          headers: httpOptions.headers || {},
          withCredentials: httpOptions.withCredentials
        });
        if (typeof req.setTimeout === "function") {
          req.setTimeout(httpOptions.timeout);
        }
        req.on("timeout", () => {
          req.abort();
        });
        req.on("error", reject);
        req.once("response", (res) => {
          res.body = Buffer.alloc(0);
          res.on("data", (data) => {
            res.body = Buffer.concat([res.body, Buffer.from(data)]);
          });
          res.on("error", reject);
          res.on("end", () => {
            resolve(res);
          });
        });
      });
    }
    function download(u, httpOptions, redirects) {
      return new Promise((resolve, reject) => {
        u = url.parse(u);
        redirects = redirects || [];
        redirects.push(u.href);
        get2(u, httpOptions).then((res) => {
          if (res.statusCode >= 400) {
            throw ono2({ status: res.statusCode }, `HTTP ERROR ${res.statusCode}`);
          } else if (res.statusCode >= 300) {
            if (redirects.length > httpOptions.redirects) {
              reject(
                new ResolverError(
                  ono2(
                    { status: res.statusCode },
                    `Error downloading ${redirects[0]}. 
Too many redirects: 
  ${redirects.join(" \n  ")}`
                  )
                )
              );
            } else if (!res.headers.location) {
              throw ono2({ status: res.statusCode }, `HTTP ${res.statusCode} redirect with no location header`);
            } else {
              const redirectTo = url.resolve(u, res.headers.location);
              download(redirectTo, httpOptions, redirects).then(resolve, reject);
            }
          } else {
            resolve(res.body || Buffer.alloc(0));
          }
        }).catch((err) => {
          reject(new ResolverError(ono2(err, `Error downloading ${u.href}`), u.href));
        });
      });
    }
    module2.exports = {
      /**
       * The order that this resolver will run, in relation to other resolvers.
       *
       * @type {number}
       */
      order: 200,
      /**
       * HTTP headers to send when downloading files.
       *
       * @example:
       * {
       *   "User-Agent": "JSON Schema $Ref Parser",
       *   Accept: "application/json"
       * }
       *
       * @type {object}
       */
      headers: null,
      /**
       * HTTP request timeout (in milliseconds).
       *
       * @type {number}
       */
      timeout: 5e3,
      // 5 seconds
      /**
       * The maximum number of HTTP redirects to follow.
       * To disable automatic following of redirects, set this to zero.
       *
       * @type {number}
       */
      redirects: 5,
      /**
       * The `withCredentials` option of XMLHttpRequest.
       * Set this to `true` if you're downloading files from a CORS-enabled server that requires authentication
       *
       * @type {boolean}
       */
      withCredentials: false,
      /**
       * Determines whether this resolver can read a given file reference.
       * Resolvers that return true will be tried in order, until one successfully resolves the file.
       * Resolvers that return false will not be given a chance to resolve the file.
       *
       * @param {object} file           - An object containing information about the referenced file
       * @param {string} file.url       - The full URL of the referenced file
       * @param {string} file.extension - The lowercased file extension (e.g. ".txt", ".html", etc.)
       * @returns {boolean}
       */
      canRead(file) {
        return url.isHttp(file.url);
      },
      /**
       * Reads the given URL and returns its raw contents as a Buffer.
       *
       * @param {object} file           - An object containing information about the referenced file
       * @param {string} file.url       - The full URL of the referenced file
       * @param {string} file.extension - The lowercased file extension (e.g. ".txt", ".html", etc.)
       * @returns {Promise<Buffer>}
       */
      read(file) {
        const u = url.parse(file.url);
        if (process.browser && !u.protocol) {
          u.protocol = url.parse(location.href).protocol;
        }
        return download(u, this);
      }
    };
  }
});

// node_modules/@readme/json-schema-ref-parser/lib/options.js
var require_options = __commonJS({
  "node_modules/@readme/json-schema-ref-parser/lib/options.js"(exports2, module2) {
    var binaryParser = require_binary();
    var jsonParser = require_json();
    var textParser = require_text();
    var yamlParser = require_yaml();
    var fileResolver = require_file();
    var httpResolver = require_http();
    module2.exports = $RefParserOptions;
    function $RefParserOptions(options) {
      merge2(this, $RefParserOptions.defaults);
      merge2(this, options);
    }
    $RefParserOptions.defaults = {
      /**
       * Determines how different types of files will be parsed.
       *
       * You can add additional parsers of your own, replace an existing one with
       * your own implementation, or disable any parser by setting it to false.
       */
      parse: {
        json: jsonParser,
        yaml: yamlParser,
        text: textParser,
        binary: binaryParser
      },
      /**
       * Determines how JSON References will be resolved.
       *
       * You can add additional resolvers of your own, replace an existing one with
       * your own implementation, or disable any resolver by setting it to false.
       */
      resolve: {
        file: fileResolver,
        http: httpResolver,
        /**
         * Determines whether external $ref pointers will be resolved.
         * If this option is disabled, then none of above resolvers will be called.
         * Instead, external $ref pointers will simply be ignored.
         *
         * @type {boolean}
         */
        external: true
      },
      /**
       * By default, JSON Schema $Ref Parser throws the first error it encounters. Setting `continueOnError` to `true`
       * causes it to keep processing as much as possible and then throw a single error that contains all errors
       * that were encountered.
       */
      continueOnError: false,
      /**
       * Determines the types of JSON references that are allowed.
       */
      dereference: {
        /**
         * Dereference circular (recursive) JSON references?
         * If false, then a {@link ReferenceError} will be thrown if a circular reference is found.
         * If "ignore", then circular references will not be dereferenced.
         *
         * @type {boolean|string}
         */
        circular: true
      }
    };
    function merge2(target, source) {
      if (isMergeable(source)) {
        const keys = Object.keys(source);
        for (let i = 0; i < keys.length; i++) {
          const key = keys[i];
          const sourceSetting = source[key];
          const targetSetting = target[key];
          if (isMergeable(sourceSetting)) {
            target[key] = merge2(targetSetting || {}, sourceSetting);
          } else if (sourceSetting !== void 0) {
            target[key] = sourceSetting;
          }
        }
      }
      return target;
    }
    function isMergeable(val) {
      return val && typeof val === "object" && !Array.isArray(val) && !(val instanceof RegExp) && !(val instanceof Date);
    }
  }
});

// node_modules/@readme/json-schema-ref-parser/lib/normalize-args.js
var require_normalize_args = __commonJS({
  "node_modules/@readme/json-schema-ref-parser/lib/normalize-args.js"(exports2, module2) {
    var Options = require_options();
    module2.exports = function normalizeArgs2(args) {
      let path;
      let schema2;
      let options;
      let callback;
      args = Array.prototype.slice.call(args);
      if (typeof args[args.length - 1] === "function") {
        callback = args.pop();
      }
      if (typeof args[0] === "string") {
        path = args[0];
        if (typeof args[2] === "object") {
          schema2 = args[1];
          options = args[2];
        } else {
          schema2 = void 0;
          options = args[1];
        }
      } else {
        path = "";
        schema2 = args[0];
        options = args[1];
      }
      if (!(options instanceof Options)) {
        options = new Options(options);
      }
      return {
        path,
        schema: schema2,
        options,
        callback
      };
    };
  }
});

// node_modules/@readme/json-schema-ref-parser/lib/util/plugins.js
var require_plugins = __commonJS({
  "node_modules/@readme/json-schema-ref-parser/lib/util/plugins.js"(exports2) {
    exports2.all = function(plugins) {
      return Object.keys(plugins).filter((key) => {
        return typeof plugins[key] === "object";
      }).map((key) => {
        plugins[key].name = key;
        return plugins[key];
      });
    };
    exports2.filter = function(plugins, method, file) {
      return plugins.filter((plugin) => {
        return !!getResult(plugin, method, file);
      });
    };
    exports2.sort = function(plugins) {
      for (const plugin of plugins) {
        plugin.order = plugin.order || Number.MAX_SAFE_INTEGER;
      }
      return plugins.sort((a, b) => {
        return a.order - b.order;
      });
    };
    exports2.run = function(plugins, method, file, $refs) {
      let plugin;
      let lastError;
      let index = 0;
      return new Promise((resolve, reject) => {
        runNextPlugin();
        function runNextPlugin() {
          plugin = plugins[index++];
          if (!plugin) {
            return reject(lastError);
          }
          try {
            const result = getResult(plugin, method, file, callback, $refs);
            if (result && typeof result.then === "function") {
              result.then(onSuccess, onError);
            } else if (result !== void 0) {
              onSuccess(result);
            } else if (index === plugins.length) {
              throw new Error("No promise has been returned or callback has been called.");
            }
          } catch (e) {
            onError(e);
          }
        }
        function callback(err, result) {
          if (err) {
            onError(err);
          } else {
            onSuccess(result);
          }
        }
        function onSuccess(result) {
          resolve({
            plugin,
            result
          });
        }
        function onError(error) {
          lastError = {
            plugin,
            error
          };
          runNextPlugin();
        }
      });
    };
    function getResult(obj, prop, file, callback, $refs) {
      const value = obj[prop];
      if (typeof value === "function") {
        return value.apply(obj, [file, callback, $refs]);
      }
      if (!callback) {
        if (value instanceof RegExp) {
          return value.test(file.url);
        } else if (typeof value === "string") {
          return value === file.extension;
        } else if (Array.isArray(value)) {
          return value.indexOf(file.extension) !== -1;
        }
      }
      return value;
    }
  }
});

// node_modules/@readme/json-schema-ref-parser/lib/parse.js
var require_parse = __commonJS({
  "node_modules/@readme/json-schema-ref-parser/lib/parse.js"(exports2, module2) {
    var { ono: ono2 } = (init_esm(), __toCommonJS(esm_exports));
    var {
      ResolverError,
      ParserError,
      UnmatchedParserError,
      UnmatchedResolverError,
      isHandledError
    } = require_errors();
    var plugins = require_plugins();
    var url = require_url();
    module2.exports = async function parse6(path, $refs, options) {
      path = url.stripHash(path);
      const $ref = $refs._add(path);
      const file = {
        url: path,
        extension: url.getExtension(path)
      };
      try {
        const resolver = await readFile(file, options, $refs);
        $ref.pathType = resolver.plugin.name;
        file.data = resolver.result;
        const parser = await parseFile(file, options, $refs);
        $ref.value = parser.result;
        return parser.result;
      } catch (err) {
        if (isHandledError(err)) {
          $ref.value = err;
        }
        throw err;
      }
    };
    function readFile(file, options, $refs) {
      return new Promise((resolve, reject) => {
        let resolvers = plugins.all(options.resolve);
        resolvers = plugins.filter(resolvers, "canRead", file);
        plugins.sort(resolvers);
        plugins.run(resolvers, "read", file, $refs).then(resolve, onError);
        function onError(err) {
          if (!err && options.continueOnError) {
            reject(new UnmatchedResolverError(file.url));
          } else if (!err || !("error" in err)) {
            reject(ono2.syntax(`Unable to resolve $ref pointer "${file.url}"`));
          } else if (err.error instanceof ResolverError) {
            reject(err.error);
          } else {
            reject(new ResolverError(err, file.url));
          }
        }
      });
    }
    function parseFile(file, options, $refs) {
      return new Promise((resolve, reject) => {
        const allParsers = plugins.all(options.parse);
        const filteredParsers = plugins.filter(allParsers, "canParse", file);
        const parsers = filteredParsers.length > 0 ? filteredParsers : allParsers;
        plugins.sort(parsers);
        plugins.run(parsers, "parse", file, $refs).then(onParsed, onError);
        function onParsed(parser) {
          if (!parser.plugin.allowEmpty && isEmpty(parser.result)) {
            reject(ono2.syntax(`Error parsing "${file.url}" as ${parser.plugin.name}. 
Parsed value is empty`));
          } else {
            resolve(parser);
          }
        }
        function onError(err) {
          if (!err && options.continueOnError) {
            reject(new UnmatchedParserError(file.url));
          } else if (!err || !("error" in err)) {
            reject(ono2.syntax(`Unable to parse ${file.url}`));
          } else if (err.error instanceof ParserError) {
            reject(err.error);
          } else {
            reject(new ParserError(err.error.message, file.url));
          }
        }
      });
    }
    function isEmpty(value) {
      return value === void 0 || typeof value === "object" && Object.keys(value).length === 0 || typeof value === "string" && value.trim().length === 0 || Buffer.isBuffer(value) && value.length === 0;
    }
  }
});

// node_modules/@readme/json-schema-ref-parser/lib/refs.js
var require_refs = __commonJS({
  "node_modules/@readme/json-schema-ref-parser/lib/refs.js"(exports2, module2) {
    var { ono: ono2 } = (init_esm(), __toCommonJS(esm_exports));
    var $Ref = require_ref();
    var url = require_url();
    module2.exports = $Refs;
    function $Refs() {
      this.circular = false;
      this.circularRefs = [];
      this._$refs = {};
      this._root$Ref = null;
    }
    $Refs.prototype.paths = function(types3) {
      const paths = getPaths(this._$refs, arguments);
      return paths.map((path) => {
        return path.decoded;
      });
    };
    $Refs.prototype.values = function(types3) {
      const $refs = this._$refs;
      const paths = getPaths($refs, arguments);
      return paths.reduce((obj, path) => {
        obj[path.decoded] = $refs[path.encoded].value;
        return obj;
      }, {});
    };
    $Refs.prototype.toJSON = $Refs.prototype.values;
    $Refs.prototype.exists = function(path, options) {
      try {
        this._resolve(path, "", options);
        return true;
      } catch (e) {
        return false;
      }
    };
    $Refs.prototype.get = function(path, options) {
      return this._resolve(path, "", options).value;
    };
    $Refs.prototype.set = function(path, value) {
      const absPath = url.resolve(this._root$Ref.path, path);
      const withoutHash = url.stripHash(absPath);
      const $ref = this._$refs[withoutHash];
      if (!$ref) {
        throw ono2(`Error resolving $ref pointer "${path}". 
"${withoutHash}" not found.`);
      }
      $ref.set(absPath, value);
    };
    $Refs.prototype._add = function(path) {
      const withoutHash = url.stripHash(path);
      const $ref = new $Ref();
      $ref.path = withoutHash;
      $ref.$refs = this;
      this._$refs[withoutHash] = $ref;
      this._root$Ref = this._root$Ref || $ref;
      return $ref;
    };
    $Refs.prototype._resolve = function(path, pathFromRoot, options) {
      const absPath = url.resolve(this._root$Ref.path, path);
      const withoutHash = url.stripHash(absPath);
      const $ref = this._$refs[withoutHash];
      if (!$ref) {
        throw ono2(`Error resolving $ref pointer "${path}". 
"${withoutHash}" not found.`);
      }
      return $ref.resolve(absPath, options, path, pathFromRoot);
    };
    $Refs.prototype._get$Ref = function(path) {
      path = url.resolve(this._root$Ref.path, path);
      const withoutHash = url.stripHash(path);
      return this._$refs[withoutHash];
    };
    function getPaths($refs, types3) {
      let paths = Object.keys($refs);
      types3 = Array.isArray(types3[0]) ? types3[0] : Array.prototype.slice.call(types3);
      if (types3.length > 0 && types3[0]) {
        paths = paths.filter((key) => {
          return types3.indexOf($refs[key].pathType) !== -1;
        });
      }
      return paths.map((path) => {
        return {
          encoded: path,
          decoded: $refs[path].pathType === "file" ? url.toFileSystemPath(path, true) : path
        };
      });
    }
  }
});

// node_modules/@readme/json-schema-ref-parser/lib/resolve-external.js
var require_resolve_external = __commonJS({
  "node_modules/@readme/json-schema-ref-parser/lib/resolve-external.js"(exports2, module2) {
    var parse6 = require_parse();
    var Pointer = require_pointer();
    var $Ref = require_ref();
    var { isHandledError } = require_errors();
    var url = require_url();
    module2.exports = resolveExternal;
    function resolveExternal(parser, options) {
      if (!options.resolve.external) {
        return Promise.resolve();
      }
      try {
        const promises = crawl(parser.schema, `${parser.$refs._root$Ref.path}#`, parser.$refs, options);
        return Promise.all(promises);
      } catch (e) {
        return Promise.reject(e);
      }
    }
    function crawl(obj, path, $refs, options, seen) {
      seen = seen || /* @__PURE__ */ new Set();
      let promises = [];
      if (obj && typeof obj === "object" && !ArrayBuffer.isView(obj) && !seen.has(obj)) {
        seen.add(obj);
        if ($Ref.isExternal$Ref(obj)) {
          promises.push(resolve$Ref(obj, path, $refs, options));
        } else {
          for (const key of Object.keys(obj)) {
            const keyPath = Pointer.join(path, key);
            const value = obj[key];
            if ($Ref.isExternal$Ref(value)) {
              promises.push(resolve$Ref(value, keyPath, $refs, options));
            } else {
              promises = promises.concat(crawl(value, keyPath, $refs, options, seen));
            }
          }
        }
      }
      return promises;
    }
    async function resolve$Ref($ref, path, $refs, options) {
      const resolvedPath = url.resolve(path, $ref.$ref);
      const withoutHash = url.stripHash(resolvedPath);
      $ref = $refs._$refs[withoutHash];
      if ($ref) {
        return Promise.resolve($ref.value);
      }
      try {
        const result = await parse6(resolvedPath, $refs, options);
        const promises = crawl(result, `${withoutHash}#`, $refs, options);
        return Promise.all(promises);
      } catch (err) {
        if (!options.continueOnError || !isHandledError(err)) {
          throw err;
        }
        if ($refs._$refs[withoutHash]) {
          err.source = url.stripHash(path);
          err.path = url.safePointerToPath(url.getHash(path));
        }
        return [];
      }
    }
  }
});

// node_modules/@readme/json-schema-ref-parser/lib/index.js
var require_lib9 = __commonJS({
  "node_modules/@readme/json-schema-ref-parser/lib/index.js"(exports2, module2) {
    var { ono: ono2 } = (init_esm(), __toCommonJS(esm_exports));
    var maybe = require_maybe();
    var _bundle = require_bundle();
    var _dereference = require_dereference();
    var normalizeArgs2 = require_normalize_args();
    var _parse = require_parse();
    var $Refs = require_refs();
    var resolveExternal = require_resolve_external();
    var {
      JSONParserError,
      InvalidPointerError,
      MissingPointerError,
      ResolverError,
      ParserError,
      UnmatchedParserError,
      UnmatchedResolverError,
      isHandledError,
      JSONParserErrorGroup
    } = require_errors();
    var url = require_url();
    module2.exports = $RefParser2;
    module2.exports.default = $RefParser2;
    module2.exports.JSONParserError = JSONParserError;
    module2.exports.InvalidPointerError = InvalidPointerError;
    module2.exports.MissingPointerError = MissingPointerError;
    module2.exports.ResolverError = ResolverError;
    module2.exports.ParserError = ParserError;
    module2.exports.UnmatchedParserError = UnmatchedParserError;
    module2.exports.UnmatchedResolverError = UnmatchedResolverError;
    function $RefParser2() {
      this.schema = null;
      this.$refs = new $Refs();
    }
    $RefParser2.parse = function parse6(path, schema2, options, callback) {
      const Class = this;
      const instance = new Class();
      return instance.parse.apply(instance, arguments);
    };
    $RefParser2.prototype.parse = async function parse6(path, schema2, options, callback) {
      const args = normalizeArgs2(arguments);
      let promise;
      if (!args.path && !args.schema) {
        const err = ono2(`Expected a file path, URL, or object. Got ${args.path || args.schema}`);
        return maybe(args.callback, Promise.reject(err));
      }
      this.schema = null;
      this.$refs = new $Refs();
      let pathType = "http";
      if (url.isFileSystemPath(args.path)) {
        args.path = url.fromFileSystemPath(args.path);
        pathType = "file";
      }
      args.path = url.resolve(url.cwd(), args.path);
      if (args.schema && typeof args.schema === "object") {
        const $ref = this.$refs._add(args.path);
        $ref.value = args.schema;
        $ref.pathType = pathType;
        promise = Promise.resolve(args.schema);
      } else {
        promise = _parse(args.path, this.$refs, args.options);
      }
      const me = this;
      try {
        const result = await promise;
        if (result !== null && typeof result === "object" && !Buffer.isBuffer(result)) {
          me.schema = result;
          return maybe(args.callback, Promise.resolve(me.schema));
        } else if (args.options.continueOnError) {
          me.schema = null;
          return maybe(args.callback, Promise.resolve(me.schema));
        }
        throw ono2.syntax(`"${me.$refs._root$Ref.path || result}" is not a valid JSON Schema`);
      } catch (err) {
        if (!args.options.continueOnError || !isHandledError(err)) {
          return maybe(args.callback, Promise.reject(err));
        }
        if (this.$refs._$refs[url.stripHash(args.path)]) {
          this.$refs._$refs[url.stripHash(args.path)].addError(err);
        }
        return maybe(args.callback, Promise.resolve(null));
      }
    };
    $RefParser2.resolve = function resolve(path, schema2, options, callback) {
      const Class = this;
      const instance = new Class();
      return instance.resolve.apply(instance, arguments);
    };
    $RefParser2.prototype.resolve = async function resolve(path, schema2, options, callback) {
      const me = this;
      const args = normalizeArgs2(arguments);
      try {
        await this.parse(args.path, args.schema, args.options);
        await resolveExternal(me, args.options);
        finalize(me);
        return maybe(args.callback, Promise.resolve(me.$refs));
      } catch (err) {
        return maybe(args.callback, Promise.reject(err));
      }
    };
    $RefParser2.bundle = function bundle(path, schema2, options, callback) {
      const Class = this;
      const instance = new Class();
      return instance.bundle.apply(instance, arguments);
    };
    $RefParser2.prototype.bundle = async function bundle(path, schema2, options, callback) {
      const me = this;
      const args = normalizeArgs2(arguments);
      try {
        await this.resolve(args.path, args.schema, args.options);
        _bundle(me, args.options);
        finalize(me);
        return maybe(args.callback, Promise.resolve(me.schema));
      } catch (err) {
        return maybe(args.callback, Promise.reject(err));
      }
    };
    $RefParser2.dereference = function dereference(path, schema2, options, callback) {
      const Class = this;
      const instance = new Class();
      return instance.dereference.apply(instance, arguments);
    };
    $RefParser2.prototype.dereference = async function dereference(path, schema2, options, callback) {
      const me = this;
      const args = normalizeArgs2(arguments);
      try {
        await this.resolve(args.path, args.schema, args.options);
        _dereference(me, args.options);
        finalize(me);
        return maybe(args.callback, Promise.resolve(me.schema));
      } catch (err) {
        return maybe(args.callback, Promise.reject(err));
      }
    };
    function finalize(parser) {
      const errors = JSONParserErrorGroup.getParserErrors(parser);
      if (errors.length > 0) {
        throw new JSONParserErrorGroup(parser);
      }
    }
  }
});

// node_modules/es-errors/index.js
var require_es_errors = __commonJS({
  "node_modules/es-errors/index.js"(exports2, module2) {
    "use strict";
    module2.exports = Error;
  }
});

// node_modules/es-errors/eval.js
var require_eval = __commonJS({
  "node_modules/es-errors/eval.js"(exports2, module2) {
    "use strict";
    module2.exports = EvalError;
  }
});

// node_modules/es-errors/range.js
var require_range = __commonJS({
  "node_modules/es-errors/range.js"(exports2, module2) {
    "use strict";
    module2.exports = RangeError;
  }
});

// node_modules/es-errors/ref.js
var require_ref2 = __commonJS({
  "node_modules/es-errors/ref.js"(exports2, module2) {
    "use strict";
    module2.exports = ReferenceError;
  }
});

// node_modules/es-errors/syntax.js
var require_syntax = __commonJS({
  "node_modules/es-errors/syntax.js"(exports2, module2) {
    "use strict";
    module2.exports = SyntaxError;
  }
});

// node_modules/es-errors/type.js
var require_type2 = __commonJS({
  "node_modules/es-errors/type.js"(exports2, module2) {
    "use strict";
    module2.exports = TypeError;
  }
});

// node_modules/es-errors/uri.js
var require_uri = __commonJS({
  "node_modules/es-errors/uri.js"(exports2, module2) {
    "use strict";
    module2.exports = URIError;
  }
});

// node_modules/has-symbols/shams.js
var require_shams = __commonJS({
  "node_modules/has-symbols/shams.js"(exports2, module2) {
    "use strict";
    module2.exports = function hasSymbols() {
      if (typeof Symbol !== "function" || typeof Object.getOwnPropertySymbols !== "function") {
        return false;
      }
      if (typeof Symbol.iterator === "symbol") {
        return true;
      }
      var obj = {};
      var sym = Symbol("test");
      var symObj = Object(sym);
      if (typeof sym === "string") {
        return false;
      }
      if (Object.prototype.toString.call(sym) !== "[object Symbol]") {
        return false;
      }
      if (Object.prototype.toString.call(symObj) !== "[object Symbol]") {
        return false;
      }
      var symVal = 42;
      obj[sym] = symVal;
      for (sym in obj) {
        return false;
      }
      if (typeof Object.keys === "function" && Object.keys(obj).length !== 0) {
        return false;
      }
      if (typeof Object.getOwnPropertyNames === "function" && Object.getOwnPropertyNames(obj).length !== 0) {
        return false;
      }
      var syms = Object.getOwnPropertySymbols(obj);
      if (syms.length !== 1 || syms[0] !== sym) {
        return false;
      }
      if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
        return false;
      }
      if (typeof Object.getOwnPropertyDescriptor === "function") {
        var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
        if (descriptor.value !== symVal || descriptor.enumerable !== true) {
          return false;
        }
      }
      return true;
    };
  }
});

// node_modules/has-symbols/index.js
var require_has_symbols = __commonJS({
  "node_modules/has-symbols/index.js"(exports2, module2) {
    "use strict";
    var origSymbol = typeof Symbol !== "undefined" && Symbol;
    var hasSymbolSham = require_shams();
    module2.exports = function hasNativeSymbols() {
      if (typeof origSymbol !== "function") {
        return false;
      }
      if (typeof Symbol !== "function") {
        return false;
      }
      if (typeof origSymbol("foo") !== "symbol") {
        return false;
      }
      if (typeof Symbol("bar") !== "symbol") {
        return false;
      }
      return hasSymbolSham();
    };
  }
});

// node_modules/has-proto/index.js
var require_has_proto = __commonJS({
  "node_modules/has-proto/index.js"(exports2, module2) {
    "use strict";
    var test = {
      __proto__: null,
      foo: {}
    };
    var $Object = Object;
    module2.exports = function hasProto() {
      return { __proto__: test }.foo === test.foo && !(test instanceof $Object);
    };
  }
});

// node_modules/function-bind/implementation.js
var require_implementation2 = __commonJS({
  "node_modules/function-bind/implementation.js"(exports2, module2) {
    "use strict";
    var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
    var toStr = Object.prototype.toString;
    var max = Math.max;
    var funcType = "[object Function]";
    var concatty = function concatty2(a, b) {
      var arr = [];
      for (var i = 0; i < a.length; i += 1) {
        arr[i] = a[i];
      }
      for (var j = 0; j < b.length; j += 1) {
        arr[j + a.length] = b[j];
      }
      return arr;
    };
    var slicy = function slicy2(arrLike, offset) {
      var arr = [];
      for (var i = offset || 0, j = 0; i < arrLike.length; i += 1, j += 1) {
        arr[j] = arrLike[i];
      }
      return arr;
    };
    var joiny = function(arr, joiner) {
      var str2 = "";
      for (var i = 0; i < arr.length; i += 1) {
        str2 += arr[i];
        if (i + 1 < arr.length) {
          str2 += joiner;
        }
      }
      return str2;
    };
    module2.exports = function bind(that) {
      var target = this;
      if (typeof target !== "function" || toStr.apply(target) !== funcType) {
        throw new TypeError(ERROR_MESSAGE + target);
      }
      var args = slicy(arguments, 1);
      var bound;
      var binder = function() {
        if (this instanceof bound) {
          var result = target.apply(
            this,
            concatty(args, arguments)
          );
          if (Object(result) === result) {
            return result;
          }
          return this;
        }
        return target.apply(
          that,
          concatty(args, arguments)
        );
      };
      var boundLength = max(0, target.length - args.length);
      var boundArgs = [];
      for (var i = 0; i < boundLength; i++) {
        boundArgs[i] = "$" + i;
      }
      bound = Function("binder", "return function (" + joiny(boundArgs, ",") + "){ return binder.apply(this,arguments); }")(binder);
      if (target.prototype) {
        var Empty = function Empty2() {
        };
        Empty.prototype = target.prototype;
        bound.prototype = new Empty();
        Empty.prototype = null;
      }
      return bound;
    };
  }
});

// node_modules/function-bind/index.js
var require_function_bind = __commonJS({
  "node_modules/function-bind/index.js"(exports2, module2) {
    "use strict";
    var implementation = require_implementation2();
    module2.exports = Function.prototype.bind || implementation;
  }
});

// node_modules/hasown/index.js
var require_hasown = __commonJS({
  "node_modules/hasown/index.js"(exports2, module2) {
    "use strict";
    var call = Function.prototype.call;
    var $hasOwn = Object.prototype.hasOwnProperty;
    var bind = require_function_bind();
    module2.exports = bind.call(call, $hasOwn);
  }
});

// node_modules/get-intrinsic/index.js
var require_get_intrinsic = __commonJS({
  "node_modules/get-intrinsic/index.js"(exports2, module2) {
    "use strict";
    var undefined2;
    var $Error = require_es_errors();
    var $EvalError = require_eval();
    var $RangeError = require_range();
    var $ReferenceError = require_ref2();
    var $SyntaxError = require_syntax();
    var $TypeError = require_type2();
    var $URIError = require_uri();
    var $Function = Function;
    var getEvalledConstructor = function(expressionSyntax) {
      try {
        return $Function('"use strict"; return (' + expressionSyntax + ").constructor;")();
      } catch (e) {
      }
    };
    var $gOPD = Object.getOwnPropertyDescriptor;
    if ($gOPD) {
      try {
        $gOPD({}, "");
      } catch (e) {
        $gOPD = null;
      }
    }
    var throwTypeError = function() {
      throw new $TypeError();
    };
    var ThrowTypeError = $gOPD ? function() {
      try {
        arguments.callee;
        return throwTypeError;
      } catch (calleeThrows) {
        try {
          return $gOPD(arguments, "callee").get;
        } catch (gOPDthrows) {
          return throwTypeError;
        }
      }
    }() : throwTypeError;
    var hasSymbols = require_has_symbols()();
    var hasProto = require_has_proto()();
    var getProto = Object.getPrototypeOf || (hasProto ? function(x) {
      return x.__proto__;
    } : null);
    var needsEval = {};
    var TypedArray = typeof Uint8Array === "undefined" || !getProto ? undefined2 : getProto(Uint8Array);
    var INTRINSICS = {
      __proto__: null,
      "%AggregateError%": typeof AggregateError === "undefined" ? undefined2 : AggregateError,
      "%Array%": Array,
      "%ArrayBuffer%": typeof ArrayBuffer === "undefined" ? undefined2 : ArrayBuffer,
      "%ArrayIteratorPrototype%": hasSymbols && getProto ? getProto([][Symbol.iterator]()) : undefined2,
      "%AsyncFromSyncIteratorPrototype%": undefined2,
      "%AsyncFunction%": needsEval,
      "%AsyncGenerator%": needsEval,
      "%AsyncGeneratorFunction%": needsEval,
      "%AsyncIteratorPrototype%": needsEval,
      "%Atomics%": typeof Atomics === "undefined" ? undefined2 : Atomics,
      "%BigInt%": typeof BigInt === "undefined" ? undefined2 : BigInt,
      "%BigInt64Array%": typeof BigInt64Array === "undefined" ? undefined2 : BigInt64Array,
      "%BigUint64Array%": typeof BigUint64Array === "undefined" ? undefined2 : BigUint64Array,
      "%Boolean%": Boolean,
      "%DataView%": typeof DataView === "undefined" ? undefined2 : DataView,
      "%Date%": Date,
      "%decodeURI%": decodeURI,
      "%decodeURIComponent%": decodeURIComponent,
      "%encodeURI%": encodeURI,
      "%encodeURIComponent%": encodeURIComponent,
      "%Error%": $Error,
      "%eval%": eval,
      // eslint-disable-line no-eval
      "%EvalError%": $EvalError,
      "%Float32Array%": typeof Float32Array === "undefined" ? undefined2 : Float32Array,
      "%Float64Array%": typeof Float64Array === "undefined" ? undefined2 : Float64Array,
      "%FinalizationRegistry%": typeof FinalizationRegistry === "undefined" ? undefined2 : FinalizationRegistry,
      "%Function%": $Function,
      "%GeneratorFunction%": needsEval,
      "%Int8Array%": typeof Int8Array === "undefined" ? undefined2 : Int8Array,
      "%Int16Array%": typeof Int16Array === "undefined" ? undefined2 : Int16Array,
      "%Int32Array%": typeof Int32Array === "undefined" ? undefined2 : Int32Array,
      "%isFinite%": isFinite,
      "%isNaN%": isNaN,
      "%IteratorPrototype%": hasSymbols && getProto ? getProto(getProto([][Symbol.iterator]())) : undefined2,
      "%JSON%": typeof JSON === "object" ? JSON : undefined2,
      "%Map%": typeof Map === "undefined" ? undefined2 : Map,
      "%MapIteratorPrototype%": typeof Map === "undefined" || !hasSymbols || !getProto ? undefined2 : getProto((/* @__PURE__ */ new Map())[Symbol.iterator]()),
      "%Math%": Math,
      "%Number%": Number,
      "%Object%": Object,
      "%parseFloat%": parseFloat,
      "%parseInt%": parseInt,
      "%Promise%": typeof Promise === "undefined" ? undefined2 : Promise,
      "%Proxy%": typeof Proxy === "undefined" ? undefined2 : Proxy,
      "%RangeError%": $RangeError,
      "%ReferenceError%": $ReferenceError,
      "%Reflect%": typeof Reflect === "undefined" ? undefined2 : Reflect,
      "%RegExp%": RegExp,
      "%Set%": typeof Set === "undefined" ? undefined2 : Set,
      "%SetIteratorPrototype%": typeof Set === "undefined" || !hasSymbols || !getProto ? undefined2 : getProto((/* @__PURE__ */ new Set())[Symbol.iterator]()),
      "%SharedArrayBuffer%": typeof SharedArrayBuffer === "undefined" ? undefined2 : SharedArrayBuffer,
      "%String%": String,
      "%StringIteratorPrototype%": hasSymbols && getProto ? getProto(""[Symbol.iterator]()) : undefined2,
      "%Symbol%": hasSymbols ? Symbol : undefined2,
      "%SyntaxError%": $SyntaxError,
      "%ThrowTypeError%": ThrowTypeError,
      "%TypedArray%": TypedArray,
      "%TypeError%": $TypeError,
      "%Uint8Array%": typeof Uint8Array === "undefined" ? undefined2 : Uint8Array,
      "%Uint8ClampedArray%": typeof Uint8ClampedArray === "undefined" ? undefined2 : Uint8ClampedArray,
      "%Uint16Array%": typeof Uint16Array === "undefined" ? undefined2 : Uint16Array,
      "%Uint32Array%": typeof Uint32Array === "undefined" ? undefined2 : Uint32Array,
      "%URIError%": $URIError,
      "%WeakMap%": typeof WeakMap === "undefined" ? undefined2 : WeakMap,
      "%WeakRef%": typeof WeakRef === "undefined" ? undefined2 : WeakRef,
      "%WeakSet%": typeof WeakSet === "undefined" ? undefined2 : WeakSet
    };
    if (getProto) {
      try {
        null.error;
      } catch (e) {
        errorProto = getProto(getProto(e));
        INTRINSICS["%Error.prototype%"] = errorProto;
      }
    }
    var errorProto;
    var doEval = function doEval2(name) {
      var value;
      if (name === "%AsyncFunction%") {
        value = getEvalledConstructor("async function () {}");
      } else if (name === "%GeneratorFunction%") {
        value = getEvalledConstructor("function* () {}");
      } else if (name === "%AsyncGeneratorFunction%") {
        value = getEvalledConstructor("async function* () {}");
      } else if (name === "%AsyncGenerator%") {
        var fn = doEval2("%AsyncGeneratorFunction%");
        if (fn) {
          value = fn.prototype;
        }
      } else if (name === "%AsyncIteratorPrototype%") {
        var gen = doEval2("%AsyncGenerator%");
        if (gen && getProto) {
          value = getProto(gen.prototype);
        }
      }
      INTRINSICS[name] = value;
      return value;
    };
    var LEGACY_ALIASES = {
      __proto__: null,
      "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
      "%ArrayPrototype%": ["Array", "prototype"],
      "%ArrayProto_entries%": ["Array", "prototype", "entries"],
      "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
      "%ArrayProto_keys%": ["Array", "prototype", "keys"],
      "%ArrayProto_values%": ["Array", "prototype", "values"],
      "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
      "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
      "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
      "%BooleanPrototype%": ["Boolean", "prototype"],
      "%DataViewPrototype%": ["DataView", "prototype"],
      "%DatePrototype%": ["Date", "prototype"],
      "%ErrorPrototype%": ["Error", "prototype"],
      "%EvalErrorPrototype%": ["EvalError", "prototype"],
      "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
      "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
      "%FunctionPrototype%": ["Function", "prototype"],
      "%Generator%": ["GeneratorFunction", "prototype"],
      "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
      "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
      "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
      "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
      "%JSONParse%": ["JSON", "parse"],
      "%JSONStringify%": ["JSON", "stringify"],
      "%MapPrototype%": ["Map", "prototype"],
      "%NumberPrototype%": ["Number", "prototype"],
      "%ObjectPrototype%": ["Object", "prototype"],
      "%ObjProto_toString%": ["Object", "prototype", "toString"],
      "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
      "%PromisePrototype%": ["Promise", "prototype"],
      "%PromiseProto_then%": ["Promise", "prototype", "then"],
      "%Promise_all%": ["Promise", "all"],
      "%Promise_reject%": ["Promise", "reject"],
      "%Promise_resolve%": ["Promise", "resolve"],
      "%RangeErrorPrototype%": ["RangeError", "prototype"],
      "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
      "%RegExpPrototype%": ["RegExp", "prototype"],
      "%SetPrototype%": ["Set", "prototype"],
      "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
      "%StringPrototype%": ["String", "prototype"],
      "%SymbolPrototype%": ["Symbol", "prototype"],
      "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
      "%TypedArrayPrototype%": ["TypedArray", "prototype"],
      "%TypeErrorPrototype%": ["TypeError", "prototype"],
      "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
      "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
      "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
      "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
      "%URIErrorPrototype%": ["URIError", "prototype"],
      "%WeakMapPrototype%": ["WeakMap", "prototype"],
      "%WeakSetPrototype%": ["WeakSet", "prototype"]
    };
    var bind = require_function_bind();
    var hasOwn = require_hasown();
    var $concat = bind.call(Function.call, Array.prototype.concat);
    var $spliceApply = bind.call(Function.apply, Array.prototype.splice);
    var $replace = bind.call(Function.call, String.prototype.replace);
    var $strSlice = bind.call(Function.call, String.prototype.slice);
    var $exec = bind.call(Function.call, RegExp.prototype.exec);
    var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
    var reEscapeChar = /\\(\\)?/g;
    var stringToPath = function stringToPath2(string) {
      var first = $strSlice(string, 0, 1);
      var last = $strSlice(string, -1);
      if (first === "%" && last !== "%") {
        throw new $SyntaxError("invalid intrinsic syntax, expected closing `%`");
      } else if (last === "%" && first !== "%") {
        throw new $SyntaxError("invalid intrinsic syntax, expected opening `%`");
      }
      var result = [];
      $replace(string, rePropName, function(match2, number, quote2, subString) {
        result[result.length] = quote2 ? $replace(subString, reEscapeChar, "$1") : number || match2;
      });
      return result;
    };
    var getBaseIntrinsic = function getBaseIntrinsic2(name, allowMissing) {
      var intrinsicName = name;
      var alias;
      if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
        alias = LEGACY_ALIASES[intrinsicName];
        intrinsicName = "%" + alias[0] + "%";
      }
      if (hasOwn(INTRINSICS, intrinsicName)) {
        var value = INTRINSICS[intrinsicName];
        if (value === needsEval) {
          value = doEval(intrinsicName);
        }
        if (typeof value === "undefined" && !allowMissing) {
          throw new $TypeError("intrinsic " + name + " exists, but is not available. Please file an issue!");
        }
        return {
          alias,
          name: intrinsicName,
          value
        };
      }
      throw new $SyntaxError("intrinsic " + name + " does not exist!");
    };
    module2.exports = function GetIntrinsic(name, allowMissing) {
      if (typeof name !== "string" || name.length === 0) {
        throw new $TypeError("intrinsic name must be a non-empty string");
      }
      if (arguments.length > 1 && typeof allowMissing !== "boolean") {
        throw new $TypeError('"allowMissing" argument must be a boolean');
      }
      if ($exec(/^%?[^%]*%?$/, name) === null) {
        throw new $SyntaxError("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
      }
      var parts = stringToPath(name);
      var intrinsicBaseName = parts.length > 0 ? parts[0] : "";
      var intrinsic = getBaseIntrinsic("%" + intrinsicBaseName + "%", allowMissing);
      var intrinsicRealName = intrinsic.name;
      var value = intrinsic.value;
      var skipFurtherCaching = false;
      var alias = intrinsic.alias;
      if (alias) {
        intrinsicBaseName = alias[0];
        $spliceApply(parts, $concat([0, 1], alias));
      }
      for (var i = 1, isOwn = true; i < parts.length; i += 1) {
        var part = parts[i];
        var first = $strSlice(part, 0, 1);
        var last = $strSlice(part, -1);
        if ((first === '"' || first === "'" || first === "`" || (last === '"' || last === "'" || last === "`")) && first !== last) {
          throw new $SyntaxError("property names with quotes must have matching quotes");
        }
        if (part === "constructor" || !isOwn) {
          skipFurtherCaching = true;
        }
        intrinsicBaseName += "." + part;
        intrinsicRealName = "%" + intrinsicBaseName + "%";
        if (hasOwn(INTRINSICS, intrinsicRealName)) {
          value = INTRINSICS[intrinsicRealName];
        } else if (value != null) {
          if (!(part in value)) {
            if (!allowMissing) {
              throw new $TypeError("base intrinsic for " + name + " exists, but the property is not available.");
            }
            return void 0;
          }
          if ($gOPD && i + 1 >= parts.length) {
            var desc = $gOPD(value, part);
            isOwn = !!desc;
            if (isOwn && "get" in desc && !("originalValue" in desc.get)) {
              value = desc.get;
            } else {
              value = value[part];
            }
          } else {
            isOwn = hasOwn(value, part);
            value = value[part];
          }
          if (isOwn && !skipFurtherCaching) {
            INTRINSICS[intrinsicRealName] = value;
          }
        }
      }
      return value;
    };
  }
});

// node_modules/es-define-property/index.js
var require_es_define_property = __commonJS({
  "node_modules/es-define-property/index.js"(exports2, module2) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var $defineProperty = GetIntrinsic("%Object.defineProperty%", true) || false;
    if ($defineProperty) {
      try {
        $defineProperty({}, "a", { value: 1 });
      } catch (e) {
        $defineProperty = false;
      }
    }
    module2.exports = $defineProperty;
  }
});

// node_modules/gopd/index.js
var require_gopd = __commonJS({
  "node_modules/gopd/index.js"(exports2, module2) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var $gOPD = GetIntrinsic("%Object.getOwnPropertyDescriptor%", true);
    if ($gOPD) {
      try {
        $gOPD([], "length");
      } catch (e) {
        $gOPD = null;
      }
    }
    module2.exports = $gOPD;
  }
});

// node_modules/define-data-property/index.js
var require_define_data_property = __commonJS({
  "node_modules/define-data-property/index.js"(exports2, module2) {
    "use strict";
    var $defineProperty = require_es_define_property();
    var $SyntaxError = require_syntax();
    var $TypeError = require_type2();
    var gopd = require_gopd();
    module2.exports = function defineDataProperty(obj, property, value) {
      if (!obj || typeof obj !== "object" && typeof obj !== "function") {
        throw new $TypeError("`obj` must be an object or a function`");
      }
      if (typeof property !== "string" && typeof property !== "symbol") {
        throw new $TypeError("`property` must be a string or a symbol`");
      }
      if (arguments.length > 3 && typeof arguments[3] !== "boolean" && arguments[3] !== null) {
        throw new $TypeError("`nonEnumerable`, if provided, must be a boolean or null");
      }
      if (arguments.length > 4 && typeof arguments[4] !== "boolean" && arguments[4] !== null) {
        throw new $TypeError("`nonWritable`, if provided, must be a boolean or null");
      }
      if (arguments.length > 5 && typeof arguments[5] !== "boolean" && arguments[5] !== null) {
        throw new $TypeError("`nonConfigurable`, if provided, must be a boolean or null");
      }
      if (arguments.length > 6 && typeof arguments[6] !== "boolean") {
        throw new $TypeError("`loose`, if provided, must be a boolean");
      }
      var nonEnumerable = arguments.length > 3 ? arguments[3] : null;
      var nonWritable = arguments.length > 4 ? arguments[4] : null;
      var nonConfigurable = arguments.length > 5 ? arguments[5] : null;
      var loose = arguments.length > 6 ? arguments[6] : false;
      var desc = !!gopd && gopd(obj, property);
      if ($defineProperty) {
        $defineProperty(obj, property, {
          configurable: nonConfigurable === null && desc ? desc.configurable : !nonConfigurable,
          enumerable: nonEnumerable === null && desc ? desc.enumerable : !nonEnumerable,
          value,
          writable: nonWritable === null && desc ? desc.writable : !nonWritable
        });
      } else if (loose || !nonEnumerable && !nonWritable && !nonConfigurable) {
        obj[property] = value;
      } else {
        throw new $SyntaxError("This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.");
      }
    };
  }
});

// node_modules/has-property-descriptors/index.js
var require_has_property_descriptors = __commonJS({
  "node_modules/has-property-descriptors/index.js"(exports2, module2) {
    "use strict";
    var $defineProperty = require_es_define_property();
    var hasPropertyDescriptors = function hasPropertyDescriptors2() {
      return !!$defineProperty;
    };
    hasPropertyDescriptors.hasArrayLengthDefineBug = function hasArrayLengthDefineBug() {
      if (!$defineProperty) {
        return null;
      }
      try {
        return $defineProperty([], "length", { value: 1 }).length !== 1;
      } catch (e) {
        return true;
      }
    };
    module2.exports = hasPropertyDescriptors;
  }
});

// node_modules/set-function-length/index.js
var require_set_function_length = __commonJS({
  "node_modules/set-function-length/index.js"(exports2, module2) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var define2 = require_define_data_property();
    var hasDescriptors = require_has_property_descriptors()();
    var gOPD = require_gopd();
    var $TypeError = require_type2();
    var $floor = GetIntrinsic("%Math.floor%");
    module2.exports = function setFunctionLength(fn, length) {
      if (typeof fn !== "function") {
        throw new $TypeError("`fn` is not a function");
      }
      if (typeof length !== "number" || length < 0 || length > 4294967295 || $floor(length) !== length) {
        throw new $TypeError("`length` must be a positive 32-bit integer");
      }
      var loose = arguments.length > 2 && !!arguments[2];
      var functionLengthIsConfigurable = true;
      var functionLengthIsWritable = true;
      if ("length" in fn && gOPD) {
        var desc = gOPD(fn, "length");
        if (desc && !desc.configurable) {
          functionLengthIsConfigurable = false;
        }
        if (desc && !desc.writable) {
          functionLengthIsWritable = false;
        }
      }
      if (functionLengthIsConfigurable || functionLengthIsWritable || !loose) {
        if (hasDescriptors) {
          define2(
            /** @type {Parameters<define>[0]} */
            fn,
            "length",
            length,
            true,
            true
          );
        } else {
          define2(
            /** @type {Parameters<define>[0]} */
            fn,
            "length",
            length
          );
        }
      }
      return fn;
    };
  }
});

// node_modules/call-bind/index.js
var require_call_bind = __commonJS({
  "node_modules/call-bind/index.js"(exports2, module2) {
    "use strict";
    var bind = require_function_bind();
    var GetIntrinsic = require_get_intrinsic();
    var setFunctionLength = require_set_function_length();
    var $TypeError = require_type2();
    var $apply = GetIntrinsic("%Function.prototype.apply%");
    var $call = GetIntrinsic("%Function.prototype.call%");
    var $reflectApply = GetIntrinsic("%Reflect.apply%", true) || bind.call($call, $apply);
    var $defineProperty = require_es_define_property();
    var $max = GetIntrinsic("%Math.max%");
    module2.exports = function callBind(originalFunction) {
      if (typeof originalFunction !== "function") {
        throw new $TypeError("a function is required");
      }
      var func = $reflectApply(bind, $call, arguments);
      return setFunctionLength(
        func,
        1 + $max(0, originalFunction.length - (arguments.length - 1)),
        true
      );
    };
    var applyBind = function applyBind2() {
      return $reflectApply(bind, $apply, arguments);
    };
    if ($defineProperty) {
      $defineProperty(module2.exports, "apply", { value: applyBind });
    } else {
      module2.exports.apply = applyBind;
    }
  }
});

// node_modules/call-bind/callBound.js
var require_callBound = __commonJS({
  "node_modules/call-bind/callBound.js"(exports2, module2) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var callBind = require_call_bind();
    var $indexOf = callBind(GetIntrinsic("String.prototype.indexOf"));
    module2.exports = function callBoundIntrinsic(name, allowMissing) {
      var intrinsic = GetIntrinsic(name, !!allowMissing);
      if (typeof intrinsic === "function" && $indexOf(name, ".prototype.") > -1) {
        return callBind(intrinsic);
      }
      return intrinsic;
    };
  }
});

// node_modules/object-inspect/util.inspect.js
var require_util_inspect = __commonJS({
  "node_modules/object-inspect/util.inspect.js"(exports2, module2) {
    module2.exports = require("util").inspect;
  }
});

// node_modules/object-inspect/index.js
var require_object_inspect = __commonJS({
  "node_modules/object-inspect/index.js"(exports2, module2) {
    var hasMap = typeof Map === "function" && Map.prototype;
    var mapSizeDescriptor = Object.getOwnPropertyDescriptor && hasMap ? Object.getOwnPropertyDescriptor(Map.prototype, "size") : null;
    var mapSize = hasMap && mapSizeDescriptor && typeof mapSizeDescriptor.get === "function" ? mapSizeDescriptor.get : null;
    var mapForEach = hasMap && Map.prototype.forEach;
    var hasSet = typeof Set === "function" && Set.prototype;
    var setSizeDescriptor = Object.getOwnPropertyDescriptor && hasSet ? Object.getOwnPropertyDescriptor(Set.prototype, "size") : null;
    var setSize = hasSet && setSizeDescriptor && typeof setSizeDescriptor.get === "function" ? setSizeDescriptor.get : null;
    var setForEach = hasSet && Set.prototype.forEach;
    var hasWeakMap = typeof WeakMap === "function" && WeakMap.prototype;
    var weakMapHas = hasWeakMap ? WeakMap.prototype.has : null;
    var hasWeakSet = typeof WeakSet === "function" && WeakSet.prototype;
    var weakSetHas = hasWeakSet ? WeakSet.prototype.has : null;
    var hasWeakRef = typeof WeakRef === "function" && WeakRef.prototype;
    var weakRefDeref = hasWeakRef ? WeakRef.prototype.deref : null;
    var booleanValueOf = Boolean.prototype.valueOf;
    var objectToString = Object.prototype.toString;
    var functionToString = Function.prototype.toString;
    var $match = String.prototype.match;
    var $slice = String.prototype.slice;
    var $replace = String.prototype.replace;
    var $toUpperCase = String.prototype.toUpperCase;
    var $toLowerCase = String.prototype.toLowerCase;
    var $test = RegExp.prototype.test;
    var $concat = Array.prototype.concat;
    var $join = Array.prototype.join;
    var $arrSlice = Array.prototype.slice;
    var $floor = Math.floor;
    var bigIntValueOf = typeof BigInt === "function" ? BigInt.prototype.valueOf : null;
    var gOPS = Object.getOwnPropertySymbols;
    var symToString = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? Symbol.prototype.toString : null;
    var hasShammedSymbols = typeof Symbol === "function" && typeof Symbol.iterator === "object";
    var toStringTag = typeof Symbol === "function" && Symbol.toStringTag && (typeof Symbol.toStringTag === hasShammedSymbols ? "object" : "symbol") ? Symbol.toStringTag : null;
    var isEnumerable = Object.prototype.propertyIsEnumerable;
    var gPO = (typeof Reflect === "function" ? Reflect.getPrototypeOf : Object.getPrototypeOf) || ([].__proto__ === Array.prototype ? function(O) {
      return O.__proto__;
    } : null);
    function addNumericSeparator(num, str2) {
      if (num === Infinity || num === -Infinity || num !== num || num && num > -1e3 && num < 1e3 || $test.call(/e/, str2)) {
        return str2;
      }
      var sepRegex = /[0-9](?=(?:[0-9]{3})+(?![0-9]))/g;
      if (typeof num === "number") {
        var int2 = num < 0 ? -$floor(-num) : $floor(num);
        if (int2 !== num) {
          var intStr = String(int2);
          var dec = $slice.call(str2, intStr.length + 1);
          return $replace.call(intStr, sepRegex, "$&_") + "." + $replace.call($replace.call(dec, /([0-9]{3})/g, "$&_"), /_$/, "");
        }
      }
      return $replace.call(str2, sepRegex, "$&_");
    }
    var utilInspect = require_util_inspect();
    var inspectCustom = utilInspect.custom;
    var inspectSymbol = isSymbol(inspectCustom) ? inspectCustom : null;
    module2.exports = function inspect_(obj, options, depth, seen) {
      var opts = options || {};
      if (has(opts, "quoteStyle") && (opts.quoteStyle !== "single" && opts.quoteStyle !== "double")) {
        throw new TypeError('option "quoteStyle" must be "single" or "double"');
      }
      if (has(opts, "maxStringLength") && (typeof opts.maxStringLength === "number" ? opts.maxStringLength < 0 && opts.maxStringLength !== Infinity : opts.maxStringLength !== null)) {
        throw new TypeError('option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`');
      }
      var customInspect = has(opts, "customInspect") ? opts.customInspect : true;
      if (typeof customInspect !== "boolean" && customInspect !== "symbol") {
        throw new TypeError("option \"customInspect\", if provided, must be `true`, `false`, or `'symbol'`");
      }
      if (has(opts, "indent") && opts.indent !== null && opts.indent !== "	" && !(parseInt(opts.indent, 10) === opts.indent && opts.indent > 0)) {
        throw new TypeError('option "indent" must be "\\t", an integer > 0, or `null`');
      }
      if (has(opts, "numericSeparator") && typeof opts.numericSeparator !== "boolean") {
        throw new TypeError('option "numericSeparator", if provided, must be `true` or `false`');
      }
      var numericSeparator = opts.numericSeparator;
      if (typeof obj === "undefined") {
        return "undefined";
      }
      if (obj === null) {
        return "null";
      }
      if (typeof obj === "boolean") {
        return obj ? "true" : "false";
      }
      if (typeof obj === "string") {
        return inspectString(obj, opts);
      }
      if (typeof obj === "number") {
        if (obj === 0) {
          return Infinity / obj > 0 ? "0" : "-0";
        }
        var str2 = String(obj);
        return numericSeparator ? addNumericSeparator(obj, str2) : str2;
      }
      if (typeof obj === "bigint") {
        var bigIntStr = String(obj) + "n";
        return numericSeparator ? addNumericSeparator(obj, bigIntStr) : bigIntStr;
      }
      var maxDepth = typeof opts.depth === "undefined" ? 5 : opts.depth;
      if (typeof depth === "undefined") {
        depth = 0;
      }
      if (depth >= maxDepth && maxDepth > 0 && typeof obj === "object") {
        return isArray(obj) ? "[Array]" : "[Object]";
      }
      var indent = getIndent(opts, depth);
      if (typeof seen === "undefined") {
        seen = [];
      } else if (indexOf(seen, obj) >= 0) {
        return "[Circular]";
      }
      function inspect3(value, from, noIndent) {
        if (from) {
          seen = $arrSlice.call(seen);
          seen.push(from);
        }
        if (noIndent) {
          var newOpts = {
            depth: opts.depth
          };
          if (has(opts, "quoteStyle")) {
            newOpts.quoteStyle = opts.quoteStyle;
          }
          return inspect_(value, newOpts, depth + 1, seen);
        }
        return inspect_(value, opts, depth + 1, seen);
      }
      if (typeof obj === "function" && !isRegExp(obj)) {
        var name = nameOf(obj);
        var keys = arrObjKeys(obj, inspect3);
        return "[Function" + (name ? ": " + name : " (anonymous)") + "]" + (keys.length > 0 ? " { " + $join.call(keys, ", ") + " }" : "");
      }
      if (isSymbol(obj)) {
        var symString = hasShammedSymbols ? $replace.call(String(obj), /^(Symbol\(.*\))_[^)]*$/, "$1") : symToString.call(obj);
        return typeof obj === "object" && !hasShammedSymbols ? markBoxed(symString) : symString;
      }
      if (isElement(obj)) {
        var s = "<" + $toLowerCase.call(String(obj.nodeName));
        var attrs = obj.attributes || [];
        for (var i = 0; i < attrs.length; i++) {
          s += " " + attrs[i].name + "=" + wrapQuotes(quote2(attrs[i].value), "double", opts);
        }
        s += ">";
        if (obj.childNodes && obj.childNodes.length) {
          s += "...";
        }
        s += "</" + $toLowerCase.call(String(obj.nodeName)) + ">";
        return s;
      }
      if (isArray(obj)) {
        if (obj.length === 0) {
          return "[]";
        }
        var xs = arrObjKeys(obj, inspect3);
        if (indent && !singleLineValues(xs)) {
          return "[" + indentedJoin(xs, indent) + "]";
        }
        return "[ " + $join.call(xs, ", ") + " ]";
      }
      if (isError(obj)) {
        var parts = arrObjKeys(obj, inspect3);
        if (!("cause" in Error.prototype) && "cause" in obj && !isEnumerable.call(obj, "cause")) {
          return "{ [" + String(obj) + "] " + $join.call($concat.call("[cause]: " + inspect3(obj.cause), parts), ", ") + " }";
        }
        if (parts.length === 0) {
          return "[" + String(obj) + "]";
        }
        return "{ [" + String(obj) + "] " + $join.call(parts, ", ") + " }";
      }
      if (typeof obj === "object" && customInspect) {
        if (inspectSymbol && typeof obj[inspectSymbol] === "function" && utilInspect) {
          return utilInspect(obj, { depth: maxDepth - depth });
        } else if (customInspect !== "symbol" && typeof obj.inspect === "function") {
          return obj.inspect();
        }
      }
      if (isMap(obj)) {
        var mapParts = [];
        if (mapForEach) {
          mapForEach.call(obj, function(value, key) {
            mapParts.push(inspect3(key, obj, true) + " => " + inspect3(value, obj));
          });
        }
        return collectionOf("Map", mapSize.call(obj), mapParts, indent);
      }
      if (isSet(obj)) {
        var setParts = [];
        if (setForEach) {
          setForEach.call(obj, function(value) {
            setParts.push(inspect3(value, obj));
          });
        }
        return collectionOf("Set", setSize.call(obj), setParts, indent);
      }
      if (isWeakMap(obj)) {
        return weakCollectionOf("WeakMap");
      }
      if (isWeakSet(obj)) {
        return weakCollectionOf("WeakSet");
      }
      if (isWeakRef(obj)) {
        return weakCollectionOf("WeakRef");
      }
      if (isNumber(obj)) {
        return markBoxed(inspect3(Number(obj)));
      }
      if (isBigInt(obj)) {
        return markBoxed(inspect3(bigIntValueOf.call(obj)));
      }
      if (isBoolean2(obj)) {
        return markBoxed(booleanValueOf.call(obj));
      }
      if (isString(obj)) {
        return markBoxed(inspect3(String(obj)));
      }
      if (typeof window !== "undefined" && obj === window) {
        return "{ [object Window] }";
      }
      if (typeof globalThis !== "undefined" && obj === globalThis || typeof global !== "undefined" && obj === global) {
        return "{ [object globalThis] }";
      }
      if (!isDate(obj) && !isRegExp(obj)) {
        var ys = arrObjKeys(obj, inspect3);
        var isPlainObject = gPO ? gPO(obj) === Object.prototype : obj instanceof Object || obj.constructor === Object;
        var protoTag = obj instanceof Object ? "" : "null prototype";
        var stringTag = !isPlainObject && toStringTag && Object(obj) === obj && toStringTag in obj ? $slice.call(toStr(obj), 8, -1) : protoTag ? "Object" : "";
        var constructorTag = isPlainObject || typeof obj.constructor !== "function" ? "" : obj.constructor.name ? obj.constructor.name + " " : "";
        var tag = constructorTag + (stringTag || protoTag ? "[" + $join.call($concat.call([], stringTag || [], protoTag || []), ": ") + "] " : "");
        if (ys.length === 0) {
          return tag + "{}";
        }
        if (indent) {
          return tag + "{" + indentedJoin(ys, indent) + "}";
        }
        return tag + "{ " + $join.call(ys, ", ") + " }";
      }
      return String(obj);
    };
    function wrapQuotes(s, defaultStyle, opts) {
      var quoteChar = (opts.quoteStyle || defaultStyle) === "double" ? '"' : "'";
      return quoteChar + s + quoteChar;
    }
    function quote2(s) {
      return $replace.call(String(s), /"/g, "&quot;");
    }
    function isArray(obj) {
      return toStr(obj) === "[object Array]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isDate(obj) {
      return toStr(obj) === "[object Date]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isRegExp(obj) {
      return toStr(obj) === "[object RegExp]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isError(obj) {
      return toStr(obj) === "[object Error]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isString(obj) {
      return toStr(obj) === "[object String]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isNumber(obj) {
      return toStr(obj) === "[object Number]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isBoolean2(obj) {
      return toStr(obj) === "[object Boolean]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isSymbol(obj) {
      if (hasShammedSymbols) {
        return obj && typeof obj === "object" && obj instanceof Symbol;
      }
      if (typeof obj === "symbol") {
        return true;
      }
      if (!obj || typeof obj !== "object" || !symToString) {
        return false;
      }
      try {
        symToString.call(obj);
        return true;
      } catch (e) {
      }
      return false;
    }
    function isBigInt(obj) {
      if (!obj || typeof obj !== "object" || !bigIntValueOf) {
        return false;
      }
      try {
        bigIntValueOf.call(obj);
        return true;
      } catch (e) {
      }
      return false;
    }
    var hasOwn = Object.prototype.hasOwnProperty || function(key) {
      return key in this;
    };
    function has(obj, key) {
      return hasOwn.call(obj, key);
    }
    function toStr(obj) {
      return objectToString.call(obj);
    }
    function nameOf(f) {
      if (f.name) {
        return f.name;
      }
      var m = $match.call(functionToString.call(f), /^function\s*([\w$]+)/);
      if (m) {
        return m[1];
      }
      return null;
    }
    function indexOf(xs, x) {
      if (xs.indexOf) {
        return xs.indexOf(x);
      }
      for (var i = 0, l = xs.length; i < l; i++) {
        if (xs[i] === x) {
          return i;
        }
      }
      return -1;
    }
    function isMap(x) {
      if (!mapSize || !x || typeof x !== "object") {
        return false;
      }
      try {
        mapSize.call(x);
        try {
          setSize.call(x);
        } catch (s) {
          return true;
        }
        return x instanceof Map;
      } catch (e) {
      }
      return false;
    }
    function isWeakMap(x) {
      if (!weakMapHas || !x || typeof x !== "object") {
        return false;
      }
      try {
        weakMapHas.call(x, weakMapHas);
        try {
          weakSetHas.call(x, weakSetHas);
        } catch (s) {
          return true;
        }
        return x instanceof WeakMap;
      } catch (e) {
      }
      return false;
    }
    function isWeakRef(x) {
      if (!weakRefDeref || !x || typeof x !== "object") {
        return false;
      }
      try {
        weakRefDeref.call(x);
        return true;
      } catch (e) {
      }
      return false;
    }
    function isSet(x) {
      if (!setSize || !x || typeof x !== "object") {
        return false;
      }
      try {
        setSize.call(x);
        try {
          mapSize.call(x);
        } catch (m) {
          return true;
        }
        return x instanceof Set;
      } catch (e) {
      }
      return false;
    }
    function isWeakSet(x) {
      if (!weakSetHas || !x || typeof x !== "object") {
        return false;
      }
      try {
        weakSetHas.call(x, weakSetHas);
        try {
          weakMapHas.call(x, weakMapHas);
        } catch (s) {
          return true;
        }
        return x instanceof WeakSet;
      } catch (e) {
      }
      return false;
    }
    function isElement(x) {
      if (!x || typeof x !== "object") {
        return false;
      }
      if (typeof HTMLElement !== "undefined" && x instanceof HTMLElement) {
        return true;
      }
      return typeof x.nodeName === "string" && typeof x.getAttribute === "function";
    }
    function inspectString(str2, opts) {
      if (str2.length > opts.maxStringLength) {
        var remaining = str2.length - opts.maxStringLength;
        var trailer = "... " + remaining + " more character" + (remaining > 1 ? "s" : "");
        return inspectString($slice.call(str2, 0, opts.maxStringLength), opts) + trailer;
      }
      var s = $replace.call($replace.call(str2, /(['\\])/g, "\\$1"), /[\x00-\x1f]/g, lowbyte);
      return wrapQuotes(s, "single", opts);
    }
    function lowbyte(c2) {
      var n = c2.charCodeAt(0);
      var x = {
        8: "b",
        9: "t",
        10: "n",
        12: "f",
        13: "r"
      }[n];
      if (x) {
        return "\\" + x;
      }
      return "\\x" + (n < 16 ? "0" : "") + $toUpperCase.call(n.toString(16));
    }
    function markBoxed(str2) {
      return "Object(" + str2 + ")";
    }
    function weakCollectionOf(type2) {
      return type2 + " { ? }";
    }
    function collectionOf(type2, size, entries, indent) {
      var joinedEntries = indent ? indentedJoin(entries, indent) : $join.call(entries, ", ");
      return type2 + " (" + size + ") {" + joinedEntries + "}";
    }
    function singleLineValues(xs) {
      for (var i = 0; i < xs.length; i++) {
        if (indexOf(xs[i], "\n") >= 0) {
          return false;
        }
      }
      return true;
    }
    function getIndent(opts, depth) {
      var baseIndent;
      if (opts.indent === "	") {
        baseIndent = "	";
      } else if (typeof opts.indent === "number" && opts.indent > 0) {
        baseIndent = $join.call(Array(opts.indent + 1), " ");
      } else {
        return null;
      }
      return {
        base: baseIndent,
        prev: $join.call(Array(depth + 1), baseIndent)
      };
    }
    function indentedJoin(xs, indent) {
      if (xs.length === 0) {
        return "";
      }
      var lineJoiner = "\n" + indent.prev + indent.base;
      return lineJoiner + $join.call(xs, "," + lineJoiner) + "\n" + indent.prev;
    }
    function arrObjKeys(obj, inspect3) {
      var isArr = isArray(obj);
      var xs = [];
      if (isArr) {
        xs.length = obj.length;
        for (var i = 0; i < obj.length; i++) {
          xs[i] = has(obj, i) ? inspect3(obj[i], obj) : "";
        }
      }
      var syms = typeof gOPS === "function" ? gOPS(obj) : [];
      var symMap;
      if (hasShammedSymbols) {
        symMap = {};
        for (var k = 0; k < syms.length; k++) {
          symMap["$" + syms[k]] = syms[k];
        }
      }
      for (var key in obj) {
        if (!has(obj, key)) {
          continue;
        }
        if (isArr && String(Number(key)) === key && key < obj.length) {
          continue;
        }
        if (hasShammedSymbols && symMap["$" + key] instanceof Symbol) {
          continue;
        } else if ($test.call(/[^\w$]/, key)) {
          xs.push(inspect3(key, obj) + ": " + inspect3(obj[key], obj));
        } else {
          xs.push(key + ": " + inspect3(obj[key], obj));
        }
      }
      if (typeof gOPS === "function") {
        for (var j = 0; j < syms.length; j++) {
          if (isEnumerable.call(obj, syms[j])) {
            xs.push("[" + inspect3(syms[j]) + "]: " + inspect3(obj[syms[j]], obj));
          }
        }
      }
      return xs;
    }
  }
});

// node_modules/side-channel/index.js
var require_side_channel = __commonJS({
  "node_modules/side-channel/index.js"(exports2, module2) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var callBound = require_callBound();
    var inspect3 = require_object_inspect();
    var $TypeError = require_type2();
    var $WeakMap = GetIntrinsic("%WeakMap%", true);
    var $Map = GetIntrinsic("%Map%", true);
    var $weakMapGet = callBound("WeakMap.prototype.get", true);
    var $weakMapSet = callBound("WeakMap.prototype.set", true);
    var $weakMapHas = callBound("WeakMap.prototype.has", true);
    var $mapGet = callBound("Map.prototype.get", true);
    var $mapSet = callBound("Map.prototype.set", true);
    var $mapHas = callBound("Map.prototype.has", true);
    var listGetNode = function(list, key) {
      var prev = list;
      var curr;
      for (; (curr = prev.next) !== null; prev = curr) {
        if (curr.key === key) {
          prev.next = curr.next;
          curr.next = /** @type {NonNullable<typeof list.next>} */
          list.next;
          list.next = curr;
          return curr;
        }
      }
    };
    var listGet = function(objects, key) {
      var node2 = listGetNode(objects, key);
      return node2 && node2.value;
    };
    var listSet = function(objects, key, value) {
      var node2 = listGetNode(objects, key);
      if (node2) {
        node2.value = value;
      } else {
        objects.next = /** @type {import('.').ListNode<typeof value>} */
        {
          // eslint-disable-line no-param-reassign, no-extra-parens
          key,
          next: objects.next,
          value
        };
      }
    };
    var listHas = function(objects, key) {
      return !!listGetNode(objects, key);
    };
    module2.exports = function getSideChannel() {
      var $wm;
      var $m;
      var $o;
      var channel = {
        assert: function(key) {
          if (!channel.has(key)) {
            throw new $TypeError("Side channel does not contain " + inspect3(key));
          }
        },
        get: function(key) {
          if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
            if ($wm) {
              return $weakMapGet($wm, key);
            }
          } else if ($Map) {
            if ($m) {
              return $mapGet($m, key);
            }
          } else {
            if ($o) {
              return listGet($o, key);
            }
          }
        },
        has: function(key) {
          if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
            if ($wm) {
              return $weakMapHas($wm, key);
            }
          } else if ($Map) {
            if ($m) {
              return $mapHas($m, key);
            }
          } else {
            if ($o) {
              return listHas($o, key);
            }
          }
          return false;
        },
        set: function(key, value) {
          if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
            if (!$wm) {
              $wm = new $WeakMap();
            }
            $weakMapSet($wm, key, value);
          } else if ($Map) {
            if (!$m) {
              $m = new $Map();
            }
            $mapSet($m, key, value);
          } else {
            if (!$o) {
              $o = { key: {}, next: null };
            }
            listSet($o, key, value);
          }
        }
      };
      return channel;
    };
  }
});

// node_modules/qs/lib/formats.js
var require_formats = __commonJS({
  "node_modules/qs/lib/formats.js"(exports2, module2) {
    "use strict";
    var replace = String.prototype.replace;
    var percentTwenties = /%20/g;
    var Format = {
      RFC1738: "RFC1738",
      RFC3986: "RFC3986"
    };
    module2.exports = {
      "default": Format.RFC3986,
      formatters: {
        RFC1738: function(value) {
          return replace.call(value, percentTwenties, "+");
        },
        RFC3986: function(value) {
          return String(value);
        }
      },
      RFC1738: Format.RFC1738,
      RFC3986: Format.RFC3986
    };
  }
});

// node_modules/qs/lib/utils.js
var require_utils = __commonJS({
  "node_modules/qs/lib/utils.js"(exports2, module2) {
    "use strict";
    var formats = require_formats();
    var has = Object.prototype.hasOwnProperty;
    var isArray = Array.isArray;
    var hexTable = function() {
      var array = [];
      for (var i = 0; i < 256; ++i) {
        array.push("%" + ((i < 16 ? "0" : "") + i.toString(16)).toUpperCase());
      }
      return array;
    }();
    var compactQueue = function compactQueue2(queue) {
      while (queue.length > 1) {
        var item = queue.pop();
        var obj = item.obj[item.prop];
        if (isArray(obj)) {
          var compacted = [];
          for (var j = 0; j < obj.length; ++j) {
            if (typeof obj[j] !== "undefined") {
              compacted.push(obj[j]);
            }
          }
          item.obj[item.prop] = compacted;
        }
      }
    };
    var arrayToObject = function arrayToObject2(source, options) {
      var obj = options && options.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
      for (var i = 0; i < source.length; ++i) {
        if (typeof source[i] !== "undefined") {
          obj[i] = source[i];
        }
      }
      return obj;
    };
    var merge2 = function merge3(target, source, options) {
      if (!source) {
        return target;
      }
      if (typeof source !== "object") {
        if (isArray(target)) {
          target.push(source);
        } else if (target && typeof target === "object") {
          if (options && (options.plainObjects || options.allowPrototypes) || !has.call(Object.prototype, source)) {
            target[source] = true;
          }
        } else {
          return [target, source];
        }
        return target;
      }
      if (!target || typeof target !== "object") {
        return [target].concat(source);
      }
      var mergeTarget = target;
      if (isArray(target) && !isArray(source)) {
        mergeTarget = arrayToObject(target, options);
      }
      if (isArray(target) && isArray(source)) {
        source.forEach(function(item, i) {
          if (has.call(target, i)) {
            var targetItem = target[i];
            if (targetItem && typeof targetItem === "object" && item && typeof item === "object") {
              target[i] = merge3(targetItem, item, options);
            } else {
              target.push(item);
            }
          } else {
            target[i] = item;
          }
        });
        return target;
      }
      return Object.keys(source).reduce(function(acc, key) {
        var value = source[key];
        if (has.call(acc, key)) {
          acc[key] = merge3(acc[key], value, options);
        } else {
          acc[key] = value;
        }
        return acc;
      }, mergeTarget);
    };
    var assign = function assignSingleSource(target, source) {
      return Object.keys(source).reduce(function(acc, key) {
        acc[key] = source[key];
        return acc;
      }, target);
    };
    var decode = function(str2, decoder, charset) {
      var strWithoutPlus = str2.replace(/\+/g, " ");
      if (charset === "iso-8859-1") {
        return strWithoutPlus.replace(/%[0-9a-f]{2}/gi, unescape);
      }
      try {
        return decodeURIComponent(strWithoutPlus);
      } catch (e) {
        return strWithoutPlus;
      }
    };
    var limit = 1024;
    var encode = function encode2(str2, defaultEncoder, charset, kind, format6) {
      if (str2.length === 0) {
        return str2;
      }
      var string = str2;
      if (typeof str2 === "symbol") {
        string = Symbol.prototype.toString.call(str2);
      } else if (typeof str2 !== "string") {
        string = String(str2);
      }
      if (charset === "iso-8859-1") {
        return escape(string).replace(/%u[0-9a-f]{4}/gi, function($0) {
          return "%26%23" + parseInt($0.slice(2), 16) + "%3B";
        });
      }
      var out = "";
      for (var j = 0; j < string.length; j += limit) {
        var segment = string.length >= limit ? string.slice(j, j + limit) : string;
        var arr = [];
        for (var i = 0; i < segment.length; ++i) {
          var c2 = segment.charCodeAt(i);
          if (c2 === 45 || c2 === 46 || c2 === 95 || c2 === 126 || c2 >= 48 && c2 <= 57 || c2 >= 65 && c2 <= 90 || c2 >= 97 && c2 <= 122 || format6 === formats.RFC1738 && (c2 === 40 || c2 === 41)) {
            arr[arr.length] = segment.charAt(i);
            continue;
          }
          if (c2 < 128) {
            arr[arr.length] = hexTable[c2];
            continue;
          }
          if (c2 < 2048) {
            arr[arr.length] = hexTable[192 | c2 >> 6] + hexTable[128 | c2 & 63];
            continue;
          }
          if (c2 < 55296 || c2 >= 57344) {
            arr[arr.length] = hexTable[224 | c2 >> 12] + hexTable[128 | c2 >> 6 & 63] + hexTable[128 | c2 & 63];
            continue;
          }
          i += 1;
          c2 = 65536 + ((c2 & 1023) << 10 | segment.charCodeAt(i) & 1023);
          arr[arr.length] = hexTable[240 | c2 >> 18] + hexTable[128 | c2 >> 12 & 63] + hexTable[128 | c2 >> 6 & 63] + hexTable[128 | c2 & 63];
        }
        out += arr.join("");
      }
      return out;
    };
    var compact = function compact2(value) {
      var queue = [{ obj: { o: value }, prop: "o" }];
      var refs = [];
      for (var i = 0; i < queue.length; ++i) {
        var item = queue[i];
        var obj = item.obj[item.prop];
        var keys = Object.keys(obj);
        for (var j = 0; j < keys.length; ++j) {
          var key = keys[j];
          var val = obj[key];
          if (typeof val === "object" && val !== null && refs.indexOf(val) === -1) {
            queue.push({ obj, prop: key });
            refs.push(val);
          }
        }
      }
      compactQueue(queue);
      return value;
    };
    var isRegExp = function isRegExp2(obj) {
      return Object.prototype.toString.call(obj) === "[object RegExp]";
    };
    var isBuffer2 = function isBuffer3(obj) {
      if (!obj || typeof obj !== "object") {
        return false;
      }
      return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));
    };
    var combine = function combine2(a, b) {
      return [].concat(a, b);
    };
    var maybeMap = function maybeMap2(val, fn) {
      if (isArray(val)) {
        var mapped = [];
        for (var i = 0; i < val.length; i += 1) {
          mapped.push(fn(val[i]));
        }
        return mapped;
      }
      return fn(val);
    };
    module2.exports = {
      arrayToObject,
      assign,
      combine,
      compact,
      decode,
      encode,
      isBuffer: isBuffer2,
      isRegExp,
      maybeMap,
      merge: merge2
    };
  }
});

// node_modules/qs/lib/stringify.js
var require_stringify = __commonJS({
  "node_modules/qs/lib/stringify.js"(exports2, module2) {
    "use strict";
    var getSideChannel = require_side_channel();
    var utils = require_utils();
    var formats = require_formats();
    var has = Object.prototype.hasOwnProperty;
    var arrayPrefixGenerators = {
      brackets: function brackets(prefix) {
        return prefix + "[]";
      },
      comma: "comma",
      indices: function indices(prefix, key) {
        return prefix + "[" + key + "]";
      },
      repeat: function repeat3(prefix) {
        return prefix;
      }
    };
    var isArray = Array.isArray;
    var push = Array.prototype.push;
    var pushToArray = function(arr, valueOrArray) {
      push.apply(arr, isArray(valueOrArray) ? valueOrArray : [valueOrArray]);
    };
    var toISO = Date.prototype.toISOString;
    var defaultFormat = formats["default"];
    var defaults = {
      addQueryPrefix: false,
      allowDots: false,
      allowEmptyArrays: false,
      arrayFormat: "indices",
      charset: "utf-8",
      charsetSentinel: false,
      delimiter: "&",
      encode: true,
      encodeDotInKeys: false,
      encoder: utils.encode,
      encodeValuesOnly: false,
      format: defaultFormat,
      formatter: formats.formatters[defaultFormat],
      // deprecated
      indices: false,
      serializeDate: function serializeDate(date) {
        return toISO.call(date);
      },
      skipNulls: false,
      strictNullHandling: false
    };
    var isNonNullishPrimitive = function isNonNullishPrimitive2(v) {
      return typeof v === "string" || typeof v === "number" || typeof v === "boolean" || typeof v === "symbol" || typeof v === "bigint";
    };
    var sentinel = {};
    var stringify3 = function stringify4(object, prefix, generateArrayPrefix, commaRoundTrip, allowEmptyArrays, strictNullHandling, skipNulls, encodeDotInKeys, encoder, filter, sort, allowDots, serializeDate, format6, formatter2, encodeValuesOnly, charset, sideChannel) {
      var obj = object;
      var tmpSc = sideChannel;
      var step = 0;
      var findFlag = false;
      while ((tmpSc = tmpSc.get(sentinel)) !== void 0 && !findFlag) {
        var pos = tmpSc.get(object);
        step += 1;
        if (typeof pos !== "undefined") {
          if (pos === step) {
            throw new RangeError("Cyclic object value");
          } else {
            findFlag = true;
          }
        }
        if (typeof tmpSc.get(sentinel) === "undefined") {
          step = 0;
        }
      }
      if (typeof filter === "function") {
        obj = filter(prefix, obj);
      } else if (obj instanceof Date) {
        obj = serializeDate(obj);
      } else if (generateArrayPrefix === "comma" && isArray(obj)) {
        obj = utils.maybeMap(obj, function(value2) {
          if (value2 instanceof Date) {
            return serializeDate(value2);
          }
          return value2;
        });
      }
      if (obj === null) {
        if (strictNullHandling) {
          return encoder && !encodeValuesOnly ? encoder(prefix, defaults.encoder, charset, "key", format6) : prefix;
        }
        obj = "";
      }
      if (isNonNullishPrimitive(obj) || utils.isBuffer(obj)) {
        if (encoder) {
          var keyValue = encodeValuesOnly ? prefix : encoder(prefix, defaults.encoder, charset, "key", format6);
          return [formatter2(keyValue) + "=" + formatter2(encoder(obj, defaults.encoder, charset, "value", format6))];
        }
        return [formatter2(prefix) + "=" + formatter2(String(obj))];
      }
      var values = [];
      if (typeof obj === "undefined") {
        return values;
      }
      var objKeys;
      if (generateArrayPrefix === "comma" && isArray(obj)) {
        if (encodeValuesOnly && encoder) {
          obj = utils.maybeMap(obj, encoder);
        }
        objKeys = [{ value: obj.length > 0 ? obj.join(",") || null : void 0 }];
      } else if (isArray(filter)) {
        objKeys = filter;
      } else {
        var keys = Object.keys(obj);
        objKeys = sort ? keys.sort(sort) : keys;
      }
      var encodedPrefix = encodeDotInKeys ? prefix.replace(/\./g, "%2E") : prefix;
      var adjustedPrefix = commaRoundTrip && isArray(obj) && obj.length === 1 ? encodedPrefix + "[]" : encodedPrefix;
      if (allowEmptyArrays && isArray(obj) && obj.length === 0) {
        return adjustedPrefix + "[]";
      }
      for (var j = 0; j < objKeys.length; ++j) {
        var key = objKeys[j];
        var value = typeof key === "object" && typeof key.value !== "undefined" ? key.value : obj[key];
        if (skipNulls && value === null) {
          continue;
        }
        var encodedKey = allowDots && encodeDotInKeys ? key.replace(/\./g, "%2E") : key;
        var keyPrefix = isArray(obj) ? typeof generateArrayPrefix === "function" ? generateArrayPrefix(adjustedPrefix, encodedKey) : adjustedPrefix : adjustedPrefix + (allowDots ? "." + encodedKey : "[" + encodedKey + "]");
        sideChannel.set(object, step);
        var valueSideChannel = getSideChannel();
        valueSideChannel.set(sentinel, sideChannel);
        pushToArray(values, stringify4(
          value,
          keyPrefix,
          generateArrayPrefix,
          commaRoundTrip,
          allowEmptyArrays,
          strictNullHandling,
          skipNulls,
          encodeDotInKeys,
          generateArrayPrefix === "comma" && encodeValuesOnly && isArray(obj) ? null : encoder,
          filter,
          sort,
          allowDots,
          serializeDate,
          format6,
          formatter2,
          encodeValuesOnly,
          charset,
          valueSideChannel
        ));
      }
      return values;
    };
    var normalizeStringifyOptions = function normalizeStringifyOptions2(opts) {
      if (!opts) {
        return defaults;
      }
      if (typeof opts.allowEmptyArrays !== "undefined" && typeof opts.allowEmptyArrays !== "boolean") {
        throw new TypeError("`allowEmptyArrays` option can only be `true` or `false`, when provided");
      }
      if (typeof opts.encodeDotInKeys !== "undefined" && typeof opts.encodeDotInKeys !== "boolean") {
        throw new TypeError("`encodeDotInKeys` option can only be `true` or `false`, when provided");
      }
      if (opts.encoder !== null && typeof opts.encoder !== "undefined" && typeof opts.encoder !== "function") {
        throw new TypeError("Encoder has to be a function.");
      }
      var charset = opts.charset || defaults.charset;
      if (typeof opts.charset !== "undefined" && opts.charset !== "utf-8" && opts.charset !== "iso-8859-1") {
        throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
      }
      var format6 = formats["default"];
      if (typeof opts.format !== "undefined") {
        if (!has.call(formats.formatters, opts.format)) {
          throw new TypeError("Unknown format option provided.");
        }
        format6 = opts.format;
      }
      var formatter2 = formats.formatters[format6];
      var filter = defaults.filter;
      if (typeof opts.filter === "function" || isArray(opts.filter)) {
        filter = opts.filter;
      }
      var arrayFormat;
      if (opts.arrayFormat in arrayPrefixGenerators) {
        arrayFormat = opts.arrayFormat;
      } else if ("indices" in opts) {
        arrayFormat = opts.indices ? "indices" : "repeat";
      } else {
        arrayFormat = defaults.arrayFormat;
      }
      if ("commaRoundTrip" in opts && typeof opts.commaRoundTrip !== "boolean") {
        throw new TypeError("`commaRoundTrip` must be a boolean, or absent");
      }
      var allowDots = typeof opts.allowDots === "undefined" ? opts.encodeDotInKeys === true ? true : defaults.allowDots : !!opts.allowDots;
      return {
        addQueryPrefix: typeof opts.addQueryPrefix === "boolean" ? opts.addQueryPrefix : defaults.addQueryPrefix,
        allowDots,
        allowEmptyArrays: typeof opts.allowEmptyArrays === "boolean" ? !!opts.allowEmptyArrays : defaults.allowEmptyArrays,
        arrayFormat,
        charset,
        charsetSentinel: typeof opts.charsetSentinel === "boolean" ? opts.charsetSentinel : defaults.charsetSentinel,
        commaRoundTrip: opts.commaRoundTrip,
        delimiter: typeof opts.delimiter === "undefined" ? defaults.delimiter : opts.delimiter,
        encode: typeof opts.encode === "boolean" ? opts.encode : defaults.encode,
        encodeDotInKeys: typeof opts.encodeDotInKeys === "boolean" ? opts.encodeDotInKeys : defaults.encodeDotInKeys,
        encoder: typeof opts.encoder === "function" ? opts.encoder : defaults.encoder,
        encodeValuesOnly: typeof opts.encodeValuesOnly === "boolean" ? opts.encodeValuesOnly : defaults.encodeValuesOnly,
        filter,
        format: format6,
        formatter: formatter2,
        serializeDate: typeof opts.serializeDate === "function" ? opts.serializeDate : defaults.serializeDate,
        skipNulls: typeof opts.skipNulls === "boolean" ? opts.skipNulls : defaults.skipNulls,
        sort: typeof opts.sort === "function" ? opts.sort : null,
        strictNullHandling: typeof opts.strictNullHandling === "boolean" ? opts.strictNullHandling : defaults.strictNullHandling
      };
    };
    module2.exports = function(object, opts) {
      var obj = object;
      var options = normalizeStringifyOptions(opts);
      var objKeys;
      var filter;
      if (typeof options.filter === "function") {
        filter = options.filter;
        obj = filter("", obj);
      } else if (isArray(options.filter)) {
        filter = options.filter;
        objKeys = filter;
      }
      var keys = [];
      if (typeof obj !== "object" || obj === null) {
        return "";
      }
      var generateArrayPrefix = arrayPrefixGenerators[options.arrayFormat];
      var commaRoundTrip = generateArrayPrefix === "comma" && options.commaRoundTrip;
      if (!objKeys) {
        objKeys = Object.keys(obj);
      }
      if (options.sort) {
        objKeys.sort(options.sort);
      }
      var sideChannel = getSideChannel();
      for (var i = 0; i < objKeys.length; ++i) {
        var key = objKeys[i];
        if (options.skipNulls && obj[key] === null) {
          continue;
        }
        pushToArray(keys, stringify3(
          obj[key],
          key,
          generateArrayPrefix,
          commaRoundTrip,
          options.allowEmptyArrays,
          options.strictNullHandling,
          options.skipNulls,
          options.encodeDotInKeys,
          options.encode ? options.encoder : null,
          options.filter,
          options.sort,
          options.allowDots,
          options.serializeDate,
          options.format,
          options.formatter,
          options.encodeValuesOnly,
          options.charset,
          sideChannel
        ));
      }
      var joined = keys.join(options.delimiter);
      var prefix = options.addQueryPrefix === true ? "?" : "";
      if (options.charsetSentinel) {
        if (options.charset === "iso-8859-1") {
          prefix += "utf8=%26%2310003%3B&";
        } else {
          prefix += "utf8=%E2%9C%93&";
        }
      }
      return joined.length > 0 ? prefix + joined : "";
    };
  }
});

// node_modules/qs/lib/parse.js
var require_parse2 = __commonJS({
  "node_modules/qs/lib/parse.js"(exports2, module2) {
    "use strict";
    var utils = require_utils();
    var has = Object.prototype.hasOwnProperty;
    var isArray = Array.isArray;
    var defaults = {
      allowDots: false,
      allowEmptyArrays: false,
      allowPrototypes: false,
      allowSparse: false,
      arrayLimit: 20,
      charset: "utf-8",
      charsetSentinel: false,
      comma: false,
      decodeDotInKeys: false,
      decoder: utils.decode,
      delimiter: "&",
      depth: 5,
      duplicates: "combine",
      ignoreQueryPrefix: false,
      interpretNumericEntities: false,
      parameterLimit: 1e3,
      parseArrays: true,
      plainObjects: false,
      strictNullHandling: false
    };
    var interpretNumericEntities = function(str2) {
      return str2.replace(/&#(\d+);/g, function($0, numberStr) {
        return String.fromCharCode(parseInt(numberStr, 10));
      });
    };
    var parseArrayValue = function(val, options) {
      if (val && typeof val === "string" && options.comma && val.indexOf(",") > -1) {
        return val.split(",");
      }
      return val;
    };
    var isoSentinel = "utf8=%26%2310003%3B";
    var charsetSentinel = "utf8=%E2%9C%93";
    var parseValues = function parseQueryStringValues(str2, options) {
      var obj = { __proto__: null };
      var cleanStr = options.ignoreQueryPrefix ? str2.replace(/^\?/, "") : str2;
      var limit = options.parameterLimit === Infinity ? void 0 : options.parameterLimit;
      var parts = cleanStr.split(options.delimiter, limit);
      var skipIndex = -1;
      var i;
      var charset = options.charset;
      if (options.charsetSentinel) {
        for (i = 0; i < parts.length; ++i) {
          if (parts[i].indexOf("utf8=") === 0) {
            if (parts[i] === charsetSentinel) {
              charset = "utf-8";
            } else if (parts[i] === isoSentinel) {
              charset = "iso-8859-1";
            }
            skipIndex = i;
            i = parts.length;
          }
        }
      }
      for (i = 0; i < parts.length; ++i) {
        if (i === skipIndex) {
          continue;
        }
        var part = parts[i];
        var bracketEqualsPos = part.indexOf("]=");
        var pos = bracketEqualsPos === -1 ? part.indexOf("=") : bracketEqualsPos + 1;
        var key, val;
        if (pos === -1) {
          key = options.decoder(part, defaults.decoder, charset, "key");
          val = options.strictNullHandling ? null : "";
        } else {
          key = options.decoder(part.slice(0, pos), defaults.decoder, charset, "key");
          val = utils.maybeMap(
            parseArrayValue(part.slice(pos + 1), options),
            function(encodedVal) {
              return options.decoder(encodedVal, defaults.decoder, charset, "value");
            }
          );
        }
        if (val && options.interpretNumericEntities && charset === "iso-8859-1") {
          val = interpretNumericEntities(val);
        }
        if (part.indexOf("[]=") > -1) {
          val = isArray(val) ? [val] : val;
        }
        var existing = has.call(obj, key);
        if (existing && options.duplicates === "combine") {
          obj[key] = utils.combine(obj[key], val);
        } else if (!existing || options.duplicates === "last") {
          obj[key] = val;
        }
      }
      return obj;
    };
    var parseObject = function(chain, val, options, valuesParsed) {
      var leaf = valuesParsed ? val : parseArrayValue(val, options);
      for (var i = chain.length - 1; i >= 0; --i) {
        var obj;
        var root = chain[i];
        if (root === "[]" && options.parseArrays) {
          obj = options.allowEmptyArrays && leaf === "" ? [] : [].concat(leaf);
        } else {
          obj = options.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
          var cleanRoot = root.charAt(0) === "[" && root.charAt(root.length - 1) === "]" ? root.slice(1, -1) : root;
          var decodedRoot = options.decodeDotInKeys ? cleanRoot.replace(/%2E/g, ".") : cleanRoot;
          var index = parseInt(decodedRoot, 10);
          if (!options.parseArrays && decodedRoot === "") {
            obj = { 0: leaf };
          } else if (!isNaN(index) && root !== decodedRoot && String(index) === decodedRoot && index >= 0 && (options.parseArrays && index <= options.arrayLimit)) {
            obj = [];
            obj[index] = leaf;
          } else if (decodedRoot !== "__proto__") {
            obj[decodedRoot] = leaf;
          }
        }
        leaf = obj;
      }
      return leaf;
    };
    var parseKeys = function parseQueryStringKeys(givenKey, val, options, valuesParsed) {
      if (!givenKey) {
        return;
      }
      var key = options.allowDots ? givenKey.replace(/\.([^.[]+)/g, "[$1]") : givenKey;
      var brackets = /(\[[^[\]]*])/;
      var child = /(\[[^[\]]*])/g;
      var segment = options.depth > 0 && brackets.exec(key);
      var parent = segment ? key.slice(0, segment.index) : key;
      var keys = [];
      if (parent) {
        if (!options.plainObjects && has.call(Object.prototype, parent)) {
          if (!options.allowPrototypes) {
            return;
          }
        }
        keys.push(parent);
      }
      var i = 0;
      while (options.depth > 0 && (segment = child.exec(key)) !== null && i < options.depth) {
        i += 1;
        if (!options.plainObjects && has.call(Object.prototype, segment[1].slice(1, -1))) {
          if (!options.allowPrototypes) {
            return;
          }
        }
        keys.push(segment[1]);
      }
      if (segment) {
        keys.push("[" + key.slice(segment.index) + "]");
      }
      return parseObject(keys, val, options, valuesParsed);
    };
    var normalizeParseOptions = function normalizeParseOptions2(opts) {
      if (!opts) {
        return defaults;
      }
      if (typeof opts.allowEmptyArrays !== "undefined" && typeof opts.allowEmptyArrays !== "boolean") {
        throw new TypeError("`allowEmptyArrays` option can only be `true` or `false`, when provided");
      }
      if (typeof opts.decodeDotInKeys !== "undefined" && typeof opts.decodeDotInKeys !== "boolean") {
        throw new TypeError("`decodeDotInKeys` option can only be `true` or `false`, when provided");
      }
      if (opts.decoder !== null && typeof opts.decoder !== "undefined" && typeof opts.decoder !== "function") {
        throw new TypeError("Decoder has to be a function.");
      }
      if (typeof opts.charset !== "undefined" && opts.charset !== "utf-8" && opts.charset !== "iso-8859-1") {
        throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
      }
      var charset = typeof opts.charset === "undefined" ? defaults.charset : opts.charset;
      var duplicates = typeof opts.duplicates === "undefined" ? defaults.duplicates : opts.duplicates;
      if (duplicates !== "combine" && duplicates !== "first" && duplicates !== "last") {
        throw new TypeError("The duplicates option must be either combine, first, or last");
      }
      var allowDots = typeof opts.allowDots === "undefined" ? opts.decodeDotInKeys === true ? true : defaults.allowDots : !!opts.allowDots;
      return {
        allowDots,
        allowEmptyArrays: typeof opts.allowEmptyArrays === "boolean" ? !!opts.allowEmptyArrays : defaults.allowEmptyArrays,
        allowPrototypes: typeof opts.allowPrototypes === "boolean" ? opts.allowPrototypes : defaults.allowPrototypes,
        allowSparse: typeof opts.allowSparse === "boolean" ? opts.allowSparse : defaults.allowSparse,
        arrayLimit: typeof opts.arrayLimit === "number" ? opts.arrayLimit : defaults.arrayLimit,
        charset,
        charsetSentinel: typeof opts.charsetSentinel === "boolean" ? opts.charsetSentinel : defaults.charsetSentinel,
        comma: typeof opts.comma === "boolean" ? opts.comma : defaults.comma,
        decodeDotInKeys: typeof opts.decodeDotInKeys === "boolean" ? opts.decodeDotInKeys : defaults.decodeDotInKeys,
        decoder: typeof opts.decoder === "function" ? opts.decoder : defaults.decoder,
        delimiter: typeof opts.delimiter === "string" || utils.isRegExp(opts.delimiter) ? opts.delimiter : defaults.delimiter,
        // eslint-disable-next-line no-implicit-coercion, no-extra-parens
        depth: typeof opts.depth === "number" || opts.depth === false ? +opts.depth : defaults.depth,
        duplicates,
        ignoreQueryPrefix: opts.ignoreQueryPrefix === true,
        interpretNumericEntities: typeof opts.interpretNumericEntities === "boolean" ? opts.interpretNumericEntities : defaults.interpretNumericEntities,
        parameterLimit: typeof opts.parameterLimit === "number" ? opts.parameterLimit : defaults.parameterLimit,
        parseArrays: opts.parseArrays !== false,
        plainObjects: typeof opts.plainObjects === "boolean" ? opts.plainObjects : defaults.plainObjects,
        strictNullHandling: typeof opts.strictNullHandling === "boolean" ? opts.strictNullHandling : defaults.strictNullHandling
      };
    };
    module2.exports = function(str2, opts) {
      var options = normalizeParseOptions(opts);
      if (str2 === "" || str2 === null || typeof str2 === "undefined") {
        return options.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
      }
      var tempObj = typeof str2 === "string" ? parseValues(str2, options) : str2;
      var obj = options.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
      var keys = Object.keys(tempObj);
      for (var i = 0; i < keys.length; ++i) {
        var key = keys[i];
        var newObj = parseKeys(key, tempObj[key], options, typeof str2 === "string");
        obj = utils.merge(obj, newObj, options);
      }
      if (options.allowSparse === true) {
        return obj;
      }
      return utils.compact(obj);
    };
  }
});

// node_modules/qs/lib/index.js
var require_lib10 = __commonJS({
  "node_modules/qs/lib/index.js"(exports2, module2) {
    "use strict";
    var stringify3 = require_stringify();
    var parse6 = require_parse2();
    var formats = require_formats();
    module2.exports = {
      formats,
      parse: parse6,
      stringify: stringify3
    };
  }
});

// node_modules/@readme/openapi-parser/lib/util.js
var require_util = __commonJS({
  "node_modules/@readme/openapi-parser/lib/util.js"(exports2) {
    var util2 = require("util");
    var url = require_url();
    exports2.format = util2.format;
    exports2.inherits = util2.inherits;
    exports2.swaggerParamRegExp = /\{([^/}]+)}/g;
    var operationsList = ["get", "post", "put", "delete", "patch", "options", "head", "trace"];
    function fixServers(server, path) {
      if (server.url && server.url.startsWith("/")) {
        const inUrl = url.parse(path);
        const finalUrl = `${inUrl.protocol}//${inUrl.hostname}${server.url}`;
        server.url = finalUrl;
      }
      return server;
    }
    function fixOasRelativeServers(schema2, filePath) {
      if (schema2.openapi && filePath && (filePath.startsWith("http:") || filePath.startsWith("https:"))) {
        if (schema2.servers) {
          schema2.servers.map((server) => fixServers(server, filePath));
        }
        ["paths", "webhooks"].forEach((component) => {
          Object.keys(schema2[component] || []).forEach((path) => {
            const pathItem = schema2[component][path];
            Object.keys(pathItem).forEach((opItem) => {
              if (opItem === "servers") {
                pathItem[opItem].map((server) => fixServers(server, filePath));
              } else if (operationsList.includes(opItem)) {
                if (pathItem[opItem].servers) {
                  pathItem[opItem].servers.map((server) => fixServers(server, filePath));
                }
              }
            });
          });
        });
      } else {
      }
    }
    function getSpecificationName(schema2) {
      return schema2.swagger ? "Swagger" : "OpenAPI";
    }
    exports2.fixOasRelativeServers = fixOasRelativeServers;
    exports2.getSpecificationName = getSpecificationName;
  }
});

// node_modules/@babel/runtime/helpers/interopRequireDefault.js
var require_interopRequireDefault = __commonJS({
  "node_modules/@babel/runtime/helpers/interopRequireDefault.js"(exports2, module2) {
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : {
        "default": e
      };
    }
    module2.exports = _interopRequireDefault, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
  }
});

// node_modules/@humanwhocodes/momoa/api.js
var require_api = __commonJS({
  "node_modules/@humanwhocodes/momoa/api.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var LBRACKET = "[";
    var RBRACKET = "]";
    var LBRACE = "{";
    var RBRACE = "}";
    var COLON = ":";
    var COMMA = ",";
    var TRUE = "true";
    var FALSE = "false";
    var NULL = "null";
    var QUOTE = '"';
    var expectedKeywords = /* @__PURE__ */ new Map([
      ["t", TRUE],
      ["f", FALSE],
      ["n", NULL]
    ]);
    var escapeToChar = /* @__PURE__ */ new Map([
      [QUOTE, QUOTE],
      ["\\", "\\"],
      ["/", "/"],
      ["b", "\b"],
      ["n", "\n"],
      ["f", "\f"],
      ["r", "\r"],
      ["t", "	"]
    ]);
    var knownTokenTypes = /* @__PURE__ */ new Map([
      [LBRACKET, "Punctuator"],
      [RBRACKET, "Punctuator"],
      [LBRACE, "Punctuator"],
      [RBRACE, "Punctuator"],
      [COLON, "Punctuator"],
      [COMMA, "Punctuator"],
      [TRUE, "Boolean"],
      [FALSE, "Boolean"],
      [NULL, "Null"]
    ]);
    var ErrorWithLocation = class extends Error {
      /**
       * 
       * @param {string} message The error message to report. 
       * @param {int} loc.line The line on which the error occurred.
       * @param {int} loc.column The column in the line where the error occurrred.
       * @param {int} loc.index The index in the string where the error occurred.
       */
      constructor(message, { line, column, index }) {
        super(`${message} (${line}:${column})`);
        this.line = line;
        this.column = column;
        this.index = index;
      }
    };
    var UnexpectedChar = class extends ErrorWithLocation {
      /**
       * Creates a new instance.
       * @param {string} unexpected The character that was found.
       * @param {Object} loc The location information for the found character.
       */
      constructor(unexpected, loc) {
        super(`Unexpected character ${unexpected} found.`, loc);
      }
    };
    var UnexpectedToken = class extends ErrorWithLocation {
      /**
       * Creates a new instance.
       * @param {string} expected The character that was expected. 
       * @param {string} unexpected The character that was found.
       * @param {Object} loc The location information for the found character.
       */
      constructor(token) {
        super(`Unexpected token ${token.type}(${token.value}) found.`, token.loc.start);
      }
    };
    var UnexpectedEOF = class extends ErrorWithLocation {
      /**
       * Creates a new instance.
       * @param {Object} loc The location information for the found character.
       */
      constructor(loc) {
        super("Unexpected end of input found.", loc);
      }
    };
    var QUOTE$1 = '"';
    var SLASH = "/";
    var STAR = "*";
    var DEFAULT_OPTIONS = {
      comments: false,
      ranges: false
    };
    function isWhitespace2(c2) {
      return /[\s\n]/.test(c2);
    }
    function isDigit2(c2) {
      return c2 >= "0" && c2 <= "9";
    }
    function isHexDigit(c2) {
      return isDigit2(c2) || /[a-f]/i.test(c2);
    }
    function isPositiveDigit(c2) {
      return c2 >= "1" && c2 <= "9";
    }
    function isKeywordStart(c2) {
      return /[tfn]/.test(c2);
    }
    function isNumberStart(c2) {
      return isDigit2(c2) || c2 === "." || c2 === "-";
    }
    function tokenize(text, options) {
      options = Object.freeze({
        ...DEFAULT_OPTIONS,
        ...options
      });
      let offset = -1;
      let line = 1;
      let column = 0;
      let newLine = false;
      const tokens = [];
      function createToken(tokenType, value, startLoc, endLoc) {
        const endOffset = startLoc.offset + value.length;
        let range = options.ranges ? {
          range: [startLoc.offset, endOffset]
        } : void 0;
        return {
          type: tokenType,
          value,
          loc: {
            start: startLoc,
            end: endLoc || {
              line: startLoc.line,
              column: startLoc.column + value.length,
              offset: endOffset
            }
          },
          ...range
        };
      }
      function next() {
        let c3 = text.charAt(++offset);
        if (newLine) {
          line++;
          column = 1;
          newLine = false;
        } else {
          column++;
        }
        if (c3 === "\r") {
          newLine = true;
          if (text.charAt(offset + 1) === "\n") {
            offset++;
          }
        } else if (c3 === "\n") {
          newLine = true;
        }
        return c3;
      }
      function locate() {
        return {
          line,
          column,
          offset
        };
      }
      function readKeyword(c3) {
        let value = expectedKeywords.get(c3);
        if (text.slice(offset, offset + value.length) === value) {
          offset += value.length - 1;
          column += value.length - 1;
          return { value, c: next() };
        }
        for (let j = 1; j < value.length; j++) {
          if (value[j] !== text.charAt(offset + j)) {
            unexpected(next());
          }
        }
      }
      function readString(c3) {
        let value = c3;
        c3 = next();
        while (c3 && c3 !== QUOTE$1) {
          if (c3 === "\\") {
            value += c3;
            c3 = next();
            if (escapeToChar.has(c3)) {
              value += c3;
            } else if (c3 === "u") {
              value += c3;
              for (let i = 0; i < 4; i++) {
                c3 = next();
                if (isHexDigit(c3)) {
                  value += c3;
                } else {
                  unexpected(c3);
                }
              }
            } else {
              unexpected(c3);
            }
          } else {
            value += c3;
          }
          c3 = next();
        }
        if (!c3) {
          unexpectedEOF();
        }
        value += c3;
        return { value, c: next() };
      }
      function readNumber(c3) {
        let value = "";
        if (c3 === "-") {
          value += c3;
          c3 = next();
          if (!isDigit2(c3)) {
            unexpected(c3);
          }
        }
        if (c3 === "0") {
          value += c3;
          c3 = next();
          if (isDigit2(c3)) {
            unexpected(c3);
          }
        } else {
          if (!isPositiveDigit(c3)) {
            unexpected(c3);
          }
          do {
            value += c3;
            c3 = next();
          } while (isDigit2(c3));
        }
        if (c3 === ".") {
          do {
            value += c3;
            c3 = next();
          } while (isDigit2(c3));
        }
        if (c3 === "e" || c3 === "E") {
          value += c3;
          c3 = next();
          if (c3 === "+" || c3 === "-") {
            value += c3;
            c3 = next();
          }
          if (!isDigit2(c3)) {
            unexpected(c3);
          }
          while (isDigit2(c3)) {
            value += c3;
            c3 = next();
          }
        }
        return { value, c: c3 };
      }
      function readComment(c3) {
        let value = c3;
        c3 = next();
        if (c3 === "/") {
          do {
            value += c3;
            c3 = next();
          } while (c3 && c3 !== "\r" && c3 !== "\n");
          return { value, c: c3 };
        }
        if (c3 === STAR) {
          while (c3) {
            value += c3;
            c3 = next();
            if (c3 === STAR) {
              value += c3;
              c3 = next();
              if (c3 === SLASH) {
                value += c3;
                c3 = next();
                return { value, c: c3 };
              }
            }
          }
          unexpectedEOF();
        }
        unexpected(c3);
      }
      function unexpected(c3) {
        throw new UnexpectedChar(c3, locate());
      }
      function unexpectedEOF() {
        throw new UnexpectedEOF(locate());
      }
      let c2 = next();
      while (offset < text.length) {
        while (isWhitespace2(c2)) {
          c2 = next();
        }
        if (!c2) {
          break;
        }
        const start = locate();
        if (knownTokenTypes.has(c2)) {
          tokens.push(createToken(knownTokenTypes.get(c2), c2, start));
          c2 = next();
        } else if (isKeywordStart(c2)) {
          const result = readKeyword(c2);
          let value = result.value;
          c2 = result.c;
          tokens.push(createToken(knownTokenTypes.get(value), value, start));
        } else if (isNumberStart(c2)) {
          const result = readNumber(c2);
          let value = result.value;
          c2 = result.c;
          tokens.push(createToken("Number", value, start));
        } else if (c2 === QUOTE$1) {
          const result = readString(c2);
          let value = result.value;
          c2 = result.c;
          tokens.push(createToken("String", value, start));
        } else if (c2 === SLASH && options.comments) {
          const result = readComment(c2);
          let value = result.value;
          c2 = result.c;
          tokens.push(createToken(value.startsWith("//") ? "LineComment" : "BlockComment", value, start, locate()));
        } else {
          unexpected(c2);
        }
      }
      return tokens;
    }
    var types3 = {
      document(body, parts = {}) {
        return {
          type: "Document",
          body,
          ...parts
        };
      },
      string(value, parts = {}) {
        return {
          type: "String",
          value,
          ...parts
        };
      },
      number(value, parts = {}) {
        return {
          type: "Number",
          value,
          ...parts
        };
      },
      boolean(value, parts = {}) {
        return {
          type: "Boolean",
          value,
          ...parts
        };
      },
      null(parts = {}) {
        return {
          type: "Null",
          value: "null",
          ...parts
        };
      },
      array(elements, parts = {}) {
        return {
          type: "Array",
          elements,
          ...parts
        };
      },
      object(members, parts = {}) {
        return {
          type: "Object",
          members,
          ...parts
        };
      },
      member(name, value, parts = {}) {
        return {
          type: "Member",
          name,
          value,
          ...parts
        };
      }
    };
    var DEFAULT_OPTIONS$1 = {
      tokens: false,
      comments: false,
      ranges: false
    };
    function getStringValue(token) {
      let value = token.value.slice(1, -1);
      let result = "";
      let escapeIndex = value.indexOf("\\");
      let lastIndex = 0;
      while (escapeIndex >= 0) {
        result += value.slice(lastIndex, escapeIndex);
        const escapeChar = value.charAt(escapeIndex + 1);
        if (escapeToChar.has(escapeChar)) {
          result += escapeToChar.get(escapeChar);
          lastIndex = escapeIndex + 2;
        } else if (escapeChar === "u") {
          const hexCode = value.slice(escapeIndex + 2, escapeIndex + 6);
          if (hexCode.length < 4 || /[^0-9a-f]/i.test(hexCode)) {
            throw new ErrorWithLocation(
              `Invalid unicode escape \\u${hexCode}.`,
              {
                line: token.loc.start.line,
                column: token.loc.start.column + escapeIndex,
                offset: token.loc.start.offset + escapeIndex
              }
            );
          }
          result += String.fromCharCode(parseInt(hexCode, 16));
          lastIndex = escapeIndex + 6;
        } else {
          throw new ErrorWithLocation(
            `Invalid escape \\${escapeChar}.`,
            {
              line: token.loc.start.line,
              column: token.loc.start.column + escapeIndex,
              offset: token.loc.start.offset + escapeIndex
            }
          );
        }
        escapeIndex = value.indexOf("\\", lastIndex);
      }
      result += value.slice(lastIndex);
      return result;
    }
    function getLiteralValue(token) {
      switch (token.type) {
        case "Boolean":
          return token.value === "true";
        case "Number":
          return Number(token.value);
        case "Null":
          return null;
        case "String":
          return getStringValue(token);
      }
    }
    function parse6(text, options) {
      options = Object.freeze({
        ...DEFAULT_OPTIONS$1,
        ...options
      });
      const tokens = tokenize(text, {
        comments: !!options.comments,
        ranges: !!options.ranges
      });
      let tokenIndex = 0;
      function nextNoComments() {
        return tokens[tokenIndex++];
      }
      function nextSkipComments() {
        const nextToken = tokens[tokenIndex++];
        if (nextToken && nextToken.type.endsWith("Comment")) {
          return nextSkipComments();
        }
        return nextToken;
      }
      const next = options.comments ? nextSkipComments : nextNoComments;
      function assertTokenValue(token, value) {
        if (!token || token.value !== value) {
          throw new UnexpectedToken(token);
        }
      }
      function assertTokenType(token, type2) {
        if (!token || token.type !== type2) {
          throw new UnexpectedToken(token);
        }
      }
      function createRange(start, end) {
        return options.ranges ? {
          range: [start.offset, end.offset]
        } : void 0;
      }
      function createLiteralNode(token) {
        const range = createRange(token.loc.start, token.loc.end);
        return {
          type: token.type,
          value: getLiteralValue(token),
          loc: {
            start: {
              ...token.loc.start
            },
            end: {
              ...token.loc.end
            }
          },
          ...range
        };
      }
      function parseProperty(token) {
        assertTokenType(token, "String");
        const name = createLiteralNode(token);
        token = next();
        assertTokenValue(token, ":");
        const value = parseValue();
        const range = createRange(name.loc.start, value.loc.end);
        return types3.member(name, value, {
          loc: {
            start: {
              ...name.loc.start
            },
            end: {
              ...value.loc.end
            }
          },
          ...range
        });
      }
      function parseObject(firstToken) {
        assertTokenValue(firstToken, "{");
        const members = [];
        let token = next();
        if (token && token.value !== "}") {
          do {
            members.push(parseProperty(token));
            token = next();
            if (token.value === ",") {
              token = next();
            } else {
              break;
            }
          } while (token);
        }
        assertTokenValue(token, "}");
        const range = createRange(firstToken.loc.start, token.loc.end);
        return types3.object(members, {
          loc: {
            start: {
              ...firstToken.loc.start
            },
            end: {
              ...token.loc.end
            }
          },
          ...range
        });
      }
      function parseArray(firstToken) {
        assertTokenValue(firstToken, "[");
        const elements = [];
        let token = next();
        if (token && token.value !== "]") {
          do {
            elements.push(parseValue(token));
            token = next();
            if (token.value === ",") {
              token = next();
            } else {
              break;
            }
          } while (token);
        }
        assertTokenValue(token, "]");
        const range = createRange(firstToken.loc.start, token.loc.end);
        return types3.array(elements, {
          type: "Array",
          elements,
          loc: {
            start: {
              ...firstToken.loc.start
            },
            end: {
              ...token.loc.end
            }
          },
          ...range
        });
      }
      function parseValue(token) {
        token = token || next();
        switch (token.type) {
          case "String":
          case "Boolean":
          case "Number":
          case "Null":
            return createLiteralNode(token);
          case "Punctuator":
            if (token.value === "{") {
              return parseObject(token);
            } else if (token.value === "[") {
              return parseArray(token);
            }
          default:
            throw new UnexpectedToken(token);
        }
      }
      const docBody = parseValue();
      const unexpectedToken = next();
      if (unexpectedToken) {
        throw new UnexpectedToken(unexpectedToken);
      }
      const docParts = {
        loc: {
          start: {
            line: 1,
            column: 1,
            offset: 0
          },
          end: {
            ...docBody.loc.end
          }
        }
      };
      if (options.tokens) {
        docParts.tokens = tokens;
      }
      if (options.ranges) {
        docParts.range = createRange(docParts.loc.start, docParts.loc.end);
      }
      return types3.document(docBody, docParts);
    }
    var childKeys = /* @__PURE__ */ new Map([
      ["Document", ["body"]],
      ["Object", ["members"]],
      ["Member", ["name", "value"]],
      ["Array", ["elements"]],
      ["String", []],
      ["Number", []],
      ["Boolean", []],
      ["Null", []]
    ]);
    function isObject5(value) {
      return value && typeof value === "object";
    }
    function isNode(value) {
      return isObject5(value) && typeof value.type === "string";
    }
    function traverse(root, visitor) {
      function visitNode(node2, parent) {
        if (typeof visitor.enter === "function") {
          visitor.enter(node2, parent);
        }
        for (const key of childKeys.get(node2.type)) {
          const value = node2[key];
          if (isObject5(value)) {
            if (Array.isArray(value)) {
              value.forEach((child) => visitNode(child, node2));
            } else if (isNode(value)) {
              visitNode(value, node2);
            }
          }
        }
        if (typeof visitor.exit === "function") {
          visitor.exit(node2, parent);
        }
      }
      visitNode(root);
    }
    function iterator(root, filter = () => true) {
      const traversal = [];
      traverse(root, {
        enter(node2, parent) {
          traversal.push({ node: node2, parent, phase: "enter" });
        },
        exit(node2, parent) {
          traversal.push({ node: node2, parent, phase: "exit" });
        }
      });
      return traversal.filter(filter).values();
    }
    function evaluate(node2) {
      switch (node2.type) {
        case "String":
        case "Number":
        case "Boolean":
          return node2.value;
        case "Null":
          return null;
        case "Array":
          return node2.elements.map(evaluate);
        case "Object": {
          const object = {};
          node2.members.forEach((member) => {
            object[evaluate(member.name)] = evaluate(member.value);
          });
          return object;
        }
        case "Document":
          return evaluate(node2.body);
        case "Property":
          throw new Error("Cannot evaluate object property outside of an object.");
        default:
          throw new Error(`Unknown node type ${node2.type}.`);
      }
    }
    function print(node2, { indent = 0 } = {}) {
      const value = evaluate(node2);
      return JSON.stringify(value, null, indent);
    }
    exports2.evaluate = evaluate;
    exports2.iterator = iterator;
    exports2.parse = parse6;
    exports2.print = print;
    exports2.tokenize = tokenize;
    exports2.traverse = traverse;
    exports2.types = types3;
  }
});

// node_modules/@babel/runtime/helpers/typeof.js
var require_typeof = __commonJS({
  "node_modules/@babel/runtime/helpers/typeof.js"(exports2, module2) {
    function _typeof(o) {
      "@babel/helpers - typeof";
      return module2.exports = _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, module2.exports.__esModule = true, module2.exports["default"] = module2.exports, _typeof(o);
    }
    module2.exports = _typeof, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
  }
});

// node_modules/@babel/runtime/helpers/toPrimitive.js
var require_toPrimitive = __commonJS({
  "node_modules/@babel/runtime/helpers/toPrimitive.js"(exports2, module2) {
    var _typeof = require_typeof()["default"];
    function toPrimitive(t, r2) {
      if ("object" != _typeof(t) || !t) return t;
      var e = t[Symbol.toPrimitive];
      if (void 0 !== e) {
        var i = e.call(t, r2 || "default");
        if ("object" != _typeof(i)) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r2 ? String : Number)(t);
    }
    module2.exports = toPrimitive, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
  }
});

// node_modules/@babel/runtime/helpers/toPropertyKey.js
var require_toPropertyKey = __commonJS({
  "node_modules/@babel/runtime/helpers/toPropertyKey.js"(exports2, module2) {
    var _typeof = require_typeof()["default"];
    var toPrimitive = require_toPrimitive();
    function toPropertyKey(t) {
      var i = toPrimitive(t, "string");
      return "symbol" == _typeof(i) ? i : i + "";
    }
    module2.exports = toPropertyKey, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
  }
});

// node_modules/@babel/runtime/helpers/defineProperty.js
var require_defineProperty2 = __commonJS({
  "node_modules/@babel/runtime/helpers/defineProperty.js"(exports2, module2) {
    var toPropertyKey = require_toPropertyKey();
    function _defineProperty(e, r2, t) {
      return (r2 = toPropertyKey(r2)) in e ? Object.defineProperty(e, r2, {
        value: t,
        enumerable: true,
        configurable: true,
        writable: true
      }) : e[r2] = t, e;
    }
    module2.exports = _defineProperty, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
  }
});

// node_modules/@babel/runtime/helpers/arrayLikeToArray.js
var require_arrayLikeToArray = __commonJS({
  "node_modules/@babel/runtime/helpers/arrayLikeToArray.js"(exports2, module2) {
    function _arrayLikeToArray(r2, a) {
      (null == a || a > r2.length) && (a = r2.length);
      for (var e = 0, n = Array(a); e < a; e++) n[e] = r2[e];
      return n;
    }
    module2.exports = _arrayLikeToArray, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
  }
});

// node_modules/@babel/runtime/helpers/arrayWithoutHoles.js
var require_arrayWithoutHoles = __commonJS({
  "node_modules/@babel/runtime/helpers/arrayWithoutHoles.js"(exports2, module2) {
    var arrayLikeToArray = require_arrayLikeToArray();
    function _arrayWithoutHoles(r2) {
      if (Array.isArray(r2)) return arrayLikeToArray(r2);
    }
    module2.exports = _arrayWithoutHoles, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
  }
});

// node_modules/@babel/runtime/helpers/iterableToArray.js
var require_iterableToArray = __commonJS({
  "node_modules/@babel/runtime/helpers/iterableToArray.js"(exports2, module2) {
    function _iterableToArray(r2) {
      if ("undefined" != typeof Symbol && null != r2[Symbol.iterator] || null != r2["@@iterator"]) return Array.from(r2);
    }
    module2.exports = _iterableToArray, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
  }
});

// node_modules/@babel/runtime/helpers/unsupportedIterableToArray.js
var require_unsupportedIterableToArray = __commonJS({
  "node_modules/@babel/runtime/helpers/unsupportedIterableToArray.js"(exports2, module2) {
    var arrayLikeToArray = require_arrayLikeToArray();
    function _unsupportedIterableToArray(r2, a) {
      if (r2) {
        if ("string" == typeof r2) return arrayLikeToArray(r2, a);
        var t = {}.toString.call(r2).slice(8, -1);
        return "Object" === t && r2.constructor && (t = r2.constructor.name), "Map" === t || "Set" === t ? Array.from(r2) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? arrayLikeToArray(r2, a) : void 0;
      }
    }
    module2.exports = _unsupportedIterableToArray, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
  }
});

// node_modules/@babel/runtime/helpers/nonIterableSpread.js
var require_nonIterableSpread = __commonJS({
  "node_modules/@babel/runtime/helpers/nonIterableSpread.js"(exports2, module2) {
    function _nonIterableSpread() {
      throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    module2.exports = _nonIterableSpread, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
  }
});

// node_modules/@babel/runtime/helpers/toConsumableArray.js
var require_toConsumableArray = __commonJS({
  "node_modules/@babel/runtime/helpers/toConsumableArray.js"(exports2, module2) {
    var arrayWithoutHoles = require_arrayWithoutHoles();
    var iterableToArray = require_iterableToArray();
    var unsupportedIterableToArray = require_unsupportedIterableToArray();
    var nonIterableSpread = require_nonIterableSpread();
    function _toConsumableArray(r2) {
      return arrayWithoutHoles(r2) || iterableToArray(r2) || unsupportedIterableToArray(r2) || nonIterableSpread();
    }
    module2.exports = _toConsumableArray, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
  }
});

// node_modules/@babel/runtime/helpers/arrayWithHoles.js
var require_arrayWithHoles = __commonJS({
  "node_modules/@babel/runtime/helpers/arrayWithHoles.js"(exports2, module2) {
    function _arrayWithHoles(r2) {
      if (Array.isArray(r2)) return r2;
    }
    module2.exports = _arrayWithHoles, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
  }
});

// node_modules/@babel/runtime/helpers/iterableToArrayLimit.js
var require_iterableToArrayLimit = __commonJS({
  "node_modules/@babel/runtime/helpers/iterableToArrayLimit.js"(exports2, module2) {
    function _iterableToArrayLimit(r2, l) {
      var t = null == r2 ? null : "undefined" != typeof Symbol && r2[Symbol.iterator] || r2["@@iterator"];
      if (null != t) {
        var e, n, i, u, a = [], f = true, o = false;
        try {
          if (i = (t = t.call(r2)).next, 0 === l) {
            if (Object(t) !== t) return;
            f = false;
          } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = true) ;
        } catch (r3) {
          o = true, n = r3;
        } finally {
          try {
            if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return;
          } finally {
            if (o) throw n;
          }
        }
        return a;
      }
    }
    module2.exports = _iterableToArrayLimit, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
  }
});

// node_modules/@babel/runtime/helpers/nonIterableRest.js
var require_nonIterableRest = __commonJS({
  "node_modules/@babel/runtime/helpers/nonIterableRest.js"(exports2, module2) {
    function _nonIterableRest() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    module2.exports = _nonIterableRest, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
  }
});

// node_modules/@babel/runtime/helpers/slicedToArray.js
var require_slicedToArray = __commonJS({
  "node_modules/@babel/runtime/helpers/slicedToArray.js"(exports2, module2) {
    var arrayWithHoles = require_arrayWithHoles();
    var iterableToArrayLimit = require_iterableToArrayLimit();
    var unsupportedIterableToArray = require_unsupportedIterableToArray();
    var nonIterableRest = require_nonIterableRest();
    function _slicedToArray(r2, e) {
      return arrayWithHoles(r2) || iterableToArrayLimit(r2, e) || unsupportedIterableToArray(r2, e) || nonIterableRest();
    }
    module2.exports = _slicedToArray, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
  }
});

// node_modules/@readme/better-ajv-errors/lib/utils.js
var require_utils2 = __commonJS({
  "node_modules/@readme/better-ajv-errors/lib/utils.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.notUndefined = exports2.isRequiredError = exports2.isEnumError = exports2.isAnyOfError = exports2.getSiblings = exports2.getErrors = exports2.getChildren = exports2.concatAll = void 0;
    var eq = function eq2(x) {
      return function(y) {
        return x === y;
      };
    };
    var not = function not2(fn) {
      return function(x) {
        return !fn(x);
      };
    };
    var getValues = function getValues2(o) {
      return Object.values(o);
    };
    var notUndefined = function notUndefined2(x) {
      return x !== void 0;
    };
    exports2.notUndefined = notUndefined;
    var isXError = function isXError2(x) {
      return function(error) {
        return error.keyword === x;
      };
    };
    var isRequiredError = isXError("required");
    exports2.isRequiredError = isRequiredError;
    var isAnyOfError = isXError("anyOf");
    exports2.isAnyOfError = isAnyOfError;
    var isEnumError = isXError("enum");
    exports2.isEnumError = isEnumError;
    var getErrors = function getErrors2(node2) {
      return node2 && node2.errors || [];
    };
    exports2.getErrors = getErrors;
    var getChildren = function getChildren2(node2) {
      return node2 && getValues(node2.children) || [];
    };
    exports2.getChildren = getChildren;
    var getSiblings = function getSiblings2(parent) {
      return function(node2) {
        return getChildren(parent).filter(not(eq(node2)));
      };
    };
    exports2.getSiblings = getSiblings;
    var concatAll = (
      /* ::<T> */
      function concatAll2(xs) {
        return function(ys) {
          return ys.reduce(function(zs, z) {
            return zs.concat(z);
          }, xs);
        };
      }
    );
    exports2.concatAll = concatAll;
  }
});

// node_modules/@babel/runtime/helpers/taggedTemplateLiteral.js
var require_taggedTemplateLiteral = __commonJS({
  "node_modules/@babel/runtime/helpers/taggedTemplateLiteral.js"(exports2, module2) {
    function _taggedTemplateLiteral(e, t) {
      return t || (t = e.slice(0)), Object.freeze(Object.defineProperties(e, {
        raw: {
          value: Object.freeze(t)
        }
      }));
    }
    module2.exports = _taggedTemplateLiteral, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
  }
});

// node_modules/@babel/runtime/helpers/classCallCheck.js
var require_classCallCheck = __commonJS({
  "node_modules/@babel/runtime/helpers/classCallCheck.js"(exports2, module2) {
    function _classCallCheck(a, n) {
      if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
    }
    module2.exports = _classCallCheck, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
  }
});

// node_modules/@babel/runtime/helpers/createClass.js
var require_createClass = __commonJS({
  "node_modules/@babel/runtime/helpers/createClass.js"(exports2, module2) {
    var toPropertyKey = require_toPropertyKey();
    function _defineProperties(e, r2) {
      for (var t = 0; t < r2.length; t++) {
        var o = r2[t];
        o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(e, toPropertyKey(o.key), o);
      }
    }
    function _createClass(e, r2, t) {
      return r2 && _defineProperties(e.prototype, r2), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", {
        writable: false
      }), e;
    }
    module2.exports = _createClass, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
  }
});

// node_modules/@babel/runtime/helpers/setPrototypeOf.js
var require_setPrototypeOf = __commonJS({
  "node_modules/@babel/runtime/helpers/setPrototypeOf.js"(exports2, module2) {
    function _setPrototypeOf(t, e) {
      return module2.exports = _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t2, e2) {
        return t2.__proto__ = e2, t2;
      }, module2.exports.__esModule = true, module2.exports["default"] = module2.exports, _setPrototypeOf(t, e);
    }
    module2.exports = _setPrototypeOf, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
  }
});

// node_modules/@babel/runtime/helpers/inherits.js
var require_inherits = __commonJS({
  "node_modules/@babel/runtime/helpers/inherits.js"(exports2, module2) {
    var setPrototypeOf = require_setPrototypeOf();
    function _inherits(t, e) {
      if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
      t.prototype = Object.create(e && e.prototype, {
        constructor: {
          value: t,
          writable: true,
          configurable: true
        }
      }), Object.defineProperty(t, "prototype", {
        writable: false
      }), e && setPrototypeOf(t, e);
    }
    module2.exports = _inherits, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
  }
});

// node_modules/@babel/runtime/helpers/assertThisInitialized.js
var require_assertThisInitialized = __commonJS({
  "node_modules/@babel/runtime/helpers/assertThisInitialized.js"(exports2, module2) {
    function _assertThisInitialized(e) {
      if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return e;
    }
    module2.exports = _assertThisInitialized, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
  }
});

// node_modules/@babel/runtime/helpers/possibleConstructorReturn.js
var require_possibleConstructorReturn = __commonJS({
  "node_modules/@babel/runtime/helpers/possibleConstructorReturn.js"(exports2, module2) {
    var _typeof = require_typeof()["default"];
    var assertThisInitialized = require_assertThisInitialized();
    function _possibleConstructorReturn(t, e) {
      if (e && ("object" == _typeof(e) || "function" == typeof e)) return e;
      if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
      return assertThisInitialized(t);
    }
    module2.exports = _possibleConstructorReturn, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
  }
});

// node_modules/@babel/runtime/helpers/getPrototypeOf.js
var require_getPrototypeOf = __commonJS({
  "node_modules/@babel/runtime/helpers/getPrototypeOf.js"(exports2, module2) {
    function _getPrototypeOf(t) {
      return module2.exports = _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t2) {
        return t2.__proto__ || Object.getPrototypeOf(t2);
      }, module2.exports.__esModule = true, module2.exports["default"] = module2.exports, _getPrototypeOf(t);
    }
    module2.exports = _getPrototypeOf, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
  }
});

// node_modules/js-tokens/index.js
var require_js_tokens = __commonJS({
  "node_modules/js-tokens/index.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = /((['"])(?:(?!\2|\\).|\\(?:\r\n|[\s\S]))*(\2)?|`(?:[^`\\$]|\\[\s\S]|\$(?!\{)|\$\{(?:[^{}]|\{[^}]*\}?)*\}?)*(`)?)|(\/\/.*)|(\/\*(?:[^*]|\*(?!\/))*(\*\/)?)|(\/(?!\*)(?:\[(?:(?![\]\\]).|\\.)*\]|(?![\/\]\\]).|\\.)+\/(?:(?!\s*(?:\b|[\u0080-\uFFFF$\\'"~({]|[+\-!](?!=)|\.?\d))|[gmiyus]{1,6}\b(?![\u0080-\uFFFF$\\]|\s*(?:[+\-*%&|^<>!=?({]|\/(?![\/*])))))|(0[xX][\da-fA-F]+|0[oO][0-7]+|0[bB][01]+|(?:\d*\.\d+|\d+\.?)(?:[eE][+-]?\d+)?)|((?!\d)(?:(?!\s)[$\w\u0080-\uFFFF]|\\u[\da-fA-F]{4}|\\u\{[\da-fA-F]+\})+)|(--|\+\+|&&|\|\||=>|\.{3}|(?:[+\-\/%&|^]|\*{1,2}|<{1,2}|>{1,3}|!=?|={1,2})=?|[?~.,:;[\](){}])|(\s+)|(^$|[\s\S])/g;
    exports2.matchToToken = function(match2) {
      var token = { type: "invalid", value: match2[0], closed: void 0 };
      if (match2[1]) token.type = "string", token.closed = !!(match2[3] || match2[4]);
      else if (match2[5]) token.type = "comment";
      else if (match2[6]) token.type = "comment", token.closed = !!match2[7];
      else if (match2[8]) token.type = "regex";
      else if (match2[9]) token.type = "number";
      else if (match2[10]) token.type = "name";
      else if (match2[11]) token.type = "punctuator";
      else if (match2[12]) token.type = "whitespace";
      return token;
    };
  }
});

// node_modules/@babel/helper-validator-identifier/lib/identifier.js
var require_identifier = __commonJS({
  "node_modules/@babel/helper-validator-identifier/lib/identifier.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.isIdentifierChar = isIdentifierChar;
    exports2.isIdentifierName = isIdentifierName;
    exports2.isIdentifierStart = isIdentifierStart;
    var nonASCIIidentifierStartChars = "\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC";
    var nonASCIIidentifierChars = "\u200C\u200D\xB7\u0300-\u036F\u0387\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u0669\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07C0-\u07C9\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0898-\u089F\u08CA-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0966-\u096F\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09E6-\u09EF\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A66-\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AE6-\u0AEF\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B66-\u0B6F\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0BE6-\u0BEF\u0C00-\u0C04\u0C3C\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CE6-\u0CEF\u0CF3\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D66-\u0D6F\u0D81-\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0E50-\u0E59\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECE\u0ED0-\u0ED9\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1040-\u1049\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109D\u135D-\u135F\u1369-\u1371\u1712-\u1715\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u17E0-\u17E9\u180B-\u180D\u180F-\u1819\u18A9\u1920-\u192B\u1930-\u193B\u1946-\u194F\u19D0-\u19DA\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AB0-\u1ABD\u1ABF-\u1ACE\u1B00-\u1B04\u1B34-\u1B44\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BB0-\u1BB9\u1BE6-\u1BF3\u1C24-\u1C37\u1C40-\u1C49\u1C50-\u1C59\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DFF\u200C\u200D\u203F\u2040\u2054\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\u30FB\uA620-\uA629\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA82C\uA880\uA881\uA8B4-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F1\uA8FF-\uA909\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9D0-\uA9D9\uA9E5\uA9F0-\uA9F9\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA50-\uAA59\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uABF0-\uABF9\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFF10-\uFF19\uFF3F\uFF65";
    var nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
    var nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");
    nonASCIIidentifierStartChars = nonASCIIidentifierChars = null;
    var astralIdentifierStartCodes = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 68, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2, 33, 125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071, 18, 5, 4026, 582, 8634, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8936, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43, 485, 27, 757, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4153, 7, 221, 3, 5761, 15, 7472, 16, 621, 2467, 541, 1507, 4938, 6, 4191];
    var astralIdentifierCodes = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 81, 2, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 9, 5351, 0, 7, 14, 13835, 9, 87, 9, 39, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4706, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 983, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
    function isInAstralSet(code, set3) {
      let pos = 65536;
      for (let i = 0, length = set3.length; i < length; i += 2) {
        pos += set3[i];
        if (pos > code) return false;
        pos += set3[i + 1];
        if (pos >= code) return true;
      }
      return false;
    }
    function isIdentifierStart(code) {
      if (code < 65) return code === 36;
      if (code <= 90) return true;
      if (code < 97) return code === 95;
      if (code <= 122) return true;
      if (code <= 65535) {
        return code >= 170 && nonASCIIidentifierStart.test(String.fromCharCode(code));
      }
      return isInAstralSet(code, astralIdentifierStartCodes);
    }
    function isIdentifierChar(code) {
      if (code < 48) return code === 36;
      if (code < 58) return true;
      if (code < 65) return false;
      if (code <= 90) return true;
      if (code < 97) return code === 95;
      if (code <= 122) return true;
      if (code <= 65535) {
        return code >= 170 && nonASCIIidentifier.test(String.fromCharCode(code));
      }
      return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes);
    }
    function isIdentifierName(name) {
      let isFirst = true;
      for (let i = 0; i < name.length; i++) {
        let cp = name.charCodeAt(i);
        if ((cp & 64512) === 55296 && i + 1 < name.length) {
          const trail = name.charCodeAt(++i);
          if ((trail & 64512) === 56320) {
            cp = 65536 + ((cp & 1023) << 10) + (trail & 1023);
          }
        }
        if (isFirst) {
          isFirst = false;
          if (!isIdentifierStart(cp)) {
            return false;
          }
        } else if (!isIdentifierChar(cp)) {
          return false;
        }
      }
      return !isFirst;
    }
  }
});

// node_modules/@babel/helper-validator-identifier/lib/keyword.js
var require_keyword = __commonJS({
  "node_modules/@babel/helper-validator-identifier/lib/keyword.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.isKeyword = isKeyword;
    exports2.isReservedWord = isReservedWord;
    exports2.isStrictBindOnlyReservedWord = isStrictBindOnlyReservedWord;
    exports2.isStrictBindReservedWord = isStrictBindReservedWord;
    exports2.isStrictReservedWord = isStrictReservedWord;
    var reservedWords = {
      keyword: ["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete"],
      strict: ["implements", "interface", "let", "package", "private", "protected", "public", "static", "yield"],
      strictBind: ["eval", "arguments"]
    };
    var keywords = new Set(reservedWords.keyword);
    var reservedWordsStrictSet = new Set(reservedWords.strict);
    var reservedWordsStrictBindSet = new Set(reservedWords.strictBind);
    function isReservedWord(word, inModule) {
      return inModule && word === "await" || word === "enum";
    }
    function isStrictReservedWord(word, inModule) {
      return isReservedWord(word, inModule) || reservedWordsStrictSet.has(word);
    }
    function isStrictBindOnlyReservedWord(word) {
      return reservedWordsStrictBindSet.has(word);
    }
    function isStrictBindReservedWord(word, inModule) {
      return isStrictReservedWord(word, inModule) || isStrictBindOnlyReservedWord(word);
    }
    function isKeyword(word) {
      return keywords.has(word);
    }
  }
});

// node_modules/@babel/helper-validator-identifier/lib/index.js
var require_lib11 = __commonJS({
  "node_modules/@babel/helper-validator-identifier/lib/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    Object.defineProperty(exports2, "isIdentifierChar", {
      enumerable: true,
      get: function() {
        return _identifier.isIdentifierChar;
      }
    });
    Object.defineProperty(exports2, "isIdentifierName", {
      enumerable: true,
      get: function() {
        return _identifier.isIdentifierName;
      }
    });
    Object.defineProperty(exports2, "isIdentifierStart", {
      enumerable: true,
      get: function() {
        return _identifier.isIdentifierStart;
      }
    });
    Object.defineProperty(exports2, "isKeyword", {
      enumerable: true,
      get: function() {
        return _keyword.isKeyword;
      }
    });
    Object.defineProperty(exports2, "isReservedWord", {
      enumerable: true,
      get: function() {
        return _keyword.isReservedWord;
      }
    });
    Object.defineProperty(exports2, "isStrictBindOnlyReservedWord", {
      enumerable: true,
      get: function() {
        return _keyword.isStrictBindOnlyReservedWord;
      }
    });
    Object.defineProperty(exports2, "isStrictBindReservedWord", {
      enumerable: true,
      get: function() {
        return _keyword.isStrictBindReservedWord;
      }
    });
    Object.defineProperty(exports2, "isStrictReservedWord", {
      enumerable: true,
      get: function() {
        return _keyword.isStrictReservedWord;
      }
    });
    var _identifier = require_identifier();
    var _keyword = require_keyword();
  }
});

// node_modules/picocolors/picocolors.js
var require_picocolors = __commonJS({
  "node_modules/picocolors/picocolors.js"(exports2, module2) {
    var argv = process.argv || [];
    var env = process.env;
    var isColorSupported = !("NO_COLOR" in env || argv.includes("--no-color")) && ("FORCE_COLOR" in env || argv.includes("--color") || process.platform === "win32" || require != null && require("tty").isatty(1) && env.TERM !== "dumb" || "CI" in env);
    var formatter2 = (open, close, replace = open) => (input) => {
      let string = "" + input;
      let index = string.indexOf(close, open.length);
      return ~index ? open + replaceClose(string, close, replace, index) + close : open + string + close;
    };
    var replaceClose = (string, close, replace, index) => {
      let result = "";
      let cursor = 0;
      do {
        result += string.substring(cursor, index) + replace;
        cursor = index + close.length;
        index = string.indexOf(close, cursor);
      } while (~index);
      return result + string.substring(cursor);
    };
    var createColors = (enabled = isColorSupported) => {
      let init = enabled ? formatter2 : () => String;
      return {
        isColorSupported: enabled,
        reset: init("\x1B[0m", "\x1B[0m"),
        bold: init("\x1B[1m", "\x1B[22m", "\x1B[22m\x1B[1m"),
        dim: init("\x1B[2m", "\x1B[22m", "\x1B[22m\x1B[2m"),
        italic: init("\x1B[3m", "\x1B[23m"),
        underline: init("\x1B[4m", "\x1B[24m"),
        inverse: init("\x1B[7m", "\x1B[27m"),
        hidden: init("\x1B[8m", "\x1B[28m"),
        strikethrough: init("\x1B[9m", "\x1B[29m"),
        black: init("\x1B[30m", "\x1B[39m"),
        red: init("\x1B[31m", "\x1B[39m"),
        green: init("\x1B[32m", "\x1B[39m"),
        yellow: init("\x1B[33m", "\x1B[39m"),
        blue: init("\x1B[34m", "\x1B[39m"),
        magenta: init("\x1B[35m", "\x1B[39m"),
        cyan: init("\x1B[36m", "\x1B[39m"),
        white: init("\x1B[37m", "\x1B[39m"),
        gray: init("\x1B[90m", "\x1B[39m"),
        bgBlack: init("\x1B[40m", "\x1B[49m"),
        bgRed: init("\x1B[41m", "\x1B[49m"),
        bgGreen: init("\x1B[42m", "\x1B[49m"),
        bgYellow: init("\x1B[43m", "\x1B[49m"),
        bgBlue: init("\x1B[44m", "\x1B[49m"),
        bgMagenta: init("\x1B[45m", "\x1B[49m"),
        bgCyan: init("\x1B[46m", "\x1B[49m"),
        bgWhite: init("\x1B[47m", "\x1B[49m")
      };
    };
    module2.exports = createColors();
    module2.exports.createColors = createColors;
  }
});

// node_modules/escape-string-regexp/index.js
var require_escape_string_regexp = __commonJS({
  "node_modules/escape-string-regexp/index.js"(exports2, module2) {
    "use strict";
    var matchOperatorsRe = /[|\\{}()[\]^$+*?.]/g;
    module2.exports = function(str2) {
      if (typeof str2 !== "string") {
        throw new TypeError("Expected a string");
      }
      return str2.replace(matchOperatorsRe, "\\$&");
    };
  }
});

// node_modules/@babel/highlight/node_modules/color-name/index.js
var require_color_name = __commonJS({
  "node_modules/@babel/highlight/node_modules/color-name/index.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      "aliceblue": [240, 248, 255],
      "antiquewhite": [250, 235, 215],
      "aqua": [0, 255, 255],
      "aquamarine": [127, 255, 212],
      "azure": [240, 255, 255],
      "beige": [245, 245, 220],
      "bisque": [255, 228, 196],
      "black": [0, 0, 0],
      "blanchedalmond": [255, 235, 205],
      "blue": [0, 0, 255],
      "blueviolet": [138, 43, 226],
      "brown": [165, 42, 42],
      "burlywood": [222, 184, 135],
      "cadetblue": [95, 158, 160],
      "chartreuse": [127, 255, 0],
      "chocolate": [210, 105, 30],
      "coral": [255, 127, 80],
      "cornflowerblue": [100, 149, 237],
      "cornsilk": [255, 248, 220],
      "crimson": [220, 20, 60],
      "cyan": [0, 255, 255],
      "darkblue": [0, 0, 139],
      "darkcyan": [0, 139, 139],
      "darkgoldenrod": [184, 134, 11],
      "darkgray": [169, 169, 169],
      "darkgreen": [0, 100, 0],
      "darkgrey": [169, 169, 169],
      "darkkhaki": [189, 183, 107],
      "darkmagenta": [139, 0, 139],
      "darkolivegreen": [85, 107, 47],
      "darkorange": [255, 140, 0],
      "darkorchid": [153, 50, 204],
      "darkred": [139, 0, 0],
      "darksalmon": [233, 150, 122],
      "darkseagreen": [143, 188, 143],
      "darkslateblue": [72, 61, 139],
      "darkslategray": [47, 79, 79],
      "darkslategrey": [47, 79, 79],
      "darkturquoise": [0, 206, 209],
      "darkviolet": [148, 0, 211],
      "deeppink": [255, 20, 147],
      "deepskyblue": [0, 191, 255],
      "dimgray": [105, 105, 105],
      "dimgrey": [105, 105, 105],
      "dodgerblue": [30, 144, 255],
      "firebrick": [178, 34, 34],
      "floralwhite": [255, 250, 240],
      "forestgreen": [34, 139, 34],
      "fuchsia": [255, 0, 255],
      "gainsboro": [220, 220, 220],
      "ghostwhite": [248, 248, 255],
      "gold": [255, 215, 0],
      "goldenrod": [218, 165, 32],
      "gray": [128, 128, 128],
      "green": [0, 128, 0],
      "greenyellow": [173, 255, 47],
      "grey": [128, 128, 128],
      "honeydew": [240, 255, 240],
      "hotpink": [255, 105, 180],
      "indianred": [205, 92, 92],
      "indigo": [75, 0, 130],
      "ivory": [255, 255, 240],
      "khaki": [240, 230, 140],
      "lavender": [230, 230, 250],
      "lavenderblush": [255, 240, 245],
      "lawngreen": [124, 252, 0],
      "lemonchiffon": [255, 250, 205],
      "lightblue": [173, 216, 230],
      "lightcoral": [240, 128, 128],
      "lightcyan": [224, 255, 255],
      "lightgoldenrodyellow": [250, 250, 210],
      "lightgray": [211, 211, 211],
      "lightgreen": [144, 238, 144],
      "lightgrey": [211, 211, 211],
      "lightpink": [255, 182, 193],
      "lightsalmon": [255, 160, 122],
      "lightseagreen": [32, 178, 170],
      "lightskyblue": [135, 206, 250],
      "lightslategray": [119, 136, 153],
      "lightslategrey": [119, 136, 153],
      "lightsteelblue": [176, 196, 222],
      "lightyellow": [255, 255, 224],
      "lime": [0, 255, 0],
      "limegreen": [50, 205, 50],
      "linen": [250, 240, 230],
      "magenta": [255, 0, 255],
      "maroon": [128, 0, 0],
      "mediumaquamarine": [102, 205, 170],
      "mediumblue": [0, 0, 205],
      "mediumorchid": [186, 85, 211],
      "mediumpurple": [147, 112, 219],
      "mediumseagreen": [60, 179, 113],
      "mediumslateblue": [123, 104, 238],
      "mediumspringgreen": [0, 250, 154],
      "mediumturquoise": [72, 209, 204],
      "mediumvioletred": [199, 21, 133],
      "midnightblue": [25, 25, 112],
      "mintcream": [245, 255, 250],
      "mistyrose": [255, 228, 225],
      "moccasin": [255, 228, 181],
      "navajowhite": [255, 222, 173],
      "navy": [0, 0, 128],
      "oldlace": [253, 245, 230],
      "olive": [128, 128, 0],
      "olivedrab": [107, 142, 35],
      "orange": [255, 165, 0],
      "orangered": [255, 69, 0],
      "orchid": [218, 112, 214],
      "palegoldenrod": [238, 232, 170],
      "palegreen": [152, 251, 152],
      "paleturquoise": [175, 238, 238],
      "palevioletred": [219, 112, 147],
      "papayawhip": [255, 239, 213],
      "peachpuff": [255, 218, 185],
      "peru": [205, 133, 63],
      "pink": [255, 192, 203],
      "plum": [221, 160, 221],
      "powderblue": [176, 224, 230],
      "purple": [128, 0, 128],
      "rebeccapurple": [102, 51, 153],
      "red": [255, 0, 0],
      "rosybrown": [188, 143, 143],
      "royalblue": [65, 105, 225],
      "saddlebrown": [139, 69, 19],
      "salmon": [250, 128, 114],
      "sandybrown": [244, 164, 96],
      "seagreen": [46, 139, 87],
      "seashell": [255, 245, 238],
      "sienna": [160, 82, 45],
      "silver": [192, 192, 192],
      "skyblue": [135, 206, 235],
      "slateblue": [106, 90, 205],
      "slategray": [112, 128, 144],
      "slategrey": [112, 128, 144],
      "snow": [255, 250, 250],
      "springgreen": [0, 255, 127],
      "steelblue": [70, 130, 180],
      "tan": [210, 180, 140],
      "teal": [0, 128, 128],
      "thistle": [216, 191, 216],
      "tomato": [255, 99, 71],
      "turquoise": [64, 224, 208],
      "violet": [238, 130, 238],
      "wheat": [245, 222, 179],
      "white": [255, 255, 255],
      "whitesmoke": [245, 245, 245],
      "yellow": [255, 255, 0],
      "yellowgreen": [154, 205, 50]
    };
  }
});

// node_modules/@babel/highlight/node_modules/color-convert/conversions.js
var require_conversions = __commonJS({
  "node_modules/@babel/highlight/node_modules/color-convert/conversions.js"(exports2, module2) {
    var cssKeywords = require_color_name();
    var reverseKeywords = {};
    for (key in cssKeywords) {
      if (cssKeywords.hasOwnProperty(key)) {
        reverseKeywords[cssKeywords[key]] = key;
      }
    }
    var key;
    var convert2 = module2.exports = {
      rgb: { channels: 3, labels: "rgb" },
      hsl: { channels: 3, labels: "hsl" },
      hsv: { channels: 3, labels: "hsv" },
      hwb: { channels: 3, labels: "hwb" },
      cmyk: { channels: 4, labels: "cmyk" },
      xyz: { channels: 3, labels: "xyz" },
      lab: { channels: 3, labels: "lab" },
      lch: { channels: 3, labels: "lch" },
      hex: { channels: 1, labels: ["hex"] },
      keyword: { channels: 1, labels: ["keyword"] },
      ansi16: { channels: 1, labels: ["ansi16"] },
      ansi256: { channels: 1, labels: ["ansi256"] },
      hcg: { channels: 3, labels: ["h", "c", "g"] },
      apple: { channels: 3, labels: ["r16", "g16", "b16"] },
      gray: { channels: 1, labels: ["gray"] }
    };
    for (model in convert2) {
      if (convert2.hasOwnProperty(model)) {
        if (!("channels" in convert2[model])) {
          throw new Error("missing channels property: " + model);
        }
        if (!("labels" in convert2[model])) {
          throw new Error("missing channel labels property: " + model);
        }
        if (convert2[model].labels.length !== convert2[model].channels) {
          throw new Error("channel and label counts mismatch: " + model);
        }
        channels = convert2[model].channels;
        labels = convert2[model].labels;
        delete convert2[model].channels;
        delete convert2[model].labels;
        Object.defineProperty(convert2[model], "channels", { value: channels });
        Object.defineProperty(convert2[model], "labels", { value: labels });
      }
    }
    var channels;
    var labels;
    var model;
    convert2.rgb.hsl = function(rgb) {
      var r2 = rgb[0] / 255;
      var g = rgb[1] / 255;
      var b = rgb[2] / 255;
      var min = Math.min(r2, g, b);
      var max = Math.max(r2, g, b);
      var delta = max - min;
      var h;
      var s;
      var l;
      if (max === min) {
        h = 0;
      } else if (r2 === max) {
        h = (g - b) / delta;
      } else if (g === max) {
        h = 2 + (b - r2) / delta;
      } else if (b === max) {
        h = 4 + (r2 - g) / delta;
      }
      h = Math.min(h * 60, 360);
      if (h < 0) {
        h += 360;
      }
      l = (min + max) / 2;
      if (max === min) {
        s = 0;
      } else if (l <= 0.5) {
        s = delta / (max + min);
      } else {
        s = delta / (2 - max - min);
      }
      return [h, s * 100, l * 100];
    };
    convert2.rgb.hsv = function(rgb) {
      var rdif;
      var gdif;
      var bdif;
      var h;
      var s;
      var r2 = rgb[0] / 255;
      var g = rgb[1] / 255;
      var b = rgb[2] / 255;
      var v = Math.max(r2, g, b);
      var diff = v - Math.min(r2, g, b);
      var diffc = function(c2) {
        return (v - c2) / 6 / diff + 1 / 2;
      };
      if (diff === 0) {
        h = s = 0;
      } else {
        s = diff / v;
        rdif = diffc(r2);
        gdif = diffc(g);
        bdif = diffc(b);
        if (r2 === v) {
          h = bdif - gdif;
        } else if (g === v) {
          h = 1 / 3 + rdif - bdif;
        } else if (b === v) {
          h = 2 / 3 + gdif - rdif;
        }
        if (h < 0) {
          h += 1;
        } else if (h > 1) {
          h -= 1;
        }
      }
      return [
        h * 360,
        s * 100,
        v * 100
      ];
    };
    convert2.rgb.hwb = function(rgb) {
      var r2 = rgb[0];
      var g = rgb[1];
      var b = rgb[2];
      var h = convert2.rgb.hsl(rgb)[0];
      var w = 1 / 255 * Math.min(r2, Math.min(g, b));
      b = 1 - 1 / 255 * Math.max(r2, Math.max(g, b));
      return [h, w * 100, b * 100];
    };
    convert2.rgb.cmyk = function(rgb) {
      var r2 = rgb[0] / 255;
      var g = rgb[1] / 255;
      var b = rgb[2] / 255;
      var c2;
      var m;
      var y;
      var k;
      k = Math.min(1 - r2, 1 - g, 1 - b);
      c2 = (1 - r2 - k) / (1 - k) || 0;
      m = (1 - g - k) / (1 - k) || 0;
      y = (1 - b - k) / (1 - k) || 0;
      return [c2 * 100, m * 100, y * 100, k * 100];
    };
    function comparativeDistance(x, y) {
      return Math.pow(x[0] - y[0], 2) + Math.pow(x[1] - y[1], 2) + Math.pow(x[2] - y[2], 2);
    }
    convert2.rgb.keyword = function(rgb) {
      var reversed = reverseKeywords[rgb];
      if (reversed) {
        return reversed;
      }
      var currentClosestDistance = Infinity;
      var currentClosestKeyword;
      for (var keyword in cssKeywords) {
        if (cssKeywords.hasOwnProperty(keyword)) {
          var value = cssKeywords[keyword];
          var distance = comparativeDistance(rgb, value);
          if (distance < currentClosestDistance) {
            currentClosestDistance = distance;
            currentClosestKeyword = keyword;
          }
        }
      }
      return currentClosestKeyword;
    };
    convert2.keyword.rgb = function(keyword) {
      return cssKeywords[keyword];
    };
    convert2.rgb.xyz = function(rgb) {
      var r2 = rgb[0] / 255;
      var g = rgb[1] / 255;
      var b = rgb[2] / 255;
      r2 = r2 > 0.04045 ? Math.pow((r2 + 0.055) / 1.055, 2.4) : r2 / 12.92;
      g = g > 0.04045 ? Math.pow((g + 0.055) / 1.055, 2.4) : g / 12.92;
      b = b > 0.04045 ? Math.pow((b + 0.055) / 1.055, 2.4) : b / 12.92;
      var x = r2 * 0.4124 + g * 0.3576 + b * 0.1805;
      var y = r2 * 0.2126 + g * 0.7152 + b * 0.0722;
      var z = r2 * 0.0193 + g * 0.1192 + b * 0.9505;
      return [x * 100, y * 100, z * 100];
    };
    convert2.rgb.lab = function(rgb) {
      var xyz = convert2.rgb.xyz(rgb);
      var x = xyz[0];
      var y = xyz[1];
      var z = xyz[2];
      var l;
      var a;
      var b;
      x /= 95.047;
      y /= 100;
      z /= 108.883;
      x = x > 8856e-6 ? Math.pow(x, 1 / 3) : 7.787 * x + 16 / 116;
      y = y > 8856e-6 ? Math.pow(y, 1 / 3) : 7.787 * y + 16 / 116;
      z = z > 8856e-6 ? Math.pow(z, 1 / 3) : 7.787 * z + 16 / 116;
      l = 116 * y - 16;
      a = 500 * (x - y);
      b = 200 * (y - z);
      return [l, a, b];
    };
    convert2.hsl.rgb = function(hsl) {
      var h = hsl[0] / 360;
      var s = hsl[1] / 100;
      var l = hsl[2] / 100;
      var t1;
      var t2;
      var t3;
      var rgb;
      var val;
      if (s === 0) {
        val = l * 255;
        return [val, val, val];
      }
      if (l < 0.5) {
        t2 = l * (1 + s);
      } else {
        t2 = l + s - l * s;
      }
      t1 = 2 * l - t2;
      rgb = [0, 0, 0];
      for (var i = 0; i < 3; i++) {
        t3 = h + 1 / 3 * -(i - 1);
        if (t3 < 0) {
          t3++;
        }
        if (t3 > 1) {
          t3--;
        }
        if (6 * t3 < 1) {
          val = t1 + (t2 - t1) * 6 * t3;
        } else if (2 * t3 < 1) {
          val = t2;
        } else if (3 * t3 < 2) {
          val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
        } else {
          val = t1;
        }
        rgb[i] = val * 255;
      }
      return rgb;
    };
    convert2.hsl.hsv = function(hsl) {
      var h = hsl[0];
      var s = hsl[1] / 100;
      var l = hsl[2] / 100;
      var smin = s;
      var lmin = Math.max(l, 0.01);
      var sv;
      var v;
      l *= 2;
      s *= l <= 1 ? l : 2 - l;
      smin *= lmin <= 1 ? lmin : 2 - lmin;
      v = (l + s) / 2;
      sv = l === 0 ? 2 * smin / (lmin + smin) : 2 * s / (l + s);
      return [h, sv * 100, v * 100];
    };
    convert2.hsv.rgb = function(hsv) {
      var h = hsv[0] / 60;
      var s = hsv[1] / 100;
      var v = hsv[2] / 100;
      var hi = Math.floor(h) % 6;
      var f = h - Math.floor(h);
      var p = 255 * v * (1 - s);
      var q = 255 * v * (1 - s * f);
      var t = 255 * v * (1 - s * (1 - f));
      v *= 255;
      switch (hi) {
        case 0:
          return [v, t, p];
        case 1:
          return [q, v, p];
        case 2:
          return [p, v, t];
        case 3:
          return [p, q, v];
        case 4:
          return [t, p, v];
        case 5:
          return [v, p, q];
      }
    };
    convert2.hsv.hsl = function(hsv) {
      var h = hsv[0];
      var s = hsv[1] / 100;
      var v = hsv[2] / 100;
      var vmin = Math.max(v, 0.01);
      var lmin;
      var sl;
      var l;
      l = (2 - s) * v;
      lmin = (2 - s) * vmin;
      sl = s * vmin;
      sl /= lmin <= 1 ? lmin : 2 - lmin;
      sl = sl || 0;
      l /= 2;
      return [h, sl * 100, l * 100];
    };
    convert2.hwb.rgb = function(hwb) {
      var h = hwb[0] / 360;
      var wh = hwb[1] / 100;
      var bl = hwb[2] / 100;
      var ratio = wh + bl;
      var i;
      var v;
      var f;
      var n;
      if (ratio > 1) {
        wh /= ratio;
        bl /= ratio;
      }
      i = Math.floor(6 * h);
      v = 1 - bl;
      f = 6 * h - i;
      if ((i & 1) !== 0) {
        f = 1 - f;
      }
      n = wh + f * (v - wh);
      var r2;
      var g;
      var b;
      switch (i) {
        default:
        case 6:
        case 0:
          r2 = v;
          g = n;
          b = wh;
          break;
        case 1:
          r2 = n;
          g = v;
          b = wh;
          break;
        case 2:
          r2 = wh;
          g = v;
          b = n;
          break;
        case 3:
          r2 = wh;
          g = n;
          b = v;
          break;
        case 4:
          r2 = n;
          g = wh;
          b = v;
          break;
        case 5:
          r2 = v;
          g = wh;
          b = n;
          break;
      }
      return [r2 * 255, g * 255, b * 255];
    };
    convert2.cmyk.rgb = function(cmyk) {
      var c2 = cmyk[0] / 100;
      var m = cmyk[1] / 100;
      var y = cmyk[2] / 100;
      var k = cmyk[3] / 100;
      var r2;
      var g;
      var b;
      r2 = 1 - Math.min(1, c2 * (1 - k) + k);
      g = 1 - Math.min(1, m * (1 - k) + k);
      b = 1 - Math.min(1, y * (1 - k) + k);
      return [r2 * 255, g * 255, b * 255];
    };
    convert2.xyz.rgb = function(xyz) {
      var x = xyz[0] / 100;
      var y = xyz[1] / 100;
      var z = xyz[2] / 100;
      var r2;
      var g;
      var b;
      r2 = x * 3.2406 + y * -1.5372 + z * -0.4986;
      g = x * -0.9689 + y * 1.8758 + z * 0.0415;
      b = x * 0.0557 + y * -0.204 + z * 1.057;
      r2 = r2 > 31308e-7 ? 1.055 * Math.pow(r2, 1 / 2.4) - 0.055 : r2 * 12.92;
      g = g > 31308e-7 ? 1.055 * Math.pow(g, 1 / 2.4) - 0.055 : g * 12.92;
      b = b > 31308e-7 ? 1.055 * Math.pow(b, 1 / 2.4) - 0.055 : b * 12.92;
      r2 = Math.min(Math.max(0, r2), 1);
      g = Math.min(Math.max(0, g), 1);
      b = Math.min(Math.max(0, b), 1);
      return [r2 * 255, g * 255, b * 255];
    };
    convert2.xyz.lab = function(xyz) {
      var x = xyz[0];
      var y = xyz[1];
      var z = xyz[2];
      var l;
      var a;
      var b;
      x /= 95.047;
      y /= 100;
      z /= 108.883;
      x = x > 8856e-6 ? Math.pow(x, 1 / 3) : 7.787 * x + 16 / 116;
      y = y > 8856e-6 ? Math.pow(y, 1 / 3) : 7.787 * y + 16 / 116;
      z = z > 8856e-6 ? Math.pow(z, 1 / 3) : 7.787 * z + 16 / 116;
      l = 116 * y - 16;
      a = 500 * (x - y);
      b = 200 * (y - z);
      return [l, a, b];
    };
    convert2.lab.xyz = function(lab) {
      var l = lab[0];
      var a = lab[1];
      var b = lab[2];
      var x;
      var y;
      var z;
      y = (l + 16) / 116;
      x = a / 500 + y;
      z = y - b / 200;
      var y2 = Math.pow(y, 3);
      var x2 = Math.pow(x, 3);
      var z2 = Math.pow(z, 3);
      y = y2 > 8856e-6 ? y2 : (y - 16 / 116) / 7.787;
      x = x2 > 8856e-6 ? x2 : (x - 16 / 116) / 7.787;
      z = z2 > 8856e-6 ? z2 : (z - 16 / 116) / 7.787;
      x *= 95.047;
      y *= 100;
      z *= 108.883;
      return [x, y, z];
    };
    convert2.lab.lch = function(lab) {
      var l = lab[0];
      var a = lab[1];
      var b = lab[2];
      var hr;
      var h;
      var c2;
      hr = Math.atan2(b, a);
      h = hr * 360 / 2 / Math.PI;
      if (h < 0) {
        h += 360;
      }
      c2 = Math.sqrt(a * a + b * b);
      return [l, c2, h];
    };
    convert2.lch.lab = function(lch) {
      var l = lch[0];
      var c2 = lch[1];
      var h = lch[2];
      var a;
      var b;
      var hr;
      hr = h / 360 * 2 * Math.PI;
      a = c2 * Math.cos(hr);
      b = c2 * Math.sin(hr);
      return [l, a, b];
    };
    convert2.rgb.ansi16 = function(args) {
      var r2 = args[0];
      var g = args[1];
      var b = args[2];
      var value = 1 in arguments ? arguments[1] : convert2.rgb.hsv(args)[2];
      value = Math.round(value / 50);
      if (value === 0) {
        return 30;
      }
      var ansi = 30 + (Math.round(b / 255) << 2 | Math.round(g / 255) << 1 | Math.round(r2 / 255));
      if (value === 2) {
        ansi += 60;
      }
      return ansi;
    };
    convert2.hsv.ansi16 = function(args) {
      return convert2.rgb.ansi16(convert2.hsv.rgb(args), args[2]);
    };
    convert2.rgb.ansi256 = function(args) {
      var r2 = args[0];
      var g = args[1];
      var b = args[2];
      if (r2 === g && g === b) {
        if (r2 < 8) {
          return 16;
        }
        if (r2 > 248) {
          return 231;
        }
        return Math.round((r2 - 8) / 247 * 24) + 232;
      }
      var ansi = 16 + 36 * Math.round(r2 / 255 * 5) + 6 * Math.round(g / 255 * 5) + Math.round(b / 255 * 5);
      return ansi;
    };
    convert2.ansi16.rgb = function(args) {
      var color = args % 10;
      if (color === 0 || color === 7) {
        if (args > 50) {
          color += 3.5;
        }
        color = color / 10.5 * 255;
        return [color, color, color];
      }
      var mult = (~~(args > 50) + 1) * 0.5;
      var r2 = (color & 1) * mult * 255;
      var g = (color >> 1 & 1) * mult * 255;
      var b = (color >> 2 & 1) * mult * 255;
      return [r2, g, b];
    };
    convert2.ansi256.rgb = function(args) {
      if (args >= 232) {
        var c2 = (args - 232) * 10 + 8;
        return [c2, c2, c2];
      }
      args -= 16;
      var rem;
      var r2 = Math.floor(args / 36) / 5 * 255;
      var g = Math.floor((rem = args % 36) / 6) / 5 * 255;
      var b = rem % 6 / 5 * 255;
      return [r2, g, b];
    };
    convert2.rgb.hex = function(args) {
      var integer = ((Math.round(args[0]) & 255) << 16) + ((Math.round(args[1]) & 255) << 8) + (Math.round(args[2]) & 255);
      var string = integer.toString(16).toUpperCase();
      return "000000".substring(string.length) + string;
    };
    convert2.hex.rgb = function(args) {
      var match2 = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
      if (!match2) {
        return [0, 0, 0];
      }
      var colorString = match2[0];
      if (match2[0].length === 3) {
        colorString = colorString.split("").map(function(char) {
          return char + char;
        }).join("");
      }
      var integer = parseInt(colorString, 16);
      var r2 = integer >> 16 & 255;
      var g = integer >> 8 & 255;
      var b = integer & 255;
      return [r2, g, b];
    };
    convert2.rgb.hcg = function(rgb) {
      var r2 = rgb[0] / 255;
      var g = rgb[1] / 255;
      var b = rgb[2] / 255;
      var max = Math.max(Math.max(r2, g), b);
      var min = Math.min(Math.min(r2, g), b);
      var chroma = max - min;
      var grayscale;
      var hue;
      if (chroma < 1) {
        grayscale = min / (1 - chroma);
      } else {
        grayscale = 0;
      }
      if (chroma <= 0) {
        hue = 0;
      } else if (max === r2) {
        hue = (g - b) / chroma % 6;
      } else if (max === g) {
        hue = 2 + (b - r2) / chroma;
      } else {
        hue = 4 + (r2 - g) / chroma + 4;
      }
      hue /= 6;
      hue %= 1;
      return [hue * 360, chroma * 100, grayscale * 100];
    };
    convert2.hsl.hcg = function(hsl) {
      var s = hsl[1] / 100;
      var l = hsl[2] / 100;
      var c2 = 1;
      var f = 0;
      if (l < 0.5) {
        c2 = 2 * s * l;
      } else {
        c2 = 2 * s * (1 - l);
      }
      if (c2 < 1) {
        f = (l - 0.5 * c2) / (1 - c2);
      }
      return [hsl[0], c2 * 100, f * 100];
    };
    convert2.hsv.hcg = function(hsv) {
      var s = hsv[1] / 100;
      var v = hsv[2] / 100;
      var c2 = s * v;
      var f = 0;
      if (c2 < 1) {
        f = (v - c2) / (1 - c2);
      }
      return [hsv[0], c2 * 100, f * 100];
    };
    convert2.hcg.rgb = function(hcg) {
      var h = hcg[0] / 360;
      var c2 = hcg[1] / 100;
      var g = hcg[2] / 100;
      if (c2 === 0) {
        return [g * 255, g * 255, g * 255];
      }
      var pure = [0, 0, 0];
      var hi = h % 1 * 6;
      var v = hi % 1;
      var w = 1 - v;
      var mg = 0;
      switch (Math.floor(hi)) {
        case 0:
          pure[0] = 1;
          pure[1] = v;
          pure[2] = 0;
          break;
        case 1:
          pure[0] = w;
          pure[1] = 1;
          pure[2] = 0;
          break;
        case 2:
          pure[0] = 0;
          pure[1] = 1;
          pure[2] = v;
          break;
        case 3:
          pure[0] = 0;
          pure[1] = w;
          pure[2] = 1;
          break;
        case 4:
          pure[0] = v;
          pure[1] = 0;
          pure[2] = 1;
          break;
        default:
          pure[0] = 1;
          pure[1] = 0;
          pure[2] = w;
      }
      mg = (1 - c2) * g;
      return [
        (c2 * pure[0] + mg) * 255,
        (c2 * pure[1] + mg) * 255,
        (c2 * pure[2] + mg) * 255
      ];
    };
    convert2.hcg.hsv = function(hcg) {
      var c2 = hcg[1] / 100;
      var g = hcg[2] / 100;
      var v = c2 + g * (1 - c2);
      var f = 0;
      if (v > 0) {
        f = c2 / v;
      }
      return [hcg[0], f * 100, v * 100];
    };
    convert2.hcg.hsl = function(hcg) {
      var c2 = hcg[1] / 100;
      var g = hcg[2] / 100;
      var l = g * (1 - c2) + 0.5 * c2;
      var s = 0;
      if (l > 0 && l < 0.5) {
        s = c2 / (2 * l);
      } else if (l >= 0.5 && l < 1) {
        s = c2 / (2 * (1 - l));
      }
      return [hcg[0], s * 100, l * 100];
    };
    convert2.hcg.hwb = function(hcg) {
      var c2 = hcg[1] / 100;
      var g = hcg[2] / 100;
      var v = c2 + g * (1 - c2);
      return [hcg[0], (v - c2) * 100, (1 - v) * 100];
    };
    convert2.hwb.hcg = function(hwb) {
      var w = hwb[1] / 100;
      var b = hwb[2] / 100;
      var v = 1 - b;
      var c2 = v - w;
      var g = 0;
      if (c2 < 1) {
        g = (v - c2) / (1 - c2);
      }
      return [hwb[0], c2 * 100, g * 100];
    };
    convert2.apple.rgb = function(apple) {
      return [apple[0] / 65535 * 255, apple[1] / 65535 * 255, apple[2] / 65535 * 255];
    };
    convert2.rgb.apple = function(rgb) {
      return [rgb[0] / 255 * 65535, rgb[1] / 255 * 65535, rgb[2] / 255 * 65535];
    };
    convert2.gray.rgb = function(args) {
      return [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];
    };
    convert2.gray.hsl = convert2.gray.hsv = function(args) {
      return [0, 0, args[0]];
    };
    convert2.gray.hwb = function(gray) {
      return [0, 100, gray[0]];
    };
    convert2.gray.cmyk = function(gray) {
      return [0, 0, 0, gray[0]];
    };
    convert2.gray.lab = function(gray) {
      return [gray[0], 0, 0];
    };
    convert2.gray.hex = function(gray) {
      var val = Math.round(gray[0] / 100 * 255) & 255;
      var integer = (val << 16) + (val << 8) + val;
      var string = integer.toString(16).toUpperCase();
      return "000000".substring(string.length) + string;
    };
    convert2.rgb.gray = function(rgb) {
      var val = (rgb[0] + rgb[1] + rgb[2]) / 3;
      return [val / 255 * 100];
    };
  }
});

// node_modules/@babel/highlight/node_modules/color-convert/route.js
var require_route = __commonJS({
  "node_modules/@babel/highlight/node_modules/color-convert/route.js"(exports2, module2) {
    var conversions = require_conversions();
    function buildGraph() {
      var graph = {};
      var models = Object.keys(conversions);
      for (var len = models.length, i = 0; i < len; i++) {
        graph[models[i]] = {
          // http://jsperf.com/1-vs-infinity
          // micro-opt, but this is simple.
          distance: -1,
          parent: null
        };
      }
      return graph;
    }
    function deriveBFS(fromModel) {
      var graph = buildGraph();
      var queue = [fromModel];
      graph[fromModel].distance = 0;
      while (queue.length) {
        var current = queue.pop();
        var adjacents = Object.keys(conversions[current]);
        for (var len = adjacents.length, i = 0; i < len; i++) {
          var adjacent = adjacents[i];
          var node2 = graph[adjacent];
          if (node2.distance === -1) {
            node2.distance = graph[current].distance + 1;
            node2.parent = current;
            queue.unshift(adjacent);
          }
        }
      }
      return graph;
    }
    function link(from, to) {
      return function(args) {
        return to(from(args));
      };
    }
    function wrapConversion(toModel, graph) {
      var path = [graph[toModel].parent, toModel];
      var fn = conversions[graph[toModel].parent][toModel];
      var cur = graph[toModel].parent;
      while (graph[cur].parent) {
        path.unshift(graph[cur].parent);
        fn = link(conversions[graph[cur].parent][cur], fn);
        cur = graph[cur].parent;
      }
      fn.conversion = path;
      return fn;
    }
    module2.exports = function(fromModel) {
      var graph = deriveBFS(fromModel);
      var conversion = {};
      var models = Object.keys(graph);
      for (var len = models.length, i = 0; i < len; i++) {
        var toModel = models[i];
        var node2 = graph[toModel];
        if (node2.parent === null) {
          continue;
        }
        conversion[toModel] = wrapConversion(toModel, graph);
      }
      return conversion;
    };
  }
});

// node_modules/@babel/highlight/node_modules/color-convert/index.js
var require_color_convert = __commonJS({
  "node_modules/@babel/highlight/node_modules/color-convert/index.js"(exports2, module2) {
    var conversions = require_conversions();
    var route = require_route();
    var convert2 = {};
    var models = Object.keys(conversions);
    function wrapRaw(fn) {
      var wrappedFn = function(args) {
        if (args === void 0 || args === null) {
          return args;
        }
        if (arguments.length > 1) {
          args = Array.prototype.slice.call(arguments);
        }
        return fn(args);
      };
      if ("conversion" in fn) {
        wrappedFn.conversion = fn.conversion;
      }
      return wrappedFn;
    }
    function wrapRounded(fn) {
      var wrappedFn = function(args) {
        if (args === void 0 || args === null) {
          return args;
        }
        if (arguments.length > 1) {
          args = Array.prototype.slice.call(arguments);
        }
        var result = fn(args);
        if (typeof result === "object") {
          for (var len = result.length, i = 0; i < len; i++) {
            result[i] = Math.round(result[i]);
          }
        }
        return result;
      };
      if ("conversion" in fn) {
        wrappedFn.conversion = fn.conversion;
      }
      return wrappedFn;
    }
    models.forEach(function(fromModel) {
      convert2[fromModel] = {};
      Object.defineProperty(convert2[fromModel], "channels", { value: conversions[fromModel].channels });
      Object.defineProperty(convert2[fromModel], "labels", { value: conversions[fromModel].labels });
      var routes = route(fromModel);
      var routeModels = Object.keys(routes);
      routeModels.forEach(function(toModel) {
        var fn = routes[toModel];
        convert2[fromModel][toModel] = wrapRounded(fn);
        convert2[fromModel][toModel].raw = wrapRaw(fn);
      });
    });
    module2.exports = convert2;
  }
});

// node_modules/@babel/highlight/node_modules/ansi-styles/index.js
var require_ansi_styles = __commonJS({
  "node_modules/@babel/highlight/node_modules/ansi-styles/index.js"(exports2, module2) {
    "use strict";
    var colorConvert = require_color_convert();
    var wrapAnsi16 = (fn, offset) => function() {
      const code = fn.apply(colorConvert, arguments);
      return `\x1B[${code + offset}m`;
    };
    var wrapAnsi256 = (fn, offset) => function() {
      const code = fn.apply(colorConvert, arguments);
      return `\x1B[${38 + offset};5;${code}m`;
    };
    var wrapAnsi16m = (fn, offset) => function() {
      const rgb = fn.apply(colorConvert, arguments);
      return `\x1B[${38 + offset};2;${rgb[0]};${rgb[1]};${rgb[2]}m`;
    };
    function assembleStyles() {
      const codes = /* @__PURE__ */ new Map();
      const styles = {
        modifier: {
          reset: [0, 0],
          // 21 isn't widely supported and 22 does the same thing
          bold: [1, 22],
          dim: [2, 22],
          italic: [3, 23],
          underline: [4, 24],
          inverse: [7, 27],
          hidden: [8, 28],
          strikethrough: [9, 29]
        },
        color: {
          black: [30, 39],
          red: [31, 39],
          green: [32, 39],
          yellow: [33, 39],
          blue: [34, 39],
          magenta: [35, 39],
          cyan: [36, 39],
          white: [37, 39],
          gray: [90, 39],
          // Bright color
          redBright: [91, 39],
          greenBright: [92, 39],
          yellowBright: [93, 39],
          blueBright: [94, 39],
          magentaBright: [95, 39],
          cyanBright: [96, 39],
          whiteBright: [97, 39]
        },
        bgColor: {
          bgBlack: [40, 49],
          bgRed: [41, 49],
          bgGreen: [42, 49],
          bgYellow: [43, 49],
          bgBlue: [44, 49],
          bgMagenta: [45, 49],
          bgCyan: [46, 49],
          bgWhite: [47, 49],
          // Bright color
          bgBlackBright: [100, 49],
          bgRedBright: [101, 49],
          bgGreenBright: [102, 49],
          bgYellowBright: [103, 49],
          bgBlueBright: [104, 49],
          bgMagentaBright: [105, 49],
          bgCyanBright: [106, 49],
          bgWhiteBright: [107, 49]
        }
      };
      styles.color.grey = styles.color.gray;
      for (const groupName of Object.keys(styles)) {
        const group = styles[groupName];
        for (const styleName of Object.keys(group)) {
          const style = group[styleName];
          styles[styleName] = {
            open: `\x1B[${style[0]}m`,
            close: `\x1B[${style[1]}m`
          };
          group[styleName] = styles[styleName];
          codes.set(style[0], style[1]);
        }
        Object.defineProperty(styles, groupName, {
          value: group,
          enumerable: false
        });
        Object.defineProperty(styles, "codes", {
          value: codes,
          enumerable: false
        });
      }
      const ansi2ansi = (n) => n;
      const rgb2rgb = (r2, g, b) => [r2, g, b];
      styles.color.close = "\x1B[39m";
      styles.bgColor.close = "\x1B[49m";
      styles.color.ansi = {
        ansi: wrapAnsi16(ansi2ansi, 0)
      };
      styles.color.ansi256 = {
        ansi256: wrapAnsi256(ansi2ansi, 0)
      };
      styles.color.ansi16m = {
        rgb: wrapAnsi16m(rgb2rgb, 0)
      };
      styles.bgColor.ansi = {
        ansi: wrapAnsi16(ansi2ansi, 10)
      };
      styles.bgColor.ansi256 = {
        ansi256: wrapAnsi256(ansi2ansi, 10)
      };
      styles.bgColor.ansi16m = {
        rgb: wrapAnsi16m(rgb2rgb, 10)
      };
      for (let key of Object.keys(colorConvert)) {
        if (typeof colorConvert[key] !== "object") {
          continue;
        }
        const suite = colorConvert[key];
        if (key === "ansi16") {
          key = "ansi";
        }
        if ("ansi16" in suite) {
          styles.color.ansi[key] = wrapAnsi16(suite.ansi16, 0);
          styles.bgColor.ansi[key] = wrapAnsi16(suite.ansi16, 10);
        }
        if ("ansi256" in suite) {
          styles.color.ansi256[key] = wrapAnsi256(suite.ansi256, 0);
          styles.bgColor.ansi256[key] = wrapAnsi256(suite.ansi256, 10);
        }
        if ("rgb" in suite) {
          styles.color.ansi16m[key] = wrapAnsi16m(suite.rgb, 0);
          styles.bgColor.ansi16m[key] = wrapAnsi16m(suite.rgb, 10);
        }
      }
      return styles;
    }
    Object.defineProperty(module2, "exports", {
      enumerable: true,
      get: assembleStyles
    });
  }
});

// node_modules/@babel/highlight/node_modules/has-flag/index.js
var require_has_flag = __commonJS({
  "node_modules/@babel/highlight/node_modules/has-flag/index.js"(exports2, module2) {
    "use strict";
    module2.exports = (flag, argv) => {
      argv = argv || process.argv;
      const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
      const pos = argv.indexOf(prefix + flag);
      const terminatorPos = argv.indexOf("--");
      return pos !== -1 && (terminatorPos === -1 ? true : pos < terminatorPos);
    };
  }
});

// node_modules/@babel/highlight/node_modules/supports-color/index.js
var require_supports_color = __commonJS({
  "node_modules/@babel/highlight/node_modules/supports-color/index.js"(exports2, module2) {
    "use strict";
    var os = require("os");
    var hasFlag = require_has_flag();
    var env = process.env;
    var forceColor;
    if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false")) {
      forceColor = false;
    } else if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) {
      forceColor = true;
    }
    if ("FORCE_COLOR" in env) {
      forceColor = env.FORCE_COLOR.length === 0 || parseInt(env.FORCE_COLOR, 10) !== 0;
    }
    function translateLevel(level) {
      if (level === 0) {
        return false;
      }
      return {
        level,
        hasBasic: true,
        has256: level >= 2,
        has16m: level >= 3
      };
    }
    function supportsColor(stream) {
      if (forceColor === false) {
        return 0;
      }
      if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) {
        return 3;
      }
      if (hasFlag("color=256")) {
        return 2;
      }
      if (stream && !stream.isTTY && forceColor !== true) {
        return 0;
      }
      const min = forceColor ? 1 : 0;
      if (process.platform === "win32") {
        const osRelease = os.release().split(".");
        if (Number(process.versions.node.split(".")[0]) >= 8 && Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
          return Number(osRelease[2]) >= 14931 ? 3 : 2;
        }
        return 1;
      }
      if ("CI" in env) {
        if (["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI"].some((sign) => sign in env) || env.CI_NAME === "codeship") {
          return 1;
        }
        return min;
      }
      if ("TEAMCITY_VERSION" in env) {
        return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
      }
      if (env.COLORTERM === "truecolor") {
        return 3;
      }
      if ("TERM_PROGRAM" in env) {
        const version = parseInt((env.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
        switch (env.TERM_PROGRAM) {
          case "iTerm.app":
            return version >= 3 ? 3 : 2;
          case "Apple_Terminal":
            return 2;
        }
      }
      if (/-256(color)?$/i.test(env.TERM)) {
        return 2;
      }
      if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
        return 1;
      }
      if ("COLORTERM" in env) {
        return 1;
      }
      if (env.TERM === "dumb") {
        return min;
      }
      return min;
    }
    function getSupportLevel(stream) {
      const level = supportsColor(stream);
      return translateLevel(level);
    }
    module2.exports = {
      supportsColor: getSupportLevel,
      stdout: getSupportLevel(process.stdout),
      stderr: getSupportLevel(process.stderr)
    };
  }
});

// node_modules/@babel/highlight/node_modules/chalk/templates.js
var require_templates = __commonJS({
  "node_modules/@babel/highlight/node_modules/chalk/templates.js"(exports2, module2) {
    "use strict";
    var TEMPLATE_REGEX = /(?:\\(u[a-f\d]{4}|x[a-f\d]{2}|.))|(?:\{(~)?(\w+(?:\([^)]*\))?(?:\.\w+(?:\([^)]*\))?)*)(?:[ \t]|(?=\r?\n)))|(\})|((?:.|[\r\n\f])+?)/gi;
    var STYLE_REGEX = /(?:^|\.)(\w+)(?:\(([^)]*)\))?/g;
    var STRING_REGEX = /^(['"])((?:\\.|(?!\1)[^\\])*)\1$/;
    var ESCAPE_REGEX = /\\(u[a-f\d]{4}|x[a-f\d]{2}|.)|([^\\])/gi;
    var ESCAPES = /* @__PURE__ */ new Map([
      ["n", "\n"],
      ["r", "\r"],
      ["t", "	"],
      ["b", "\b"],
      ["f", "\f"],
      ["v", "\v"],
      ["0", "\0"],
      ["\\", "\\"],
      ["e", "\x1B"],
      ["a", "\x07"]
    ]);
    function unescape2(c2) {
      if (c2[0] === "u" && c2.length === 5 || c2[0] === "x" && c2.length === 3) {
        return String.fromCharCode(parseInt(c2.slice(1), 16));
      }
      return ESCAPES.get(c2) || c2;
    }
    function parseArguments(name, args) {
      const results = [];
      const chunks = args.trim().split(/\s*,\s*/g);
      let matches;
      for (const chunk of chunks) {
        if (!isNaN(chunk)) {
          results.push(Number(chunk));
        } else if (matches = chunk.match(STRING_REGEX)) {
          results.push(matches[2].replace(ESCAPE_REGEX, (m, escape3, chr) => escape3 ? unescape2(escape3) : chr));
        } else {
          throw new Error(`Invalid Chalk template style argument: ${chunk} (in style '${name}')`);
        }
      }
      return results;
    }
    function parseStyle(style) {
      STYLE_REGEX.lastIndex = 0;
      const results = [];
      let matches;
      while ((matches = STYLE_REGEX.exec(style)) !== null) {
        const name = matches[1];
        if (matches[2]) {
          const args = parseArguments(name, matches[2]);
          results.push([name].concat(args));
        } else {
          results.push([name]);
        }
      }
      return results;
    }
    function buildStyle(chalk, styles) {
      const enabled = {};
      for (const layer of styles) {
        for (const style of layer.styles) {
          enabled[style[0]] = layer.inverse ? null : style.slice(1);
        }
      }
      let current = chalk;
      for (const styleName of Object.keys(enabled)) {
        if (Array.isArray(enabled[styleName])) {
          if (!(styleName in current)) {
            throw new Error(`Unknown Chalk style: ${styleName}`);
          }
          if (enabled[styleName].length > 0) {
            current = current[styleName].apply(current, enabled[styleName]);
          } else {
            current = current[styleName];
          }
        }
      }
      return current;
    }
    module2.exports = (chalk, tmp) => {
      const styles = [];
      const chunks = [];
      let chunk = [];
      tmp.replace(TEMPLATE_REGEX, (m, escapeChar, inverse, style, close, chr) => {
        if (escapeChar) {
          chunk.push(unescape2(escapeChar));
        } else if (style) {
          const str2 = chunk.join("");
          chunk = [];
          chunks.push(styles.length === 0 ? str2 : buildStyle(chalk, styles)(str2));
          styles.push({ inverse, styles: parseStyle(style) });
        } else if (close) {
          if (styles.length === 0) {
            throw new Error("Found extraneous } in Chalk template literal");
          }
          chunks.push(buildStyle(chalk, styles)(chunk.join("")));
          chunk = [];
          styles.pop();
        } else {
          chunk.push(chr);
        }
      });
      chunks.push(chunk.join(""));
      if (styles.length > 0) {
        const errMsg = `Chalk template literal is missing ${styles.length} closing bracket${styles.length === 1 ? "" : "s"} (\`}\`)`;
        throw new Error(errMsg);
      }
      return chunks.join("");
    };
  }
});

// node_modules/@babel/highlight/node_modules/chalk/index.js
var require_chalk = __commonJS({
  "node_modules/@babel/highlight/node_modules/chalk/index.js"(exports2, module2) {
    "use strict";
    var escapeStringRegexp = require_escape_string_regexp();
    var ansiStyles = require_ansi_styles();
    var stdoutColor = require_supports_color().stdout;
    var template = require_templates();
    var isSimpleWindowsTerm = process.platform === "win32" && !(process.env.TERM || "").toLowerCase().startsWith("xterm");
    var levelMapping = ["ansi", "ansi", "ansi256", "ansi16m"];
    var skipModels = /* @__PURE__ */ new Set(["gray"]);
    var styles = /* @__PURE__ */ Object.create(null);
    function applyOptions(obj, options) {
      options = options || {};
      const scLevel = stdoutColor ? stdoutColor.level : 0;
      obj.level = options.level === void 0 ? scLevel : options.level;
      obj.enabled = "enabled" in options ? options.enabled : obj.level > 0;
    }
    function Chalk(options) {
      if (!this || !(this instanceof Chalk) || this.template) {
        const chalk = {};
        applyOptions(chalk, options);
        chalk.template = function() {
          const args = [].slice.call(arguments);
          return chalkTag.apply(null, [chalk.template].concat(args));
        };
        Object.setPrototypeOf(chalk, Chalk.prototype);
        Object.setPrototypeOf(chalk.template, chalk);
        chalk.template.constructor = Chalk;
        return chalk.template;
      }
      applyOptions(this, options);
    }
    if (isSimpleWindowsTerm) {
      ansiStyles.blue.open = "\x1B[94m";
    }
    for (const key of Object.keys(ansiStyles)) {
      ansiStyles[key].closeRe = new RegExp(escapeStringRegexp(ansiStyles[key].close), "g");
      styles[key] = {
        get() {
          const codes = ansiStyles[key];
          return build.call(this, this._styles ? this._styles.concat(codes) : [codes], this._empty, key);
        }
      };
    }
    styles.visible = {
      get() {
        return build.call(this, this._styles || [], true, "visible");
      }
    };
    ansiStyles.color.closeRe = new RegExp(escapeStringRegexp(ansiStyles.color.close), "g");
    for (const model of Object.keys(ansiStyles.color.ansi)) {
      if (skipModels.has(model)) {
        continue;
      }
      styles[model] = {
        get() {
          const level = this.level;
          return function() {
            const open = ansiStyles.color[levelMapping[level]][model].apply(null, arguments);
            const codes = {
              open,
              close: ansiStyles.color.close,
              closeRe: ansiStyles.color.closeRe
            };
            return build.call(this, this._styles ? this._styles.concat(codes) : [codes], this._empty, model);
          };
        }
      };
    }
    ansiStyles.bgColor.closeRe = new RegExp(escapeStringRegexp(ansiStyles.bgColor.close), "g");
    for (const model of Object.keys(ansiStyles.bgColor.ansi)) {
      if (skipModels.has(model)) {
        continue;
      }
      const bgModel = "bg" + model[0].toUpperCase() + model.slice(1);
      styles[bgModel] = {
        get() {
          const level = this.level;
          return function() {
            const open = ansiStyles.bgColor[levelMapping[level]][model].apply(null, arguments);
            const codes = {
              open,
              close: ansiStyles.bgColor.close,
              closeRe: ansiStyles.bgColor.closeRe
            };
            return build.call(this, this._styles ? this._styles.concat(codes) : [codes], this._empty, model);
          };
        }
      };
    }
    var proto = Object.defineProperties(() => {
    }, styles);
    function build(_styles, _empty, key) {
      const builder = function() {
        return applyStyle.apply(builder, arguments);
      };
      builder._styles = _styles;
      builder._empty = _empty;
      const self2 = this;
      Object.defineProperty(builder, "level", {
        enumerable: true,
        get() {
          return self2.level;
        },
        set(level) {
          self2.level = level;
        }
      });
      Object.defineProperty(builder, "enabled", {
        enumerable: true,
        get() {
          return self2.enabled;
        },
        set(enabled) {
          self2.enabled = enabled;
        }
      });
      builder.hasGrey = this.hasGrey || key === "gray" || key === "grey";
      builder.__proto__ = proto;
      return builder;
    }
    function applyStyle() {
      const args = arguments;
      const argsLen = args.length;
      let str2 = String(arguments[0]);
      if (argsLen === 0) {
        return "";
      }
      if (argsLen > 1) {
        for (let a = 1; a < argsLen; a++) {
          str2 += " " + args[a];
        }
      }
      if (!this.enabled || this.level <= 0 || !str2) {
        return this._empty ? "" : str2;
      }
      const originalDim = ansiStyles.dim.open;
      if (isSimpleWindowsTerm && this.hasGrey) {
        ansiStyles.dim.open = "";
      }
      for (const code of this._styles.slice().reverse()) {
        str2 = code.open + str2.replace(code.closeRe, code.open) + code.close;
        str2 = str2.replace(/\r?\n/g, `${code.close}$&${code.open}`);
      }
      ansiStyles.dim.open = originalDim;
      return str2;
    }
    function chalkTag(chalk, strings) {
      if (!Array.isArray(strings)) {
        return [].slice.call(arguments, 1).join(" ");
      }
      const args = [].slice.call(arguments, 2);
      const parts = [strings.raw[0]];
      for (let i = 1; i < strings.length; i++) {
        parts.push(String(args[i - 1]).replace(/[{}\\]/g, "\\$&"));
        parts.push(String(strings.raw[i]));
      }
      return template(chalk, parts.join(""));
    }
    Object.defineProperties(Chalk.prototype, styles);
    module2.exports = Chalk();
    module2.exports.supportsColor = stdoutColor;
    module2.exports.default = module2.exports;
  }
});

// node_modules/@babel/highlight/lib/index.js
var require_lib12 = __commonJS({
  "node_modules/@babel/highlight/lib/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = highlight;
    exports2.shouldHighlight = shouldHighlight;
    var _jsTokens = require_js_tokens();
    var _helperValidatorIdentifier = require_lib11();
    var _picocolors = _interopRequireWildcard(require_picocolors(), true);
    function _getRequireWildcardCache(e) {
      if ("function" != typeof WeakMap) return null;
      var r2 = /* @__PURE__ */ new WeakMap(), t = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = function(e2) {
        return e2 ? t : r2;
      })(e);
    }
    function _interopRequireWildcard(e, r2) {
      if (!r2 && e && e.__esModule) return e;
      if (null === e || "object" != typeof e && "function" != typeof e) return { default: e };
      var t = _getRequireWildcardCache(r2);
      if (t && t.has(e)) return t.get(e);
      var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) {
        var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;
        i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];
      }
      return n.default = e, t && t.set(e, n), n;
    }
    var colors = typeof process === "object" && (process.env.FORCE_COLOR === "0" || process.env.FORCE_COLOR === "false") ? (0, _picocolors.createColors)(false) : _picocolors.default;
    var compose = (f, g) => (v) => f(g(v));
    var sometimesKeywords = /* @__PURE__ */ new Set(["as", "async", "from", "get", "of", "set"]);
    function getDefs(colors2) {
      return {
        keyword: colors2.cyan,
        capitalized: colors2.yellow,
        jsxIdentifier: colors2.yellow,
        punctuator: colors2.yellow,
        number: colors2.magenta,
        string: colors2.green,
        regex: colors2.magenta,
        comment: colors2.gray,
        invalid: compose(compose(colors2.white, colors2.bgRed), colors2.bold)
      };
    }
    var NEWLINE = /\r\n|[\n\r\u2028\u2029]/;
    var BRACKET = /^[()[\]{}]$/;
    var tokenize;
    {
      const JSX_TAG = /^[a-z][\w-]*$/i;
      const getTokenType = function(token, offset, text) {
        if (token.type === "name") {
          if ((0, _helperValidatorIdentifier.isKeyword)(token.value) || (0, _helperValidatorIdentifier.isStrictReservedWord)(token.value, true) || sometimesKeywords.has(token.value)) {
            return "keyword";
          }
          if (JSX_TAG.test(token.value) && (text[offset - 1] === "<" || text.slice(offset - 2, offset) === "</")) {
            return "jsxIdentifier";
          }
          if (token.value[0] !== token.value[0].toLowerCase()) {
            return "capitalized";
          }
        }
        if (token.type === "punctuator" && BRACKET.test(token.value)) {
          return "bracket";
        }
        if (token.type === "invalid" && (token.value === "@" || token.value === "#")) {
          return "punctuator";
        }
        return token.type;
      };
      tokenize = function* (text) {
        let match2;
        while (match2 = _jsTokens.default.exec(text)) {
          const token = _jsTokens.matchToToken(match2);
          yield {
            type: getTokenType(token, match2.index, text),
            value: token.value
          };
        }
      };
    }
    function highlightTokens(defs, text) {
      let highlighted = "";
      for (const {
        type: type2,
        value
      } of tokenize(text)) {
        const colorize = defs[type2];
        if (colorize) {
          highlighted += value.split(NEWLINE).map((str2) => colorize(str2)).join("\n");
        } else {
          highlighted += value;
        }
      }
      return highlighted;
    }
    function shouldHighlight(options) {
      return colors.isColorSupported || options.forceColor;
    }
    var pcWithForcedColor = void 0;
    function getColors(forceColor) {
      if (forceColor) {
        var _pcWithForcedColor;
        (_pcWithForcedColor = pcWithForcedColor) != null ? _pcWithForcedColor : pcWithForcedColor = (0, _picocolors.createColors)(true);
        return pcWithForcedColor;
      }
      return colors;
    }
    function highlight(code, options = {}) {
      if (code !== "" && shouldHighlight(options)) {
        const defs = getDefs(getColors(options.forceColor));
        return highlightTokens(defs, code);
      } else {
        return code;
      }
    }
    {
      let chalk, chalkWithForcedColor;
      exports2.getChalk = ({
        forceColor
      }) => {
        var _chalk;
        (_chalk = chalk) != null ? _chalk : chalk = require_chalk();
        if (forceColor) {
          var _chalkWithForcedColor;
          (_chalkWithForcedColor = chalkWithForcedColor) != null ? _chalkWithForcedColor : chalkWithForcedColor = new chalk.constructor({
            enabled: true,
            level: 1
          });
          return chalkWithForcedColor;
        }
        return chalk;
      };
    }
  }
});

// node_modules/@babel/code-frame/lib/index.js
var require_lib13 = __commonJS({
  "node_modules/@babel/code-frame/lib/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.codeFrameColumns = codeFrameColumns;
    exports2.default = _default2;
    var _highlight = require_lib12();
    var _picocolors = _interopRequireWildcard(require_picocolors(), true);
    function _getRequireWildcardCache(e) {
      if ("function" != typeof WeakMap) return null;
      var r2 = /* @__PURE__ */ new WeakMap(), t = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = function(e2) {
        return e2 ? t : r2;
      })(e);
    }
    function _interopRequireWildcard(e, r2) {
      if (!r2 && e && e.__esModule) return e;
      if (null === e || "object" != typeof e && "function" != typeof e) return { default: e };
      var t = _getRequireWildcardCache(r2);
      if (t && t.has(e)) return t.get(e);
      var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) {
        var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;
        i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];
      }
      return n.default = e, t && t.set(e, n), n;
    }
    var colors = typeof process === "object" && (process.env.FORCE_COLOR === "0" || process.env.FORCE_COLOR === "false") ? (0, _picocolors.createColors)(false) : _picocolors.default;
    var compose = (f, g) => (v) => f(g(v));
    var pcWithForcedColor = void 0;
    function getColors(forceColor) {
      if (forceColor) {
        var _pcWithForcedColor;
        (_pcWithForcedColor = pcWithForcedColor) != null ? _pcWithForcedColor : pcWithForcedColor = (0, _picocolors.createColors)(true);
        return pcWithForcedColor;
      }
      return colors;
    }
    var deprecationWarningShown = false;
    function getDefs(colors2) {
      return {
        gutter: colors2.gray,
        marker: compose(colors2.red, colors2.bold),
        message: compose(colors2.red, colors2.bold)
      };
    }
    var NEWLINE = /\r\n|[\n\r\u2028\u2029]/;
    function getMarkerLines(loc, source, opts) {
      const startLoc = Object.assign({
        column: 0,
        line: -1
      }, loc.start);
      const endLoc = Object.assign({}, startLoc, loc.end);
      const {
        linesAbove = 2,
        linesBelow = 3
      } = opts || {};
      const startLine = startLoc.line;
      const startColumn = startLoc.column;
      const endLine = endLoc.line;
      const endColumn = endLoc.column;
      let start = Math.max(startLine - (linesAbove + 1), 0);
      let end = Math.min(source.length, endLine + linesBelow);
      if (startLine === -1) {
        start = 0;
      }
      if (endLine === -1) {
        end = source.length;
      }
      const lineDiff = endLine - startLine;
      const markerLines = {};
      if (lineDiff) {
        for (let i = 0; i <= lineDiff; i++) {
          const lineNumber = i + startLine;
          if (!startColumn) {
            markerLines[lineNumber] = true;
          } else if (i === 0) {
            const sourceLength = source[lineNumber - 1].length;
            markerLines[lineNumber] = [startColumn, sourceLength - startColumn + 1];
          } else if (i === lineDiff) {
            markerLines[lineNumber] = [0, endColumn];
          } else {
            const sourceLength = source[lineNumber - i].length;
            markerLines[lineNumber] = [0, sourceLength];
          }
        }
      } else {
        if (startColumn === endColumn) {
          if (startColumn) {
            markerLines[startLine] = [startColumn, 0];
          } else {
            markerLines[startLine] = true;
          }
        } else {
          markerLines[startLine] = [startColumn, endColumn - startColumn];
        }
      }
      return {
        start,
        end,
        markerLines
      };
    }
    function codeFrameColumns(rawLines, loc, opts = {}) {
      const highlighted = (opts.highlightCode || opts.forceColor) && (0, _highlight.shouldHighlight)(opts);
      const colors2 = getColors(opts.forceColor);
      const defs = getDefs(colors2);
      const maybeHighlight = (fmt, string) => {
        return highlighted ? fmt(string) : string;
      };
      const lines = rawLines.split(NEWLINE);
      const {
        start,
        end,
        markerLines
      } = getMarkerLines(loc, lines, opts);
      const hasColumns = loc.start && typeof loc.start.column === "number";
      const numberMaxWidth = String(end).length;
      const highlightedLines = highlighted ? (0, _highlight.default)(rawLines, opts) : rawLines;
      let frame = highlightedLines.split(NEWLINE, end).slice(start, end).map((line, index) => {
        const number = start + 1 + index;
        const paddedNumber = ` ${number}`.slice(-numberMaxWidth);
        const gutter = ` ${paddedNumber} |`;
        const hasMarker = markerLines[number];
        const lastMarkerLine = !markerLines[number + 1];
        if (hasMarker) {
          let markerLine = "";
          if (Array.isArray(hasMarker)) {
            const markerSpacing = line.slice(0, Math.max(hasMarker[0] - 1, 0)).replace(/[^\t]/g, " ");
            const numberOfMarkers = hasMarker[1] || 1;
            markerLine = ["\n ", maybeHighlight(defs.gutter, gutter.replace(/\d/g, " ")), " ", markerSpacing, maybeHighlight(defs.marker, "^").repeat(numberOfMarkers)].join("");
            if (lastMarkerLine && opts.message) {
              markerLine += " " + maybeHighlight(defs.message, opts.message);
            }
          }
          return [maybeHighlight(defs.marker, ">"), maybeHighlight(defs.gutter, gutter), line.length > 0 ? ` ${line}` : "", markerLine].join("");
        } else {
          return ` ${maybeHighlight(defs.gutter, gutter)}${line.length > 0 ? ` ${line}` : ""}`;
        }
      }).join("\n");
      if (opts.message && !hasColumns) {
        frame = `${" ".repeat(numberMaxWidth + 1)}${opts.message}
${frame}`;
      }
      if (highlighted) {
        return colors2.reset(frame);
      } else {
        return frame;
      }
    }
    function _default2(rawLines, lineNumber, colNumber, opts = {}) {
      if (!deprecationWarningShown) {
        deprecationWarningShown = true;
        const message = "Passing lineNumber and colNumber is deprecated to @babel/code-frame. Please use `codeFrameColumns`.";
        if (process.emitWarning) {
          process.emitWarning(message, "DeprecationWarning");
        } else {
          const deprecationError = new Error(message);
          deprecationError.name = "DeprecationWarning";
          console.warn(new Error(message));
        }
      }
      colNumber = Math.max(colNumber, 0);
      const location2 = {
        start: {
          column: colNumber,
          line: lineNumber
        }
      };
      return codeFrameColumns(rawLines, location2, opts);
    }
  }
});

// node_modules/color-name/index.js
var require_color_name2 = __commonJS({
  "node_modules/color-name/index.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      "aliceblue": [240, 248, 255],
      "antiquewhite": [250, 235, 215],
      "aqua": [0, 255, 255],
      "aquamarine": [127, 255, 212],
      "azure": [240, 255, 255],
      "beige": [245, 245, 220],
      "bisque": [255, 228, 196],
      "black": [0, 0, 0],
      "blanchedalmond": [255, 235, 205],
      "blue": [0, 0, 255],
      "blueviolet": [138, 43, 226],
      "brown": [165, 42, 42],
      "burlywood": [222, 184, 135],
      "cadetblue": [95, 158, 160],
      "chartreuse": [127, 255, 0],
      "chocolate": [210, 105, 30],
      "coral": [255, 127, 80],
      "cornflowerblue": [100, 149, 237],
      "cornsilk": [255, 248, 220],
      "crimson": [220, 20, 60],
      "cyan": [0, 255, 255],
      "darkblue": [0, 0, 139],
      "darkcyan": [0, 139, 139],
      "darkgoldenrod": [184, 134, 11],
      "darkgray": [169, 169, 169],
      "darkgreen": [0, 100, 0],
      "darkgrey": [169, 169, 169],
      "darkkhaki": [189, 183, 107],
      "darkmagenta": [139, 0, 139],
      "darkolivegreen": [85, 107, 47],
      "darkorange": [255, 140, 0],
      "darkorchid": [153, 50, 204],
      "darkred": [139, 0, 0],
      "darksalmon": [233, 150, 122],
      "darkseagreen": [143, 188, 143],
      "darkslateblue": [72, 61, 139],
      "darkslategray": [47, 79, 79],
      "darkslategrey": [47, 79, 79],
      "darkturquoise": [0, 206, 209],
      "darkviolet": [148, 0, 211],
      "deeppink": [255, 20, 147],
      "deepskyblue": [0, 191, 255],
      "dimgray": [105, 105, 105],
      "dimgrey": [105, 105, 105],
      "dodgerblue": [30, 144, 255],
      "firebrick": [178, 34, 34],
      "floralwhite": [255, 250, 240],
      "forestgreen": [34, 139, 34],
      "fuchsia": [255, 0, 255],
      "gainsboro": [220, 220, 220],
      "ghostwhite": [248, 248, 255],
      "gold": [255, 215, 0],
      "goldenrod": [218, 165, 32],
      "gray": [128, 128, 128],
      "green": [0, 128, 0],
      "greenyellow": [173, 255, 47],
      "grey": [128, 128, 128],
      "honeydew": [240, 255, 240],
      "hotpink": [255, 105, 180],
      "indianred": [205, 92, 92],
      "indigo": [75, 0, 130],
      "ivory": [255, 255, 240],
      "khaki": [240, 230, 140],
      "lavender": [230, 230, 250],
      "lavenderblush": [255, 240, 245],
      "lawngreen": [124, 252, 0],
      "lemonchiffon": [255, 250, 205],
      "lightblue": [173, 216, 230],
      "lightcoral": [240, 128, 128],
      "lightcyan": [224, 255, 255],
      "lightgoldenrodyellow": [250, 250, 210],
      "lightgray": [211, 211, 211],
      "lightgreen": [144, 238, 144],
      "lightgrey": [211, 211, 211],
      "lightpink": [255, 182, 193],
      "lightsalmon": [255, 160, 122],
      "lightseagreen": [32, 178, 170],
      "lightskyblue": [135, 206, 250],
      "lightslategray": [119, 136, 153],
      "lightslategrey": [119, 136, 153],
      "lightsteelblue": [176, 196, 222],
      "lightyellow": [255, 255, 224],
      "lime": [0, 255, 0],
      "limegreen": [50, 205, 50],
      "linen": [250, 240, 230],
      "magenta": [255, 0, 255],
      "maroon": [128, 0, 0],
      "mediumaquamarine": [102, 205, 170],
      "mediumblue": [0, 0, 205],
      "mediumorchid": [186, 85, 211],
      "mediumpurple": [147, 112, 219],
      "mediumseagreen": [60, 179, 113],
      "mediumslateblue": [123, 104, 238],
      "mediumspringgreen": [0, 250, 154],
      "mediumturquoise": [72, 209, 204],
      "mediumvioletred": [199, 21, 133],
      "midnightblue": [25, 25, 112],
      "mintcream": [245, 255, 250],
      "mistyrose": [255, 228, 225],
      "moccasin": [255, 228, 181],
      "navajowhite": [255, 222, 173],
      "navy": [0, 0, 128],
      "oldlace": [253, 245, 230],
      "olive": [128, 128, 0],
      "olivedrab": [107, 142, 35],
      "orange": [255, 165, 0],
      "orangered": [255, 69, 0],
      "orchid": [218, 112, 214],
      "palegoldenrod": [238, 232, 170],
      "palegreen": [152, 251, 152],
      "paleturquoise": [175, 238, 238],
      "palevioletred": [219, 112, 147],
      "papayawhip": [255, 239, 213],
      "peachpuff": [255, 218, 185],
      "peru": [205, 133, 63],
      "pink": [255, 192, 203],
      "plum": [221, 160, 221],
      "powderblue": [176, 224, 230],
      "purple": [128, 0, 128],
      "rebeccapurple": [102, 51, 153],
      "red": [255, 0, 0],
      "rosybrown": [188, 143, 143],
      "royalblue": [65, 105, 225],
      "saddlebrown": [139, 69, 19],
      "salmon": [250, 128, 114],
      "sandybrown": [244, 164, 96],
      "seagreen": [46, 139, 87],
      "seashell": [255, 245, 238],
      "sienna": [160, 82, 45],
      "silver": [192, 192, 192],
      "skyblue": [135, 206, 235],
      "slateblue": [106, 90, 205],
      "slategray": [112, 128, 144],
      "slategrey": [112, 128, 144],
      "snow": [255, 250, 250],
      "springgreen": [0, 255, 127],
      "steelblue": [70, 130, 180],
      "tan": [210, 180, 140],
      "teal": [0, 128, 128],
      "thistle": [216, 191, 216],
      "tomato": [255, 99, 71],
      "turquoise": [64, 224, 208],
      "violet": [238, 130, 238],
      "wheat": [245, 222, 179],
      "white": [255, 255, 255],
      "whitesmoke": [245, 245, 245],
      "yellow": [255, 255, 0],
      "yellowgreen": [154, 205, 50]
    };
  }
});

// node_modules/color-convert/conversions.js
var require_conversions2 = __commonJS({
  "node_modules/color-convert/conversions.js"(exports2, module2) {
    var cssKeywords = require_color_name2();
    var reverseKeywords = {};
    for (const key of Object.keys(cssKeywords)) {
      reverseKeywords[cssKeywords[key]] = key;
    }
    var convert2 = {
      rgb: { channels: 3, labels: "rgb" },
      hsl: { channels: 3, labels: "hsl" },
      hsv: { channels: 3, labels: "hsv" },
      hwb: { channels: 3, labels: "hwb" },
      cmyk: { channels: 4, labels: "cmyk" },
      xyz: { channels: 3, labels: "xyz" },
      lab: { channels: 3, labels: "lab" },
      lch: { channels: 3, labels: "lch" },
      hex: { channels: 1, labels: ["hex"] },
      keyword: { channels: 1, labels: ["keyword"] },
      ansi16: { channels: 1, labels: ["ansi16"] },
      ansi256: { channels: 1, labels: ["ansi256"] },
      hcg: { channels: 3, labels: ["h", "c", "g"] },
      apple: { channels: 3, labels: ["r16", "g16", "b16"] },
      gray: { channels: 1, labels: ["gray"] }
    };
    module2.exports = convert2;
    for (const model of Object.keys(convert2)) {
      if (!("channels" in convert2[model])) {
        throw new Error("missing channels property: " + model);
      }
      if (!("labels" in convert2[model])) {
        throw new Error("missing channel labels property: " + model);
      }
      if (convert2[model].labels.length !== convert2[model].channels) {
        throw new Error("channel and label counts mismatch: " + model);
      }
      const { channels, labels } = convert2[model];
      delete convert2[model].channels;
      delete convert2[model].labels;
      Object.defineProperty(convert2[model], "channels", { value: channels });
      Object.defineProperty(convert2[model], "labels", { value: labels });
    }
    convert2.rgb.hsl = function(rgb) {
      const r2 = rgb[0] / 255;
      const g = rgb[1] / 255;
      const b = rgb[2] / 255;
      const min = Math.min(r2, g, b);
      const max = Math.max(r2, g, b);
      const delta = max - min;
      let h;
      let s;
      if (max === min) {
        h = 0;
      } else if (r2 === max) {
        h = (g - b) / delta;
      } else if (g === max) {
        h = 2 + (b - r2) / delta;
      } else if (b === max) {
        h = 4 + (r2 - g) / delta;
      }
      h = Math.min(h * 60, 360);
      if (h < 0) {
        h += 360;
      }
      const l = (min + max) / 2;
      if (max === min) {
        s = 0;
      } else if (l <= 0.5) {
        s = delta / (max + min);
      } else {
        s = delta / (2 - max - min);
      }
      return [h, s * 100, l * 100];
    };
    convert2.rgb.hsv = function(rgb) {
      let rdif;
      let gdif;
      let bdif;
      let h;
      let s;
      const r2 = rgb[0] / 255;
      const g = rgb[1] / 255;
      const b = rgb[2] / 255;
      const v = Math.max(r2, g, b);
      const diff = v - Math.min(r2, g, b);
      const diffc = function(c2) {
        return (v - c2) / 6 / diff + 1 / 2;
      };
      if (diff === 0) {
        h = 0;
        s = 0;
      } else {
        s = diff / v;
        rdif = diffc(r2);
        gdif = diffc(g);
        bdif = diffc(b);
        if (r2 === v) {
          h = bdif - gdif;
        } else if (g === v) {
          h = 1 / 3 + rdif - bdif;
        } else if (b === v) {
          h = 2 / 3 + gdif - rdif;
        }
        if (h < 0) {
          h += 1;
        } else if (h > 1) {
          h -= 1;
        }
      }
      return [
        h * 360,
        s * 100,
        v * 100
      ];
    };
    convert2.rgb.hwb = function(rgb) {
      const r2 = rgb[0];
      const g = rgb[1];
      let b = rgb[2];
      const h = convert2.rgb.hsl(rgb)[0];
      const w = 1 / 255 * Math.min(r2, Math.min(g, b));
      b = 1 - 1 / 255 * Math.max(r2, Math.max(g, b));
      return [h, w * 100, b * 100];
    };
    convert2.rgb.cmyk = function(rgb) {
      const r2 = rgb[0] / 255;
      const g = rgb[1] / 255;
      const b = rgb[2] / 255;
      const k = Math.min(1 - r2, 1 - g, 1 - b);
      const c2 = (1 - r2 - k) / (1 - k) || 0;
      const m = (1 - g - k) / (1 - k) || 0;
      const y = (1 - b - k) / (1 - k) || 0;
      return [c2 * 100, m * 100, y * 100, k * 100];
    };
    function comparativeDistance(x, y) {
      return (x[0] - y[0]) ** 2 + (x[1] - y[1]) ** 2 + (x[2] - y[2]) ** 2;
    }
    convert2.rgb.keyword = function(rgb) {
      const reversed = reverseKeywords[rgb];
      if (reversed) {
        return reversed;
      }
      let currentClosestDistance = Infinity;
      let currentClosestKeyword;
      for (const keyword of Object.keys(cssKeywords)) {
        const value = cssKeywords[keyword];
        const distance = comparativeDistance(rgb, value);
        if (distance < currentClosestDistance) {
          currentClosestDistance = distance;
          currentClosestKeyword = keyword;
        }
      }
      return currentClosestKeyword;
    };
    convert2.keyword.rgb = function(keyword) {
      return cssKeywords[keyword];
    };
    convert2.rgb.xyz = function(rgb) {
      let r2 = rgb[0] / 255;
      let g = rgb[1] / 255;
      let b = rgb[2] / 255;
      r2 = r2 > 0.04045 ? ((r2 + 0.055) / 1.055) ** 2.4 : r2 / 12.92;
      g = g > 0.04045 ? ((g + 0.055) / 1.055) ** 2.4 : g / 12.92;
      b = b > 0.04045 ? ((b + 0.055) / 1.055) ** 2.4 : b / 12.92;
      const x = r2 * 0.4124 + g * 0.3576 + b * 0.1805;
      const y = r2 * 0.2126 + g * 0.7152 + b * 0.0722;
      const z = r2 * 0.0193 + g * 0.1192 + b * 0.9505;
      return [x * 100, y * 100, z * 100];
    };
    convert2.rgb.lab = function(rgb) {
      const xyz = convert2.rgb.xyz(rgb);
      let x = xyz[0];
      let y = xyz[1];
      let z = xyz[2];
      x /= 95.047;
      y /= 100;
      z /= 108.883;
      x = x > 8856e-6 ? x ** (1 / 3) : 7.787 * x + 16 / 116;
      y = y > 8856e-6 ? y ** (1 / 3) : 7.787 * y + 16 / 116;
      z = z > 8856e-6 ? z ** (1 / 3) : 7.787 * z + 16 / 116;
      const l = 116 * y - 16;
      const a = 500 * (x - y);
      const b = 200 * (y - z);
      return [l, a, b];
    };
    convert2.hsl.rgb = function(hsl) {
      const h = hsl[0] / 360;
      const s = hsl[1] / 100;
      const l = hsl[2] / 100;
      let t2;
      let t3;
      let val;
      if (s === 0) {
        val = l * 255;
        return [val, val, val];
      }
      if (l < 0.5) {
        t2 = l * (1 + s);
      } else {
        t2 = l + s - l * s;
      }
      const t1 = 2 * l - t2;
      const rgb = [0, 0, 0];
      for (let i = 0; i < 3; i++) {
        t3 = h + 1 / 3 * -(i - 1);
        if (t3 < 0) {
          t3++;
        }
        if (t3 > 1) {
          t3--;
        }
        if (6 * t3 < 1) {
          val = t1 + (t2 - t1) * 6 * t3;
        } else if (2 * t3 < 1) {
          val = t2;
        } else if (3 * t3 < 2) {
          val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
        } else {
          val = t1;
        }
        rgb[i] = val * 255;
      }
      return rgb;
    };
    convert2.hsl.hsv = function(hsl) {
      const h = hsl[0];
      let s = hsl[1] / 100;
      let l = hsl[2] / 100;
      let smin = s;
      const lmin = Math.max(l, 0.01);
      l *= 2;
      s *= l <= 1 ? l : 2 - l;
      smin *= lmin <= 1 ? lmin : 2 - lmin;
      const v = (l + s) / 2;
      const sv = l === 0 ? 2 * smin / (lmin + smin) : 2 * s / (l + s);
      return [h, sv * 100, v * 100];
    };
    convert2.hsv.rgb = function(hsv) {
      const h = hsv[0] / 60;
      const s = hsv[1] / 100;
      let v = hsv[2] / 100;
      const hi = Math.floor(h) % 6;
      const f = h - Math.floor(h);
      const p = 255 * v * (1 - s);
      const q = 255 * v * (1 - s * f);
      const t = 255 * v * (1 - s * (1 - f));
      v *= 255;
      switch (hi) {
        case 0:
          return [v, t, p];
        case 1:
          return [q, v, p];
        case 2:
          return [p, v, t];
        case 3:
          return [p, q, v];
        case 4:
          return [t, p, v];
        case 5:
          return [v, p, q];
      }
    };
    convert2.hsv.hsl = function(hsv) {
      const h = hsv[0];
      const s = hsv[1] / 100;
      const v = hsv[2] / 100;
      const vmin = Math.max(v, 0.01);
      let sl;
      let l;
      l = (2 - s) * v;
      const lmin = (2 - s) * vmin;
      sl = s * vmin;
      sl /= lmin <= 1 ? lmin : 2 - lmin;
      sl = sl || 0;
      l /= 2;
      return [h, sl * 100, l * 100];
    };
    convert2.hwb.rgb = function(hwb) {
      const h = hwb[0] / 360;
      let wh = hwb[1] / 100;
      let bl = hwb[2] / 100;
      const ratio = wh + bl;
      let f;
      if (ratio > 1) {
        wh /= ratio;
        bl /= ratio;
      }
      const i = Math.floor(6 * h);
      const v = 1 - bl;
      f = 6 * h - i;
      if ((i & 1) !== 0) {
        f = 1 - f;
      }
      const n = wh + f * (v - wh);
      let r2;
      let g;
      let b;
      switch (i) {
        default:
        case 6:
        case 0:
          r2 = v;
          g = n;
          b = wh;
          break;
        case 1:
          r2 = n;
          g = v;
          b = wh;
          break;
        case 2:
          r2 = wh;
          g = v;
          b = n;
          break;
        case 3:
          r2 = wh;
          g = n;
          b = v;
          break;
        case 4:
          r2 = n;
          g = wh;
          b = v;
          break;
        case 5:
          r2 = v;
          g = wh;
          b = n;
          break;
      }
      return [r2 * 255, g * 255, b * 255];
    };
    convert2.cmyk.rgb = function(cmyk) {
      const c2 = cmyk[0] / 100;
      const m = cmyk[1] / 100;
      const y = cmyk[2] / 100;
      const k = cmyk[3] / 100;
      const r2 = 1 - Math.min(1, c2 * (1 - k) + k);
      const g = 1 - Math.min(1, m * (1 - k) + k);
      const b = 1 - Math.min(1, y * (1 - k) + k);
      return [r2 * 255, g * 255, b * 255];
    };
    convert2.xyz.rgb = function(xyz) {
      const x = xyz[0] / 100;
      const y = xyz[1] / 100;
      const z = xyz[2] / 100;
      let r2;
      let g;
      let b;
      r2 = x * 3.2406 + y * -1.5372 + z * -0.4986;
      g = x * -0.9689 + y * 1.8758 + z * 0.0415;
      b = x * 0.0557 + y * -0.204 + z * 1.057;
      r2 = r2 > 31308e-7 ? 1.055 * r2 ** (1 / 2.4) - 0.055 : r2 * 12.92;
      g = g > 31308e-7 ? 1.055 * g ** (1 / 2.4) - 0.055 : g * 12.92;
      b = b > 31308e-7 ? 1.055 * b ** (1 / 2.4) - 0.055 : b * 12.92;
      r2 = Math.min(Math.max(0, r2), 1);
      g = Math.min(Math.max(0, g), 1);
      b = Math.min(Math.max(0, b), 1);
      return [r2 * 255, g * 255, b * 255];
    };
    convert2.xyz.lab = function(xyz) {
      let x = xyz[0];
      let y = xyz[1];
      let z = xyz[2];
      x /= 95.047;
      y /= 100;
      z /= 108.883;
      x = x > 8856e-6 ? x ** (1 / 3) : 7.787 * x + 16 / 116;
      y = y > 8856e-6 ? y ** (1 / 3) : 7.787 * y + 16 / 116;
      z = z > 8856e-6 ? z ** (1 / 3) : 7.787 * z + 16 / 116;
      const l = 116 * y - 16;
      const a = 500 * (x - y);
      const b = 200 * (y - z);
      return [l, a, b];
    };
    convert2.lab.xyz = function(lab) {
      const l = lab[0];
      const a = lab[1];
      const b = lab[2];
      let x;
      let y;
      let z;
      y = (l + 16) / 116;
      x = a / 500 + y;
      z = y - b / 200;
      const y2 = y ** 3;
      const x2 = x ** 3;
      const z2 = z ** 3;
      y = y2 > 8856e-6 ? y2 : (y - 16 / 116) / 7.787;
      x = x2 > 8856e-6 ? x2 : (x - 16 / 116) / 7.787;
      z = z2 > 8856e-6 ? z2 : (z - 16 / 116) / 7.787;
      x *= 95.047;
      y *= 100;
      z *= 108.883;
      return [x, y, z];
    };
    convert2.lab.lch = function(lab) {
      const l = lab[0];
      const a = lab[1];
      const b = lab[2];
      let h;
      const hr = Math.atan2(b, a);
      h = hr * 360 / 2 / Math.PI;
      if (h < 0) {
        h += 360;
      }
      const c2 = Math.sqrt(a * a + b * b);
      return [l, c2, h];
    };
    convert2.lch.lab = function(lch) {
      const l = lch[0];
      const c2 = lch[1];
      const h = lch[2];
      const hr = h / 360 * 2 * Math.PI;
      const a = c2 * Math.cos(hr);
      const b = c2 * Math.sin(hr);
      return [l, a, b];
    };
    convert2.rgb.ansi16 = function(args, saturation = null) {
      const [r2, g, b] = args;
      let value = saturation === null ? convert2.rgb.hsv(args)[2] : saturation;
      value = Math.round(value / 50);
      if (value === 0) {
        return 30;
      }
      let ansi = 30 + (Math.round(b / 255) << 2 | Math.round(g / 255) << 1 | Math.round(r2 / 255));
      if (value === 2) {
        ansi += 60;
      }
      return ansi;
    };
    convert2.hsv.ansi16 = function(args) {
      return convert2.rgb.ansi16(convert2.hsv.rgb(args), args[2]);
    };
    convert2.rgb.ansi256 = function(args) {
      const r2 = args[0];
      const g = args[1];
      const b = args[2];
      if (r2 === g && g === b) {
        if (r2 < 8) {
          return 16;
        }
        if (r2 > 248) {
          return 231;
        }
        return Math.round((r2 - 8) / 247 * 24) + 232;
      }
      const ansi = 16 + 36 * Math.round(r2 / 255 * 5) + 6 * Math.round(g / 255 * 5) + Math.round(b / 255 * 5);
      return ansi;
    };
    convert2.ansi16.rgb = function(args) {
      let color = args % 10;
      if (color === 0 || color === 7) {
        if (args > 50) {
          color += 3.5;
        }
        color = color / 10.5 * 255;
        return [color, color, color];
      }
      const mult = (~~(args > 50) + 1) * 0.5;
      const r2 = (color & 1) * mult * 255;
      const g = (color >> 1 & 1) * mult * 255;
      const b = (color >> 2 & 1) * mult * 255;
      return [r2, g, b];
    };
    convert2.ansi256.rgb = function(args) {
      if (args >= 232) {
        const c2 = (args - 232) * 10 + 8;
        return [c2, c2, c2];
      }
      args -= 16;
      let rem;
      const r2 = Math.floor(args / 36) / 5 * 255;
      const g = Math.floor((rem = args % 36) / 6) / 5 * 255;
      const b = rem % 6 / 5 * 255;
      return [r2, g, b];
    };
    convert2.rgb.hex = function(args) {
      const integer = ((Math.round(args[0]) & 255) << 16) + ((Math.round(args[1]) & 255) << 8) + (Math.round(args[2]) & 255);
      const string = integer.toString(16).toUpperCase();
      return "000000".substring(string.length) + string;
    };
    convert2.hex.rgb = function(args) {
      const match2 = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
      if (!match2) {
        return [0, 0, 0];
      }
      let colorString = match2[0];
      if (match2[0].length === 3) {
        colorString = colorString.split("").map((char) => {
          return char + char;
        }).join("");
      }
      const integer = parseInt(colorString, 16);
      const r2 = integer >> 16 & 255;
      const g = integer >> 8 & 255;
      const b = integer & 255;
      return [r2, g, b];
    };
    convert2.rgb.hcg = function(rgb) {
      const r2 = rgb[0] / 255;
      const g = rgb[1] / 255;
      const b = rgb[2] / 255;
      const max = Math.max(Math.max(r2, g), b);
      const min = Math.min(Math.min(r2, g), b);
      const chroma = max - min;
      let grayscale;
      let hue;
      if (chroma < 1) {
        grayscale = min / (1 - chroma);
      } else {
        grayscale = 0;
      }
      if (chroma <= 0) {
        hue = 0;
      } else if (max === r2) {
        hue = (g - b) / chroma % 6;
      } else if (max === g) {
        hue = 2 + (b - r2) / chroma;
      } else {
        hue = 4 + (r2 - g) / chroma;
      }
      hue /= 6;
      hue %= 1;
      return [hue * 360, chroma * 100, grayscale * 100];
    };
    convert2.hsl.hcg = function(hsl) {
      const s = hsl[1] / 100;
      const l = hsl[2] / 100;
      const c2 = l < 0.5 ? 2 * s * l : 2 * s * (1 - l);
      let f = 0;
      if (c2 < 1) {
        f = (l - 0.5 * c2) / (1 - c2);
      }
      return [hsl[0], c2 * 100, f * 100];
    };
    convert2.hsv.hcg = function(hsv) {
      const s = hsv[1] / 100;
      const v = hsv[2] / 100;
      const c2 = s * v;
      let f = 0;
      if (c2 < 1) {
        f = (v - c2) / (1 - c2);
      }
      return [hsv[0], c2 * 100, f * 100];
    };
    convert2.hcg.rgb = function(hcg) {
      const h = hcg[0] / 360;
      const c2 = hcg[1] / 100;
      const g = hcg[2] / 100;
      if (c2 === 0) {
        return [g * 255, g * 255, g * 255];
      }
      const pure = [0, 0, 0];
      const hi = h % 1 * 6;
      const v = hi % 1;
      const w = 1 - v;
      let mg = 0;
      switch (Math.floor(hi)) {
        case 0:
          pure[0] = 1;
          pure[1] = v;
          pure[2] = 0;
          break;
        case 1:
          pure[0] = w;
          pure[1] = 1;
          pure[2] = 0;
          break;
        case 2:
          pure[0] = 0;
          pure[1] = 1;
          pure[2] = v;
          break;
        case 3:
          pure[0] = 0;
          pure[1] = w;
          pure[2] = 1;
          break;
        case 4:
          pure[0] = v;
          pure[1] = 0;
          pure[2] = 1;
          break;
        default:
          pure[0] = 1;
          pure[1] = 0;
          pure[2] = w;
      }
      mg = (1 - c2) * g;
      return [
        (c2 * pure[0] + mg) * 255,
        (c2 * pure[1] + mg) * 255,
        (c2 * pure[2] + mg) * 255
      ];
    };
    convert2.hcg.hsv = function(hcg) {
      const c2 = hcg[1] / 100;
      const g = hcg[2] / 100;
      const v = c2 + g * (1 - c2);
      let f = 0;
      if (v > 0) {
        f = c2 / v;
      }
      return [hcg[0], f * 100, v * 100];
    };
    convert2.hcg.hsl = function(hcg) {
      const c2 = hcg[1] / 100;
      const g = hcg[2] / 100;
      const l = g * (1 - c2) + 0.5 * c2;
      let s = 0;
      if (l > 0 && l < 0.5) {
        s = c2 / (2 * l);
      } else if (l >= 0.5 && l < 1) {
        s = c2 / (2 * (1 - l));
      }
      return [hcg[0], s * 100, l * 100];
    };
    convert2.hcg.hwb = function(hcg) {
      const c2 = hcg[1] / 100;
      const g = hcg[2] / 100;
      const v = c2 + g * (1 - c2);
      return [hcg[0], (v - c2) * 100, (1 - v) * 100];
    };
    convert2.hwb.hcg = function(hwb) {
      const w = hwb[1] / 100;
      const b = hwb[2] / 100;
      const v = 1 - b;
      const c2 = v - w;
      let g = 0;
      if (c2 < 1) {
        g = (v - c2) / (1 - c2);
      }
      return [hwb[0], c2 * 100, g * 100];
    };
    convert2.apple.rgb = function(apple) {
      return [apple[0] / 65535 * 255, apple[1] / 65535 * 255, apple[2] / 65535 * 255];
    };
    convert2.rgb.apple = function(rgb) {
      return [rgb[0] / 255 * 65535, rgb[1] / 255 * 65535, rgb[2] / 255 * 65535];
    };
    convert2.gray.rgb = function(args) {
      return [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];
    };
    convert2.gray.hsl = function(args) {
      return [0, 0, args[0]];
    };
    convert2.gray.hsv = convert2.gray.hsl;
    convert2.gray.hwb = function(gray) {
      return [0, 100, gray[0]];
    };
    convert2.gray.cmyk = function(gray) {
      return [0, 0, 0, gray[0]];
    };
    convert2.gray.lab = function(gray) {
      return [gray[0], 0, 0];
    };
    convert2.gray.hex = function(gray) {
      const val = Math.round(gray[0] / 100 * 255) & 255;
      const integer = (val << 16) + (val << 8) + val;
      const string = integer.toString(16).toUpperCase();
      return "000000".substring(string.length) + string;
    };
    convert2.rgb.gray = function(rgb) {
      const val = (rgb[0] + rgb[1] + rgb[2]) / 3;
      return [val / 255 * 100];
    };
  }
});

// node_modules/color-convert/route.js
var require_route2 = __commonJS({
  "node_modules/color-convert/route.js"(exports2, module2) {
    var conversions = require_conversions2();
    function buildGraph() {
      const graph = {};
      const models = Object.keys(conversions);
      for (let len = models.length, i = 0; i < len; i++) {
        graph[models[i]] = {
          // http://jsperf.com/1-vs-infinity
          // micro-opt, but this is simple.
          distance: -1,
          parent: null
        };
      }
      return graph;
    }
    function deriveBFS(fromModel) {
      const graph = buildGraph();
      const queue = [fromModel];
      graph[fromModel].distance = 0;
      while (queue.length) {
        const current = queue.pop();
        const adjacents = Object.keys(conversions[current]);
        for (let len = adjacents.length, i = 0; i < len; i++) {
          const adjacent = adjacents[i];
          const node2 = graph[adjacent];
          if (node2.distance === -1) {
            node2.distance = graph[current].distance + 1;
            node2.parent = current;
            queue.unshift(adjacent);
          }
        }
      }
      return graph;
    }
    function link(from, to) {
      return function(args) {
        return to(from(args));
      };
    }
    function wrapConversion(toModel, graph) {
      const path = [graph[toModel].parent, toModel];
      let fn = conversions[graph[toModel].parent][toModel];
      let cur = graph[toModel].parent;
      while (graph[cur].parent) {
        path.unshift(graph[cur].parent);
        fn = link(conversions[graph[cur].parent][cur], fn);
        cur = graph[cur].parent;
      }
      fn.conversion = path;
      return fn;
    }
    module2.exports = function(fromModel) {
      const graph = deriveBFS(fromModel);
      const conversion = {};
      const models = Object.keys(graph);
      for (let len = models.length, i = 0; i < len; i++) {
        const toModel = models[i];
        const node2 = graph[toModel];
        if (node2.parent === null) {
          continue;
        }
        conversion[toModel] = wrapConversion(toModel, graph);
      }
      return conversion;
    };
  }
});

// node_modules/color-convert/index.js
var require_color_convert2 = __commonJS({
  "node_modules/color-convert/index.js"(exports2, module2) {
    var conversions = require_conversions2();
    var route = require_route2();
    var convert2 = {};
    var models = Object.keys(conversions);
    function wrapRaw(fn) {
      const wrappedFn = function(...args) {
        const arg0 = args[0];
        if (arg0 === void 0 || arg0 === null) {
          return arg0;
        }
        if (arg0.length > 1) {
          args = arg0;
        }
        return fn(args);
      };
      if ("conversion" in fn) {
        wrappedFn.conversion = fn.conversion;
      }
      return wrappedFn;
    }
    function wrapRounded(fn) {
      const wrappedFn = function(...args) {
        const arg0 = args[0];
        if (arg0 === void 0 || arg0 === null) {
          return arg0;
        }
        if (arg0.length > 1) {
          args = arg0;
        }
        const result = fn(args);
        if (typeof result === "object") {
          for (let len = result.length, i = 0; i < len; i++) {
            result[i] = Math.round(result[i]);
          }
        }
        return result;
      };
      if ("conversion" in fn) {
        wrappedFn.conversion = fn.conversion;
      }
      return wrappedFn;
    }
    models.forEach((fromModel) => {
      convert2[fromModel] = {};
      Object.defineProperty(convert2[fromModel], "channels", { value: conversions[fromModel].channels });
      Object.defineProperty(convert2[fromModel], "labels", { value: conversions[fromModel].labels });
      const routes = route(fromModel);
      const routeModels = Object.keys(routes);
      routeModels.forEach((toModel) => {
        const fn = routes[toModel];
        convert2[fromModel][toModel] = wrapRounded(fn);
        convert2[fromModel][toModel].raw = wrapRaw(fn);
      });
    });
    module2.exports = convert2;
  }
});

// node_modules/ansi-styles/index.js
var require_ansi_styles2 = __commonJS({
  "node_modules/ansi-styles/index.js"(exports2, module2) {
    "use strict";
    var wrapAnsi16 = (fn, offset) => (...args) => {
      const code = fn(...args);
      return `\x1B[${code + offset}m`;
    };
    var wrapAnsi256 = (fn, offset) => (...args) => {
      const code = fn(...args);
      return `\x1B[${38 + offset};5;${code}m`;
    };
    var wrapAnsi16m = (fn, offset) => (...args) => {
      const rgb = fn(...args);
      return `\x1B[${38 + offset};2;${rgb[0]};${rgb[1]};${rgb[2]}m`;
    };
    var ansi2ansi = (n) => n;
    var rgb2rgb = (r2, g, b) => [r2, g, b];
    var setLazyProperty = (object, property, get2) => {
      Object.defineProperty(object, property, {
        get: () => {
          const value = get2();
          Object.defineProperty(object, property, {
            value,
            enumerable: true,
            configurable: true
          });
          return value;
        },
        enumerable: true,
        configurable: true
      });
    };
    var colorConvert;
    var makeDynamicStyles = (wrap, targetSpace, identity, isBackground) => {
      if (colorConvert === void 0) {
        colorConvert = require_color_convert2();
      }
      const offset = isBackground ? 10 : 0;
      const styles = {};
      for (const [sourceSpace, suite] of Object.entries(colorConvert)) {
        const name = sourceSpace === "ansi16" ? "ansi" : sourceSpace;
        if (sourceSpace === targetSpace) {
          styles[name] = wrap(identity, offset);
        } else if (typeof suite === "object") {
          styles[name] = wrap(suite[targetSpace], offset);
        }
      }
      return styles;
    };
    function assembleStyles() {
      const codes = /* @__PURE__ */ new Map();
      const styles = {
        modifier: {
          reset: [0, 0],
          // 21 isn't widely supported and 22 does the same thing
          bold: [1, 22],
          dim: [2, 22],
          italic: [3, 23],
          underline: [4, 24],
          inverse: [7, 27],
          hidden: [8, 28],
          strikethrough: [9, 29]
        },
        color: {
          black: [30, 39],
          red: [31, 39],
          green: [32, 39],
          yellow: [33, 39],
          blue: [34, 39],
          magenta: [35, 39],
          cyan: [36, 39],
          white: [37, 39],
          // Bright color
          blackBright: [90, 39],
          redBright: [91, 39],
          greenBright: [92, 39],
          yellowBright: [93, 39],
          blueBright: [94, 39],
          magentaBright: [95, 39],
          cyanBright: [96, 39],
          whiteBright: [97, 39]
        },
        bgColor: {
          bgBlack: [40, 49],
          bgRed: [41, 49],
          bgGreen: [42, 49],
          bgYellow: [43, 49],
          bgBlue: [44, 49],
          bgMagenta: [45, 49],
          bgCyan: [46, 49],
          bgWhite: [47, 49],
          // Bright color
          bgBlackBright: [100, 49],
          bgRedBright: [101, 49],
          bgGreenBright: [102, 49],
          bgYellowBright: [103, 49],
          bgBlueBright: [104, 49],
          bgMagentaBright: [105, 49],
          bgCyanBright: [106, 49],
          bgWhiteBright: [107, 49]
        }
      };
      styles.color.gray = styles.color.blackBright;
      styles.bgColor.bgGray = styles.bgColor.bgBlackBright;
      styles.color.grey = styles.color.blackBright;
      styles.bgColor.bgGrey = styles.bgColor.bgBlackBright;
      for (const [groupName, group] of Object.entries(styles)) {
        for (const [styleName, style] of Object.entries(group)) {
          styles[styleName] = {
            open: `\x1B[${style[0]}m`,
            close: `\x1B[${style[1]}m`
          };
          group[styleName] = styles[styleName];
          codes.set(style[0], style[1]);
        }
        Object.defineProperty(styles, groupName, {
          value: group,
          enumerable: false
        });
      }
      Object.defineProperty(styles, "codes", {
        value: codes,
        enumerable: false
      });
      styles.color.close = "\x1B[39m";
      styles.bgColor.close = "\x1B[49m";
      setLazyProperty(styles.color, "ansi", () => makeDynamicStyles(wrapAnsi16, "ansi16", ansi2ansi, false));
      setLazyProperty(styles.color, "ansi256", () => makeDynamicStyles(wrapAnsi256, "ansi256", ansi2ansi, false));
      setLazyProperty(styles.color, "ansi16m", () => makeDynamicStyles(wrapAnsi16m, "rgb", rgb2rgb, false));
      setLazyProperty(styles.bgColor, "ansi", () => makeDynamicStyles(wrapAnsi16, "ansi16", ansi2ansi, true));
      setLazyProperty(styles.bgColor, "ansi256", () => makeDynamicStyles(wrapAnsi256, "ansi256", ansi2ansi, true));
      setLazyProperty(styles.bgColor, "ansi16m", () => makeDynamicStyles(wrapAnsi16m, "rgb", rgb2rgb, true));
      return styles;
    }
    Object.defineProperty(module2, "exports", {
      enumerable: true,
      get: assembleStyles
    });
  }
});

// node_modules/has-flag/index.js
var require_has_flag2 = __commonJS({
  "node_modules/has-flag/index.js"(exports2, module2) {
    "use strict";
    module2.exports = (flag, argv = process.argv) => {
      const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
      const position = argv.indexOf(prefix + flag);
      const terminatorPosition = argv.indexOf("--");
      return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
    };
  }
});

// node_modules/supports-color/index.js
var require_supports_color2 = __commonJS({
  "node_modules/supports-color/index.js"(exports2, module2) {
    "use strict";
    var os = require("os");
    var tty = require("tty");
    var hasFlag = require_has_flag2();
    var { env } = process;
    var forceColor;
    if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false") || hasFlag("color=never")) {
      forceColor = 0;
    } else if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) {
      forceColor = 1;
    }
    if ("FORCE_COLOR" in env) {
      if (env.FORCE_COLOR === "true") {
        forceColor = 1;
      } else if (env.FORCE_COLOR === "false") {
        forceColor = 0;
      } else {
        forceColor = env.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(env.FORCE_COLOR, 10), 3);
      }
    }
    function translateLevel(level) {
      if (level === 0) {
        return false;
      }
      return {
        level,
        hasBasic: true,
        has256: level >= 2,
        has16m: level >= 3
      };
    }
    function supportsColor(haveStream, streamIsTTY) {
      if (forceColor === 0) {
        return 0;
      }
      if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) {
        return 3;
      }
      if (hasFlag("color=256")) {
        return 2;
      }
      if (haveStream && !streamIsTTY && forceColor === void 0) {
        return 0;
      }
      const min = forceColor || 0;
      if (env.TERM === "dumb") {
        return min;
      }
      if (process.platform === "win32") {
        const osRelease = os.release().split(".");
        if (Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
          return Number(osRelease[2]) >= 14931 ? 3 : 2;
        }
        return 1;
      }
      if ("CI" in env) {
        if (["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI", "GITHUB_ACTIONS", "BUILDKITE"].some((sign) => sign in env) || env.CI_NAME === "codeship") {
          return 1;
        }
        return min;
      }
      if ("TEAMCITY_VERSION" in env) {
        return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
      }
      if (env.COLORTERM === "truecolor") {
        return 3;
      }
      if ("TERM_PROGRAM" in env) {
        const version = parseInt((env.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
        switch (env.TERM_PROGRAM) {
          case "iTerm.app":
            return version >= 3 ? 3 : 2;
          case "Apple_Terminal":
            return 2;
        }
      }
      if (/-256(color)?$/i.test(env.TERM)) {
        return 2;
      }
      if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
        return 1;
      }
      if ("COLORTERM" in env) {
        return 1;
      }
      return min;
    }
    function getSupportLevel(stream) {
      const level = supportsColor(stream, stream && stream.isTTY);
      return translateLevel(level);
    }
    module2.exports = {
      supportsColor: getSupportLevel,
      stdout: translateLevel(supportsColor(true, tty.isatty(1))),
      stderr: translateLevel(supportsColor(true, tty.isatty(2)))
    };
  }
});

// node_modules/chalk/source/util.js
var require_util2 = __commonJS({
  "node_modules/chalk/source/util.js"(exports2, module2) {
    "use strict";
    var stringReplaceAll = (string, substring, replacer) => {
      let index = string.indexOf(substring);
      if (index === -1) {
        return string;
      }
      const substringLength = substring.length;
      let endIndex = 0;
      let returnValue = "";
      do {
        returnValue += string.substr(endIndex, index - endIndex) + substring + replacer;
        endIndex = index + substringLength;
        index = string.indexOf(substring, endIndex);
      } while (index !== -1);
      returnValue += string.substr(endIndex);
      return returnValue;
    };
    var stringEncaseCRLFWithFirstIndex = (string, prefix, postfix, index) => {
      let endIndex = 0;
      let returnValue = "";
      do {
        const gotCR = string[index - 1] === "\r";
        returnValue += string.substr(endIndex, (gotCR ? index - 1 : index) - endIndex) + prefix + (gotCR ? "\r\n" : "\n") + postfix;
        endIndex = index + 1;
        index = string.indexOf("\n", endIndex);
      } while (index !== -1);
      returnValue += string.substr(endIndex);
      return returnValue;
    };
    module2.exports = {
      stringReplaceAll,
      stringEncaseCRLFWithFirstIndex
    };
  }
});

// node_modules/chalk/source/templates.js
var require_templates2 = __commonJS({
  "node_modules/chalk/source/templates.js"(exports2, module2) {
    "use strict";
    var TEMPLATE_REGEX = /(?:\\(u(?:[a-f\d]{4}|\{[a-f\d]{1,6}\})|x[a-f\d]{2}|.))|(?:\{(~)?(\w+(?:\([^)]*\))?(?:\.\w+(?:\([^)]*\))?)*)(?:[ \t]|(?=\r?\n)))|(\})|((?:.|[\r\n\f])+?)/gi;
    var STYLE_REGEX = /(?:^|\.)(\w+)(?:\(([^)]*)\))?/g;
    var STRING_REGEX = /^(['"])((?:\\.|(?!\1)[^\\])*)\1$/;
    var ESCAPE_REGEX = /\\(u(?:[a-f\d]{4}|{[a-f\d]{1,6}})|x[a-f\d]{2}|.)|([^\\])/gi;
    var ESCAPES = /* @__PURE__ */ new Map([
      ["n", "\n"],
      ["r", "\r"],
      ["t", "	"],
      ["b", "\b"],
      ["f", "\f"],
      ["v", "\v"],
      ["0", "\0"],
      ["\\", "\\"],
      ["e", "\x1B"],
      ["a", "\x07"]
    ]);
    function unescape2(c2) {
      const u = c2[0] === "u";
      const bracket = c2[1] === "{";
      if (u && !bracket && c2.length === 5 || c2[0] === "x" && c2.length === 3) {
        return String.fromCharCode(parseInt(c2.slice(1), 16));
      }
      if (u && bracket) {
        return String.fromCodePoint(parseInt(c2.slice(2, -1), 16));
      }
      return ESCAPES.get(c2) || c2;
    }
    function parseArguments(name, arguments_) {
      const results = [];
      const chunks = arguments_.trim().split(/\s*,\s*/g);
      let matches;
      for (const chunk of chunks) {
        const number = Number(chunk);
        if (!Number.isNaN(number)) {
          results.push(number);
        } else if (matches = chunk.match(STRING_REGEX)) {
          results.push(matches[2].replace(ESCAPE_REGEX, (m, escape3, character) => escape3 ? unescape2(escape3) : character));
        } else {
          throw new Error(`Invalid Chalk template style argument: ${chunk} (in style '${name}')`);
        }
      }
      return results;
    }
    function parseStyle(style) {
      STYLE_REGEX.lastIndex = 0;
      const results = [];
      let matches;
      while ((matches = STYLE_REGEX.exec(style)) !== null) {
        const name = matches[1];
        if (matches[2]) {
          const args = parseArguments(name, matches[2]);
          results.push([name].concat(args));
        } else {
          results.push([name]);
        }
      }
      return results;
    }
    function buildStyle(chalk, styles) {
      const enabled = {};
      for (const layer of styles) {
        for (const style of layer.styles) {
          enabled[style[0]] = layer.inverse ? null : style.slice(1);
        }
      }
      let current = chalk;
      for (const [styleName, styles2] of Object.entries(enabled)) {
        if (!Array.isArray(styles2)) {
          continue;
        }
        if (!(styleName in current)) {
          throw new Error(`Unknown Chalk style: ${styleName}`);
        }
        current = styles2.length > 0 ? current[styleName](...styles2) : current[styleName];
      }
      return current;
    }
    module2.exports = (chalk, temporary) => {
      const styles = [];
      const chunks = [];
      let chunk = [];
      temporary.replace(TEMPLATE_REGEX, (m, escapeCharacter, inverse, style, close, character) => {
        if (escapeCharacter) {
          chunk.push(unescape2(escapeCharacter));
        } else if (style) {
          const string = chunk.join("");
          chunk = [];
          chunks.push(styles.length === 0 ? string : buildStyle(chalk, styles)(string));
          styles.push({ inverse, styles: parseStyle(style) });
        } else if (close) {
          if (styles.length === 0) {
            throw new Error("Found extraneous } in Chalk template literal");
          }
          chunks.push(buildStyle(chalk, styles)(chunk.join("")));
          chunk = [];
          styles.pop();
        } else {
          chunk.push(character);
        }
      });
      chunks.push(chunk.join(""));
      if (styles.length > 0) {
        const errMessage = `Chalk template literal is missing ${styles.length} closing bracket${styles.length === 1 ? "" : "s"} (\`}\`)`;
        throw new Error(errMessage);
      }
      return chunks.join("");
    };
  }
});

// node_modules/chalk/source/index.js
var require_source = __commonJS({
  "node_modules/chalk/source/index.js"(exports2, module2) {
    "use strict";
    var ansiStyles = require_ansi_styles2();
    var { stdout: stdoutColor, stderr: stderrColor } = require_supports_color2();
    var {
      stringReplaceAll,
      stringEncaseCRLFWithFirstIndex
    } = require_util2();
    var { isArray } = Array;
    var levelMapping = [
      "ansi",
      "ansi",
      "ansi256",
      "ansi16m"
    ];
    var styles = /* @__PURE__ */ Object.create(null);
    var applyOptions = (object, options = {}) => {
      if (options.level && !(Number.isInteger(options.level) && options.level >= 0 && options.level <= 3)) {
        throw new Error("The `level` option should be an integer from 0 to 3");
      }
      const colorLevel = stdoutColor ? stdoutColor.level : 0;
      object.level = options.level === void 0 ? colorLevel : options.level;
    };
    var ChalkClass = class {
      constructor(options) {
        return chalkFactory(options);
      }
    };
    var chalkFactory = (options) => {
      const chalk2 = {};
      applyOptions(chalk2, options);
      chalk2.template = (...arguments_) => chalkTag(chalk2.template, ...arguments_);
      Object.setPrototypeOf(chalk2, Chalk.prototype);
      Object.setPrototypeOf(chalk2.template, chalk2);
      chalk2.template.constructor = () => {
        throw new Error("`chalk.constructor()` is deprecated. Use `new chalk.Instance()` instead.");
      };
      chalk2.template.Instance = ChalkClass;
      return chalk2.template;
    };
    function Chalk(options) {
      return chalkFactory(options);
    }
    for (const [styleName, style] of Object.entries(ansiStyles)) {
      styles[styleName] = {
        get() {
          const builder = createBuilder(this, createStyler(style.open, style.close, this._styler), this._isEmpty);
          Object.defineProperty(this, styleName, { value: builder });
          return builder;
        }
      };
    }
    styles.visible = {
      get() {
        const builder = createBuilder(this, this._styler, true);
        Object.defineProperty(this, "visible", { value: builder });
        return builder;
      }
    };
    var usedModels = ["rgb", "hex", "keyword", "hsl", "hsv", "hwb", "ansi", "ansi256"];
    for (const model of usedModels) {
      styles[model] = {
        get() {
          const { level } = this;
          return function(...arguments_) {
            const styler = createStyler(ansiStyles.color[levelMapping[level]][model](...arguments_), ansiStyles.color.close, this._styler);
            return createBuilder(this, styler, this._isEmpty);
          };
        }
      };
    }
    for (const model of usedModels) {
      const bgModel = "bg" + model[0].toUpperCase() + model.slice(1);
      styles[bgModel] = {
        get() {
          const { level } = this;
          return function(...arguments_) {
            const styler = createStyler(ansiStyles.bgColor[levelMapping[level]][model](...arguments_), ansiStyles.bgColor.close, this._styler);
            return createBuilder(this, styler, this._isEmpty);
          };
        }
      };
    }
    var proto = Object.defineProperties(() => {
    }, {
      ...styles,
      level: {
        enumerable: true,
        get() {
          return this._generator.level;
        },
        set(level) {
          this._generator.level = level;
        }
      }
    });
    var createStyler = (open, close, parent) => {
      let openAll;
      let closeAll;
      if (parent === void 0) {
        openAll = open;
        closeAll = close;
      } else {
        openAll = parent.openAll + open;
        closeAll = close + parent.closeAll;
      }
      return {
        open,
        close,
        openAll,
        closeAll,
        parent
      };
    };
    var createBuilder = (self2, _styler, _isEmpty) => {
      const builder = (...arguments_) => {
        if (isArray(arguments_[0]) && isArray(arguments_[0].raw)) {
          return applyStyle(builder, chalkTag(builder, ...arguments_));
        }
        return applyStyle(builder, arguments_.length === 1 ? "" + arguments_[0] : arguments_.join(" "));
      };
      Object.setPrototypeOf(builder, proto);
      builder._generator = self2;
      builder._styler = _styler;
      builder._isEmpty = _isEmpty;
      return builder;
    };
    var applyStyle = (self2, string) => {
      if (self2.level <= 0 || !string) {
        return self2._isEmpty ? "" : string;
      }
      let styler = self2._styler;
      if (styler === void 0) {
        return string;
      }
      const { openAll, closeAll } = styler;
      if (string.indexOf("\x1B") !== -1) {
        while (styler !== void 0) {
          string = stringReplaceAll(string, styler.close, styler.open);
          styler = styler.parent;
        }
      }
      const lfIndex = string.indexOf("\n");
      if (lfIndex !== -1) {
        string = stringEncaseCRLFWithFirstIndex(string, closeAll, openAll, lfIndex);
      }
      return openAll + string + closeAll;
    };
    var template;
    var chalkTag = (chalk2, ...strings) => {
      const [firstString] = strings;
      if (!isArray(firstString) || !isArray(firstString.raw)) {
        return strings.join(" ");
      }
      const arguments_ = strings.slice(1);
      const parts = [firstString.raw[0]];
      for (let i = 1; i < firstString.length; i++) {
        parts.push(
          String(arguments_[i - 1]).replace(/[{}\\]/g, "\\$&"),
          String(firstString.raw[i])
        );
      }
      if (template === void 0) {
        template = require_templates2();
      }
      return template(chalk2, parts.join(""));
    };
    Object.defineProperties(Chalk.prototype, styles);
    var chalk = Chalk();
    chalk.supportsColor = stdoutColor;
    chalk.stderr = Chalk({ level: stderrColor ? stderrColor.level : 0 });
    chalk.stderr.supportsColor = stderrColor;
    module2.exports = chalk;
  }
});

// node_modules/@readme/better-ajv-errors/lib/json/utils.js
var require_utils3 = __commonJS({
  "node_modules/@readme/better-ajv-errors/lib/json/utils.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.getPointers = void 0;
    var getPointers = function getPointers2(dataPath) {
      var pointers = dataPath.split("/").slice(1);
      for (var index in pointers) {
        pointers[index] = pointers[index].split("~1").join("/").split("~0").join("~");
      }
      return pointers;
    };
    exports2.getPointers = getPointers;
  }
});

// node_modules/@readme/better-ajv-errors/lib/json/get-meta-from-path.js
var require_get_meta_from_path = __commonJS({
  "node_modules/@readme/better-ajv-errors/lib/json/get-meta-from-path.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2["default"] = getMetaFromPath;
    var _utils = require_utils3();
    function getMetaFromPath(jsonAst, dataPath, includeIdentifierLocation) {
      var pointers = (0, _utils.getPointers)(dataPath);
      var lastPointerIndex = pointers.length - 1;
      return pointers.reduce(function(obj, pointer, idx) {
        switch (obj.type) {
          case "Object": {
            var filtered = obj.members.filter(function(child) {
              return child.name.value === pointer;
            });
            if (filtered.length !== 1) {
              throw new Error("Couldn't find property ".concat(pointer, " of ").concat(dataPath));
            }
            var _filtered$ = filtered[0], name = _filtered$.name, value = _filtered$.value;
            return includeIdentifierLocation && idx === lastPointerIndex ? name : value;
          }
          case "Array":
            return obj.elements[pointer];
          default:
            console.log(obj);
        }
      }, jsonAst.body);
    }
    module2.exports = exports2.default;
  }
});

// node_modules/@readme/better-ajv-errors/lib/json/get-decorated-data-path.js
var require_get_decorated_data_path = __commonJS({
  "node_modules/@readme/better-ajv-errors/lib/json/get-decorated-data-path.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2["default"] = getDecoratedDataPath;
    var _utils = require_utils3();
    function getTypeName(obj) {
      if (!obj || !obj.elements) {
        return "";
      }
      var type2 = obj.elements.filter(function(child) {
        return child && child.name && child.name.value === "type";
      });
      if (!type2.length) {
        return "";
      }
      return type2[0].value && ":".concat(type2[0].value.value) || "";
    }
    function getDecoratedDataPath(jsonAst, dataPath) {
      var decoratedPath = "";
      (0, _utils.getPointers)(dataPath).reduce(function(obj, pointer) {
        switch (obj.type) {
          case "Object": {
            decoratedPath += "/".concat(pointer);
            var filtered = obj.members.filter(function(child) {
              return child.name.value === pointer;
            });
            if (filtered.length !== 1) {
              throw new Error("Couldn't find property ".concat(pointer, " of ").concat(dataPath));
            }
            return filtered[0].value;
          }
          case "Array": {
            decoratedPath += "/".concat(pointer).concat(getTypeName(obj.elements[pointer]));
            return obj.elements[pointer];
          }
          default:
            console.log(obj);
        }
      }, jsonAst.body);
      return decoratedPath;
    }
    module2.exports = exports2.default;
  }
});

// node_modules/@readme/better-ajv-errors/lib/json/index.js
var require_json3 = __commonJS({
  "node_modules/@readme/better-ajv-errors/lib/json/index.js"(exports2) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    Object.defineProperty(exports2, "getDecoratedDataPath", {
      enumerable: true,
      get: function get2() {
        return _getDecoratedDataPath["default"];
      }
    });
    Object.defineProperty(exports2, "getMetaFromPath", {
      enumerable: true,
      get: function get2() {
        return _getMetaFromPath["default"];
      }
    });
    var _getMetaFromPath = _interopRequireDefault(require_get_meta_from_path());
    var _getDecoratedDataPath = _interopRequireDefault(require_get_decorated_data_path());
  }
});

// node_modules/@readme/better-ajv-errors/lib/validation-errors/base.js
var require_base = __commonJS({
  "node_modules/@readme/better-ajv-errors/lib/validation-errors/base.js"(exports2, module2) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2["default"] = void 0;
    var _classCallCheck2 = _interopRequireDefault(require_classCallCheck());
    var _createClass2 = _interopRequireDefault(require_createClass());
    var _codeFrame = require_lib13();
    var _chalk = _interopRequireDefault(require_source());
    var _json = require_json3();
    var BaseValidationError = /* @__PURE__ */ function() {
      function BaseValidationError2() {
        var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {
          isIdentifierLocation: false
        };
        var _ref = arguments.length > 1 ? arguments[1] : void 0, colorize = _ref.colorize, data = _ref.data, schema2 = _ref.schema, jsonAst = _ref.jsonAst, jsonRaw = _ref.jsonRaw;
        (0, _classCallCheck2["default"])(this, BaseValidationError2);
        this.options = options;
        this.colorize = !!(!!colorize || colorize === void 0);
        this.data = data;
        this.schema = schema2;
        this.jsonAst = jsonAst;
        this.jsonRaw = jsonRaw;
      }
      (0, _createClass2["default"])(BaseValidationError2, [{
        key: "getChalk",
        value: function getChalk() {
          return this.colorize ? _chalk["default"] : new _chalk["default"].Instance({
            level: 0
          });
        }
      }, {
        key: "getLocation",
        value: function getLocation3() {
          var dataPath = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.instancePath;
          var _this$options = this.options, isIdentifierLocation = _this$options.isIdentifierLocation, isSkipEndLocation = _this$options.isSkipEndLocation;
          var _getMetaFromPath = (0, _json.getMetaFromPath)(this.jsonAst, dataPath, isIdentifierLocation), loc = _getMetaFromPath.loc;
          return {
            start: loc.start,
            end: isSkipEndLocation ? void 0 : loc.end
          };
        }
      }, {
        key: "getDecoratedPath",
        value: function getDecoratedPath() {
          var dataPath = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.instancePath;
          return (0, _json.getDecoratedDataPath)(this.jsonAst, dataPath);
        }
      }, {
        key: "getCodeFrame",
        value: function getCodeFrame(message) {
          var dataPath = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.instancePath;
          return (0, _codeFrame.codeFrameColumns)(this.jsonRaw, this.getLocation(dataPath), {
            /**
             * `@babel/highlight`, by way of `@babel/code-frame`, highlights out entire block of raw JSON
             * instead of just our `location` block -- so if you have a block of raw JSON that's upwards
             * of 2mb+ and have a lot of errors to generate code frames for then we're re-highlighting
             * the same huge chunk of code over and over and over and over again, all just so
             * `@babel/code-frame` will eventually extract a small <10 line chunk out of it to return to
             * us.
             *
             * Disabling `highlightCode` here will only disable highlighting the code we're showing users;
             * if `options.colorize` is supplied to this library then the error message we're adding will
             * still be highlighted.
             */
            highlightCode: false,
            message
          });
        }
        /**
         * @return {string}
         */
      }, {
        key: "instancePath",
        get: function get2() {
          return typeof this.options.instancePath !== "undefined" ? this.options.instancePath : this.options.dataPath;
        }
      }, {
        key: "print",
        value: function print() {
          throw new Error("Implement the 'print' method inside ".concat(this.constructor.name, "!"));
        }
      }, {
        key: "getError",
        value: function getError() {
          throw new Error("Implement the 'getError' method inside ".concat(this.constructor.name, "!"));
        }
      }]);
      return BaseValidationError2;
    }();
    exports2["default"] = BaseValidationError;
    module2.exports = exports2.default;
  }
});

// node_modules/@readme/better-ajv-errors/lib/validation-errors/additional-prop.js
var require_additional_prop = __commonJS({
  "node_modules/@readme/better-ajv-errors/lib/validation-errors/additional-prop.js"(exports2, module2) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2["default"] = void 0;
    var _defineProperty2 = _interopRequireDefault(require_defineProperty2());
    var _taggedTemplateLiteral2 = _interopRequireDefault(require_taggedTemplateLiteral());
    var _classCallCheck2 = _interopRequireDefault(require_classCallCheck());
    var _createClass2 = _interopRequireDefault(require_createClass());
    var _inherits2 = _interopRequireDefault(require_inherits());
    var _possibleConstructorReturn2 = _interopRequireDefault(require_possibleConstructorReturn());
    var _getPrototypeOf2 = _interopRequireDefault(require_getPrototypeOf());
    var _base = _interopRequireDefault(require_base());
    var _templateObject;
    var _templateObject2;
    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = null != arguments[i] ? arguments[i] : {};
        i % 2 ? ownKeys(Object(source), true).forEach(function(key) {
          (0, _defineProperty2["default"])(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function _createSuperInternal() {
        var Super = (0, _getPrototypeOf2["default"])(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return (0, _possibleConstructorReturn2["default"])(this, result);
      };
    }
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct) return false;
      if (Reflect.construct.sham) return false;
      if (typeof Proxy === "function") return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    var AdditionalPropValidationError = /* @__PURE__ */ function(_BaseValidationError) {
      (0, _inherits2["default"])(AdditionalPropValidationError2, _BaseValidationError);
      var _super = _createSuper(AdditionalPropValidationError2);
      function AdditionalPropValidationError2() {
        var _this;
        (0, _classCallCheck2["default"])(this, AdditionalPropValidationError2);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        _this = _super.call.apply(_super, [this].concat(args));
        _this.name = "AdditionalPropValidationError";
        _this.options.isIdentifierLocation = true;
        return _this;
      }
      (0, _createClass2["default"])(AdditionalPropValidationError2, [{
        key: "print",
        value: function print() {
          var _this$options = this.options, message = _this$options.message, params2 = _this$options.params;
          var chalk = this.getChalk();
          var output = [chalk(_templateObject || (_templateObject = (0, _taggedTemplateLiteral2["default"])(["{red {bold ADDITIONAL PROPERTY} ", "}\n"], ["{red {bold ADDITIONAL PROPERTY} ", "}\\n"])), message)];
          return output.concat(this.getCodeFrame(chalk(_templateObject2 || (_templateObject2 = (0, _taggedTemplateLiteral2["default"])(["\u{1F632}  {magentaBright ", "} is not expected to be here!"])), params2.additionalProperty), "".concat(this.instancePath, "/").concat(params2.additionalProperty)));
        }
      }, {
        key: "getError",
        value: function getError() {
          var params2 = this.options.params;
          return _objectSpread(_objectSpread({}, this.getLocation("".concat(this.instancePath, "/").concat(params2.additionalProperty))), {}, {
            error: "".concat(this.getDecoratedPath(), " Property ").concat(params2.additionalProperty, " is not expected to be here"),
            path: this.instancePath
          });
        }
      }]);
      return AdditionalPropValidationError2;
    }(_base["default"]);
    exports2["default"] = AdditionalPropValidationError;
    module2.exports = exports2.default;
  }
});

// node_modules/@readme/better-ajv-errors/lib/validation-errors/default.js
var require_default2 = __commonJS({
  "node_modules/@readme/better-ajv-errors/lib/validation-errors/default.js"(exports2, module2) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2["default"] = void 0;
    var _defineProperty2 = _interopRequireDefault(require_defineProperty2());
    var _taggedTemplateLiteral2 = _interopRequireDefault(require_taggedTemplateLiteral());
    var _classCallCheck2 = _interopRequireDefault(require_classCallCheck());
    var _createClass2 = _interopRequireDefault(require_createClass());
    var _inherits2 = _interopRequireDefault(require_inherits());
    var _possibleConstructorReturn2 = _interopRequireDefault(require_possibleConstructorReturn());
    var _getPrototypeOf2 = _interopRequireDefault(require_getPrototypeOf());
    var _base = _interopRequireDefault(require_base());
    var _templateObject;
    var _templateObject2;
    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = null != arguments[i] ? arguments[i] : {};
        i % 2 ? ownKeys(Object(source), true).forEach(function(key) {
          (0, _defineProperty2["default"])(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function _createSuperInternal() {
        var Super = (0, _getPrototypeOf2["default"])(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return (0, _possibleConstructorReturn2["default"])(this, result);
      };
    }
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct) return false;
      if (Reflect.construct.sham) return false;
      if (typeof Proxy === "function") return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    var DefaultValidationError = /* @__PURE__ */ function(_BaseValidationError) {
      (0, _inherits2["default"])(DefaultValidationError2, _BaseValidationError);
      var _super = _createSuper(DefaultValidationError2);
      function DefaultValidationError2() {
        var _this;
        (0, _classCallCheck2["default"])(this, DefaultValidationError2);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        _this = _super.call.apply(_super, [this].concat(args));
        _this.name = "DefaultValidationError";
        _this.options.isSkipEndLocation = true;
        return _this;
      }
      (0, _createClass2["default"])(DefaultValidationError2, [{
        key: "print",
        value: function print() {
          var _this$options = this.options, keyword = _this$options.keyword, message = _this$options.message;
          var chalk = this.getChalk();
          var output = [chalk(_templateObject || (_templateObject = (0, _taggedTemplateLiteral2["default"])(["{red {bold ", "} ", "}\n"], ["{red {bold ", "} ", "}\\n"])), keyword.toUpperCase(), message)];
          return output.concat(this.getCodeFrame(chalk(_templateObject2 || (_templateObject2 = (0, _taggedTemplateLiteral2["default"])(["\u{1F448}\u{1F3FD}  {magentaBright ", "} ", ""])), keyword, message)));
        }
      }, {
        key: "getError",
        value: function getError() {
          var _this$options2 = this.options, keyword = _this$options2.keyword, message = _this$options2.message;
          return _objectSpread(_objectSpread({}, this.getLocation()), {}, {
            error: "".concat(this.getDecoratedPath(), ": ").concat(keyword, " ").concat(message),
            path: this.instancePath
          });
        }
      }]);
      return DefaultValidationError2;
    }(_base["default"]);
    exports2["default"] = DefaultValidationError;
    module2.exports = exports2.default;
  }
});

// node_modules/leven/index.js
var require_leven = __commonJS({
  "node_modules/leven/index.js"(exports2, module2) {
    "use strict";
    var array = [];
    var charCodeCache = [];
    var leven = (left, right) => {
      if (left === right) {
        return 0;
      }
      const swap = left;
      if (left.length > right.length) {
        left = right;
        right = swap;
      }
      let leftLength = left.length;
      let rightLength = right.length;
      while (leftLength > 0 && left.charCodeAt(~-leftLength) === right.charCodeAt(~-rightLength)) {
        leftLength--;
        rightLength--;
      }
      let start = 0;
      while (start < leftLength && left.charCodeAt(start) === right.charCodeAt(start)) {
        start++;
      }
      leftLength -= start;
      rightLength -= start;
      if (leftLength === 0) {
        return rightLength;
      }
      let bCharCode;
      let result;
      let temp;
      let temp2;
      let i = 0;
      let j = 0;
      while (i < leftLength) {
        charCodeCache[i] = left.charCodeAt(start + i);
        array[i] = ++i;
      }
      while (j < rightLength) {
        bCharCode = right.charCodeAt(start + j);
        temp = j++;
        result = j;
        for (i = 0; i < leftLength; i++) {
          temp2 = bCharCode === charCodeCache[i] ? temp : temp + 1;
          temp = array[i];
          result = array[i] = temp > result ? temp2 > result ? result + 1 : temp2 : temp2 > temp ? temp + 1 : temp2;
        }
      }
      return result;
    };
    module2.exports = leven;
    module2.exports.default = leven;
  }
});

// node_modules/@readme/better-ajv-errors/lib/validation-errors/enum.js
var require_enum = __commonJS({
  "node_modules/@readme/better-ajv-errors/lib/validation-errors/enum.js"(exports2, module2) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2["default"] = void 0;
    var _defineProperty2 = _interopRequireDefault(require_defineProperty2());
    var _taggedTemplateLiteral2 = _interopRequireDefault(require_taggedTemplateLiteral());
    var _classCallCheck2 = _interopRequireDefault(require_classCallCheck());
    var _createClass2 = _interopRequireDefault(require_createClass());
    var _inherits2 = _interopRequireDefault(require_inherits());
    var _possibleConstructorReturn2 = _interopRequireDefault(require_possibleConstructorReturn());
    var _getPrototypeOf2 = _interopRequireDefault(require_getPrototypeOf());
    var _jsonpointer = _interopRequireDefault(require_jsonpointer());
    var _leven = _interopRequireDefault(require_leven());
    var _base = _interopRequireDefault(require_base());
    var _templateObject;
    var _templateObject2;
    var _templateObject3;
    var _templateObject4;
    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = null != arguments[i] ? arguments[i] : {};
        i % 2 ? ownKeys(Object(source), true).forEach(function(key) {
          (0, _defineProperty2["default"])(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function _createSuperInternal() {
        var Super = (0, _getPrototypeOf2["default"])(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return (0, _possibleConstructorReturn2["default"])(this, result);
      };
    }
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct) return false;
      if (Reflect.construct.sham) return false;
      if (typeof Proxy === "function") return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    var EnumValidationError = /* @__PURE__ */ function(_BaseValidationError) {
      (0, _inherits2["default"])(EnumValidationError2, _BaseValidationError);
      var _super = _createSuper(EnumValidationError2);
      function EnumValidationError2() {
        var _this;
        (0, _classCallCheck2["default"])(this, EnumValidationError2);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        _this = _super.call.apply(_super, [this].concat(args));
        _this.name = "EnumValidationError";
        return _this;
      }
      (0, _createClass2["default"])(EnumValidationError2, [{
        key: "print",
        value: function print() {
          var _this$options = this.options, message = _this$options.message, allowedValues = _this$options.params.allowedValues;
          var chalk = this.getChalk();
          var bestMatch = this.findBestMatch();
          var output = [chalk(_templateObject || (_templateObject = (0, _taggedTemplateLiteral2["default"])(["{red {bold ENUM} ", "}"])), message), chalk(_templateObject2 || (_templateObject2 = (0, _taggedTemplateLiteral2["default"])(["{red (", ")}\n"], ["{red (", ")}\\n"])), allowedValues.join(", "))];
          return output.concat(this.getCodeFrame(bestMatch !== null ? chalk(_templateObject3 || (_templateObject3 = (0, _taggedTemplateLiteral2["default"])(["\u{1F448}\u{1F3FD}  Did you mean {magentaBright ", "} here?"])), bestMatch) : chalk(_templateObject4 || (_templateObject4 = (0, _taggedTemplateLiteral2["default"])(["\u{1F448}\u{1F3FD}  Unexpected value, should be equal to one of the allowed values"])))));
        }
      }, {
        key: "getError",
        value: function getError() {
          var _this$options2 = this.options, message = _this$options2.message, params2 = _this$options2.params;
          var bestMatch = this.findBestMatch();
          var allowedValues = params2.allowedValues.join(", ");
          var output = _objectSpread(_objectSpread({}, this.getLocation()), {}, {
            error: "".concat(this.getDecoratedPath(), " ").concat(message, ": ").concat(allowedValues),
            path: this.instancePath
          });
          if (bestMatch !== null) {
            output.suggestion = "Did you mean ".concat(bestMatch, "?");
          }
          return output;
        }
      }, {
        key: "findBestMatch",
        value: function findBestMatch() {
          var allowedValues = this.options.params.allowedValues;
          var currentValue = this.instancePath === "" ? this.data : _jsonpointer["default"].get(this.data, this.instancePath);
          if (!currentValue) {
            return null;
          }
          var bestMatch = allowedValues.map(function(value) {
            return {
              value,
              weight: (0, _leven["default"])(value, currentValue.toString())
            };
          }).sort(function(x, y) {
            return x.weight > y.weight ? 1 : x.weight < y.weight ? -1 : 0;
          })[0];
          return allowedValues.length === 1 || bestMatch.weight < bestMatch.value.length ? bestMatch.value : null;
        }
      }]);
      return EnumValidationError2;
    }(_base["default"]);
    exports2["default"] = EnumValidationError;
    module2.exports = exports2.default;
  }
});

// node_modules/@readme/better-ajv-errors/lib/validation-errors/pattern.js
var require_pattern = __commonJS({
  "node_modules/@readme/better-ajv-errors/lib/validation-errors/pattern.js"(exports2, module2) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2["default"] = void 0;
    var _defineProperty2 = _interopRequireDefault(require_defineProperty2());
    var _taggedTemplateLiteral2 = _interopRequireDefault(require_taggedTemplateLiteral());
    var _classCallCheck2 = _interopRequireDefault(require_classCallCheck());
    var _createClass2 = _interopRequireDefault(require_createClass());
    var _inherits2 = _interopRequireDefault(require_inherits());
    var _possibleConstructorReturn2 = _interopRequireDefault(require_possibleConstructorReturn());
    var _getPrototypeOf2 = _interopRequireDefault(require_getPrototypeOf());
    var _base = _interopRequireDefault(require_base());
    var _templateObject;
    var _templateObject2;
    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = null != arguments[i] ? arguments[i] : {};
        i % 2 ? ownKeys(Object(source), true).forEach(function(key) {
          (0, _defineProperty2["default"])(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function _createSuperInternal() {
        var Super = (0, _getPrototypeOf2["default"])(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return (0, _possibleConstructorReturn2["default"])(this, result);
      };
    }
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct) return false;
      if (Reflect.construct.sham) return false;
      if (typeof Proxy === "function") return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    var PatternValidationError = /* @__PURE__ */ function(_BaseValidationError) {
      (0, _inherits2["default"])(PatternValidationError2, _BaseValidationError);
      var _super = _createSuper(PatternValidationError2);
      function PatternValidationError2() {
        var _this;
        (0, _classCallCheck2["default"])(this, PatternValidationError2);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        _this = _super.call.apply(_super, [this].concat(args));
        _this.name = "PatternValidationError";
        _this.options.isIdentifierLocation = true;
        return _this;
      }
      (0, _createClass2["default"])(PatternValidationError2, [{
        key: "print",
        value: function print() {
          var _this$options = this.options, message = _this$options.message, params2 = _this$options.params, propertyName = _this$options.propertyName;
          var chalk = this.getChalk();
          var output = [chalk(_templateObject || (_templateObject = (0, _taggedTemplateLiteral2["default"])(["{red {bold PROPERTY} ", "}\n"], ["{red {bold PROPERTY} ", "}\\n"])), message)];
          return output.concat(this.getCodeFrame(chalk(_templateObject2 || (_templateObject2 = (0, _taggedTemplateLiteral2["default"])(["\u{1F632}  must match pattern {magentaBright ", "}"])), params2.pattern), "".concat(this.instancePath, "/").concat(propertyName)));
        }
      }, {
        key: "getError",
        value: function getError() {
          var _this$options2 = this.options, params2 = _this$options2.params, propertyName = _this$options2.propertyName;
          return _objectSpread(_objectSpread({}, this.getLocation()), {}, {
            error: "".concat(this.getDecoratedPath(), ' Property "').concat(propertyName, '" must match pattern ').concat(params2.pattern),
            path: this.instancePath
          });
        }
      }]);
      return PatternValidationError2;
    }(_base["default"]);
    exports2["default"] = PatternValidationError;
    module2.exports = exports2.default;
  }
});

// node_modules/@babel/runtime/helpers/superPropBase.js
var require_superPropBase = __commonJS({
  "node_modules/@babel/runtime/helpers/superPropBase.js"(exports2, module2) {
    var getPrototypeOf = require_getPrototypeOf();
    function _superPropBase(t, o) {
      for (; !{}.hasOwnProperty.call(t, o) && null !== (t = getPrototypeOf(t)); ) ;
      return t;
    }
    module2.exports = _superPropBase, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
  }
});

// node_modules/@babel/runtime/helpers/get.js
var require_get3 = __commonJS({
  "node_modules/@babel/runtime/helpers/get.js"(exports2, module2) {
    var superPropBase = require_superPropBase();
    function _get() {
      return module2.exports = _get = "undefined" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function(e, t, r2) {
        var p = superPropBase(e, t);
        if (p) {
          var n = Object.getOwnPropertyDescriptor(p, t);
          return n.get ? n.get.call(arguments.length < 3 ? e : r2) : n.value;
        }
      }, module2.exports.__esModule = true, module2.exports["default"] = module2.exports, _get.apply(null, arguments);
    }
    module2.exports = _get, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
  }
});

// node_modules/@readme/better-ajv-errors/lib/validation-errors/required.js
var require_required = __commonJS({
  "node_modules/@readme/better-ajv-errors/lib/validation-errors/required.js"(exports2, module2) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2["default"] = void 0;
    var _defineProperty2 = _interopRequireDefault(require_defineProperty2());
    var _taggedTemplateLiteral2 = _interopRequireDefault(require_taggedTemplateLiteral());
    var _classCallCheck2 = _interopRequireDefault(require_classCallCheck());
    var _createClass2 = _interopRequireDefault(require_createClass());
    var _get2 = _interopRequireDefault(require_get3());
    var _inherits2 = _interopRequireDefault(require_inherits());
    var _possibleConstructorReturn2 = _interopRequireDefault(require_possibleConstructorReturn());
    var _getPrototypeOf2 = _interopRequireDefault(require_getPrototypeOf());
    var _base = _interopRequireDefault(require_base());
    var _templateObject;
    var _templateObject2;
    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = null != arguments[i] ? arguments[i] : {};
        i % 2 ? ownKeys(Object(source), true).forEach(function(key) {
          (0, _defineProperty2["default"])(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function _createSuperInternal() {
        var Super = (0, _getPrototypeOf2["default"])(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return (0, _possibleConstructorReturn2["default"])(this, result);
      };
    }
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct) return false;
      if (Reflect.construct.sham) return false;
      if (typeof Proxy === "function") return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    var RequiredValidationError = /* @__PURE__ */ function(_BaseValidationError) {
      (0, _inherits2["default"])(RequiredValidationError2, _BaseValidationError);
      var _super = _createSuper(RequiredValidationError2);
      function RequiredValidationError2() {
        var _this;
        (0, _classCallCheck2["default"])(this, RequiredValidationError2);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        _this = _super.call.apply(_super, [this].concat(args));
        _this.name = "RequiredValidationError";
        return _this;
      }
      (0, _createClass2["default"])(RequiredValidationError2, [{
        key: "getLocation",
        value: function getLocation3() {
          var dataPath = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.instancePath;
          var _get$call = (0, _get2["default"])((0, _getPrototypeOf2["default"])(RequiredValidationError2.prototype), "getLocation", this).call(this, dataPath), start = _get$call.start;
          return {
            start
          };
        }
      }, {
        key: "print",
        value: function print() {
          var _this$options = this.options, message = _this$options.message, params2 = _this$options.params;
          var chalk = this.getChalk();
          var output = [chalk(_templateObject || (_templateObject = (0, _taggedTemplateLiteral2["default"])(["{red {bold REQUIRED} ", "}\n"], ["{red {bold REQUIRED} ", "}\\n"])), message)];
          return output.concat(this.getCodeFrame(chalk(_templateObject2 || (_templateObject2 = (0, _taggedTemplateLiteral2["default"])(["\u2639\uFE0F  {magentaBright ", "} is missing here!"])), params2.missingProperty)));
        }
      }, {
        key: "getError",
        value: function getError() {
          var message = this.options.message;
          return _objectSpread(_objectSpread({}, this.getLocation()), {}, {
            error: "".concat(this.getDecoratedPath(), " ").concat(message),
            path: this.instancePath
          });
        }
      }]);
      return RequiredValidationError2;
    }(_base["default"]);
    exports2["default"] = RequiredValidationError;
    module2.exports = exports2.default;
  }
});

// node_modules/@readme/better-ajv-errors/lib/validation-errors/unevaluated-prop.js
var require_unevaluated_prop = __commonJS({
  "node_modules/@readme/better-ajv-errors/lib/validation-errors/unevaluated-prop.js"(exports2, module2) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2["default"] = void 0;
    var _defineProperty2 = _interopRequireDefault(require_defineProperty2());
    var _taggedTemplateLiteral2 = _interopRequireDefault(require_taggedTemplateLiteral());
    var _classCallCheck2 = _interopRequireDefault(require_classCallCheck());
    var _createClass2 = _interopRequireDefault(require_createClass());
    var _inherits2 = _interopRequireDefault(require_inherits());
    var _possibleConstructorReturn2 = _interopRequireDefault(require_possibleConstructorReturn());
    var _getPrototypeOf2 = _interopRequireDefault(require_getPrototypeOf());
    var _base = _interopRequireDefault(require_base());
    var _templateObject;
    var _templateObject2;
    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = null != arguments[i] ? arguments[i] : {};
        i % 2 ? ownKeys(Object(source), true).forEach(function(key) {
          (0, _defineProperty2["default"])(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function _createSuperInternal() {
        var Super = (0, _getPrototypeOf2["default"])(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return (0, _possibleConstructorReturn2["default"])(this, result);
      };
    }
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct) return false;
      if (Reflect.construct.sham) return false;
      if (typeof Proxy === "function") return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    var UnevaluatedPropValidationError = /* @__PURE__ */ function(_BaseValidationError) {
      (0, _inherits2["default"])(UnevaluatedPropValidationError2, _BaseValidationError);
      var _super = _createSuper(UnevaluatedPropValidationError2);
      function UnevaluatedPropValidationError2() {
        var _this;
        (0, _classCallCheck2["default"])(this, UnevaluatedPropValidationError2);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        _this = _super.call.apply(_super, [this].concat(args));
        _this.name = "UnevaluatedPropValidationError";
        _this.options.isIdentifierLocation = true;
        return _this;
      }
      (0, _createClass2["default"])(UnevaluatedPropValidationError2, [{
        key: "print",
        value: function print() {
          var _this$options = this.options, message = _this$options.message, params2 = _this$options.params;
          var chalk = this.getChalk();
          var output = [chalk(_templateObject || (_templateObject = (0, _taggedTemplateLiteral2["default"])(["{red {bold UNEVALUATED PROPERTY} ", "}\n"], ["{red {bold UNEVALUATED PROPERTY} ", "}\\n"])), message)];
          return output.concat(this.getCodeFrame(chalk(_templateObject2 || (_templateObject2 = (0, _taggedTemplateLiteral2["default"])(["\u{1F632}  {magentaBright ", "} is not expected to be here!"])), params2.unevaluatedProperty), "".concat(this.instancePath, "/").concat(params2.unevaluatedProperty)));
        }
      }, {
        key: "getError",
        value: function getError() {
          var params2 = this.options.params;
          return _objectSpread(_objectSpread({}, this.getLocation("".concat(this.instancePath, "/").concat(params2.unevaluatedProperty))), {}, {
            error: "".concat(this.getDecoratedPath(), " Property ").concat(params2.unevaluatedProperty, " is not expected to be here"),
            path: this.instancePath
          });
        }
      }]);
      return UnevaluatedPropValidationError2;
    }(_base["default"]);
    exports2["default"] = UnevaluatedPropValidationError;
    module2.exports = exports2.default;
  }
});

// node_modules/@readme/better-ajv-errors/lib/validation-errors/index.js
var require_validation_errors = __commonJS({
  "node_modules/@readme/better-ajv-errors/lib/validation-errors/index.js"(exports2) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    Object.defineProperty(exports2, "AdditionalPropValidationError", {
      enumerable: true,
      get: function get2() {
        return _additionalProp["default"];
      }
    });
    Object.defineProperty(exports2, "DefaultValidationError", {
      enumerable: true,
      get: function get2() {
        return _default2["default"];
      }
    });
    Object.defineProperty(exports2, "EnumValidationError", {
      enumerable: true,
      get: function get2() {
        return _enum["default"];
      }
    });
    Object.defineProperty(exports2, "PatternValidationError", {
      enumerable: true,
      get: function get2() {
        return _pattern["default"];
      }
    });
    Object.defineProperty(exports2, "RequiredValidationError", {
      enumerable: true,
      get: function get2() {
        return _required["default"];
      }
    });
    Object.defineProperty(exports2, "UnevaluatedPropValidationError", {
      enumerable: true,
      get: function get2() {
        return _unevaluatedProp["default"];
      }
    });
    var _additionalProp = _interopRequireDefault(require_additional_prop());
    var _default2 = _interopRequireDefault(require_default2());
    var _enum = _interopRequireDefault(require_enum());
    var _pattern = _interopRequireDefault(require_pattern());
    var _required = _interopRequireDefault(require_required());
    var _unevaluatedProp = _interopRequireDefault(require_unevaluated_prop());
  }
});

// node_modules/@readme/better-ajv-errors/lib/helpers.js
var require_helpers = __commonJS({
  "node_modules/@readme/better-ajv-errors/lib/helpers.js"(exports2) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.createErrorInstances = createErrorInstances;
    exports2["default"] = prettify;
    exports2.filterRedundantErrors = filterRedundantErrors;
    exports2.makeTree = makeTree;
    var _defineProperty2 = _interopRequireDefault(require_defineProperty2());
    var _toConsumableArray2 = _interopRequireDefault(require_toConsumableArray());
    var _slicedToArray2 = _interopRequireDefault(require_slicedToArray());
    var _utils = require_utils2();
    var _validationErrors = require_validation_errors();
    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = null != arguments[i] ? arguments[i] : {};
        i % 2 ? ownKeys(Object(source), true).forEach(function(key) {
          (0, _defineProperty2["default"])(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    var JSON_POINTERS_REGEX = /\/[\w_-]+(\/\d+)?/g;
    function makeTree() {
      var ajvErrors = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
      var root = {
        children: {}
      };
      ajvErrors.forEach(function(ajvError) {
        var instancePath = typeof ajvError.instancePath !== "undefined" ? ajvError.instancePath : ajvError.dataPath;
        var paths = instancePath === "" ? [""] : instancePath.match(JSON_POINTERS_REGEX);
        if (paths) {
          paths.reduce(function(obj, path, i) {
            obj.children[path] = obj.children[path] || {
              children: {},
              errors: []
            };
            if (i === paths.length - 1) {
              obj.children[path].errors.push(ajvError);
            }
            return obj.children[path];
          }, root);
        }
      });
      return root;
    }
    function filterRedundantErrors(root, parent, key) {
      (0, _utils.getErrors)(root).forEach(function(error) {
        if ((0, _utils.isRequiredError)(error)) {
          root.errors = [error];
          root.children = {};
        }
      });
      if ((0, _utils.getErrors)(root).some(_utils.isAnyOfError)) {
        if (Object.keys(root.children).length > 0) {
          delete root.errors;
        }
      }
      if (root.errors && root.errors.length && (0, _utils.getErrors)(root).every(_utils.isEnumError)) {
        if ((0, _utils.getSiblings)(parent)(root).filter(_utils.notUndefined).some(_utils.getErrors)) {
          delete parent.children[key];
        }
      }
      Object.entries(root.children).forEach(function(_ref) {
        var _ref2 = (0, _slicedToArray2["default"])(_ref, 2), k = _ref2[0], child = _ref2[1];
        return filterRedundantErrors(child, root, k);
      });
    }
    function createErrorInstances(root, options) {
      var errors = (0, _utils.getErrors)(root);
      if (errors.length && errors.every(_utils.isEnumError)) {
        var uniqueValues = new Set((0, _utils.concatAll)([])(errors.map(function(e) {
          return e.params.allowedValues;
        })));
        var allowedValues = (0, _toConsumableArray2["default"])(uniqueValues);
        var error = errors[0];
        return [new _validationErrors.EnumValidationError(_objectSpread(_objectSpread({}, error), {}, {
          params: {
            allowedValues
          }
        }), options)];
      }
      return (0, _utils.concatAll)(errors.reduce(function(ret, error2) {
        switch (error2.keyword) {
          case "additionalProperties":
            return ret.concat(new _validationErrors.AdditionalPropValidationError(error2, options));
          case "pattern":
            return ret.concat(new _validationErrors.PatternValidationError(error2, options));
          case "required":
            return ret.concat(new _validationErrors.RequiredValidationError(error2, options));
          case "unevaluatedProperties":
            return ret.concat(new _validationErrors.UnevaluatedPropValidationError(error2, options));
          default:
            return ret.concat(new _validationErrors.DefaultValidationError(error2, options));
        }
      }, []))((0, _utils.getChildren)(root).map(function(child) {
        return createErrorInstances(child, options);
      }));
    }
    function prettify(ajvErrors, options) {
      var tree = makeTree(ajvErrors || []);
      filterRedundantErrors(tree);
      return createErrorInstances(tree, options);
    }
  }
});

// node_modules/@readme/better-ajv-errors/lib/index.js
var require_lib14 = __commonJS({
  "node_modules/@readme/better-ajv-errors/lib/index.js"(exports2, module2) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2["default"] = betterAjvErrors;
    var _momoa = require_api();
    var _helpers = _interopRequireDefault(require_helpers());
    function betterAjvErrors(schema2, data, errors) {
      var options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
      var _options$colorize = options.colorize, colorize = _options$colorize === void 0 ? true : _options$colorize, _options$format = options.format, format6 = _options$format === void 0 ? "cli" : _options$format, _options$indent = options.indent, indent = _options$indent === void 0 ? null : _options$indent, _options$json = options.json, json3 = _options$json === void 0 ? null : _options$json;
      var jsonRaw = json3 || JSON.stringify(data, null, indent);
      var jsonAst = (0, _momoa.parse)(jsonRaw);
      var customErrorToText = function customErrorToText2(error) {
        return error.print().join("\n");
      };
      var customErrorToStructure = function customErrorToStructure2(error) {
        return error.getError();
      };
      var customErrors = (0, _helpers["default"])(errors, {
        colorize,
        data,
        schema: schema2,
        jsonAst,
        jsonRaw
      });
      if (format6 === "cli") {
        return customErrors.map(customErrorToText).join("\n\n");
      }
      return customErrors.map(customErrorToStructure);
    }
    module2.exports = exports2.default;
  }
});

// node_modules/@readme/openapi-schemas/dist/index.js
var require_dist2 = __commonJS({
  "node_modules/@readme/openapi-schemas/dist/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var apiDeclaration_default = {
      id: "https://raw.githubusercontent.com/OAI/OpenAPI-Specification/master/schemas/v1.2/apiDeclaration.json#",
      $schema: "http://json-schema.org/draft-04/schema#",
      type: "object",
      required: ["swaggerVersion", "basePath", "apis"],
      properties: {
        swaggerVersion: { enum: ["1.2"] },
        apiVersion: { type: "string" },
        basePath: {
          type: "string",
          format: "uri",
          pattern: "^https?://"
        },
        resourcePath: {
          type: "string",
          format: "uri",
          pattern: "^/"
        },
        apis: {
          type: "array",
          items: { $ref: "#/definitions/apiObject" }
        },
        models: {
          type: "object",
          additionalProperties: {
            $ref: "modelsObject.json#"
          }
        },
        produces: { $ref: "#/definitions/mimeTypeArray" },
        consumes: { $ref: "#/definitions/mimeTypeArray" },
        authorizations: { $ref: "authorizationObject.json#" }
      },
      additionalProperties: false,
      definitions: {
        apiObject: {
          type: "object",
          required: ["path", "operations"],
          properties: {
            path: {
              type: "string",
              format: "uri-template",
              pattern: "^/"
            },
            description: { type: "string" },
            operations: {
              type: "array",
              items: { $ref: "operationObject.json#" }
            }
          },
          additionalProperties: false
        },
        mimeTypeArray: {
          type: "array",
          items: {
            type: "string",
            format: "mime-type"
          },
          uniqueItems: true
        }
      }
    };
    var schema_default = {
      title: "A JSON Schema for Swagger 2.0 API.",
      id: "http://swagger.io/v2/schema.json#",
      $schema: "http://json-schema.org/draft-04/schema#",
      type: "object",
      required: [
        "swagger",
        "info",
        "paths"
      ],
      additionalProperties: false,
      patternProperties: {
        "^x-": {
          $ref: "#/definitions/vendorExtension"
        }
      },
      properties: {
        swagger: {
          type: "string",
          enum: [
            "2.0"
          ],
          description: "The Swagger version of this document."
        },
        info: {
          $ref: "#/definitions/info"
        },
        host: {
          type: "string",
          pattern: "^[^{}/ :\\\\]+(?::\\d+)?$",
          description: "The host (name or ip) of the API. Example: 'swagger.io'"
        },
        basePath: {
          type: "string",
          pattern: "^/",
          description: "The base path to the API. Example: '/api'."
        },
        schemes: {
          $ref: "#/definitions/schemesList"
        },
        consumes: {
          description: "A list of MIME types accepted by the API.",
          allOf: [
            {
              $ref: "#/definitions/mediaTypeList"
            }
          ]
        },
        produces: {
          description: "A list of MIME types the API can produce.",
          allOf: [
            {
              $ref: "#/definitions/mediaTypeList"
            }
          ]
        },
        paths: {
          $ref: "#/definitions/paths"
        },
        definitions: {
          $ref: "#/definitions/definitions"
        },
        parameters: {
          $ref: "#/definitions/parameterDefinitions"
        },
        responses: {
          $ref: "#/definitions/responseDefinitions"
        },
        security: {
          $ref: "#/definitions/security"
        },
        securityDefinitions: {
          $ref: "#/definitions/securityDefinitions"
        },
        tags: {
          type: "array",
          items: {
            $ref: "#/definitions/tag"
          },
          uniqueItems: true
        },
        externalDocs: {
          $ref: "#/definitions/externalDocs"
        }
      },
      definitions: {
        info: {
          type: "object",
          description: "General information about the API.",
          required: [
            "version",
            "title"
          ],
          additionalProperties: false,
          patternProperties: {
            "^x-": {
              $ref: "#/definitions/vendorExtension"
            }
          },
          properties: {
            title: {
              type: "string",
              description: "A unique and precise title of the API."
            },
            version: {
              type: "string",
              description: "A semantic version number of the API."
            },
            description: {
              type: "string",
              description: "A longer description of the API. Should be different from the title.  GitHub Flavored Markdown is allowed."
            },
            termsOfService: {
              type: "string",
              description: "The terms of service for the API."
            },
            contact: {
              $ref: "#/definitions/contact"
            },
            license: {
              $ref: "#/definitions/license"
            }
          }
        },
        contact: {
          type: "object",
          description: "Contact information for the owners of the API.",
          additionalProperties: false,
          properties: {
            name: {
              type: "string",
              description: "The identifying name of the contact person/organization."
            },
            url: {
              type: "string",
              description: "The URL pointing to the contact information.",
              format: "uri"
            },
            email: {
              type: "string",
              description: "The email address of the contact person/organization.",
              format: "email"
            }
          },
          patternProperties: {
            "^x-": {
              $ref: "#/definitions/vendorExtension"
            }
          }
        },
        license: {
          type: "object",
          required: [
            "name"
          ],
          additionalProperties: false,
          properties: {
            name: {
              type: "string",
              description: "The name of the license type. It's encouraged to use an OSI compatible license."
            },
            url: {
              type: "string",
              description: "The URL pointing to the license.",
              format: "uri"
            }
          },
          patternProperties: {
            "^x-": {
              $ref: "#/definitions/vendorExtension"
            }
          }
        },
        paths: {
          type: "object",
          description: "Relative paths to the individual endpoints. They must be relative to the 'basePath'.",
          patternProperties: {
            "^x-": {
              $ref: "#/definitions/vendorExtension"
            },
            "^/": {
              $ref: "#/definitions/pathItem"
            }
          },
          additionalProperties: false
        },
        definitions: {
          type: "object",
          additionalProperties: {
            $ref: "#/definitions/schema"
          },
          description: "One or more JSON objects describing the schemas being consumed and produced by the API."
        },
        parameterDefinitions: {
          type: "object",
          additionalProperties: {
            $ref: "#/definitions/parameter"
          },
          description: "One or more JSON representations for parameters"
        },
        responseDefinitions: {
          type: "object",
          additionalProperties: {
            $ref: "#/definitions/response"
          },
          description: "One or more JSON representations for responses"
        },
        externalDocs: {
          type: "object",
          additionalProperties: false,
          description: "information about external documentation",
          required: [
            "url"
          ],
          properties: {
            description: {
              type: "string"
            },
            url: {
              type: "string",
              format: "uri"
            }
          },
          patternProperties: {
            "^x-": {
              $ref: "#/definitions/vendorExtension"
            }
          }
        },
        examples: {
          type: "object",
          additionalProperties: true
        },
        mimeType: {
          type: "string",
          description: "The MIME type of the HTTP message."
        },
        operation: {
          type: "object",
          required: [
            "responses"
          ],
          additionalProperties: false,
          patternProperties: {
            "^x-": {
              $ref: "#/definitions/vendorExtension"
            }
          },
          properties: {
            tags: {
              type: "array",
              items: {
                type: "string"
              },
              uniqueItems: true
            },
            summary: {
              type: "string",
              description: "A brief summary of the operation."
            },
            description: {
              type: "string",
              description: "A longer description of the operation, GitHub Flavored Markdown is allowed."
            },
            externalDocs: {
              $ref: "#/definitions/externalDocs"
            },
            operationId: {
              type: "string",
              description: "A unique identifier of the operation."
            },
            produces: {
              description: "A list of MIME types the API can produce.",
              allOf: [
                {
                  $ref: "#/definitions/mediaTypeList"
                }
              ]
            },
            consumes: {
              description: "A list of MIME types the API can consume.",
              allOf: [
                {
                  $ref: "#/definitions/mediaTypeList"
                }
              ]
            },
            parameters: {
              $ref: "#/definitions/parametersList"
            },
            responses: {
              $ref: "#/definitions/responses"
            },
            schemes: {
              $ref: "#/definitions/schemesList"
            },
            deprecated: {
              type: "boolean",
              default: false
            },
            security: {
              $ref: "#/definitions/security"
            }
          }
        },
        pathItem: {
          type: "object",
          additionalProperties: false,
          patternProperties: {
            "^x-": {
              $ref: "#/definitions/vendorExtension"
            }
          },
          properties: {
            $ref: {
              type: "string"
            },
            get: {
              $ref: "#/definitions/operation"
            },
            put: {
              $ref: "#/definitions/operation"
            },
            post: {
              $ref: "#/definitions/operation"
            },
            delete: {
              $ref: "#/definitions/operation"
            },
            options: {
              $ref: "#/definitions/operation"
            },
            head: {
              $ref: "#/definitions/operation"
            },
            patch: {
              $ref: "#/definitions/operation"
            },
            parameters: {
              $ref: "#/definitions/parametersList"
            }
          }
        },
        responses: {
          type: "object",
          description: "Response objects names can either be any valid HTTP status code or 'default'.",
          minProperties: 1,
          additionalProperties: false,
          patternProperties: {
            "^([0-9]{3})$|^(default)$": {
              $ref: "#/definitions/responseValue"
            },
            "^x-": {
              $ref: "#/definitions/vendorExtension"
            }
          },
          not: {
            type: "object",
            additionalProperties: false,
            patternProperties: {
              "^x-": {
                $ref: "#/definitions/vendorExtension"
              }
            }
          }
        },
        responseValue: {
          oneOf: [
            {
              $ref: "#/definitions/response"
            },
            {
              $ref: "#/definitions/jsonReference"
            }
          ]
        },
        response: {
          type: "object",
          required: [
            "description"
          ],
          properties: {
            description: {
              type: "string"
            },
            schema: {
              oneOf: [
                {
                  $ref: "#/definitions/schema"
                },
                {
                  $ref: "#/definitions/fileSchema"
                }
              ]
            },
            headers: {
              $ref: "#/definitions/headers"
            },
            examples: {
              $ref: "#/definitions/examples"
            }
          },
          additionalProperties: false,
          patternProperties: {
            "^x-": {
              $ref: "#/definitions/vendorExtension"
            }
          }
        },
        headers: {
          type: "object",
          additionalProperties: {
            $ref: "#/definitions/header"
          }
        },
        header: {
          type: "object",
          additionalProperties: false,
          required: [
            "type"
          ],
          properties: {
            type: {
              type: "string",
              enum: [
                "string",
                "number",
                "integer",
                "boolean",
                "array"
              ]
            },
            format: {
              type: "string"
            },
            items: {
              $ref: "#/definitions/primitivesItems"
            },
            collectionFormat: {
              $ref: "#/definitions/collectionFormat"
            },
            default: {
              $ref: "#/definitions/default"
            },
            maximum: {
              $ref: "#/definitions/maximum"
            },
            exclusiveMaximum: {
              $ref: "#/definitions/exclusiveMaximum"
            },
            minimum: {
              $ref: "#/definitions/minimum"
            },
            exclusiveMinimum: {
              $ref: "#/definitions/exclusiveMinimum"
            },
            maxLength: {
              $ref: "#/definitions/maxLength"
            },
            minLength: {
              $ref: "#/definitions/minLength"
            },
            pattern: {
              $ref: "#/definitions/pattern"
            },
            maxItems: {
              $ref: "#/definitions/maxItems"
            },
            minItems: {
              $ref: "#/definitions/minItems"
            },
            uniqueItems: {
              $ref: "#/definitions/uniqueItems"
            },
            enum: {
              $ref: "#/definitions/enum"
            },
            multipleOf: {
              $ref: "#/definitions/multipleOf"
            },
            description: {
              type: "string"
            }
          },
          patternProperties: {
            "^x-": {
              $ref: "#/definitions/vendorExtension"
            }
          }
        },
        vendorExtension: {
          description: "Any property starting with x- is valid.",
          additionalProperties: true,
          additionalItems: true
        },
        bodyParameter: {
          type: "object",
          required: [
            "name",
            "in",
            "schema"
          ],
          patternProperties: {
            "^x-": {
              $ref: "#/definitions/vendorExtension"
            }
          },
          properties: {
            description: {
              type: "string",
              description: "A brief description of the parameter. This could contain examples of use.  GitHub Flavored Markdown is allowed."
            },
            name: {
              type: "string",
              description: "The name of the parameter."
            },
            in: {
              type: "string",
              description: "Determines the location of the parameter.",
              enum: [
                "body"
              ]
            },
            required: {
              type: "boolean",
              description: "Determines whether or not this parameter is required or optional.",
              default: false
            },
            schema: {
              $ref: "#/definitions/schema"
            }
          },
          additionalProperties: false
        },
        headerParameterSubSchema: {
          additionalProperties: false,
          patternProperties: {
            "^x-": {
              $ref: "#/definitions/vendorExtension"
            }
          },
          properties: {
            required: {
              type: "boolean",
              description: "Determines whether or not this parameter is required or optional.",
              default: false
            },
            in: {
              type: "string",
              description: "Determines the location of the parameter.",
              enum: [
                "header"
              ]
            },
            description: {
              type: "string",
              description: "A brief description of the parameter. This could contain examples of use.  GitHub Flavored Markdown is allowed."
            },
            name: {
              type: "string",
              description: "The name of the parameter."
            },
            type: {
              type: "string",
              enum: [
                "string",
                "number",
                "boolean",
                "integer",
                "array"
              ]
            },
            format: {
              type: "string"
            },
            items: {
              $ref: "#/definitions/primitivesItems"
            },
            collectionFormat: {
              $ref: "#/definitions/collectionFormat"
            },
            default: {
              $ref: "#/definitions/default"
            },
            maximum: {
              $ref: "#/definitions/maximum"
            },
            exclusiveMaximum: {
              $ref: "#/definitions/exclusiveMaximum"
            },
            minimum: {
              $ref: "#/definitions/minimum"
            },
            exclusiveMinimum: {
              $ref: "#/definitions/exclusiveMinimum"
            },
            maxLength: {
              $ref: "#/definitions/maxLength"
            },
            minLength: {
              $ref: "#/definitions/minLength"
            },
            pattern: {
              $ref: "#/definitions/pattern"
            },
            maxItems: {
              $ref: "#/definitions/maxItems"
            },
            minItems: {
              $ref: "#/definitions/minItems"
            },
            uniqueItems: {
              $ref: "#/definitions/uniqueItems"
            },
            enum: {
              $ref: "#/definitions/enum"
            },
            multipleOf: {
              $ref: "#/definitions/multipleOf"
            }
          }
        },
        queryParameterSubSchema: {
          additionalProperties: false,
          patternProperties: {
            "^x-": {
              $ref: "#/definitions/vendorExtension"
            }
          },
          properties: {
            required: {
              type: "boolean",
              description: "Determines whether or not this parameter is required or optional.",
              default: false
            },
            in: {
              type: "string",
              description: "Determines the location of the parameter.",
              enum: [
                "query"
              ]
            },
            description: {
              type: "string",
              description: "A brief description of the parameter. This could contain examples of use.  GitHub Flavored Markdown is allowed."
            },
            name: {
              type: "string",
              description: "The name of the parameter."
            },
            allowEmptyValue: {
              type: "boolean",
              default: false,
              description: "allows sending a parameter by name only or with an empty value."
            },
            type: {
              type: "string",
              enum: [
                "string",
                "number",
                "boolean",
                "integer",
                "array"
              ]
            },
            format: {
              type: "string"
            },
            items: {
              $ref: "#/definitions/primitivesItems"
            },
            collectionFormat: {
              $ref: "#/definitions/collectionFormatWithMulti"
            },
            default: {
              $ref: "#/definitions/default"
            },
            maximum: {
              $ref: "#/definitions/maximum"
            },
            exclusiveMaximum: {
              $ref: "#/definitions/exclusiveMaximum"
            },
            minimum: {
              $ref: "#/definitions/minimum"
            },
            exclusiveMinimum: {
              $ref: "#/definitions/exclusiveMinimum"
            },
            maxLength: {
              $ref: "#/definitions/maxLength"
            },
            minLength: {
              $ref: "#/definitions/minLength"
            },
            pattern: {
              $ref: "#/definitions/pattern"
            },
            maxItems: {
              $ref: "#/definitions/maxItems"
            },
            minItems: {
              $ref: "#/definitions/minItems"
            },
            uniqueItems: {
              $ref: "#/definitions/uniqueItems"
            },
            enum: {
              $ref: "#/definitions/enum"
            },
            multipleOf: {
              $ref: "#/definitions/multipleOf"
            }
          }
        },
        formDataParameterSubSchema: {
          additionalProperties: false,
          patternProperties: {
            "^x-": {
              $ref: "#/definitions/vendorExtension"
            }
          },
          properties: {
            required: {
              type: "boolean",
              description: "Determines whether or not this parameter is required or optional.",
              default: false
            },
            in: {
              type: "string",
              description: "Determines the location of the parameter.",
              enum: [
                "formData"
              ]
            },
            description: {
              type: "string",
              description: "A brief description of the parameter. This could contain examples of use.  GitHub Flavored Markdown is allowed."
            },
            name: {
              type: "string",
              description: "The name of the parameter."
            },
            allowEmptyValue: {
              type: "boolean",
              default: false,
              description: "allows sending a parameter by name only or with an empty value."
            },
            type: {
              type: "string",
              enum: [
                "string",
                "number",
                "boolean",
                "integer",
                "array",
                "file"
              ]
            },
            format: {
              type: "string"
            },
            items: {
              $ref: "#/definitions/primitivesItems"
            },
            collectionFormat: {
              $ref: "#/definitions/collectionFormatWithMulti"
            },
            default: {
              $ref: "#/definitions/default"
            },
            maximum: {
              $ref: "#/definitions/maximum"
            },
            exclusiveMaximum: {
              $ref: "#/definitions/exclusiveMaximum"
            },
            minimum: {
              $ref: "#/definitions/minimum"
            },
            exclusiveMinimum: {
              $ref: "#/definitions/exclusiveMinimum"
            },
            maxLength: {
              $ref: "#/definitions/maxLength"
            },
            minLength: {
              $ref: "#/definitions/minLength"
            },
            pattern: {
              $ref: "#/definitions/pattern"
            },
            maxItems: {
              $ref: "#/definitions/maxItems"
            },
            minItems: {
              $ref: "#/definitions/minItems"
            },
            uniqueItems: {
              $ref: "#/definitions/uniqueItems"
            },
            enum: {
              $ref: "#/definitions/enum"
            },
            multipleOf: {
              $ref: "#/definitions/multipleOf"
            }
          }
        },
        pathParameterSubSchema: {
          additionalProperties: false,
          patternProperties: {
            "^x-": {
              $ref: "#/definitions/vendorExtension"
            }
          },
          required: [
            "required"
          ],
          properties: {
            required: {
              type: "boolean",
              enum: [
                true
              ],
              description: "Determines whether or not this parameter is required or optional."
            },
            in: {
              type: "string",
              description: "Determines the location of the parameter.",
              enum: [
                "path"
              ]
            },
            description: {
              type: "string",
              description: "A brief description of the parameter. This could contain examples of use.  GitHub Flavored Markdown is allowed."
            },
            name: {
              type: "string",
              description: "The name of the parameter."
            },
            type: {
              type: "string",
              enum: [
                "string",
                "number",
                "boolean",
                "integer",
                "array"
              ]
            },
            format: {
              type: "string"
            },
            items: {
              $ref: "#/definitions/primitivesItems"
            },
            collectionFormat: {
              $ref: "#/definitions/collectionFormat"
            },
            default: {
              $ref: "#/definitions/default"
            },
            maximum: {
              $ref: "#/definitions/maximum"
            },
            exclusiveMaximum: {
              $ref: "#/definitions/exclusiveMaximum"
            },
            minimum: {
              $ref: "#/definitions/minimum"
            },
            exclusiveMinimum: {
              $ref: "#/definitions/exclusiveMinimum"
            },
            maxLength: {
              $ref: "#/definitions/maxLength"
            },
            minLength: {
              $ref: "#/definitions/minLength"
            },
            pattern: {
              $ref: "#/definitions/pattern"
            },
            maxItems: {
              $ref: "#/definitions/maxItems"
            },
            minItems: {
              $ref: "#/definitions/minItems"
            },
            uniqueItems: {
              $ref: "#/definitions/uniqueItems"
            },
            enum: {
              $ref: "#/definitions/enum"
            },
            multipleOf: {
              $ref: "#/definitions/multipleOf"
            }
          }
        },
        nonBodyParameter: {
          type: "object",
          required: [
            "name",
            "in",
            "type"
          ],
          oneOf: [
            {
              $ref: "#/definitions/headerParameterSubSchema"
            },
            {
              $ref: "#/definitions/formDataParameterSubSchema"
            },
            {
              $ref: "#/definitions/queryParameterSubSchema"
            },
            {
              $ref: "#/definitions/pathParameterSubSchema"
            }
          ]
        },
        parameter: {
          oneOf: [
            {
              $ref: "#/definitions/bodyParameter"
            },
            {
              $ref: "#/definitions/nonBodyParameter"
            }
          ]
        },
        schema: {
          type: "object",
          description: "A deterministic version of a JSON Schema object.",
          patternProperties: {
            "^x-": {
              $ref: "#/definitions/vendorExtension"
            }
          },
          properties: {
            $ref: {
              type: "string"
            },
            format: {
              type: "string"
            },
            title: {
              $ref: "http://json-schema.org/draft-04/schema#/properties/title"
            },
            description: {
              $ref: "http://json-schema.org/draft-04/schema#/properties/description"
            },
            default: {
              $ref: "http://json-schema.org/draft-04/schema#/properties/default"
            },
            multipleOf: {
              $ref: "http://json-schema.org/draft-04/schema#/properties/multipleOf"
            },
            maximum: {
              $ref: "http://json-schema.org/draft-04/schema#/properties/maximum"
            },
            exclusiveMaximum: {
              $ref: "http://json-schema.org/draft-04/schema#/properties/exclusiveMaximum"
            },
            minimum: {
              $ref: "http://json-schema.org/draft-04/schema#/properties/minimum"
            },
            exclusiveMinimum: {
              $ref: "http://json-schema.org/draft-04/schema#/properties/exclusiveMinimum"
            },
            maxLength: {
              $ref: "http://json-schema.org/draft-04/schema#/definitions/positiveInteger"
            },
            minLength: {
              $ref: "http://json-schema.org/draft-04/schema#/definitions/positiveIntegerDefault0"
            },
            pattern: {
              $ref: "http://json-schema.org/draft-04/schema#/properties/pattern"
            },
            maxItems: {
              $ref: "http://json-schema.org/draft-04/schema#/definitions/positiveInteger"
            },
            minItems: {
              $ref: "http://json-schema.org/draft-04/schema#/definitions/positiveIntegerDefault0"
            },
            uniqueItems: {
              $ref: "http://json-schema.org/draft-04/schema#/properties/uniqueItems"
            },
            maxProperties: {
              $ref: "http://json-schema.org/draft-04/schema#/definitions/positiveInteger"
            },
            minProperties: {
              $ref: "http://json-schema.org/draft-04/schema#/definitions/positiveIntegerDefault0"
            },
            required: {
              $ref: "http://json-schema.org/draft-04/schema#/definitions/stringArray"
            },
            enum: {
              $ref: "http://json-schema.org/draft-04/schema#/properties/enum"
            },
            additionalProperties: {
              anyOf: [
                {
                  $ref: "#/definitions/schema"
                },
                {
                  type: "boolean"
                }
              ],
              default: {}
            },
            type: {
              $ref: "http://json-schema.org/draft-04/schema#/properties/type"
            },
            items: {
              anyOf: [
                {
                  $ref: "#/definitions/schema"
                },
                {
                  type: "array",
                  minItems: 1,
                  items: {
                    $ref: "#/definitions/schema"
                  }
                }
              ],
              default: {}
            },
            allOf: {
              type: "array",
              minItems: 1,
              items: {
                $ref: "#/definitions/schema"
              }
            },
            properties: {
              type: "object",
              additionalProperties: {
                $ref: "#/definitions/schema"
              },
              default: {}
            },
            discriminator: {
              type: "string"
            },
            readOnly: {
              type: "boolean",
              default: false
            },
            xml: {
              $ref: "#/definitions/xml"
            },
            externalDocs: {
              $ref: "#/definitions/externalDocs"
            },
            example: {}
          },
          additionalProperties: false
        },
        fileSchema: {
          type: "object",
          description: "A deterministic version of a JSON Schema object.",
          patternProperties: {
            "^x-": {
              $ref: "#/definitions/vendorExtension"
            }
          },
          required: [
            "type"
          ],
          properties: {
            format: {
              type: "string"
            },
            title: {
              $ref: "http://json-schema.org/draft-04/schema#/properties/title"
            },
            description: {
              $ref: "http://json-schema.org/draft-04/schema#/properties/description"
            },
            default: {
              $ref: "http://json-schema.org/draft-04/schema#/properties/default"
            },
            required: {
              $ref: "http://json-schema.org/draft-04/schema#/definitions/stringArray"
            },
            type: {
              type: "string",
              enum: [
                "file"
              ]
            },
            readOnly: {
              type: "boolean",
              default: false
            },
            externalDocs: {
              $ref: "#/definitions/externalDocs"
            },
            example: {}
          },
          additionalProperties: false
        },
        primitivesItems: {
          type: "object",
          additionalProperties: false,
          properties: {
            type: {
              type: "string",
              enum: [
                "string",
                "number",
                "integer",
                "boolean",
                "array"
              ]
            },
            format: {
              type: "string"
            },
            items: {
              $ref: "#/definitions/primitivesItems"
            },
            collectionFormat: {
              $ref: "#/definitions/collectionFormat"
            },
            default: {
              $ref: "#/definitions/default"
            },
            maximum: {
              $ref: "#/definitions/maximum"
            },
            exclusiveMaximum: {
              $ref: "#/definitions/exclusiveMaximum"
            },
            minimum: {
              $ref: "#/definitions/minimum"
            },
            exclusiveMinimum: {
              $ref: "#/definitions/exclusiveMinimum"
            },
            maxLength: {
              $ref: "#/definitions/maxLength"
            },
            minLength: {
              $ref: "#/definitions/minLength"
            },
            pattern: {
              $ref: "#/definitions/pattern"
            },
            maxItems: {
              $ref: "#/definitions/maxItems"
            },
            minItems: {
              $ref: "#/definitions/minItems"
            },
            uniqueItems: {
              $ref: "#/definitions/uniqueItems"
            },
            enum: {
              $ref: "#/definitions/enum"
            },
            multipleOf: {
              $ref: "#/definitions/multipleOf"
            }
          },
          patternProperties: {
            "^x-": {
              $ref: "#/definitions/vendorExtension"
            }
          }
        },
        security: {
          type: "array",
          items: {
            $ref: "#/definitions/securityRequirement"
          },
          uniqueItems: true
        },
        securityRequirement: {
          type: "object",
          additionalProperties: {
            type: "array",
            items: {
              type: "string"
            },
            uniqueItems: true
          }
        },
        xml: {
          type: "object",
          additionalProperties: false,
          properties: {
            name: {
              type: "string"
            },
            namespace: {
              type: "string"
            },
            prefix: {
              type: "string"
            },
            attribute: {
              type: "boolean",
              default: false
            },
            wrapped: {
              type: "boolean",
              default: false
            }
          },
          patternProperties: {
            "^x-": {
              $ref: "#/definitions/vendorExtension"
            }
          }
        },
        tag: {
          type: "object",
          additionalProperties: false,
          required: [
            "name"
          ],
          properties: {
            name: {
              type: "string"
            },
            description: {
              type: "string"
            },
            externalDocs: {
              $ref: "#/definitions/externalDocs"
            }
          },
          patternProperties: {
            "^x-": {
              $ref: "#/definitions/vendorExtension"
            }
          }
        },
        securityDefinitions: {
          type: "object",
          additionalProperties: {
            oneOf: [
              {
                $ref: "#/definitions/basicAuthenticationSecurity"
              },
              {
                $ref: "#/definitions/apiKeySecurity"
              },
              {
                $ref: "#/definitions/oauth2ImplicitSecurity"
              },
              {
                $ref: "#/definitions/oauth2PasswordSecurity"
              },
              {
                $ref: "#/definitions/oauth2ApplicationSecurity"
              },
              {
                $ref: "#/definitions/oauth2AccessCodeSecurity"
              }
            ]
          }
        },
        basicAuthenticationSecurity: {
          type: "object",
          additionalProperties: false,
          required: [
            "type"
          ],
          properties: {
            type: {
              type: "string",
              enum: [
                "basic"
              ]
            },
            description: {
              type: "string"
            }
          },
          patternProperties: {
            "^x-": {
              $ref: "#/definitions/vendorExtension"
            }
          }
        },
        apiKeySecurity: {
          type: "object",
          additionalProperties: false,
          required: [
            "type",
            "name",
            "in"
          ],
          properties: {
            type: {
              type: "string",
              enum: [
                "apiKey"
              ]
            },
            name: {
              type: "string"
            },
            in: {
              type: "string",
              enum: [
                "header",
                "query"
              ]
            },
            description: {
              type: "string"
            }
          },
          patternProperties: {
            "^x-": {
              $ref: "#/definitions/vendorExtension"
            }
          }
        },
        oauth2ImplicitSecurity: {
          type: "object",
          additionalProperties: false,
          required: [
            "type",
            "flow",
            "authorizationUrl"
          ],
          properties: {
            type: {
              type: "string",
              enum: [
                "oauth2"
              ]
            },
            flow: {
              type: "string",
              enum: [
                "implicit"
              ]
            },
            scopes: {
              $ref: "#/definitions/oauth2Scopes"
            },
            authorizationUrl: {
              type: "string",
              format: "uri"
            },
            description: {
              type: "string"
            }
          },
          patternProperties: {
            "^x-": {
              $ref: "#/definitions/vendorExtension"
            }
          }
        },
        oauth2PasswordSecurity: {
          type: "object",
          additionalProperties: false,
          required: [
            "type",
            "flow",
            "tokenUrl"
          ],
          properties: {
            type: {
              type: "string",
              enum: [
                "oauth2"
              ]
            },
            flow: {
              type: "string",
              enum: [
                "password"
              ]
            },
            scopes: {
              $ref: "#/definitions/oauth2Scopes"
            },
            tokenUrl: {
              type: "string",
              format: "uri"
            },
            description: {
              type: "string"
            }
          },
          patternProperties: {
            "^x-": {
              $ref: "#/definitions/vendorExtension"
            }
          }
        },
        oauth2ApplicationSecurity: {
          type: "object",
          additionalProperties: false,
          required: [
            "type",
            "flow",
            "tokenUrl"
          ],
          properties: {
            type: {
              type: "string",
              enum: [
                "oauth2"
              ]
            },
            flow: {
              type: "string",
              enum: [
                "application"
              ]
            },
            scopes: {
              $ref: "#/definitions/oauth2Scopes"
            },
            tokenUrl: {
              type: "string",
              format: "uri"
            },
            description: {
              type: "string"
            }
          },
          patternProperties: {
            "^x-": {
              $ref: "#/definitions/vendorExtension"
            }
          }
        },
        oauth2AccessCodeSecurity: {
          type: "object",
          additionalProperties: false,
          required: [
            "type",
            "flow",
            "authorizationUrl",
            "tokenUrl"
          ],
          properties: {
            type: {
              type: "string",
              enum: [
                "oauth2"
              ]
            },
            flow: {
              type: "string",
              enum: [
                "accessCode"
              ]
            },
            scopes: {
              $ref: "#/definitions/oauth2Scopes"
            },
            authorizationUrl: {
              type: "string",
              format: "uri"
            },
            tokenUrl: {
              type: "string",
              format: "uri"
            },
            description: {
              type: "string"
            }
          },
          patternProperties: {
            "^x-": {
              $ref: "#/definitions/vendorExtension"
            }
          }
        },
        oauth2Scopes: {
          type: "object",
          additionalProperties: {
            type: "string"
          }
        },
        mediaTypeList: {
          type: "array",
          items: {
            $ref: "#/definitions/mimeType"
          },
          uniqueItems: true
        },
        parametersList: {
          type: "array",
          description: "The parameters needed to send a valid API call.",
          additionalItems: false,
          items: {
            oneOf: [
              {
                $ref: "#/definitions/parameter"
              },
              {
                $ref: "#/definitions/jsonReference"
              }
            ]
          },
          uniqueItems: true
        },
        schemesList: {
          type: "array",
          description: "The transfer protocol of the API.",
          items: {
            type: "string",
            enum: [
              "http",
              "https",
              "ws",
              "wss"
            ]
          },
          uniqueItems: true
        },
        collectionFormat: {
          type: "string",
          enum: [
            "csv",
            "ssv",
            "tsv",
            "pipes"
          ],
          default: "csv"
        },
        collectionFormatWithMulti: {
          type: "string",
          enum: [
            "csv",
            "ssv",
            "tsv",
            "pipes",
            "multi"
          ],
          default: "csv"
        },
        title: {
          $ref: "http://json-schema.org/draft-04/schema#/properties/title"
        },
        description: {
          $ref: "http://json-schema.org/draft-04/schema#/properties/description"
        },
        default: {
          $ref: "http://json-schema.org/draft-04/schema#/properties/default"
        },
        multipleOf: {
          $ref: "http://json-schema.org/draft-04/schema#/properties/multipleOf"
        },
        maximum: {
          $ref: "http://json-schema.org/draft-04/schema#/properties/maximum"
        },
        exclusiveMaximum: {
          $ref: "http://json-schema.org/draft-04/schema#/properties/exclusiveMaximum"
        },
        minimum: {
          $ref: "http://json-schema.org/draft-04/schema#/properties/minimum"
        },
        exclusiveMinimum: {
          $ref: "http://json-schema.org/draft-04/schema#/properties/exclusiveMinimum"
        },
        maxLength: {
          $ref: "http://json-schema.org/draft-04/schema#/definitions/positiveInteger"
        },
        minLength: {
          $ref: "http://json-schema.org/draft-04/schema#/definitions/positiveIntegerDefault0"
        },
        pattern: {
          $ref: "http://json-schema.org/draft-04/schema#/properties/pattern"
        },
        maxItems: {
          $ref: "http://json-schema.org/draft-04/schema#/definitions/positiveInteger"
        },
        minItems: {
          $ref: "http://json-schema.org/draft-04/schema#/definitions/positiveIntegerDefault0"
        },
        uniqueItems: {
          $ref: "http://json-schema.org/draft-04/schema#/properties/uniqueItems"
        },
        enum: {
          $ref: "http://json-schema.org/draft-04/schema#/properties/enum"
        },
        jsonReference: {
          type: "object",
          required: [
            "$ref"
          ],
          additionalProperties: false,
          properties: {
            $ref: {
              type: "string"
            }
          }
        }
      }
    };
    var schema_default2 = {
      id: "https://spec.openapis.org/oas/3.0/schema/2021-09-28",
      $schema: "http://json-schema.org/draft-04/schema#",
      description: "The description of OpenAPI v3.0.x documents, as defined by https://spec.openapis.org/oas/v3.0.3",
      type: "object",
      required: [
        "openapi",
        "info",
        "paths"
      ],
      properties: {
        openapi: {
          type: "string",
          pattern: "^3\\.0\\.\\d(-.+)?$"
        },
        info: {
          $ref: "#/definitions/Info"
        },
        externalDocs: {
          $ref: "#/definitions/ExternalDocumentation"
        },
        servers: {
          type: "array",
          items: {
            $ref: "#/definitions/Server"
          }
        },
        security: {
          type: "array",
          items: {
            $ref: "#/definitions/SecurityRequirement"
          }
        },
        tags: {
          type: "array",
          items: {
            $ref: "#/definitions/Tag"
          },
          uniqueItems: true
        },
        paths: {
          $ref: "#/definitions/Paths"
        },
        components: {
          $ref: "#/definitions/Components"
        }
      },
      patternProperties: {
        "^x-": {}
      },
      additionalProperties: false,
      definitions: {
        Reference: {
          type: "object",
          required: [
            "$ref"
          ],
          patternProperties: {
            "^\\$ref$": {
              type: "string",
              format: "uri-reference"
            }
          }
        },
        Info: {
          type: "object",
          required: [
            "title",
            "version"
          ],
          properties: {
            title: {
              type: "string"
            },
            description: {
              type: "string"
            },
            termsOfService: {
              type: "string",
              format: "uri-reference"
            },
            contact: {
              $ref: "#/definitions/Contact"
            },
            license: {
              $ref: "#/definitions/License"
            },
            version: {
              type: "string"
            }
          },
          patternProperties: {
            "^x-": {}
          },
          additionalProperties: false
        },
        Contact: {
          type: "object",
          properties: {
            name: {
              type: "string"
            },
            url: {
              type: "string",
              format: "uri-reference"
            },
            email: {
              type: "string",
              format: "email"
            }
          },
          patternProperties: {
            "^x-": {}
          },
          additionalProperties: false
        },
        License: {
          type: "object",
          required: [
            "name"
          ],
          properties: {
            name: {
              type: "string"
            },
            url: {
              type: "string",
              format: "uri-reference"
            }
          },
          patternProperties: {
            "^x-": {}
          },
          additionalProperties: false
        },
        Server: {
          type: "object",
          required: [
            "url"
          ],
          properties: {
            url: {
              type: "string"
            },
            description: {
              type: "string"
            },
            variables: {
              type: "object",
              additionalProperties: {
                $ref: "#/definitions/ServerVariable"
              }
            }
          },
          patternProperties: {
            "^x-": {}
          },
          additionalProperties: false
        },
        ServerVariable: {
          type: "object",
          required: [
            "default"
          ],
          properties: {
            enum: {
              type: "array",
              items: {
                type: "string"
              }
            },
            default: {
              type: "string"
            },
            description: {
              type: "string"
            }
          },
          patternProperties: {
            "^x-": {}
          },
          additionalProperties: false
        },
        Components: {
          type: "object",
          properties: {
            schemas: {
              type: "object",
              patternProperties: {
                "^[a-zA-Z0-9\\.\\-_]+$": {
                  oneOf: [
                    {
                      $ref: "#/definitions/Schema"
                    },
                    {
                      $ref: "#/definitions/Reference"
                    }
                  ]
                }
              }
            },
            responses: {
              type: "object",
              patternProperties: {
                "^[a-zA-Z0-9\\.\\-_]+$": {
                  oneOf: [
                    {
                      $ref: "#/definitions/Reference"
                    },
                    {
                      $ref: "#/definitions/Response"
                    }
                  ]
                }
              }
            },
            parameters: {
              type: "object",
              patternProperties: {
                "^[a-zA-Z0-9\\.\\-_]+$": {
                  oneOf: [
                    {
                      $ref: "#/definitions/Reference"
                    },
                    {
                      $ref: "#/definitions/Parameter"
                    }
                  ]
                }
              }
            },
            examples: {
              type: "object",
              patternProperties: {
                "^[a-zA-Z0-9\\.\\-_]+$": {
                  oneOf: [
                    {
                      $ref: "#/definitions/Reference"
                    },
                    {
                      $ref: "#/definitions/Example"
                    }
                  ]
                }
              }
            },
            requestBodies: {
              type: "object",
              patternProperties: {
                "^[a-zA-Z0-9\\.\\-_]+$": {
                  oneOf: [
                    {
                      $ref: "#/definitions/Reference"
                    },
                    {
                      $ref: "#/definitions/RequestBody"
                    }
                  ]
                }
              }
            },
            headers: {
              type: "object",
              patternProperties: {
                "^[a-zA-Z0-9\\.\\-_]+$": {
                  oneOf: [
                    {
                      $ref: "#/definitions/Reference"
                    },
                    {
                      $ref: "#/definitions/Header"
                    }
                  ]
                }
              }
            },
            securitySchemes: {
              type: "object",
              patternProperties: {
                "^[a-zA-Z0-9\\.\\-_]+$": {
                  oneOf: [
                    {
                      $ref: "#/definitions/Reference"
                    },
                    {
                      $ref: "#/definitions/SecurityScheme"
                    }
                  ]
                }
              }
            },
            links: {
              type: "object",
              patternProperties: {
                "^[a-zA-Z0-9\\.\\-_]+$": {
                  oneOf: [
                    {
                      $ref: "#/definitions/Reference"
                    },
                    {
                      $ref: "#/definitions/Link"
                    }
                  ]
                }
              }
            },
            callbacks: {
              type: "object",
              patternProperties: {
                "^[a-zA-Z0-9\\.\\-_]+$": {
                  oneOf: [
                    {
                      $ref: "#/definitions/Reference"
                    },
                    {
                      $ref: "#/definitions/Callback"
                    }
                  ]
                }
              }
            }
          },
          patternProperties: {
            "^x-": {}
          },
          additionalProperties: false
        },
        Schema: {
          type: "object",
          properties: {
            title: {
              type: "string"
            },
            multipleOf: {
              type: "number",
              minimum: 0,
              exclusiveMinimum: true
            },
            maximum: {
              type: "number"
            },
            exclusiveMaximum: {
              type: "boolean",
              default: false
            },
            minimum: {
              type: "number"
            },
            exclusiveMinimum: {
              type: "boolean",
              default: false
            },
            maxLength: {
              type: "integer",
              minimum: 0
            },
            minLength: {
              type: "integer",
              minimum: 0,
              default: 0
            },
            pattern: {
              type: "string",
              format: "regex"
            },
            maxItems: {
              type: "integer",
              minimum: 0
            },
            minItems: {
              type: "integer",
              minimum: 0,
              default: 0
            },
            uniqueItems: {
              type: "boolean",
              default: false
            },
            maxProperties: {
              type: "integer",
              minimum: 0
            },
            minProperties: {
              type: "integer",
              minimum: 0,
              default: 0
            },
            required: {
              type: "array",
              items: {
                type: "string"
              },
              minItems: 1,
              uniqueItems: true
            },
            enum: {
              type: "array",
              items: {},
              minItems: 1,
              uniqueItems: false
            },
            type: {
              type: "string",
              enum: [
                "array",
                "boolean",
                "integer",
                "number",
                "object",
                "string"
              ]
            },
            not: {
              oneOf: [
                {
                  $ref: "#/definitions/Schema"
                },
                {
                  $ref: "#/definitions/Reference"
                }
              ]
            },
            allOf: {
              type: "array",
              items: {
                oneOf: [
                  {
                    $ref: "#/definitions/Schema"
                  },
                  {
                    $ref: "#/definitions/Reference"
                  }
                ]
              }
            },
            oneOf: {
              type: "array",
              items: {
                oneOf: [
                  {
                    $ref: "#/definitions/Schema"
                  },
                  {
                    $ref: "#/definitions/Reference"
                  }
                ]
              }
            },
            anyOf: {
              type: "array",
              items: {
                oneOf: [
                  {
                    $ref: "#/definitions/Schema"
                  },
                  {
                    $ref: "#/definitions/Reference"
                  }
                ]
              }
            },
            items: {
              oneOf: [
                {
                  $ref: "#/definitions/Schema"
                },
                {
                  $ref: "#/definitions/Reference"
                }
              ]
            },
            properties: {
              type: "object",
              additionalProperties: {
                oneOf: [
                  {
                    $ref: "#/definitions/Schema"
                  },
                  {
                    $ref: "#/definitions/Reference"
                  }
                ]
              }
            },
            additionalProperties: {
              oneOf: [
                {
                  $ref: "#/definitions/Schema"
                },
                {
                  $ref: "#/definitions/Reference"
                },
                {
                  type: "boolean"
                }
              ],
              default: true
            },
            description: {
              type: "string"
            },
            format: {
              type: "string"
            },
            default: {},
            nullable: {
              type: "boolean",
              default: false
            },
            discriminator: {
              $ref: "#/definitions/Discriminator"
            },
            readOnly: {
              type: "boolean",
              default: false
            },
            writeOnly: {
              type: "boolean",
              default: false
            },
            example: {},
            externalDocs: {
              $ref: "#/definitions/ExternalDocumentation"
            },
            deprecated: {
              type: "boolean",
              default: false
            },
            xml: {
              $ref: "#/definitions/XML"
            }
          },
          patternProperties: {
            "^x-": {}
          },
          additionalProperties: false
        },
        Discriminator: {
          type: "object",
          required: [
            "propertyName"
          ],
          properties: {
            propertyName: {
              type: "string"
            },
            mapping: {
              type: "object",
              additionalProperties: {
                type: "string"
              }
            }
          }
        },
        XML: {
          type: "object",
          properties: {
            name: {
              type: "string"
            },
            namespace: {
              type: "string",
              format: "uri"
            },
            prefix: {
              type: "string"
            },
            attribute: {
              type: "boolean",
              default: false
            },
            wrapped: {
              type: "boolean",
              default: false
            }
          },
          patternProperties: {
            "^x-": {}
          },
          additionalProperties: false
        },
        Response: {
          type: "object",
          required: [
            "description"
          ],
          properties: {
            description: {
              type: "string"
            },
            headers: {
              type: "object",
              additionalProperties: {
                oneOf: [
                  {
                    $ref: "#/definitions/Header"
                  },
                  {
                    $ref: "#/definitions/Reference"
                  }
                ]
              }
            },
            content: {
              type: "object",
              additionalProperties: {
                $ref: "#/definitions/MediaType"
              }
            },
            links: {
              type: "object",
              additionalProperties: {
                oneOf: [
                  {
                    $ref: "#/definitions/Link"
                  },
                  {
                    $ref: "#/definitions/Reference"
                  }
                ]
              }
            }
          },
          patternProperties: {
            "^x-": {}
          },
          additionalProperties: false
        },
        MediaType: {
          type: "object",
          properties: {
            schema: {
              oneOf: [
                {
                  $ref: "#/definitions/Schema"
                },
                {
                  $ref: "#/definitions/Reference"
                }
              ]
            },
            example: {},
            examples: {
              type: "object",
              additionalProperties: {
                oneOf: [
                  {
                    $ref: "#/definitions/Example"
                  },
                  {
                    $ref: "#/definitions/Reference"
                  }
                ]
              }
            },
            encoding: {
              type: "object",
              additionalProperties: {
                $ref: "#/definitions/Encoding"
              }
            }
          },
          patternProperties: {
            "^x-": {}
          },
          additionalProperties: false,
          allOf: [
            {
              $ref: "#/definitions/ExampleXORExamples"
            }
          ]
        },
        Example: {
          type: "object",
          properties: {
            summary: {
              type: "string"
            },
            description: {
              type: "string"
            },
            value: {},
            externalValue: {
              type: "string",
              format: "uri-reference"
            }
          },
          patternProperties: {
            "^x-": {}
          },
          additionalProperties: false
        },
        Header: {
          type: "object",
          properties: {
            description: {
              type: "string"
            },
            required: {
              type: "boolean",
              default: false
            },
            deprecated: {
              type: "boolean",
              default: false
            },
            allowEmptyValue: {
              type: "boolean",
              default: false
            },
            style: {
              type: "string",
              enum: [
                "simple"
              ],
              default: "simple"
            },
            explode: {
              type: "boolean"
            },
            allowReserved: {
              type: "boolean",
              default: false
            },
            schema: {
              oneOf: [
                {
                  $ref: "#/definitions/Schema"
                },
                {
                  $ref: "#/definitions/Reference"
                }
              ]
            },
            content: {
              type: "object",
              additionalProperties: {
                $ref: "#/definitions/MediaType"
              },
              minProperties: 1,
              maxProperties: 1
            },
            example: {},
            examples: {
              type: "object",
              additionalProperties: {
                oneOf: [
                  {
                    $ref: "#/definitions/Example"
                  },
                  {
                    $ref: "#/definitions/Reference"
                  }
                ]
              }
            }
          },
          patternProperties: {
            "^x-": {}
          },
          additionalProperties: false,
          allOf: [
            {
              $ref: "#/definitions/ExampleXORExamples"
            },
            {
              $ref: "#/definitions/SchemaXORContent"
            }
          ]
        },
        Paths: {
          type: "object",
          patternProperties: {
            "^\\/": {
              $ref: "#/definitions/PathItem"
            },
            "^x-": {}
          },
          additionalProperties: false
        },
        PathItem: {
          type: "object",
          properties: {
            $ref: {
              type: "string"
            },
            summary: {
              type: "string"
            },
            description: {
              type: "string"
            },
            servers: {
              type: "array",
              items: {
                $ref: "#/definitions/Server"
              }
            },
            parameters: {
              type: "array",
              items: {
                oneOf: [
                  {
                    $ref: "#/definitions/Parameter"
                  },
                  {
                    $ref: "#/definitions/Reference"
                  }
                ]
              },
              uniqueItems: true
            }
          },
          patternProperties: {
            "^(get|put|post|delete|options|head|patch|trace)$": {
              $ref: "#/definitions/Operation"
            },
            "^x-": {}
          },
          additionalProperties: false
        },
        Operation: {
          type: "object",
          required: [
            "responses"
          ],
          properties: {
            tags: {
              type: "array",
              items: {
                type: "string"
              }
            },
            summary: {
              type: "string"
            },
            description: {
              type: "string"
            },
            externalDocs: {
              $ref: "#/definitions/ExternalDocumentation"
            },
            operationId: {
              type: "string"
            },
            parameters: {
              type: "array",
              items: {
                oneOf: [
                  {
                    $ref: "#/definitions/Parameter"
                  },
                  {
                    $ref: "#/definitions/Reference"
                  }
                ]
              },
              uniqueItems: true
            },
            requestBody: {
              oneOf: [
                {
                  $ref: "#/definitions/RequestBody"
                },
                {
                  $ref: "#/definitions/Reference"
                }
              ]
            },
            responses: {
              $ref: "#/definitions/Responses"
            },
            callbacks: {
              type: "object",
              additionalProperties: {
                oneOf: [
                  {
                    $ref: "#/definitions/Callback"
                  },
                  {
                    $ref: "#/definitions/Reference"
                  }
                ]
              }
            },
            deprecated: {
              type: "boolean",
              default: false
            },
            security: {
              type: "array",
              items: {
                $ref: "#/definitions/SecurityRequirement"
              }
            },
            servers: {
              type: "array",
              items: {
                $ref: "#/definitions/Server"
              }
            }
          },
          patternProperties: {
            "^x-": {}
          },
          additionalProperties: false
        },
        Responses: {
          type: "object",
          properties: {
            default: {
              oneOf: [
                {
                  $ref: "#/definitions/Response"
                },
                {
                  $ref: "#/definitions/Reference"
                }
              ]
            }
          },
          patternProperties: {
            "^[1-5](?:\\d{2}|XX)$": {
              oneOf: [
                {
                  $ref: "#/definitions/Response"
                },
                {
                  $ref: "#/definitions/Reference"
                }
              ]
            },
            "^x-": {}
          },
          minProperties: 1,
          additionalProperties: false
        },
        SecurityRequirement: {
          type: "object",
          additionalProperties: {
            type: "array",
            items: {
              type: "string"
            }
          }
        },
        Tag: {
          type: "object",
          required: [
            "name"
          ],
          properties: {
            name: {
              type: "string"
            },
            description: {
              type: "string"
            },
            externalDocs: {
              $ref: "#/definitions/ExternalDocumentation"
            }
          },
          patternProperties: {
            "^x-": {}
          },
          additionalProperties: false
        },
        ExternalDocumentation: {
          type: "object",
          required: [
            "url"
          ],
          properties: {
            description: {
              type: "string"
            },
            url: {
              type: "string",
              format: "uri-reference"
            }
          },
          patternProperties: {
            "^x-": {}
          },
          additionalProperties: false
        },
        ExampleXORExamples: {
          description: "Example and examples are mutually exclusive",
          not: {
            required: [
              "example",
              "examples"
            ]
          }
        },
        SchemaXORContent: {
          description: "Schema and content are mutually exclusive, at least one is required",
          not: {
            required: [
              "schema",
              "content"
            ]
          },
          oneOf: [
            {
              required: [
                "schema"
              ]
            },
            {
              required: [
                "content"
              ],
              description: "Some properties are not allowed if content is present",
              allOf: [
                {
                  not: {
                    required: [
                      "style"
                    ]
                  }
                },
                {
                  not: {
                    required: [
                      "explode"
                    ]
                  }
                },
                {
                  not: {
                    required: [
                      "allowReserved"
                    ]
                  }
                },
                {
                  not: {
                    required: [
                      "example"
                    ]
                  }
                },
                {
                  not: {
                    required: [
                      "examples"
                    ]
                  }
                }
              ]
            }
          ]
        },
        Parameter: {
          type: "object",
          properties: {
            name: {
              type: "string"
            },
            in: {
              type: "string"
            },
            description: {
              type: "string"
            },
            required: {
              type: "boolean",
              default: false
            },
            deprecated: {
              type: "boolean",
              default: false
            },
            allowEmptyValue: {
              type: "boolean",
              default: false
            },
            style: {
              type: "string"
            },
            explode: {
              type: "boolean"
            },
            allowReserved: {
              type: "boolean",
              default: false
            },
            schema: {
              oneOf: [
                {
                  $ref: "#/definitions/Schema"
                },
                {
                  $ref: "#/definitions/Reference"
                }
              ]
            },
            content: {
              type: "object",
              additionalProperties: {
                $ref: "#/definitions/MediaType"
              },
              minProperties: 1,
              maxProperties: 1
            },
            example: {},
            examples: {
              type: "object",
              additionalProperties: {
                oneOf: [
                  {
                    $ref: "#/definitions/Example"
                  },
                  {
                    $ref: "#/definitions/Reference"
                  }
                ]
              }
            }
          },
          patternProperties: {
            "^x-": {}
          },
          additionalProperties: false,
          required: [
            "name",
            "in"
          ],
          allOf: [
            {
              $ref: "#/definitions/ExampleXORExamples"
            },
            {
              $ref: "#/definitions/SchemaXORContent"
            },
            {
              $ref: "#/definitions/ParameterLocation"
            }
          ]
        },
        ParameterLocation: {
          description: "Parameter location",
          oneOf: [
            {
              description: "Parameter in path",
              required: [
                "required"
              ],
              properties: {
                in: {
                  enum: [
                    "path"
                  ]
                },
                style: {
                  enum: [
                    "matrix",
                    "label",
                    "simple"
                  ],
                  default: "simple"
                },
                required: {
                  enum: [
                    true
                  ]
                }
              }
            },
            {
              description: "Parameter in query",
              properties: {
                in: {
                  enum: [
                    "query"
                  ]
                },
                style: {
                  enum: [
                    "form",
                    "spaceDelimited",
                    "pipeDelimited",
                    "deepObject"
                  ],
                  default: "form"
                }
              }
            },
            {
              description: "Parameter in header",
              properties: {
                in: {
                  enum: [
                    "header"
                  ]
                },
                style: {
                  enum: [
                    "simple"
                  ],
                  default: "simple"
                }
              }
            },
            {
              description: "Parameter in cookie",
              properties: {
                in: {
                  enum: [
                    "cookie"
                  ]
                },
                style: {
                  enum: [
                    "form"
                  ],
                  default: "form"
                }
              }
            }
          ]
        },
        RequestBody: {
          type: "object",
          required: [
            "content"
          ],
          properties: {
            description: {
              type: "string"
            },
            content: {
              type: "object",
              additionalProperties: {
                $ref: "#/definitions/MediaType"
              }
            },
            required: {
              type: "boolean",
              default: false
            }
          },
          patternProperties: {
            "^x-": {}
          },
          additionalProperties: false
        },
        SecurityScheme: {
          oneOf: [
            {
              $ref: "#/definitions/APIKeySecurityScheme"
            },
            {
              $ref: "#/definitions/HTTPSecurityScheme"
            },
            {
              $ref: "#/definitions/OAuth2SecurityScheme"
            },
            {
              $ref: "#/definitions/OpenIdConnectSecurityScheme"
            }
          ]
        },
        APIKeySecurityScheme: {
          type: "object",
          required: [
            "type",
            "name",
            "in"
          ],
          properties: {
            type: {
              type: "string",
              enum: [
                "apiKey"
              ]
            },
            name: {
              type: "string"
            },
            in: {
              type: "string",
              enum: [
                "header",
                "query",
                "cookie"
              ]
            },
            description: {
              type: "string"
            }
          },
          patternProperties: {
            "^x-": {}
          },
          additionalProperties: false
        },
        HTTPSecurityScheme: {
          type: "object",
          required: [
            "scheme",
            "type"
          ],
          properties: {
            scheme: {
              type: "string"
            },
            bearerFormat: {
              type: "string"
            },
            description: {
              type: "string"
            },
            type: {
              type: "string",
              enum: [
                "http"
              ]
            }
          },
          patternProperties: {
            "^x-": {}
          },
          additionalProperties: false,
          oneOf: [
            {
              description: "Bearer",
              properties: {
                scheme: {
                  type: "string",
                  pattern: "^[Bb][Ee][Aa][Rr][Ee][Rr]$"
                }
              }
            },
            {
              description: "Non Bearer",
              not: {
                required: [
                  "bearerFormat"
                ]
              },
              properties: {
                scheme: {
                  not: {
                    type: "string",
                    pattern: "^[Bb][Ee][Aa][Rr][Ee][Rr]$"
                  }
                }
              }
            }
          ]
        },
        OAuth2SecurityScheme: {
          type: "object",
          required: [
            "type",
            "flows"
          ],
          properties: {
            type: {
              type: "string",
              enum: [
                "oauth2"
              ]
            },
            flows: {
              $ref: "#/definitions/OAuthFlows"
            },
            description: {
              type: "string"
            }
          },
          patternProperties: {
            "^x-": {}
          },
          additionalProperties: false
        },
        OpenIdConnectSecurityScheme: {
          type: "object",
          required: [
            "type",
            "openIdConnectUrl"
          ],
          properties: {
            type: {
              type: "string",
              enum: [
                "openIdConnect"
              ]
            },
            openIdConnectUrl: {
              type: "string",
              format: "uri-reference"
            },
            description: {
              type: "string"
            }
          },
          patternProperties: {
            "^x-": {}
          },
          additionalProperties: false
        },
        OAuthFlows: {
          type: "object",
          properties: {
            implicit: {
              $ref: "#/definitions/ImplicitOAuthFlow"
            },
            password: {
              $ref: "#/definitions/PasswordOAuthFlow"
            },
            clientCredentials: {
              $ref: "#/definitions/ClientCredentialsFlow"
            },
            authorizationCode: {
              $ref: "#/definitions/AuthorizationCodeOAuthFlow"
            }
          },
          patternProperties: {
            "^x-": {}
          },
          additionalProperties: false
        },
        ImplicitOAuthFlow: {
          type: "object",
          required: [
            "authorizationUrl",
            "scopes"
          ],
          properties: {
            authorizationUrl: {
              type: "string",
              format: "uri-reference"
            },
            refreshUrl: {
              type: "string",
              format: "uri-reference"
            },
            scopes: {
              type: "object",
              additionalProperties: {
                type: "string"
              }
            }
          },
          patternProperties: {
            "^x-": {}
          },
          additionalProperties: false
        },
        PasswordOAuthFlow: {
          type: "object",
          required: [
            "tokenUrl",
            "scopes"
          ],
          properties: {
            tokenUrl: {
              type: "string",
              format: "uri-reference"
            },
            refreshUrl: {
              type: "string",
              format: "uri-reference"
            },
            scopes: {
              type: "object",
              additionalProperties: {
                type: "string"
              }
            }
          },
          patternProperties: {
            "^x-": {}
          },
          additionalProperties: false
        },
        ClientCredentialsFlow: {
          type: "object",
          required: [
            "tokenUrl",
            "scopes"
          ],
          properties: {
            tokenUrl: {
              type: "string",
              format: "uri-reference"
            },
            refreshUrl: {
              type: "string",
              format: "uri-reference"
            },
            scopes: {
              type: "object",
              additionalProperties: {
                type: "string"
              }
            }
          },
          patternProperties: {
            "^x-": {}
          },
          additionalProperties: false
        },
        AuthorizationCodeOAuthFlow: {
          type: "object",
          required: [
            "authorizationUrl",
            "tokenUrl",
            "scopes"
          ],
          properties: {
            authorizationUrl: {
              type: "string",
              format: "uri-reference"
            },
            tokenUrl: {
              type: "string",
              format: "uri-reference"
            },
            refreshUrl: {
              type: "string",
              format: "uri-reference"
            },
            scopes: {
              type: "object",
              additionalProperties: {
                type: "string"
              }
            }
          },
          patternProperties: {
            "^x-": {}
          },
          additionalProperties: false
        },
        Link: {
          type: "object",
          properties: {
            operationId: {
              type: "string"
            },
            operationRef: {
              type: "string",
              format: "uri-reference"
            },
            parameters: {
              type: "object",
              additionalProperties: {}
            },
            requestBody: {},
            description: {
              type: "string"
            },
            server: {
              $ref: "#/definitions/Server"
            }
          },
          patternProperties: {
            "^x-": {}
          },
          additionalProperties: false,
          not: {
            description: "Operation Id and Operation Ref are mutually exclusive",
            required: [
              "operationId",
              "operationRef"
            ]
          }
        },
        Callback: {
          type: "object",
          additionalProperties: {
            $ref: "#/definitions/PathItem"
          },
          patternProperties: {
            "^x-": {}
          }
        },
        Encoding: {
          type: "object",
          properties: {
            contentType: {
              type: "string"
            },
            headers: {
              type: "object",
              additionalProperties: {
                oneOf: [
                  {
                    $ref: "#/definitions/Header"
                  },
                  {
                    $ref: "#/definitions/Reference"
                  }
                ]
              }
            },
            style: {
              type: "string",
              enum: [
                "form",
                "spaceDelimited",
                "pipeDelimited",
                "deepObject"
              ]
            },
            explode: {
              type: "boolean"
            },
            allowReserved: {
              type: "boolean",
              default: false
            }
          },
          patternProperties: {
            "^x-": {}
          },
          additionalProperties: false
        }
      }
    };
    var legacy_schema_default = {
      $id: "https://spec.openapis.org/oas/3.1/schema/2022-10-07",
      $schema: "https://json-schema.org/draft/2020-12/schema",
      description: "The description of OpenAPI v3.1.x documents without schema validation, as defined by https://spec.openapis.org/oas/v3.1.0",
      type: "object",
      properties: {
        openapi: {
          type: "string",
          pattern: "^3\\.1\\.\\d+(-.+)?$"
        },
        info: {
          $ref: "#/$defs/info"
        },
        jsonSchemaDialect: {
          type: "string",
          format: "uri",
          default: "https://spec.openapis.org/oas/3.1/dialect/base"
        },
        servers: {
          type: "array",
          items: {
            $ref: "#/$defs/server"
          },
          default: [
            {
              url: "/"
            }
          ]
        },
        paths: {
          $ref: "#/$defs/paths"
        },
        webhooks: {
          type: "object",
          additionalProperties: {
            $ref: "#/$defs/path-item-or-reference"
          }
        },
        components: {
          $ref: "#/$defs/components"
        },
        security: {
          type: "array",
          items: {
            $ref: "#/$defs/security-requirement"
          }
        },
        tags: {
          type: "array",
          items: {
            $ref: "#/$defs/tag"
          }
        },
        externalDocs: {
          $ref: "#/$defs/external-documentation"
        }
      },
      required: [
        "openapi",
        "info"
      ],
      anyOf: [
        {
          required: [
            "paths"
          ]
        },
        {
          required: [
            "components"
          ]
        },
        {
          required: [
            "webhooks"
          ]
        }
      ],
      $ref: "#/$defs/specification-extensions",
      unevaluatedProperties: false,
      $defs: {
        info: {
          $comment: "https://spec.openapis.org/oas/v3.1.0#info-object",
          type: "object",
          properties: {
            title: {
              type: "string"
            },
            summary: {
              type: "string"
            },
            description: {
              type: "string"
            },
            termsOfService: {
              type: "string",
              format: "uri"
            },
            contact: {
              $ref: "#/$defs/contact"
            },
            license: {
              $ref: "#/$defs/license"
            },
            version: {
              type: "string"
            }
          },
          required: [
            "title",
            "version"
          ],
          $ref: "#/$defs/specification-extensions",
          unevaluatedProperties: false
        },
        contact: {
          $comment: "https://spec.openapis.org/oas/v3.1.0#contact-object",
          type: "object",
          properties: {
            name: {
              type: "string"
            },
            url: {
              type: "string",
              format: "uri"
            },
            email: {
              type: "string",
              format: "email"
            }
          },
          $ref: "#/$defs/specification-extensions",
          unevaluatedProperties: false
        },
        license: {
          $comment: "https://spec.openapis.org/oas/v3.1.0#license-object",
          type: "object",
          properties: {
            name: {
              type: "string"
            },
            identifier: {
              type: "string"
            },
            url: {
              type: "string",
              format: "uri"
            }
          },
          required: [
            "name"
          ],
          dependentSchemas: {
            identifier: {
              not: {
                required: [
                  "url"
                ]
              }
            }
          },
          $ref: "#/$defs/specification-extensions",
          unevaluatedProperties: false
        },
        server: {
          $comment: "https://spec.openapis.org/oas/v3.1.0#server-object",
          type: "object",
          properties: {
            url: {
              type: "string",
              format: "uri-reference"
            },
            description: {
              type: "string"
            },
            variables: {
              type: "object",
              additionalProperties: {
                $ref: "#/$defs/server-variable"
              }
            }
          },
          required: [
            "url"
          ],
          $ref: "#/$defs/specification-extensions",
          unevaluatedProperties: false
        },
        "server-variable": {
          $comment: "https://spec.openapis.org/oas/v3.1.0#server-variable-object",
          type: "object",
          properties: {
            enum: {
              type: "array",
              items: {
                type: "string"
              },
              minItems: 1
            },
            default: {
              type: "string"
            },
            description: {
              type: "string"
            }
          },
          required: [
            "default"
          ],
          $ref: "#/$defs/specification-extensions",
          unevaluatedProperties: false
        },
        components: {
          $comment: "https://spec.openapis.org/oas/v3.1.0#components-object",
          type: "object",
          properties: {
            schemas: {
              type: "object",
              additionalProperties: {
                $dynamicRef: "#meta"
              }
            },
            responses: {
              type: "object",
              additionalProperties: {
                $ref: "#/$defs/response-or-reference"
              }
            },
            parameters: {
              type: "object",
              additionalProperties: {
                $ref: "#/$defs/parameter-or-reference"
              }
            },
            examples: {
              type: "object",
              additionalProperties: {
                $ref: "#/$defs/example-or-reference"
              }
            },
            requestBodies: {
              type: "object",
              additionalProperties: {
                $ref: "#/$defs/request-body-or-reference"
              }
            },
            headers: {
              type: "object",
              additionalProperties: {
                $ref: "#/$defs/header-or-reference"
              }
            },
            securitySchemes: {
              type: "object",
              additionalProperties: {
                $ref: "#/$defs/security-scheme-or-reference"
              }
            },
            links: {
              type: "object",
              additionalProperties: {
                $ref: "#/$defs/link-or-reference"
              }
            },
            callbacks: {
              type: "object",
              additionalProperties: {
                $ref: "#/$defs/callbacks-or-reference"
              }
            },
            pathItems: {
              type: "object",
              additionalProperties: {
                $ref: "#/$defs/path-item-or-reference"
              }
            }
          },
          patternProperties: {
            "^(schemas|responses|parameters|examples|requestBodies|headers|securitySchemes|links|callbacks|pathItems)$": {
              $comment: "Enumerating all of the property names in the regex above is necessary for unevaluatedProperties to work as expected",
              propertyNames: {
                pattern: "^[a-zA-Z0-9._-]+$"
              }
            }
          },
          $ref: "#/$defs/specification-extensions",
          unevaluatedProperties: false
        },
        paths: {
          $comment: "https://spec.openapis.org/oas/v3.1.0#paths-object",
          type: "object",
          patternProperties: {
            "^/": {
              $ref: "#/$defs/path-item"
            }
          },
          $ref: "#/$defs/specification-extensions",
          unevaluatedProperties: false
        },
        "path-item": {
          $comment: "https://spec.openapis.org/oas/v3.1.0#path-item-object",
          type: "object",
          properties: {
            summary: {
              type: "string"
            },
            description: {
              type: "string"
            },
            servers: {
              type: "array",
              items: {
                $ref: "#/$defs/server"
              }
            },
            parameters: {
              type: "array",
              items: {
                $ref: "#/$defs/parameter-or-reference"
              }
            },
            get: {
              $ref: "#/$defs/operation"
            },
            put: {
              $ref: "#/$defs/operation"
            },
            post: {
              $ref: "#/$defs/operation"
            },
            delete: {
              $ref: "#/$defs/operation"
            },
            options: {
              $ref: "#/$defs/operation"
            },
            head: {
              $ref: "#/$defs/operation"
            },
            patch: {
              $ref: "#/$defs/operation"
            },
            trace: {
              $ref: "#/$defs/operation"
            }
          },
          $ref: "#/$defs/specification-extensions",
          unevaluatedProperties: false
        },
        "path-item-or-reference": {
          if: {
            type: "object",
            required: [
              "$ref"
            ]
          },
          then: {
            $ref: "#/$defs/reference"
          },
          else: {
            $ref: "#/$defs/path-item"
          }
        },
        operation: {
          $comment: "https://spec.openapis.org/oas/v3.1.0#operation-object",
          type: "object",
          properties: {
            tags: {
              type: "array",
              items: {
                type: "string"
              }
            },
            summary: {
              type: "string"
            },
            description: {
              type: "string"
            },
            externalDocs: {
              $ref: "#/$defs/external-documentation"
            },
            operationId: {
              type: "string"
            },
            parameters: {
              type: "array",
              items: {
                $ref: "#/$defs/parameter-or-reference"
              }
            },
            requestBody: {
              $ref: "#/$defs/request-body-or-reference"
            },
            responses: {
              $ref: "#/$defs/responses"
            },
            callbacks: {
              type: "object",
              additionalProperties: {
                $ref: "#/$defs/callbacks-or-reference"
              }
            },
            deprecated: {
              default: false,
              type: "boolean"
            },
            security: {
              type: "array",
              items: {
                $ref: "#/$defs/security-requirement"
              }
            },
            servers: {
              type: "array",
              items: {
                $ref: "#/$defs/server"
              }
            }
          },
          $ref: "#/$defs/specification-extensions",
          unevaluatedProperties: false
        },
        "external-documentation": {
          $comment: "https://spec.openapis.org/oas/v3.1.0#external-documentation-object",
          type: "object",
          properties: {
            description: {
              type: "string"
            },
            url: {
              type: "string",
              format: "uri"
            }
          },
          required: [
            "url"
          ],
          $ref: "#/$defs/specification-extensions",
          unevaluatedProperties: false
        },
        parameter: {
          $comment: "https://spec.openapis.org/oas/v3.1.0#parameter-object",
          type: "object",
          properties: {
            name: {
              type: "string"
            },
            in: {
              enum: [
                "query",
                "header",
                "path",
                "cookie"
              ]
            },
            description: {
              type: "string"
            },
            required: {
              default: false,
              type: "boolean"
            },
            deprecated: {
              default: false,
              type: "boolean"
            },
            schema: {
              $dynamicRef: "#meta"
            },
            content: {
              $ref: "#/$defs/content",
              minProperties: 1,
              maxProperties: 1
            }
          },
          required: [
            "name",
            "in"
          ],
          oneOf: [
            {
              required: [
                "schema"
              ]
            },
            {
              required: [
                "content"
              ]
            }
          ],
          if: {
            properties: {
              in: {
                const: "query"
              }
            },
            required: [
              "in"
            ]
          },
          then: {
            properties: {
              allowEmptyValue: {
                default: false,
                type: "boolean"
              }
            }
          },
          dependentSchemas: {
            schema: {
              properties: {
                style: {
                  type: "string"
                },
                explode: {
                  type: "boolean"
                }
              },
              allOf: [
                {
                  $ref: "#/$defs/examples"
                },
                {
                  $ref: "#/$defs/parameter/dependentSchemas/schema/$defs/styles-for-path"
                },
                {
                  $ref: "#/$defs/parameter/dependentSchemas/schema/$defs/styles-for-header"
                },
                {
                  $ref: "#/$defs/parameter/dependentSchemas/schema/$defs/styles-for-query"
                },
                {
                  $ref: "#/$defs/parameter/dependentSchemas/schema/$defs/styles-for-cookie"
                },
                {
                  $ref: "#/$defs/styles-for-form"
                }
              ],
              $defs: {
                "styles-for-path": {
                  if: {
                    properties: {
                      in: {
                        const: "path"
                      }
                    },
                    required: [
                      "in"
                    ]
                  },
                  then: {
                    properties: {
                      style: {
                        default: "simple",
                        enum: [
                          "matrix",
                          "label",
                          "simple"
                        ]
                      },
                      required: {
                        const: true
                      }
                    },
                    required: [
                      "required"
                    ]
                  }
                },
                "styles-for-header": {
                  if: {
                    properties: {
                      in: {
                        const: "header"
                      }
                    },
                    required: [
                      "in"
                    ]
                  },
                  then: {
                    properties: {
                      style: {
                        default: "simple",
                        const: "simple"
                      }
                    }
                  }
                },
                "styles-for-query": {
                  if: {
                    properties: {
                      in: {
                        const: "query"
                      }
                    },
                    required: [
                      "in"
                    ]
                  },
                  then: {
                    properties: {
                      style: {
                        default: "form",
                        enum: [
                          "form",
                          "spaceDelimited",
                          "pipeDelimited",
                          "deepObject"
                        ]
                      },
                      allowReserved: {
                        default: false,
                        type: "boolean"
                      }
                    }
                  }
                },
                "styles-for-cookie": {
                  if: {
                    properties: {
                      in: {
                        const: "cookie"
                      }
                    },
                    required: [
                      "in"
                    ]
                  },
                  then: {
                    properties: {
                      style: {
                        default: "form",
                        const: "form"
                      }
                    }
                  }
                }
              }
            }
          },
          $ref: "#/$defs/specification-extensions",
          unevaluatedProperties: false
        },
        "parameter-or-reference": {
          if: {
            type: "object",
            required: [
              "$ref"
            ]
          },
          then: {
            $ref: "#/$defs/reference"
          },
          else: {
            $ref: "#/$defs/parameter"
          }
        },
        "request-body": {
          $comment: "https://spec.openapis.org/oas/v3.1.0#request-body-object",
          type: "object",
          properties: {
            description: {
              type: "string"
            },
            content: {
              $ref: "#/$defs/content"
            },
            required: {
              default: false,
              type: "boolean"
            }
          },
          required: [
            "content"
          ],
          $ref: "#/$defs/specification-extensions",
          unevaluatedProperties: false
        },
        "request-body-or-reference": {
          if: {
            type: "object",
            required: [
              "$ref"
            ]
          },
          then: {
            $ref: "#/$defs/reference"
          },
          else: {
            $ref: "#/$defs/request-body"
          }
        },
        content: {
          $comment: "https://spec.openapis.org/oas/v3.1.0#fixed-fields-10",
          type: "object",
          additionalProperties: {
            $ref: "#/$defs/media-type"
          },
          propertyNames: {
            format: "media-range"
          }
        },
        "media-type": {
          $comment: "https://spec.openapis.org/oas/v3.1.0#media-type-object",
          type: "object",
          properties: {
            schema: {
              $dynamicRef: "#meta"
            },
            encoding: {
              type: "object",
              additionalProperties: {
                $ref: "#/$defs/encoding"
              }
            }
          },
          allOf: [
            {
              $ref: "#/$defs/specification-extensions"
            },
            {
              $ref: "#/$defs/examples"
            }
          ],
          unevaluatedProperties: false
        },
        encoding: {
          $comment: "https://spec.openapis.org/oas/v3.1.0#encoding-object",
          type: "object",
          properties: {
            contentType: {
              type: "string",
              format: "media-range"
            },
            headers: {
              type: "object",
              additionalProperties: {
                $ref: "#/$defs/header-or-reference"
              }
            },
            style: {
              default: "form",
              enum: [
                "form",
                "spaceDelimited",
                "pipeDelimited",
                "deepObject"
              ]
            },
            explode: {
              type: "boolean"
            },
            allowReserved: {
              default: false,
              type: "boolean"
            }
          },
          allOf: [
            {
              $ref: "#/$defs/specification-extensions"
            },
            {
              $ref: "#/$defs/styles-for-form"
            }
          ],
          unevaluatedProperties: false
        },
        responses: {
          $comment: "https://spec.openapis.org/oas/v3.1.0#responses-object",
          type: "object",
          properties: {
            default: {
              $ref: "#/$defs/response-or-reference"
            }
          },
          patternProperties: {
            "^[1-5](?:[0-9]{2}|XX)$": {
              $ref: "#/$defs/response-or-reference"
            }
          },
          minProperties: 1,
          $ref: "#/$defs/specification-extensions",
          unevaluatedProperties: false,
          if: {
            $comment: "either default, or at least one response code property must exist",
            patternProperties: {
              "^[1-5](?:[0-9]{2}|XX)$": false
            }
          },
          then: {
            required: [
              "default"
            ]
          }
        },
        response: {
          $comment: "https://spec.openapis.org/oas/v3.1.0#response-object",
          type: "object",
          properties: {
            description: {
              type: "string"
            },
            headers: {
              type: "object",
              additionalProperties: {
                $ref: "#/$defs/header-or-reference"
              }
            },
            content: {
              $ref: "#/$defs/content"
            },
            links: {
              type: "object",
              additionalProperties: {
                $ref: "#/$defs/link-or-reference"
              }
            }
          },
          required: [
            "description"
          ],
          $ref: "#/$defs/specification-extensions",
          unevaluatedProperties: false
        },
        "response-or-reference": {
          if: {
            type: "object",
            required: [
              "$ref"
            ]
          },
          then: {
            $ref: "#/$defs/reference"
          },
          else: {
            $ref: "#/$defs/response"
          }
        },
        callbacks: {
          $comment: "https://spec.openapis.org/oas/v3.1.0#callback-object",
          type: "object",
          $ref: "#/$defs/specification-extensions",
          additionalProperties: {
            $ref: "#/$defs/path-item-or-reference"
          }
        },
        "callbacks-or-reference": {
          if: {
            type: "object",
            required: [
              "$ref"
            ]
          },
          then: {
            $ref: "#/$defs/reference"
          },
          else: {
            $ref: "#/$defs/callbacks"
          }
        },
        example: {
          $comment: "https://spec.openapis.org/oas/v3.1.0#example-object",
          type: "object",
          properties: {
            summary: {
              type: "string"
            },
            description: {
              type: "string"
            },
            value: true,
            externalValue: {
              type: "string",
              format: "uri"
            }
          },
          not: {
            required: [
              "value",
              "externalValue"
            ]
          },
          $ref: "#/$defs/specification-extensions",
          unevaluatedProperties: false
        },
        "example-or-reference": {
          if: {
            type: "object",
            required: [
              "$ref"
            ]
          },
          then: {
            $ref: "#/$defs/reference"
          },
          else: {
            $ref: "#/$defs/example"
          }
        },
        link: {
          $comment: "https://spec.openapis.org/oas/v3.1.0#link-object",
          type: "object",
          properties: {
            operationRef: {
              type: "string",
              format: "uri-reference"
            },
            operationId: {
              type: "string"
            },
            parameters: {
              $ref: "#/$defs/map-of-strings"
            },
            requestBody: true,
            description: {
              type: "string"
            },
            body: {
              $ref: "#/$defs/server"
            }
          },
          oneOf: [
            {
              required: [
                "operationRef"
              ]
            },
            {
              required: [
                "operationId"
              ]
            }
          ],
          $ref: "#/$defs/specification-extensions",
          unevaluatedProperties: false
        },
        "link-or-reference": {
          if: {
            type: "object",
            required: [
              "$ref"
            ]
          },
          then: {
            $ref: "#/$defs/reference"
          },
          else: {
            $ref: "#/$defs/link"
          }
        },
        header: {
          $comment: "https://spec.openapis.org/oas/v3.1.0#header-object",
          type: "object",
          properties: {
            description: {
              type: "string"
            },
            required: {
              default: false,
              type: "boolean"
            },
            deprecated: {
              default: false,
              type: "boolean"
            },
            schema: {
              type: [
                "object",
                "boolean"
              ]
            },
            content: {
              $ref: "#/$defs/content",
              minProperties: 1,
              maxProperties: 1
            }
          },
          oneOf: [
            {
              required: [
                "schema"
              ]
            },
            {
              required: [
                "content"
              ]
            }
          ],
          dependentSchemas: {
            schema: {
              properties: {
                style: {
                  default: "simple",
                  const: "simple"
                },
                explode: {
                  default: false,
                  type: "boolean"
                }
              },
              $ref: "#/$defs/examples"
            }
          },
          $ref: "#/$defs/specification-extensions",
          unevaluatedProperties: false
        },
        "header-or-reference": {
          if: {
            type: "object",
            required: [
              "$ref"
            ]
          },
          then: {
            $ref: "#/$defs/reference"
          },
          else: {
            $ref: "#/$defs/header"
          }
        },
        tag: {
          $comment: "https://spec.openapis.org/oas/v3.1.0#tag-object",
          type: "object",
          properties: {
            name: {
              type: "string"
            },
            description: {
              type: "string"
            },
            externalDocs: {
              $ref: "#/$defs/external-documentation"
            }
          },
          required: [
            "name"
          ],
          $ref: "#/$defs/specification-extensions",
          unevaluatedProperties: false
        },
        reference: {
          $comment: "https://spec.openapis.org/oas/v3.1.0#reference-object",
          type: "object",
          properties: {
            $ref: {
              type: "string",
              format: "uri-reference"
            },
            summary: {
              type: "string"
            },
            description: {
              type: "string"
            }
          }
        },
        schema: {
          $comment: "https://spec.openapis.org/oas/v3.1.0#schema-object",
          $dynamicAnchor: "meta",
          type: [
            "object",
            "boolean"
          ]
        },
        "security-scheme": {
          $comment: "https://spec.openapis.org/oas/v3.1.0#security-scheme-object",
          type: "object",
          properties: {
            type: {
              enum: [
                "apiKey",
                "http",
                "mutualTLS",
                "oauth2",
                "openIdConnect"
              ]
            },
            description: {
              type: "string"
            }
          },
          required: [
            "type"
          ],
          allOf: [
            {
              $ref: "#/$defs/specification-extensions"
            },
            {
              $ref: "#/$defs/security-scheme/$defs/type-apikey"
            },
            {
              $ref: "#/$defs/security-scheme/$defs/type-http"
            },
            {
              $ref: "#/$defs/security-scheme/$defs/type-http-bearer"
            },
            {
              $ref: "#/$defs/security-scheme/$defs/type-oauth2"
            },
            {
              $ref: "#/$defs/security-scheme/$defs/type-oidc"
            }
          ],
          unevaluatedProperties: false,
          $defs: {
            "type-apikey": {
              if: {
                properties: {
                  type: {
                    const: "apiKey"
                  }
                },
                required: [
                  "type"
                ]
              },
              then: {
                properties: {
                  name: {
                    type: "string"
                  },
                  in: {
                    enum: [
                      "query",
                      "header",
                      "cookie"
                    ]
                  }
                },
                required: [
                  "name",
                  "in"
                ]
              }
            },
            "type-http": {
              if: {
                properties: {
                  type: {
                    const: "http"
                  }
                },
                required: [
                  "type"
                ]
              },
              then: {
                properties: {
                  scheme: {
                    type: "string"
                  }
                },
                required: [
                  "scheme"
                ]
              }
            },
            "type-http-bearer": {
              if: {
                properties: {
                  type: {
                    const: "http"
                  },
                  scheme: {
                    type: "string",
                    pattern: "^[Bb][Ee][Aa][Rr][Ee][Rr]$"
                  }
                },
                required: [
                  "type",
                  "scheme"
                ]
              },
              then: {
                properties: {
                  bearerFormat: {
                    type: "string"
                  }
                }
              }
            },
            "type-oauth2": {
              if: {
                properties: {
                  type: {
                    const: "oauth2"
                  }
                },
                required: [
                  "type"
                ]
              },
              then: {
                properties: {
                  flows: {
                    $ref: "#/$defs/oauth-flows"
                  }
                },
                required: [
                  "flows"
                ]
              }
            },
            "type-oidc": {
              if: {
                properties: {
                  type: {
                    const: "openIdConnect"
                  }
                },
                required: [
                  "type"
                ]
              },
              then: {
                properties: {
                  openIdConnectUrl: {
                    type: "string",
                    format: "uri"
                  }
                },
                required: [
                  "openIdConnectUrl"
                ]
              }
            }
          }
        },
        "security-scheme-or-reference": {
          if: {
            type: "object",
            required: [
              "$ref"
            ]
          },
          then: {
            $ref: "#/$defs/reference"
          },
          else: {
            $ref: "#/$defs/security-scheme"
          }
        },
        "oauth-flows": {
          type: "object",
          properties: {
            implicit: {
              $ref: "#/$defs/oauth-flows/$defs/implicit"
            },
            password: {
              $ref: "#/$defs/oauth-flows/$defs/password"
            },
            clientCredentials: {
              $ref: "#/$defs/oauth-flows/$defs/client-credentials"
            },
            authorizationCode: {
              $ref: "#/$defs/oauth-flows/$defs/authorization-code"
            }
          },
          $ref: "#/$defs/specification-extensions",
          unevaluatedProperties: false,
          $defs: {
            implicit: {
              type: "object",
              properties: {
                authorizationUrl: {
                  type: "string",
                  format: "uri"
                },
                refreshUrl: {
                  type: "string",
                  format: "uri"
                },
                scopes: {
                  $ref: "#/$defs/map-of-strings"
                }
              },
              required: [
                "authorizationUrl",
                "scopes"
              ],
              $ref: "#/$defs/specification-extensions",
              unevaluatedProperties: false
            },
            password: {
              type: "object",
              properties: {
                tokenUrl: {
                  type: "string",
                  format: "uri"
                },
                refreshUrl: {
                  type: "string",
                  format: "uri"
                },
                scopes: {
                  $ref: "#/$defs/map-of-strings"
                }
              },
              required: [
                "tokenUrl",
                "scopes"
              ],
              $ref: "#/$defs/specification-extensions",
              unevaluatedProperties: false
            },
            "client-credentials": {
              type: "object",
              properties: {
                tokenUrl: {
                  type: "string",
                  format: "uri"
                },
                refreshUrl: {
                  type: "string",
                  format: "uri"
                },
                scopes: {
                  $ref: "#/$defs/map-of-strings"
                }
              },
              required: [
                "tokenUrl",
                "scopes"
              ],
              $ref: "#/$defs/specification-extensions",
              unevaluatedProperties: false
            },
            "authorization-code": {
              type: "object",
              properties: {
                authorizationUrl: {
                  type: "string",
                  format: "uri"
                },
                tokenUrl: {
                  type: "string",
                  format: "uri"
                },
                refreshUrl: {
                  type: "string",
                  format: "uri"
                },
                scopes: {
                  $ref: "#/$defs/map-of-strings"
                }
              },
              required: [
                "authorizationUrl",
                "tokenUrl",
                "scopes"
              ],
              $ref: "#/$defs/specification-extensions",
              unevaluatedProperties: false
            }
          }
        },
        "security-requirement": {
          $comment: "https://spec.openapis.org/oas/v3.1.0#security-requirement-object",
          type: "object",
          additionalProperties: {
            type: "array",
            items: {
              type: "string"
            }
          }
        },
        "specification-extensions": {
          $comment: "https://spec.openapis.org/oas/v3.1.0#specification-extensions",
          patternProperties: {
            "^x-": true
          }
        },
        examples: {
          properties: {
            example: true,
            examples: {
              type: "object",
              additionalProperties: {
                $ref: "#/$defs/example-or-reference"
              }
            }
          }
        },
        "map-of-strings": {
          type: "object",
          additionalProperties: {
            type: "string"
          }
        },
        "styles-for-form": {
          if: {
            properties: {
              style: {
                const: "form"
              }
            },
            required: [
              "style"
            ]
          },
          then: {
            properties: {
              explode: {
                default: true
              }
            }
          },
          else: {
            properties: {
              explode: {
                default: false
              }
            }
          }
        }
      }
    };
    var schema_default3 = {
      $id: "https://spec.openapis.org/oas/3.1/schema/2022-10-07",
      $schema: "https://json-schema.org/draft/2020-12/schema",
      description: "The description of OpenAPI v3.1.x documents without schema validation, as defined by https://spec.openapis.org/oas/v3.1.0",
      type: "object",
      properties: {
        openapi: {
          type: "string",
          pattern: "^3\\.1\\.\\d+(-.+)?$"
        },
        info: {
          $ref: "#/$defs/info"
        },
        jsonSchemaDialect: {
          type: "string",
          format: "uri",
          default: "https://spec.openapis.org/oas/3.1/dialect/base"
        },
        servers: {
          type: "array",
          items: {
            $ref: "#/$defs/server"
          },
          default: [
            {
              url: "/"
            }
          ]
        },
        paths: {
          $ref: "#/$defs/paths"
        },
        webhooks: {
          type: "object",
          additionalProperties: {
            $ref: "#/$defs/path-item-or-reference"
          }
        },
        components: {
          $ref: "#/$defs/components"
        },
        security: {
          type: "array",
          items: {
            $ref: "#/$defs/security-requirement"
          }
        },
        tags: {
          type: "array",
          items: {
            $ref: "#/$defs/tag"
          }
        },
        externalDocs: {
          $ref: "#/$defs/external-documentation"
        }
      },
      required: [
        "openapi",
        "info"
      ],
      anyOf: [
        {
          required: [
            "paths"
          ]
        },
        {
          required: [
            "components"
          ]
        },
        {
          required: [
            "webhooks"
          ]
        }
      ],
      $ref: "#/$defs/specification-extensions",
      unevaluatedProperties: false,
      $defs: {
        info: {
          $comment: "https://spec.openapis.org/oas/v3.1.0#info-object",
          type: "object",
          properties: {
            title: {
              type: "string"
            },
            summary: {
              type: "string"
            },
            description: {
              type: "string"
            },
            termsOfService: {
              type: "string",
              format: "uri"
            },
            contact: {
              $ref: "#/$defs/contact"
            },
            license: {
              $ref: "#/$defs/license"
            },
            version: {
              type: "string"
            }
          },
          required: [
            "title",
            "version"
          ],
          $ref: "#/$defs/specification-extensions",
          unevaluatedProperties: false
        },
        contact: {
          $comment: "https://spec.openapis.org/oas/v3.1.0#contact-object",
          type: "object",
          properties: {
            name: {
              type: "string"
            },
            url: {
              type: "string",
              format: "uri"
            },
            email: {
              type: "string",
              format: "email"
            }
          },
          $ref: "#/$defs/specification-extensions",
          unevaluatedProperties: false
        },
        license: {
          $comment: "https://spec.openapis.org/oas/v3.1.0#license-object",
          type: "object",
          properties: {
            name: {
              type: "string"
            },
            identifier: {
              type: "string"
            },
            url: {
              type: "string",
              format: "uri"
            }
          },
          required: [
            "name"
          ],
          dependentSchemas: {
            identifier: {
              not: {
                required: [
                  "url"
                ]
              }
            }
          },
          $ref: "#/$defs/specification-extensions",
          unevaluatedProperties: false
        },
        server: {
          $comment: "https://spec.openapis.org/oas/v3.1.0#server-object",
          type: "object",
          properties: {
            url: {
              type: "string",
              format: "uri-reference"
            },
            description: {
              type: "string"
            },
            variables: {
              type: "object",
              additionalProperties: {
                $ref: "#/$defs/server-variable"
              }
            }
          },
          required: [
            "url"
          ],
          $ref: "#/$defs/specification-extensions",
          unevaluatedProperties: false
        },
        "server-variable": {
          $comment: "https://spec.openapis.org/oas/v3.1.0#server-variable-object",
          type: "object",
          properties: {
            enum: {
              type: "array",
              items: {
                type: "string"
              },
              minItems: 1
            },
            default: {
              type: "string"
            },
            description: {
              type: "string"
            }
          },
          required: [
            "default"
          ],
          $ref: "#/$defs/specification-extensions",
          unevaluatedProperties: false
        },
        components: {
          $comment: "https://spec.openapis.org/oas/v3.1.0#components-object",
          type: "object",
          properties: {
            schemas: {
              type: "object",
              additionalProperties: {
                $dynamicRef: "#meta"
              }
            },
            responses: {
              type: "object",
              additionalProperties: {
                $ref: "#/$defs/response-or-reference"
              }
            },
            parameters: {
              type: "object",
              additionalProperties: {
                $ref: "#/$defs/parameter-or-reference"
              }
            },
            examples: {
              type: "object",
              additionalProperties: {
                $ref: "#/$defs/example-or-reference"
              }
            },
            requestBodies: {
              type: "object",
              additionalProperties: {
                $ref: "#/$defs/request-body-or-reference"
              }
            },
            headers: {
              type: "object",
              additionalProperties: {
                $ref: "#/$defs/header-or-reference"
              }
            },
            securitySchemes: {
              type: "object",
              additionalProperties: {
                $ref: "#/$defs/security-scheme-or-reference"
              }
            },
            links: {
              type: "object",
              additionalProperties: {
                $ref: "#/$defs/link-or-reference"
              }
            },
            callbacks: {
              type: "object",
              additionalProperties: {
                $ref: "#/$defs/callbacks-or-reference"
              }
            },
            pathItems: {
              type: "object",
              additionalProperties: {
                $ref: "#/$defs/path-item-or-reference"
              }
            }
          },
          patternProperties: {
            "^(schemas|responses|parameters|examples|requestBodies|headers|securitySchemes|links|callbacks|pathItems)$": {
              $comment: "Enumerating all of the property names in the regex above is necessary for unevaluatedProperties to work as expected",
              propertyNames: {
                pattern: "^[a-zA-Z0-9._-]+$"
              }
            }
          },
          $ref: "#/$defs/specification-extensions",
          unevaluatedProperties: false
        },
        paths: {
          $comment: "https://spec.openapis.org/oas/v3.1.0#paths-object",
          type: "object",
          patternProperties: {
            "^/": {
              $ref: "#/$defs/path-item"
            }
          },
          $ref: "#/$defs/specification-extensions",
          unevaluatedProperties: false
        },
        "path-item": {
          $comment: "https://spec.openapis.org/oas/v3.1.0#path-item-object",
          type: "object",
          properties: {
            summary: {
              type: "string"
            },
            description: {
              type: "string"
            },
            servers: {
              type: "array",
              items: {
                $ref: "#/$defs/server"
              }
            },
            parameters: {
              type: "array",
              items: {
                $ref: "#/$defs/parameter-or-reference"
              }
            },
            get: {
              $ref: "#/$defs/operation"
            },
            put: {
              $ref: "#/$defs/operation"
            },
            post: {
              $ref: "#/$defs/operation"
            },
            delete: {
              $ref: "#/$defs/operation"
            },
            options: {
              $ref: "#/$defs/operation"
            },
            head: {
              $ref: "#/$defs/operation"
            },
            patch: {
              $ref: "#/$defs/operation"
            },
            trace: {
              $ref: "#/$defs/operation"
            }
          },
          $ref: "#/$defs/specification-extensions",
          unevaluatedProperties: false
        },
        "path-item-or-reference": {
          if: {
            type: "object",
            required: [
              "$ref"
            ]
          },
          then: {
            $ref: "#/$defs/reference"
          },
          else: {
            $ref: "#/$defs/path-item"
          }
        },
        operation: {
          $comment: "https://spec.openapis.org/oas/v3.1.0#operation-object",
          type: "object",
          properties: {
            tags: {
              type: "array",
              items: {
                type: "string"
              }
            },
            summary: {
              type: "string"
            },
            description: {
              type: "string"
            },
            externalDocs: {
              $ref: "#/$defs/external-documentation"
            },
            operationId: {
              type: "string"
            },
            parameters: {
              type: "array",
              items: {
                $ref: "#/$defs/parameter-or-reference"
              }
            },
            requestBody: {
              $ref: "#/$defs/request-body-or-reference"
            },
            responses: {
              $ref: "#/$defs/responses"
            },
            callbacks: {
              type: "object",
              additionalProperties: {
                $ref: "#/$defs/callbacks-or-reference"
              }
            },
            deprecated: {
              default: false,
              type: "boolean"
            },
            security: {
              type: "array",
              items: {
                $ref: "#/$defs/security-requirement"
              }
            },
            servers: {
              type: "array",
              items: {
                $ref: "#/$defs/server"
              }
            }
          },
          $ref: "#/$defs/specification-extensions",
          unevaluatedProperties: false
        },
        "external-documentation": {
          $comment: "https://spec.openapis.org/oas/v3.1.0#external-documentation-object",
          type: "object",
          properties: {
            description: {
              type: "string"
            },
            url: {
              type: "string",
              format: "uri"
            }
          },
          required: [
            "url"
          ],
          $ref: "#/$defs/specification-extensions",
          unevaluatedProperties: false
        },
        parameter: {
          $comment: "https://spec.openapis.org/oas/v3.1.0#parameter-object",
          type: "object",
          properties: {
            name: {
              type: "string"
            },
            in: {
              enum: [
                "query",
                "header",
                "path",
                "cookie"
              ]
            },
            description: {
              type: "string"
            },
            required: {
              default: false,
              type: "boolean"
            },
            deprecated: {
              default: false,
              type: "boolean"
            },
            schema: {
              $dynamicRef: "#meta"
            },
            content: {
              $ref: "#/$defs/content",
              minProperties: 1,
              maxProperties: 1
            }
          },
          required: [
            "name",
            "in"
          ],
          oneOf: [
            {
              required: [
                "schema"
              ]
            },
            {
              required: [
                "content"
              ]
            }
          ],
          if: {
            properties: {
              in: {
                const: "query"
              }
            },
            required: [
              "in"
            ]
          },
          then: {
            properties: {
              allowEmptyValue: {
                default: false,
                type: "boolean"
              }
            }
          },
          dependentSchemas: {
            schema: {
              properties: {
                style: {
                  type: "string"
                },
                explode: {
                  type: "boolean"
                }
              },
              allOf: [
                {
                  $ref: "#/$defs/examples"
                },
                {
                  $ref: "#/$defs/parameter/dependentSchemas/schema/$defs/styles-for-path"
                },
                {
                  $ref: "#/$defs/parameter/dependentSchemas/schema/$defs/styles-for-header"
                },
                {
                  $ref: "#/$defs/parameter/dependentSchemas/schema/$defs/styles-for-query"
                },
                {
                  $ref: "#/$defs/parameter/dependentSchemas/schema/$defs/styles-for-cookie"
                },
                {
                  $ref: "#/$defs/styles-for-form"
                }
              ],
              $defs: {
                "styles-for-path": {
                  if: {
                    properties: {
                      in: {
                        const: "path"
                      }
                    },
                    required: [
                      "in"
                    ]
                  },
                  then: {
                    properties: {
                      style: {
                        default: "simple",
                        enum: [
                          "matrix",
                          "label",
                          "simple"
                        ]
                      },
                      required: {
                        const: true
                      }
                    },
                    required: [
                      "required"
                    ]
                  }
                },
                "styles-for-header": {
                  if: {
                    properties: {
                      in: {
                        const: "header"
                      }
                    },
                    required: [
                      "in"
                    ]
                  },
                  then: {
                    properties: {
                      style: {
                        default: "simple",
                        const: "simple"
                      }
                    }
                  }
                },
                "styles-for-query": {
                  if: {
                    properties: {
                      in: {
                        const: "query"
                      }
                    },
                    required: [
                      "in"
                    ]
                  },
                  then: {
                    properties: {
                      style: {
                        default: "form",
                        enum: [
                          "form",
                          "spaceDelimited",
                          "pipeDelimited",
                          "deepObject"
                        ]
                      },
                      allowReserved: {
                        default: false,
                        type: "boolean"
                      }
                    }
                  }
                },
                "styles-for-cookie": {
                  if: {
                    properties: {
                      in: {
                        const: "cookie"
                      }
                    },
                    required: [
                      "in"
                    ]
                  },
                  then: {
                    properties: {
                      style: {
                        default: "form",
                        const: "form"
                      }
                    }
                  }
                }
              }
            }
          },
          $ref: "#/$defs/specification-extensions",
          unevaluatedProperties: false
        },
        "parameter-or-reference": {
          if: {
            type: "object",
            required: [
              "$ref"
            ]
          },
          then: {
            $ref: "#/$defs/reference"
          },
          else: {
            $ref: "#/$defs/parameter"
          }
        },
        "request-body": {
          $comment: "https://spec.openapis.org/oas/v3.1.0#request-body-object",
          type: "object",
          properties: {
            description: {
              type: "string"
            },
            content: {
              $ref: "#/$defs/content"
            },
            required: {
              default: false,
              type: "boolean"
            }
          },
          required: [
            "content"
          ],
          $ref: "#/$defs/specification-extensions",
          unevaluatedProperties: false
        },
        "request-body-or-reference": {
          if: {
            type: "object",
            required: [
              "$ref"
            ]
          },
          then: {
            $ref: "#/$defs/reference"
          },
          else: {
            $ref: "#/$defs/request-body"
          }
        },
        content: {
          $comment: "https://spec.openapis.org/oas/v3.1.0#fixed-fields-10",
          type: "object",
          additionalProperties: {
            $ref: "#/$defs/media-type"
          },
          propertyNames: {
            format: "media-range"
          }
        },
        "media-type": {
          $comment: "https://spec.openapis.org/oas/v3.1.0#media-type-object",
          type: "object",
          properties: {
            schema: {
              $dynamicRef: "#meta"
            },
            encoding: {
              type: "object",
              additionalProperties: {
                $ref: "#/$defs/encoding"
              }
            }
          },
          allOf: [
            {
              $ref: "#/$defs/specification-extensions"
            },
            {
              $ref: "#/$defs/examples"
            }
          ],
          unevaluatedProperties: false
        },
        encoding: {
          $comment: "https://spec.openapis.org/oas/v3.1.0#encoding-object",
          type: "object",
          properties: {
            contentType: {
              type: "string",
              format: "media-range"
            },
            headers: {
              type: "object",
              additionalProperties: {
                $ref: "#/$defs/header-or-reference"
              }
            },
            style: {
              default: "form",
              enum: [
                "form",
                "spaceDelimited",
                "pipeDelimited",
                "deepObject"
              ]
            },
            explode: {
              type: "boolean"
            },
            allowReserved: {
              default: false,
              type: "boolean"
            }
          },
          allOf: [
            {
              $ref: "#/$defs/specification-extensions"
            },
            {
              $ref: "#/$defs/styles-for-form"
            }
          ],
          unevaluatedProperties: false
        },
        responses: {
          $comment: "https://spec.openapis.org/oas/v3.1.0#responses-object",
          type: "object",
          properties: {
            default: {
              $ref: "#/$defs/response-or-reference"
            }
          },
          patternProperties: {
            "^[1-5](?:[0-9]{2}|XX)$": {
              $ref: "#/$defs/response-or-reference"
            }
          },
          minProperties: 1,
          $ref: "#/$defs/specification-extensions",
          unevaluatedProperties: false,
          if: {
            $comment: "either default, or at least one response code property must exist",
            patternProperties: {
              "^[1-5](?:[0-9]{2}|XX)$": false
            }
          },
          then: {
            required: ["default"]
          }
        },
        response: {
          $comment: "https://spec.openapis.org/oas/v3.1.0#response-object",
          type: "object",
          properties: {
            description: {
              type: "string"
            },
            headers: {
              type: "object",
              additionalProperties: {
                $ref: "#/$defs/header-or-reference"
              }
            },
            content: {
              $ref: "#/$defs/content"
            },
            links: {
              type: "object",
              additionalProperties: {
                $ref: "#/$defs/link-or-reference"
              }
            }
          },
          required: [
            "description"
          ],
          $ref: "#/$defs/specification-extensions",
          unevaluatedProperties: false
        },
        "response-or-reference": {
          if: {
            type: "object",
            required: [
              "$ref"
            ]
          },
          then: {
            $ref: "#/$defs/reference"
          },
          else: {
            $ref: "#/$defs/response"
          }
        },
        callbacks: {
          $comment: "https://spec.openapis.org/oas/v3.1.0#callback-object",
          type: "object",
          $ref: "#/$defs/specification-extensions",
          additionalProperties: {
            $ref: "#/$defs/path-item-or-reference"
          }
        },
        "callbacks-or-reference": {
          if: {
            type: "object",
            required: [
              "$ref"
            ]
          },
          then: {
            $ref: "#/$defs/reference"
          },
          else: {
            $ref: "#/$defs/callbacks"
          }
        },
        example: {
          $comment: "https://spec.openapis.org/oas/v3.1.0#example-object",
          type: "object",
          properties: {
            summary: {
              type: "string"
            },
            description: {
              type: "string"
            },
            value: true,
            externalValue: {
              type: "string",
              format: "uri"
            }
          },
          not: {
            required: [
              "value",
              "externalValue"
            ]
          },
          $ref: "#/$defs/specification-extensions",
          unevaluatedProperties: false
        },
        "example-or-reference": {
          if: {
            type: "object",
            required: [
              "$ref"
            ]
          },
          then: {
            $ref: "#/$defs/reference"
          },
          else: {
            $ref: "#/$defs/example"
          }
        },
        link: {
          $comment: "https://spec.openapis.org/oas/v3.1.0#link-object",
          type: "object",
          properties: {
            operationRef: {
              type: "string",
              format: "uri-reference"
            },
            operationId: {
              type: "string"
            },
            parameters: {
              $ref: "#/$defs/map-of-strings"
            },
            requestBody: true,
            description: {
              type: "string"
            },
            body: {
              $ref: "#/$defs/server"
            }
          },
          oneOf: [
            {
              required: [
                "operationRef"
              ]
            },
            {
              required: [
                "operationId"
              ]
            }
          ],
          $ref: "#/$defs/specification-extensions",
          unevaluatedProperties: false
        },
        "link-or-reference": {
          if: {
            type: "object",
            required: [
              "$ref"
            ]
          },
          then: {
            $ref: "#/$defs/reference"
          },
          else: {
            $ref: "#/$defs/link"
          }
        },
        header: {
          $comment: "https://spec.openapis.org/oas/v3.1.0#header-object",
          type: "object",
          properties: {
            description: {
              type: "string"
            },
            required: {
              default: false,
              type: "boolean"
            },
            deprecated: {
              default: false,
              type: "boolean"
            },
            schema: {
              $dynamicRef: "#meta"
            },
            content: {
              $ref: "#/$defs/content",
              minProperties: 1,
              maxProperties: 1
            }
          },
          oneOf: [
            {
              required: [
                "schema"
              ]
            },
            {
              required: [
                "content"
              ]
            }
          ],
          dependentSchemas: {
            schema: {
              properties: {
                style: {
                  default: "simple",
                  const: "simple"
                },
                explode: {
                  default: false,
                  type: "boolean"
                }
              },
              $ref: "#/$defs/examples"
            }
          },
          $ref: "#/$defs/specification-extensions",
          unevaluatedProperties: false
        },
        "header-or-reference": {
          if: {
            type: "object",
            required: [
              "$ref"
            ]
          },
          then: {
            $ref: "#/$defs/reference"
          },
          else: {
            $ref: "#/$defs/header"
          }
        },
        tag: {
          $comment: "https://spec.openapis.org/oas/v3.1.0#tag-object",
          type: "object",
          properties: {
            name: {
              type: "string"
            },
            description: {
              type: "string"
            },
            externalDocs: {
              $ref: "#/$defs/external-documentation"
            }
          },
          required: [
            "name"
          ],
          $ref: "#/$defs/specification-extensions",
          unevaluatedProperties: false
        },
        reference: {
          $comment: "https://spec.openapis.org/oas/v3.1.0#reference-object",
          type: "object",
          properties: {
            $ref: {
              type: "string",
              format: "uri-reference"
            },
            summary: {
              type: "string"
            },
            description: {
              type: "string"
            }
          }
        },
        schema: {
          $comment: "https://spec.openapis.org/oas/v3.1.0#schema-object",
          $dynamicAnchor: "meta",
          type: [
            "object",
            "boolean"
          ]
        },
        "security-scheme": {
          $comment: "https://spec.openapis.org/oas/v3.1.0#security-scheme-object",
          type: "object",
          properties: {
            type: {
              enum: [
                "apiKey",
                "http",
                "mutualTLS",
                "oauth2",
                "openIdConnect"
              ]
            },
            description: {
              type: "string"
            }
          },
          required: [
            "type"
          ],
          allOf: [
            {
              $ref: "#/$defs/specification-extensions"
            },
            {
              $ref: "#/$defs/security-scheme/$defs/type-apikey"
            },
            {
              $ref: "#/$defs/security-scheme/$defs/type-http"
            },
            {
              $ref: "#/$defs/security-scheme/$defs/type-http-bearer"
            },
            {
              $ref: "#/$defs/security-scheme/$defs/type-oauth2"
            },
            {
              $ref: "#/$defs/security-scheme/$defs/type-oidc"
            }
          ],
          unevaluatedProperties: false,
          $defs: {
            "type-apikey": {
              if: {
                properties: {
                  type: {
                    const: "apiKey"
                  }
                },
                required: [
                  "type"
                ]
              },
              then: {
                properties: {
                  name: {
                    type: "string"
                  },
                  in: {
                    enum: [
                      "query",
                      "header",
                      "cookie"
                    ]
                  }
                },
                required: [
                  "name",
                  "in"
                ]
              }
            },
            "type-http": {
              if: {
                properties: {
                  type: {
                    const: "http"
                  }
                },
                required: [
                  "type"
                ]
              },
              then: {
                properties: {
                  scheme: {
                    type: "string"
                  }
                },
                required: [
                  "scheme"
                ]
              }
            },
            "type-http-bearer": {
              if: {
                properties: {
                  type: {
                    const: "http"
                  },
                  scheme: {
                    type: "string",
                    pattern: "^[Bb][Ee][Aa][Rr][Ee][Rr]$"
                  }
                },
                required: [
                  "type",
                  "scheme"
                ]
              },
              then: {
                properties: {
                  bearerFormat: {
                    type: "string"
                  }
                }
              }
            },
            "type-oauth2": {
              if: {
                properties: {
                  type: {
                    const: "oauth2"
                  }
                },
                required: [
                  "type"
                ]
              },
              then: {
                properties: {
                  flows: {
                    $ref: "#/$defs/oauth-flows"
                  }
                },
                required: [
                  "flows"
                ]
              }
            },
            "type-oidc": {
              if: {
                properties: {
                  type: {
                    const: "openIdConnect"
                  }
                },
                required: [
                  "type"
                ]
              },
              then: {
                properties: {
                  openIdConnectUrl: {
                    type: "string",
                    format: "uri"
                  }
                },
                required: [
                  "openIdConnectUrl"
                ]
              }
            }
          }
        },
        "security-scheme-or-reference": {
          if: {
            type: "object",
            required: [
              "$ref"
            ]
          },
          then: {
            $ref: "#/$defs/reference"
          },
          else: {
            $ref: "#/$defs/security-scheme"
          }
        },
        "oauth-flows": {
          type: "object",
          properties: {
            implicit: {
              $ref: "#/$defs/oauth-flows/$defs/implicit"
            },
            password: {
              $ref: "#/$defs/oauth-flows/$defs/password"
            },
            clientCredentials: {
              $ref: "#/$defs/oauth-flows/$defs/client-credentials"
            },
            authorizationCode: {
              $ref: "#/$defs/oauth-flows/$defs/authorization-code"
            }
          },
          $ref: "#/$defs/specification-extensions",
          unevaluatedProperties: false,
          $defs: {
            implicit: {
              type: "object",
              properties: {
                authorizationUrl: {
                  type: "string",
                  format: "uri"
                },
                refreshUrl: {
                  type: "string",
                  format: "uri"
                },
                scopes: {
                  $ref: "#/$defs/map-of-strings"
                }
              },
              required: [
                "authorizationUrl",
                "scopes"
              ],
              $ref: "#/$defs/specification-extensions",
              unevaluatedProperties: false
            },
            password: {
              type: "object",
              properties: {
                tokenUrl: {
                  type: "string",
                  format: "uri"
                },
                refreshUrl: {
                  type: "string",
                  format: "uri"
                },
                scopes: {
                  $ref: "#/$defs/map-of-strings"
                }
              },
              required: [
                "tokenUrl",
                "scopes"
              ],
              $ref: "#/$defs/specification-extensions",
              unevaluatedProperties: false
            },
            "client-credentials": {
              type: "object",
              properties: {
                tokenUrl: {
                  type: "string",
                  format: "uri"
                },
                refreshUrl: {
                  type: "string",
                  format: "uri"
                },
                scopes: {
                  $ref: "#/$defs/map-of-strings"
                }
              },
              required: [
                "tokenUrl",
                "scopes"
              ],
              $ref: "#/$defs/specification-extensions",
              unevaluatedProperties: false
            },
            "authorization-code": {
              type: "object",
              properties: {
                authorizationUrl: {
                  type: "string",
                  format: "uri"
                },
                tokenUrl: {
                  type: "string",
                  format: "uri"
                },
                refreshUrl: {
                  type: "string",
                  format: "uri"
                },
                scopes: {
                  $ref: "#/$defs/map-of-strings"
                }
              },
              required: [
                "authorizationUrl",
                "tokenUrl",
                "scopes"
              ],
              $ref: "#/$defs/specification-extensions",
              unevaluatedProperties: false
            }
          }
        },
        "security-requirement": {
          $comment: "https://spec.openapis.org/oas/v3.1.0#security-requirement-object",
          type: "object",
          additionalProperties: {
            type: "array",
            items: {
              type: "string"
            }
          }
        },
        "specification-extensions": {
          $comment: "https://spec.openapis.org/oas/v3.1.0#specification-extensions",
          patternProperties: {
            "^x-": true
          }
        },
        examples: {
          properties: {
            example: true,
            examples: {
              type: "object",
              additionalProperties: {
                $ref: "#/$defs/example-or-reference"
              }
            }
          }
        },
        "map-of-strings": {
          type: "object",
          additionalProperties: {
            type: "string"
          }
        },
        "styles-for-form": {
          if: {
            properties: {
              style: {
                const: "form"
              }
            },
            required: [
              "style"
            ]
          },
          then: {
            properties: {
              explode: {
                default: true
              }
            }
          },
          else: {
            properties: {
              explode: {
                default: false
              }
            }
          }
        }
      }
    };
    var openapi = {
      v1: apiDeclaration_default,
      v2: schema_default,
      v3: schema_default2,
      v31: schema_default3,
      v31legacy: legacy_schema_default
    };
    exports2.openapi = openapi;
  }
});

// node_modules/ajv/dist/compile/codegen/code.js
var require_code = __commonJS({
  "node_modules/ajv/dist/compile/codegen/code.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.regexpCode = exports2.getEsmExportName = exports2.getProperty = exports2.safeStringify = exports2.stringify = exports2.strConcat = exports2.addCodeArg = exports2.str = exports2._ = exports2.nil = exports2._Code = exports2.Name = exports2.IDENTIFIER = exports2._CodeOrName = void 0;
    var _CodeOrName = class {
    };
    exports2._CodeOrName = _CodeOrName;
    exports2.IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i;
    var Name = class extends _CodeOrName {
      constructor(s) {
        super();
        if (!exports2.IDENTIFIER.test(s))
          throw new Error("CodeGen: name must be a valid identifier");
        this.str = s;
      }
      toString() {
        return this.str;
      }
      emptyStr() {
        return false;
      }
      get names() {
        return { [this.str]: 1 };
      }
    };
    exports2.Name = Name;
    var _Code = class extends _CodeOrName {
      constructor(code) {
        super();
        this._items = typeof code === "string" ? [code] : code;
      }
      toString() {
        return this.str;
      }
      emptyStr() {
        if (this._items.length > 1)
          return false;
        const item = this._items[0];
        return item === "" || item === '""';
      }
      get str() {
        var _a;
        return (_a = this._str) !== null && _a !== void 0 ? _a : this._str = this._items.reduce((s, c2) => `${s}${c2}`, "");
      }
      get names() {
        var _a;
        return (_a = this._names) !== null && _a !== void 0 ? _a : this._names = this._items.reduce((names, c2) => {
          if (c2 instanceof Name)
            names[c2.str] = (names[c2.str] || 0) + 1;
          return names;
        }, {});
      }
    };
    exports2._Code = _Code;
    exports2.nil = new _Code("");
    function _(strs, ...args) {
      const code = [strs[0]];
      let i = 0;
      while (i < args.length) {
        addCodeArg(code, args[i]);
        code.push(strs[++i]);
      }
      return new _Code(code);
    }
    exports2._ = _;
    var plus = new _Code("+");
    function str2(strs, ...args) {
      const expr = [safeStringify(strs[0])];
      let i = 0;
      while (i < args.length) {
        expr.push(plus);
        addCodeArg(expr, args[i]);
        expr.push(plus, safeStringify(strs[++i]));
      }
      optimize(expr);
      return new _Code(expr);
    }
    exports2.str = str2;
    function addCodeArg(code, arg) {
      if (arg instanceof _Code)
        code.push(...arg._items);
      else if (arg instanceof Name)
        code.push(arg);
      else
        code.push(interpolate(arg));
    }
    exports2.addCodeArg = addCodeArg;
    function optimize(expr) {
      let i = 1;
      while (i < expr.length - 1) {
        if (expr[i] === plus) {
          const res = mergeExprItems(expr[i - 1], expr[i + 1]);
          if (res !== void 0) {
            expr.splice(i - 1, 3, res);
            continue;
          }
          expr[i++] = "+";
        }
        i++;
      }
    }
    function mergeExprItems(a, b) {
      if (b === '""')
        return a;
      if (a === '""')
        return b;
      if (typeof a == "string") {
        if (b instanceof Name || a[a.length - 1] !== '"')
          return;
        if (typeof b != "string")
          return `${a.slice(0, -1)}${b}"`;
        if (b[0] === '"')
          return a.slice(0, -1) + b.slice(1);
        return;
      }
      if (typeof b == "string" && b[0] === '"' && !(a instanceof Name))
        return `"${a}${b.slice(1)}`;
      return;
    }
    function strConcat(c1, c2) {
      return c2.emptyStr() ? c1 : c1.emptyStr() ? c2 : str2`${c1}${c2}`;
    }
    exports2.strConcat = strConcat;
    function interpolate(x) {
      return typeof x == "number" || typeof x == "boolean" || x === null ? x : safeStringify(Array.isArray(x) ? x.join(",") : x);
    }
    function stringify3(x) {
      return new _Code(safeStringify(x));
    }
    exports2.stringify = stringify3;
    function safeStringify(x) {
      return JSON.stringify(x).replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029");
    }
    exports2.safeStringify = safeStringify;
    function getProperty(key) {
      return typeof key == "string" && exports2.IDENTIFIER.test(key) ? new _Code(`.${key}`) : _`[${key}]`;
    }
    exports2.getProperty = getProperty;
    function getEsmExportName(key) {
      if (typeof key == "string" && exports2.IDENTIFIER.test(key)) {
        return new _Code(`${key}`);
      }
      throw new Error(`CodeGen: invalid export name: ${key}, use explicit $id name mapping`);
    }
    exports2.getEsmExportName = getEsmExportName;
    function regexpCode(rx) {
      return new _Code(rx.toString());
    }
    exports2.regexpCode = regexpCode;
  }
});

// node_modules/ajv/dist/compile/codegen/scope.js
var require_scope = __commonJS({
  "node_modules/ajv/dist/compile/codegen/scope.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ValueScope = exports2.ValueScopeName = exports2.Scope = exports2.varKinds = exports2.UsedValueState = void 0;
    var code_1 = require_code();
    var ValueError = class extends Error {
      constructor(name) {
        super(`CodeGen: "code" for ${name} not defined`);
        this.value = name.value;
      }
    };
    var UsedValueState;
    (function(UsedValueState2) {
      UsedValueState2[UsedValueState2["Started"] = 0] = "Started";
      UsedValueState2[UsedValueState2["Completed"] = 1] = "Completed";
    })(UsedValueState || (exports2.UsedValueState = UsedValueState = {}));
    exports2.varKinds = {
      const: new code_1.Name("const"),
      let: new code_1.Name("let"),
      var: new code_1.Name("var")
    };
    var Scope = class {
      constructor({ prefixes, parent } = {}) {
        this._names = {};
        this._prefixes = prefixes;
        this._parent = parent;
      }
      toName(nameOrPrefix) {
        return nameOrPrefix instanceof code_1.Name ? nameOrPrefix : this.name(nameOrPrefix);
      }
      name(prefix) {
        return new code_1.Name(this._newName(prefix));
      }
      _newName(prefix) {
        const ng = this._names[prefix] || this._nameGroup(prefix);
        return `${prefix}${ng.index++}`;
      }
      _nameGroup(prefix) {
        var _a, _b;
        if (((_b = (_a = this._parent) === null || _a === void 0 ? void 0 : _a._prefixes) === null || _b === void 0 ? void 0 : _b.has(prefix)) || this._prefixes && !this._prefixes.has(prefix)) {
          throw new Error(`CodeGen: prefix "${prefix}" is not allowed in this scope`);
        }
        return this._names[prefix] = { prefix, index: 0 };
      }
    };
    exports2.Scope = Scope;
    var ValueScopeName = class extends code_1.Name {
      constructor(prefix, nameStr) {
        super(nameStr);
        this.prefix = prefix;
      }
      setValue(value, { property, itemIndex }) {
        this.value = value;
        this.scopePath = (0, code_1._)`.${new code_1.Name(property)}[${itemIndex}]`;
      }
    };
    exports2.ValueScopeName = ValueScopeName;
    var line = (0, code_1._)`\n`;
    var ValueScope = class extends Scope {
      constructor(opts) {
        super(opts);
        this._values = {};
        this._scope = opts.scope;
        this.opts = { ...opts, _n: opts.lines ? line : code_1.nil };
      }
      get() {
        return this._scope;
      }
      name(prefix) {
        return new ValueScopeName(prefix, this._newName(prefix));
      }
      value(nameOrPrefix, value) {
        var _a;
        if (value.ref === void 0)
          throw new Error("CodeGen: ref must be passed in value");
        const name = this.toName(nameOrPrefix);
        const { prefix } = name;
        const valueKey = (_a = value.key) !== null && _a !== void 0 ? _a : value.ref;
        let vs = this._values[prefix];
        if (vs) {
          const _name = vs.get(valueKey);
          if (_name)
            return _name;
        } else {
          vs = this._values[prefix] = /* @__PURE__ */ new Map();
        }
        vs.set(valueKey, name);
        const s = this._scope[prefix] || (this._scope[prefix] = []);
        const itemIndex = s.length;
        s[itemIndex] = value.ref;
        name.setValue(value, { property: prefix, itemIndex });
        return name;
      }
      getValue(prefix, keyOrRef) {
        const vs = this._values[prefix];
        if (!vs)
          return;
        return vs.get(keyOrRef);
      }
      scopeRefs(scopeName, values = this._values) {
        return this._reduceValues(values, (name) => {
          if (name.scopePath === void 0)
            throw new Error(`CodeGen: name "${name}" has no value`);
          return (0, code_1._)`${scopeName}${name.scopePath}`;
        });
      }
      scopeCode(values = this._values, usedValues, getCode) {
        return this._reduceValues(values, (name) => {
          if (name.value === void 0)
            throw new Error(`CodeGen: name "${name}" has no value`);
          return name.value.code;
        }, usedValues, getCode);
      }
      _reduceValues(values, valueCode, usedValues = {}, getCode) {
        let code = code_1.nil;
        for (const prefix in values) {
          const vs = values[prefix];
          if (!vs)
            continue;
          const nameSet = usedValues[prefix] = usedValues[prefix] || /* @__PURE__ */ new Map();
          vs.forEach((name) => {
            if (nameSet.has(name))
              return;
            nameSet.set(name, UsedValueState.Started);
            let c2 = valueCode(name);
            if (c2) {
              const def = this.opts.es5 ? exports2.varKinds.var : exports2.varKinds.const;
              code = (0, code_1._)`${code}${def} ${name} = ${c2};${this.opts._n}`;
            } else if (c2 = getCode === null || getCode === void 0 ? void 0 : getCode(name)) {
              code = (0, code_1._)`${code}${c2}${this.opts._n}`;
            } else {
              throw new ValueError(name);
            }
            nameSet.set(name, UsedValueState.Completed);
          });
        }
        return code;
      }
    };
    exports2.ValueScope = ValueScope;
  }
});

// node_modules/ajv/dist/compile/codegen/index.js
var require_codegen = __commonJS({
  "node_modules/ajv/dist/compile/codegen/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.or = exports2.and = exports2.not = exports2.CodeGen = exports2.operators = exports2.varKinds = exports2.ValueScopeName = exports2.ValueScope = exports2.Scope = exports2.Name = exports2.regexpCode = exports2.stringify = exports2.getProperty = exports2.nil = exports2.strConcat = exports2.str = exports2._ = void 0;
    var code_1 = require_code();
    var scope_1 = require_scope();
    var code_2 = require_code();
    Object.defineProperty(exports2, "_", { enumerable: true, get: function() {
      return code_2._;
    } });
    Object.defineProperty(exports2, "str", { enumerable: true, get: function() {
      return code_2.str;
    } });
    Object.defineProperty(exports2, "strConcat", { enumerable: true, get: function() {
      return code_2.strConcat;
    } });
    Object.defineProperty(exports2, "nil", { enumerable: true, get: function() {
      return code_2.nil;
    } });
    Object.defineProperty(exports2, "getProperty", { enumerable: true, get: function() {
      return code_2.getProperty;
    } });
    Object.defineProperty(exports2, "stringify", { enumerable: true, get: function() {
      return code_2.stringify;
    } });
    Object.defineProperty(exports2, "regexpCode", { enumerable: true, get: function() {
      return code_2.regexpCode;
    } });
    Object.defineProperty(exports2, "Name", { enumerable: true, get: function() {
      return code_2.Name;
    } });
    var scope_2 = require_scope();
    Object.defineProperty(exports2, "Scope", { enumerable: true, get: function() {
      return scope_2.Scope;
    } });
    Object.defineProperty(exports2, "ValueScope", { enumerable: true, get: function() {
      return scope_2.ValueScope;
    } });
    Object.defineProperty(exports2, "ValueScopeName", { enumerable: true, get: function() {
      return scope_2.ValueScopeName;
    } });
    Object.defineProperty(exports2, "varKinds", { enumerable: true, get: function() {
      return scope_2.varKinds;
    } });
    exports2.operators = {
      GT: new code_1._Code(">"),
      GTE: new code_1._Code(">="),
      LT: new code_1._Code("<"),
      LTE: new code_1._Code("<="),
      EQ: new code_1._Code("==="),
      NEQ: new code_1._Code("!=="),
      NOT: new code_1._Code("!"),
      OR: new code_1._Code("||"),
      AND: new code_1._Code("&&"),
      ADD: new code_1._Code("+")
    };
    var Node = class {
      optimizeNodes() {
        return this;
      }
      optimizeNames(_names, _constants) {
        return this;
      }
    };
    var Def = class extends Node {
      constructor(varKind, name, rhs) {
        super();
        this.varKind = varKind;
        this.name = name;
        this.rhs = rhs;
      }
      render({ es5, _n }) {
        const varKind = es5 ? scope_1.varKinds.var : this.varKind;
        const rhs = this.rhs === void 0 ? "" : ` = ${this.rhs}`;
        return `${varKind} ${this.name}${rhs};` + _n;
      }
      optimizeNames(names, constants) {
        if (!names[this.name.str])
          return;
        if (this.rhs)
          this.rhs = optimizeExpr(this.rhs, names, constants);
        return this;
      }
      get names() {
        return this.rhs instanceof code_1._CodeOrName ? this.rhs.names : {};
      }
    };
    var Assign = class extends Node {
      constructor(lhs, rhs, sideEffects) {
        super();
        this.lhs = lhs;
        this.rhs = rhs;
        this.sideEffects = sideEffects;
      }
      render({ _n }) {
        return `${this.lhs} = ${this.rhs};` + _n;
      }
      optimizeNames(names, constants) {
        if (this.lhs instanceof code_1.Name && !names[this.lhs.str] && !this.sideEffects)
          return;
        this.rhs = optimizeExpr(this.rhs, names, constants);
        return this;
      }
      get names() {
        const names = this.lhs instanceof code_1.Name ? {} : { ...this.lhs.names };
        return addExprNames(names, this.rhs);
      }
    };
    var AssignOp = class extends Assign {
      constructor(lhs, op, rhs, sideEffects) {
        super(lhs, rhs, sideEffects);
        this.op = op;
      }
      render({ _n }) {
        return `${this.lhs} ${this.op}= ${this.rhs};` + _n;
      }
    };
    var Label = class extends Node {
      constructor(label) {
        super();
        this.label = label;
        this.names = {};
      }
      render({ _n }) {
        return `${this.label}:` + _n;
      }
    };
    var Break = class extends Node {
      constructor(label) {
        super();
        this.label = label;
        this.names = {};
      }
      render({ _n }) {
        const label = this.label ? ` ${this.label}` : "";
        return `break${label};` + _n;
      }
    };
    var Throw = class extends Node {
      constructor(error) {
        super();
        this.error = error;
      }
      render({ _n }) {
        return `throw ${this.error};` + _n;
      }
      get names() {
        return this.error.names;
      }
    };
    var AnyCode = class extends Node {
      constructor(code) {
        super();
        this.code = code;
      }
      render({ _n }) {
        return `${this.code};` + _n;
      }
      optimizeNodes() {
        return `${this.code}` ? this : void 0;
      }
      optimizeNames(names, constants) {
        this.code = optimizeExpr(this.code, names, constants);
        return this;
      }
      get names() {
        return this.code instanceof code_1._CodeOrName ? this.code.names : {};
      }
    };
    var ParentNode = class extends Node {
      constructor(nodes = []) {
        super();
        this.nodes = nodes;
      }
      render(opts) {
        return this.nodes.reduce((code, n) => code + n.render(opts), "");
      }
      optimizeNodes() {
        const { nodes } = this;
        let i = nodes.length;
        while (i--) {
          const n = nodes[i].optimizeNodes();
          if (Array.isArray(n))
            nodes.splice(i, 1, ...n);
          else if (n)
            nodes[i] = n;
          else
            nodes.splice(i, 1);
        }
        return nodes.length > 0 ? this : void 0;
      }
      optimizeNames(names, constants) {
        const { nodes } = this;
        let i = nodes.length;
        while (i--) {
          const n = nodes[i];
          if (n.optimizeNames(names, constants))
            continue;
          subtractNames(names, n.names);
          nodes.splice(i, 1);
        }
        return nodes.length > 0 ? this : void 0;
      }
      get names() {
        return this.nodes.reduce((names, n) => addNames(names, n.names), {});
      }
    };
    var BlockNode = class extends ParentNode {
      render(opts) {
        return "{" + opts._n + super.render(opts) + "}" + opts._n;
      }
    };
    var Root = class extends ParentNode {
    };
    var Else = class extends BlockNode {
    };
    Else.kind = "else";
    var If = class _If extends BlockNode {
      constructor(condition, nodes) {
        super(nodes);
        this.condition = condition;
      }
      render(opts) {
        let code = `if(${this.condition})` + super.render(opts);
        if (this.else)
          code += "else " + this.else.render(opts);
        return code;
      }
      optimizeNodes() {
        super.optimizeNodes();
        const cond = this.condition;
        if (cond === true)
          return this.nodes;
        let e = this.else;
        if (e) {
          const ns = e.optimizeNodes();
          e = this.else = Array.isArray(ns) ? new Else(ns) : ns;
        }
        if (e) {
          if (cond === false)
            return e instanceof _If ? e : e.nodes;
          if (this.nodes.length)
            return this;
          return new _If(not(cond), e instanceof _If ? [e] : e.nodes);
        }
        if (cond === false || !this.nodes.length)
          return void 0;
        return this;
      }
      optimizeNames(names, constants) {
        var _a;
        this.else = (_a = this.else) === null || _a === void 0 ? void 0 : _a.optimizeNames(names, constants);
        if (!(super.optimizeNames(names, constants) || this.else))
          return;
        this.condition = optimizeExpr(this.condition, names, constants);
        return this;
      }
      get names() {
        const names = super.names;
        addExprNames(names, this.condition);
        if (this.else)
          addNames(names, this.else.names);
        return names;
      }
    };
    If.kind = "if";
    var For = class extends BlockNode {
    };
    For.kind = "for";
    var ForLoop = class extends For {
      constructor(iteration) {
        super();
        this.iteration = iteration;
      }
      render(opts) {
        return `for(${this.iteration})` + super.render(opts);
      }
      optimizeNames(names, constants) {
        if (!super.optimizeNames(names, constants))
          return;
        this.iteration = optimizeExpr(this.iteration, names, constants);
        return this;
      }
      get names() {
        return addNames(super.names, this.iteration.names);
      }
    };
    var ForRange = class extends For {
      constructor(varKind, name, from, to) {
        super();
        this.varKind = varKind;
        this.name = name;
        this.from = from;
        this.to = to;
      }
      render(opts) {
        const varKind = opts.es5 ? scope_1.varKinds.var : this.varKind;
        const { name, from, to } = this;
        return `for(${varKind} ${name}=${from}; ${name}<${to}; ${name}++)` + super.render(opts);
      }
      get names() {
        const names = addExprNames(super.names, this.from);
        return addExprNames(names, this.to);
      }
    };
    var ForIter = class extends For {
      constructor(loop, varKind, name, iterable) {
        super();
        this.loop = loop;
        this.varKind = varKind;
        this.name = name;
        this.iterable = iterable;
      }
      render(opts) {
        return `for(${this.varKind} ${this.name} ${this.loop} ${this.iterable})` + super.render(opts);
      }
      optimizeNames(names, constants) {
        if (!super.optimizeNames(names, constants))
          return;
        this.iterable = optimizeExpr(this.iterable, names, constants);
        return this;
      }
      get names() {
        return addNames(super.names, this.iterable.names);
      }
    };
    var Func = class extends BlockNode {
      constructor(name, args, async) {
        super();
        this.name = name;
        this.args = args;
        this.async = async;
      }
      render(opts) {
        const _async = this.async ? "async " : "";
        return `${_async}function ${this.name}(${this.args})` + super.render(opts);
      }
    };
    Func.kind = "func";
    var Return = class extends ParentNode {
      render(opts) {
        return "return " + super.render(opts);
      }
    };
    Return.kind = "return";
    var Try = class extends BlockNode {
      render(opts) {
        let code = "try" + super.render(opts);
        if (this.catch)
          code += this.catch.render(opts);
        if (this.finally)
          code += this.finally.render(opts);
        return code;
      }
      optimizeNodes() {
        var _a, _b;
        super.optimizeNodes();
        (_a = this.catch) === null || _a === void 0 ? void 0 : _a.optimizeNodes();
        (_b = this.finally) === null || _b === void 0 ? void 0 : _b.optimizeNodes();
        return this;
      }
      optimizeNames(names, constants) {
        var _a, _b;
        super.optimizeNames(names, constants);
        (_a = this.catch) === null || _a === void 0 ? void 0 : _a.optimizeNames(names, constants);
        (_b = this.finally) === null || _b === void 0 ? void 0 : _b.optimizeNames(names, constants);
        return this;
      }
      get names() {
        const names = super.names;
        if (this.catch)
          addNames(names, this.catch.names);
        if (this.finally)
          addNames(names, this.finally.names);
        return names;
      }
    };
    var Catch = class extends BlockNode {
      constructor(error) {
        super();
        this.error = error;
      }
      render(opts) {
        return `catch(${this.error})` + super.render(opts);
      }
    };
    Catch.kind = "catch";
    var Finally = class extends BlockNode {
      render(opts) {
        return "finally" + super.render(opts);
      }
    };
    Finally.kind = "finally";
    var CodeGen = class {
      constructor(extScope, opts = {}) {
        this._values = {};
        this._blockStarts = [];
        this._constants = {};
        this.opts = { ...opts, _n: opts.lines ? "\n" : "" };
        this._extScope = extScope;
        this._scope = new scope_1.Scope({ parent: extScope });
        this._nodes = [new Root()];
      }
      toString() {
        return this._root.render(this.opts);
      }
      // returns unique name in the internal scope
      name(prefix) {
        return this._scope.name(prefix);
      }
      // reserves unique name in the external scope
      scopeName(prefix) {
        return this._extScope.name(prefix);
      }
      // reserves unique name in the external scope and assigns value to it
      scopeValue(prefixOrName, value) {
        const name = this._extScope.value(prefixOrName, value);
        const vs = this._values[name.prefix] || (this._values[name.prefix] = /* @__PURE__ */ new Set());
        vs.add(name);
        return name;
      }
      getScopeValue(prefix, keyOrRef) {
        return this._extScope.getValue(prefix, keyOrRef);
      }
      // return code that assigns values in the external scope to the names that are used internally
      // (same names that were returned by gen.scopeName or gen.scopeValue)
      scopeRefs(scopeName) {
        return this._extScope.scopeRefs(scopeName, this._values);
      }
      scopeCode() {
        return this._extScope.scopeCode(this._values);
      }
      _def(varKind, nameOrPrefix, rhs, constant) {
        const name = this._scope.toName(nameOrPrefix);
        if (rhs !== void 0 && constant)
          this._constants[name.str] = rhs;
        this._leafNode(new Def(varKind, name, rhs));
        return name;
      }
      // `const` declaration (`var` in es5 mode)
      const(nameOrPrefix, rhs, _constant) {
        return this._def(scope_1.varKinds.const, nameOrPrefix, rhs, _constant);
      }
      // `let` declaration with optional assignment (`var` in es5 mode)
      let(nameOrPrefix, rhs, _constant) {
        return this._def(scope_1.varKinds.let, nameOrPrefix, rhs, _constant);
      }
      // `var` declaration with optional assignment
      var(nameOrPrefix, rhs, _constant) {
        return this._def(scope_1.varKinds.var, nameOrPrefix, rhs, _constant);
      }
      // assignment code
      assign(lhs, rhs, sideEffects) {
        return this._leafNode(new Assign(lhs, rhs, sideEffects));
      }
      // `+=` code
      add(lhs, rhs) {
        return this._leafNode(new AssignOp(lhs, exports2.operators.ADD, rhs));
      }
      // appends passed SafeExpr to code or executes Block
      code(c2) {
        if (typeof c2 == "function")
          c2();
        else if (c2 !== code_1.nil)
          this._leafNode(new AnyCode(c2));
        return this;
      }
      // returns code for object literal for the passed argument list of key-value pairs
      object(...keyValues) {
        const code = ["{"];
        for (const [key, value] of keyValues) {
          if (code.length > 1)
            code.push(",");
          code.push(key);
          if (key !== value || this.opts.es5) {
            code.push(":");
            (0, code_1.addCodeArg)(code, value);
          }
        }
        code.push("}");
        return new code_1._Code(code);
      }
      // `if` clause (or statement if `thenBody` and, optionally, `elseBody` are passed)
      if(condition, thenBody, elseBody) {
        this._blockNode(new If(condition));
        if (thenBody && elseBody) {
          this.code(thenBody).else().code(elseBody).endIf();
        } else if (thenBody) {
          this.code(thenBody).endIf();
        } else if (elseBody) {
          throw new Error('CodeGen: "else" body without "then" body');
        }
        return this;
      }
      // `else if` clause - invalid without `if` or after `else` clauses
      elseIf(condition) {
        return this._elseNode(new If(condition));
      }
      // `else` clause - only valid after `if` or `else if` clauses
      else() {
        return this._elseNode(new Else());
      }
      // end `if` statement (needed if gen.if was used only with condition)
      endIf() {
        return this._endBlockNode(If, Else);
      }
      _for(node2, forBody) {
        this._blockNode(node2);
        if (forBody)
          this.code(forBody).endFor();
        return this;
      }
      // a generic `for` clause (or statement if `forBody` is passed)
      for(iteration, forBody) {
        return this._for(new ForLoop(iteration), forBody);
      }
      // `for` statement for a range of values
      forRange(nameOrPrefix, from, to, forBody, varKind = this.opts.es5 ? scope_1.varKinds.var : scope_1.varKinds.let) {
        const name = this._scope.toName(nameOrPrefix);
        return this._for(new ForRange(varKind, name, from, to), () => forBody(name));
      }
      // `for-of` statement (in es5 mode replace with a normal for loop)
      forOf(nameOrPrefix, iterable, forBody, varKind = scope_1.varKinds.const) {
        const name = this._scope.toName(nameOrPrefix);
        if (this.opts.es5) {
          const arr = iterable instanceof code_1.Name ? iterable : this.var("_arr", iterable);
          return this.forRange("_i", 0, (0, code_1._)`${arr}.length`, (i) => {
            this.var(name, (0, code_1._)`${arr}[${i}]`);
            forBody(name);
          });
        }
        return this._for(new ForIter("of", varKind, name, iterable), () => forBody(name));
      }
      // `for-in` statement.
      // With option `ownProperties` replaced with a `for-of` loop for object keys
      forIn(nameOrPrefix, obj, forBody, varKind = this.opts.es5 ? scope_1.varKinds.var : scope_1.varKinds.const) {
        if (this.opts.ownProperties) {
          return this.forOf(nameOrPrefix, (0, code_1._)`Object.keys(${obj})`, forBody);
        }
        const name = this._scope.toName(nameOrPrefix);
        return this._for(new ForIter("in", varKind, name, obj), () => forBody(name));
      }
      // end `for` loop
      endFor() {
        return this._endBlockNode(For);
      }
      // `label` statement
      label(label) {
        return this._leafNode(new Label(label));
      }
      // `break` statement
      break(label) {
        return this._leafNode(new Break(label));
      }
      // `return` statement
      return(value) {
        const node2 = new Return();
        this._blockNode(node2);
        this.code(value);
        if (node2.nodes.length !== 1)
          throw new Error('CodeGen: "return" should have one node');
        return this._endBlockNode(Return);
      }
      // `try` statement
      try(tryBody, catchCode, finallyCode) {
        if (!catchCode && !finallyCode)
          throw new Error('CodeGen: "try" without "catch" and "finally"');
        const node2 = new Try();
        this._blockNode(node2);
        this.code(tryBody);
        if (catchCode) {
          const error = this.name("e");
          this._currNode = node2.catch = new Catch(error);
          catchCode(error);
        }
        if (finallyCode) {
          this._currNode = node2.finally = new Finally();
          this.code(finallyCode);
        }
        return this._endBlockNode(Catch, Finally);
      }
      // `throw` statement
      throw(error) {
        return this._leafNode(new Throw(error));
      }
      // start self-balancing block
      block(body, nodeCount) {
        this._blockStarts.push(this._nodes.length);
        if (body)
          this.code(body).endBlock(nodeCount);
        return this;
      }
      // end the current self-balancing block
      endBlock(nodeCount) {
        const len = this._blockStarts.pop();
        if (len === void 0)
          throw new Error("CodeGen: not in self-balancing block");
        const toClose = this._nodes.length - len;
        if (toClose < 0 || nodeCount !== void 0 && toClose !== nodeCount) {
          throw new Error(`CodeGen: wrong number of nodes: ${toClose} vs ${nodeCount} expected`);
        }
        this._nodes.length = len;
        return this;
      }
      // `function` heading (or definition if funcBody is passed)
      func(name, args = code_1.nil, async, funcBody) {
        this._blockNode(new Func(name, args, async));
        if (funcBody)
          this.code(funcBody).endFunc();
        return this;
      }
      // end function definition
      endFunc() {
        return this._endBlockNode(Func);
      }
      optimize(n = 1) {
        while (n-- > 0) {
          this._root.optimizeNodes();
          this._root.optimizeNames(this._root.names, this._constants);
        }
      }
      _leafNode(node2) {
        this._currNode.nodes.push(node2);
        return this;
      }
      _blockNode(node2) {
        this._currNode.nodes.push(node2);
        this._nodes.push(node2);
      }
      _endBlockNode(N1, N2) {
        const n = this._currNode;
        if (n instanceof N1 || N2 && n instanceof N2) {
          this._nodes.pop();
          return this;
        }
        throw new Error(`CodeGen: not in block "${N2 ? `${N1.kind}/${N2.kind}` : N1.kind}"`);
      }
      _elseNode(node2) {
        const n = this._currNode;
        if (!(n instanceof If)) {
          throw new Error('CodeGen: "else" without "if"');
        }
        this._currNode = n.else = node2;
        return this;
      }
      get _root() {
        return this._nodes[0];
      }
      get _currNode() {
        const ns = this._nodes;
        return ns[ns.length - 1];
      }
      set _currNode(node2) {
        const ns = this._nodes;
        ns[ns.length - 1] = node2;
      }
    };
    exports2.CodeGen = CodeGen;
    function addNames(names, from) {
      for (const n in from)
        names[n] = (names[n] || 0) + (from[n] || 0);
      return names;
    }
    function addExprNames(names, from) {
      return from instanceof code_1._CodeOrName ? addNames(names, from.names) : names;
    }
    function optimizeExpr(expr, names, constants) {
      if (expr instanceof code_1.Name)
        return replaceName(expr);
      if (!canOptimize(expr))
        return expr;
      return new code_1._Code(expr._items.reduce((items, c2) => {
        if (c2 instanceof code_1.Name)
          c2 = replaceName(c2);
        if (c2 instanceof code_1._Code)
          items.push(...c2._items);
        else
          items.push(c2);
        return items;
      }, []));
      function replaceName(n) {
        const c2 = constants[n.str];
        if (c2 === void 0 || names[n.str] !== 1)
          return n;
        delete names[n.str];
        return c2;
      }
      function canOptimize(e) {
        return e instanceof code_1._Code && e._items.some((c2) => c2 instanceof code_1.Name && names[c2.str] === 1 && constants[c2.str] !== void 0);
      }
    }
    function subtractNames(names, from) {
      for (const n in from)
        names[n] = (names[n] || 0) - (from[n] || 0);
    }
    function not(x) {
      return typeof x == "boolean" || typeof x == "number" || x === null ? !x : (0, code_1._)`!${par(x)}`;
    }
    exports2.not = not;
    var andCode = mappend(exports2.operators.AND);
    function and(...args) {
      return args.reduce(andCode);
    }
    exports2.and = and;
    var orCode = mappend(exports2.operators.OR);
    function or(...args) {
      return args.reduce(orCode);
    }
    exports2.or = or;
    function mappend(op) {
      return (x, y) => x === code_1.nil ? y : y === code_1.nil ? x : (0, code_1._)`${par(x)} ${op} ${par(y)}`;
    }
    function par(x) {
      return x instanceof code_1.Name ? x : (0, code_1._)`(${x})`;
    }
  }
});

// node_modules/ajv/dist/compile/util.js
var require_util3 = __commonJS({
  "node_modules/ajv/dist/compile/util.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.checkStrictMode = exports2.getErrorPath = exports2.Type = exports2.useFunc = exports2.setEvaluated = exports2.evaluatedPropsToName = exports2.mergeEvaluated = exports2.eachItem = exports2.unescapeJsonPointer = exports2.escapeJsonPointer = exports2.escapeFragment = exports2.unescapeFragment = exports2.schemaRefOrVal = exports2.schemaHasRulesButRef = exports2.schemaHasRules = exports2.checkUnknownRules = exports2.alwaysValidSchema = exports2.toHash = void 0;
    var codegen_1 = require_codegen();
    var code_1 = require_code();
    function toHash(arr) {
      const hash = {};
      for (const item of arr)
        hash[item] = true;
      return hash;
    }
    exports2.toHash = toHash;
    function alwaysValidSchema(it, schema2) {
      if (typeof schema2 == "boolean")
        return schema2;
      if (Object.keys(schema2).length === 0)
        return true;
      checkUnknownRules(it, schema2);
      return !schemaHasRules(schema2, it.self.RULES.all);
    }
    exports2.alwaysValidSchema = alwaysValidSchema;
    function checkUnknownRules(it, schema2 = it.schema) {
      const { opts, self: self2 } = it;
      if (!opts.strictSchema)
        return;
      if (typeof schema2 === "boolean")
        return;
      const rules = self2.RULES.keywords;
      for (const key in schema2) {
        if (!rules[key])
          checkStrictMode(it, `unknown keyword: "${key}"`);
      }
    }
    exports2.checkUnknownRules = checkUnknownRules;
    function schemaHasRules(schema2, rules) {
      if (typeof schema2 == "boolean")
        return !schema2;
      for (const key in schema2)
        if (rules[key])
          return true;
      return false;
    }
    exports2.schemaHasRules = schemaHasRules;
    function schemaHasRulesButRef(schema2, RULES) {
      if (typeof schema2 == "boolean")
        return !schema2;
      for (const key in schema2)
        if (key !== "$ref" && RULES.all[key])
          return true;
      return false;
    }
    exports2.schemaHasRulesButRef = schemaHasRulesButRef;
    function schemaRefOrVal({ topSchemaRef, schemaPath }, schema2, keyword, $data) {
      if (!$data) {
        if (typeof schema2 == "number" || typeof schema2 == "boolean")
          return schema2;
        if (typeof schema2 == "string")
          return (0, codegen_1._)`${schema2}`;
      }
      return (0, codegen_1._)`${topSchemaRef}${schemaPath}${(0, codegen_1.getProperty)(keyword)}`;
    }
    exports2.schemaRefOrVal = schemaRefOrVal;
    function unescapeFragment(str2) {
      return unescapeJsonPointer(decodeURIComponent(str2));
    }
    exports2.unescapeFragment = unescapeFragment;
    function escapeFragment(str2) {
      return encodeURIComponent(escapeJsonPointer(str2));
    }
    exports2.escapeFragment = escapeFragment;
    function escapeJsonPointer(str2) {
      if (typeof str2 == "number")
        return `${str2}`;
      return str2.replace(/~/g, "~0").replace(/\//g, "~1");
    }
    exports2.escapeJsonPointer = escapeJsonPointer;
    function unescapeJsonPointer(str2) {
      return str2.replace(/~1/g, "/").replace(/~0/g, "~");
    }
    exports2.unescapeJsonPointer = unescapeJsonPointer;
    function eachItem(xs, f) {
      if (Array.isArray(xs)) {
        for (const x of xs)
          f(x);
      } else {
        f(xs);
      }
    }
    exports2.eachItem = eachItem;
    function makeMergeEvaluated({ mergeNames, mergeToName, mergeValues, resultToName }) {
      return (gen, from, to, toName) => {
        const res = to === void 0 ? from : to instanceof codegen_1.Name ? (from instanceof codegen_1.Name ? mergeNames(gen, from, to) : mergeToName(gen, from, to), to) : from instanceof codegen_1.Name ? (mergeToName(gen, to, from), from) : mergeValues(from, to);
        return toName === codegen_1.Name && !(res instanceof codegen_1.Name) ? resultToName(gen, res) : res;
      };
    }
    exports2.mergeEvaluated = {
      props: makeMergeEvaluated({
        mergeNames: (gen, from, to) => gen.if((0, codegen_1._)`${to} !== true && ${from} !== undefined`, () => {
          gen.if((0, codegen_1._)`${from} === true`, () => gen.assign(to, true), () => gen.assign(to, (0, codegen_1._)`${to} || {}`).code((0, codegen_1._)`Object.assign(${to}, ${from})`));
        }),
        mergeToName: (gen, from, to) => gen.if((0, codegen_1._)`${to} !== true`, () => {
          if (from === true) {
            gen.assign(to, true);
          } else {
            gen.assign(to, (0, codegen_1._)`${to} || {}`);
            setEvaluated(gen, to, from);
          }
        }),
        mergeValues: (from, to) => from === true ? true : { ...from, ...to },
        resultToName: evaluatedPropsToName
      }),
      items: makeMergeEvaluated({
        mergeNames: (gen, from, to) => gen.if((0, codegen_1._)`${to} !== true && ${from} !== undefined`, () => gen.assign(to, (0, codegen_1._)`${from} === true ? true : ${to} > ${from} ? ${to} : ${from}`)),
        mergeToName: (gen, from, to) => gen.if((0, codegen_1._)`${to} !== true`, () => gen.assign(to, from === true ? true : (0, codegen_1._)`${to} > ${from} ? ${to} : ${from}`)),
        mergeValues: (from, to) => from === true ? true : Math.max(from, to),
        resultToName: (gen, items) => gen.var("items", items)
      })
    };
    function evaluatedPropsToName(gen, ps) {
      if (ps === true)
        return gen.var("props", true);
      const props = gen.var("props", (0, codegen_1._)`{}`);
      if (ps !== void 0)
        setEvaluated(gen, props, ps);
      return props;
    }
    exports2.evaluatedPropsToName = evaluatedPropsToName;
    function setEvaluated(gen, props, ps) {
      Object.keys(ps).forEach((p) => gen.assign((0, codegen_1._)`${props}${(0, codegen_1.getProperty)(p)}`, true));
    }
    exports2.setEvaluated = setEvaluated;
    var snippets = {};
    function useFunc(gen, f) {
      return gen.scopeValue("func", {
        ref: f,
        code: snippets[f.code] || (snippets[f.code] = new code_1._Code(f.code))
      });
    }
    exports2.useFunc = useFunc;
    var Type2;
    (function(Type3) {
      Type3[Type3["Num"] = 0] = "Num";
      Type3[Type3["Str"] = 1] = "Str";
    })(Type2 || (exports2.Type = Type2 = {}));
    function getErrorPath(dataProp, dataPropType, jsPropertySyntax) {
      if (dataProp instanceof codegen_1.Name) {
        const isNumber = dataPropType === Type2.Num;
        return jsPropertySyntax ? isNumber ? (0, codegen_1._)`"[" + ${dataProp} + "]"` : (0, codegen_1._)`"['" + ${dataProp} + "']"` : isNumber ? (0, codegen_1._)`"/" + ${dataProp}` : (0, codegen_1._)`"/" + ${dataProp}.replace(/~/g, "~0").replace(/\\//g, "~1")`;
      }
      return jsPropertySyntax ? (0, codegen_1.getProperty)(dataProp).toString() : "/" + escapeJsonPointer(dataProp);
    }
    exports2.getErrorPath = getErrorPath;
    function checkStrictMode(it, msg, mode = it.opts.strictSchema) {
      if (!mode)
        return;
      msg = `strict mode: ${msg}`;
      if (mode === true)
        throw new Error(msg);
      it.self.logger.warn(msg);
    }
    exports2.checkStrictMode = checkStrictMode;
  }
});

// node_modules/ajv/dist/compile/names.js
var require_names = __commonJS({
  "node_modules/ajv/dist/compile/names.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var names = {
      // validation function arguments
      data: new codegen_1.Name("data"),
      // data passed to validation function
      // args passed from referencing schema
      valCxt: new codegen_1.Name("valCxt"),
      // validation/data context - should not be used directly, it is destructured to the names below
      instancePath: new codegen_1.Name("instancePath"),
      parentData: new codegen_1.Name("parentData"),
      parentDataProperty: new codegen_1.Name("parentDataProperty"),
      rootData: new codegen_1.Name("rootData"),
      // root data - same as the data passed to the first/top validation function
      dynamicAnchors: new codegen_1.Name("dynamicAnchors"),
      // used to support recursiveRef and dynamicRef
      // function scoped variables
      vErrors: new codegen_1.Name("vErrors"),
      // null or array of validation errors
      errors: new codegen_1.Name("errors"),
      // counter of validation errors
      this: new codegen_1.Name("this"),
      // "globals"
      self: new codegen_1.Name("self"),
      scope: new codegen_1.Name("scope"),
      // JTD serialize/parse name for JSON string and position
      json: new codegen_1.Name("json"),
      jsonPos: new codegen_1.Name("jsonPos"),
      jsonLen: new codegen_1.Name("jsonLen"),
      jsonPart: new codegen_1.Name("jsonPart")
    };
    exports2.default = names;
  }
});

// node_modules/ajv/dist/compile/errors.js
var require_errors2 = __commonJS({
  "node_modules/ajv/dist/compile/errors.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.extendErrors = exports2.resetErrorsCount = exports2.reportExtraError = exports2.reportError = exports2.keyword$DataError = exports2.keywordError = void 0;
    var codegen_1 = require_codegen();
    var util_1 = require_util3();
    var names_1 = require_names();
    exports2.keywordError = {
      message: ({ keyword }) => (0, codegen_1.str)`must pass "${keyword}" keyword validation`
    };
    exports2.keyword$DataError = {
      message: ({ keyword, schemaType }) => schemaType ? (0, codegen_1.str)`"${keyword}" keyword must be ${schemaType} ($data)` : (0, codegen_1.str)`"${keyword}" keyword is invalid ($data)`
    };
    function reportError(cxt, error = exports2.keywordError, errorPaths, overrideAllErrors) {
      const { it } = cxt;
      const { gen, compositeRule, allErrors } = it;
      const errObj = errorObjectCode(cxt, error, errorPaths);
      if (overrideAllErrors !== null && overrideAllErrors !== void 0 ? overrideAllErrors : compositeRule || allErrors) {
        addError(gen, errObj);
      } else {
        returnErrors(it, (0, codegen_1._)`[${errObj}]`);
      }
    }
    exports2.reportError = reportError;
    function reportExtraError(cxt, error = exports2.keywordError, errorPaths) {
      const { it } = cxt;
      const { gen, compositeRule, allErrors } = it;
      const errObj = errorObjectCode(cxt, error, errorPaths);
      addError(gen, errObj);
      if (!(compositeRule || allErrors)) {
        returnErrors(it, names_1.default.vErrors);
      }
    }
    exports2.reportExtraError = reportExtraError;
    function resetErrorsCount(gen, errsCount) {
      gen.assign(names_1.default.errors, errsCount);
      gen.if((0, codegen_1._)`${names_1.default.vErrors} !== null`, () => gen.if(errsCount, () => gen.assign((0, codegen_1._)`${names_1.default.vErrors}.length`, errsCount), () => gen.assign(names_1.default.vErrors, null)));
    }
    exports2.resetErrorsCount = resetErrorsCount;
    function extendErrors({ gen, keyword, schemaValue, data, errsCount, it }) {
      if (errsCount === void 0)
        throw new Error("ajv implementation error");
      const err = gen.name("err");
      gen.forRange("i", errsCount, names_1.default.errors, (i) => {
        gen.const(err, (0, codegen_1._)`${names_1.default.vErrors}[${i}]`);
        gen.if((0, codegen_1._)`${err}.instancePath === undefined`, () => gen.assign((0, codegen_1._)`${err}.instancePath`, (0, codegen_1.strConcat)(names_1.default.instancePath, it.errorPath)));
        gen.assign((0, codegen_1._)`${err}.schemaPath`, (0, codegen_1.str)`${it.errSchemaPath}/${keyword}`);
        if (it.opts.verbose) {
          gen.assign((0, codegen_1._)`${err}.schema`, schemaValue);
          gen.assign((0, codegen_1._)`${err}.data`, data);
        }
      });
    }
    exports2.extendErrors = extendErrors;
    function addError(gen, errObj) {
      const err = gen.const("err", errObj);
      gen.if((0, codegen_1._)`${names_1.default.vErrors} === null`, () => gen.assign(names_1.default.vErrors, (0, codegen_1._)`[${err}]`), (0, codegen_1._)`${names_1.default.vErrors}.push(${err})`);
      gen.code((0, codegen_1._)`${names_1.default.errors}++`);
    }
    function returnErrors(it, errs) {
      const { gen, validateName: validateName2, schemaEnv } = it;
      if (schemaEnv.$async) {
        gen.throw((0, codegen_1._)`new ${it.ValidationError}(${errs})`);
      } else {
        gen.assign((0, codegen_1._)`${validateName2}.errors`, errs);
        gen.return(false);
      }
    }
    var E = {
      keyword: new codegen_1.Name("keyword"),
      schemaPath: new codegen_1.Name("schemaPath"),
      // also used in JTD errors
      params: new codegen_1.Name("params"),
      propertyName: new codegen_1.Name("propertyName"),
      message: new codegen_1.Name("message"),
      schema: new codegen_1.Name("schema"),
      parentSchema: new codegen_1.Name("parentSchema")
    };
    function errorObjectCode(cxt, error, errorPaths) {
      const { createErrors } = cxt.it;
      if (createErrors === false)
        return (0, codegen_1._)`{}`;
      return errorObject(cxt, error, errorPaths);
    }
    function errorObject(cxt, error, errorPaths = {}) {
      const { gen, it } = cxt;
      const keyValues = [
        errorInstancePath(it, errorPaths),
        errorSchemaPath(cxt, errorPaths)
      ];
      extraErrorProps(cxt, error, keyValues);
      return gen.object(...keyValues);
    }
    function errorInstancePath({ errorPath }, { instancePath }) {
      const instPath = instancePath ? (0, codegen_1.str)`${errorPath}${(0, util_1.getErrorPath)(instancePath, util_1.Type.Str)}` : errorPath;
      return [names_1.default.instancePath, (0, codegen_1.strConcat)(names_1.default.instancePath, instPath)];
    }
    function errorSchemaPath({ keyword, it: { errSchemaPath } }, { schemaPath, parentSchema }) {
      let schPath = parentSchema ? errSchemaPath : (0, codegen_1.str)`${errSchemaPath}/${keyword}`;
      if (schemaPath) {
        schPath = (0, codegen_1.str)`${schPath}${(0, util_1.getErrorPath)(schemaPath, util_1.Type.Str)}`;
      }
      return [E.schemaPath, schPath];
    }
    function extraErrorProps(cxt, { params: params2, message }, keyValues) {
      const { keyword, data, schemaValue, it } = cxt;
      const { opts, propertyName, topSchemaRef, schemaPath } = it;
      keyValues.push([E.keyword, keyword], [E.params, typeof params2 == "function" ? params2(cxt) : params2 || (0, codegen_1._)`{}`]);
      if (opts.messages) {
        keyValues.push([E.message, typeof message == "function" ? message(cxt) : message]);
      }
      if (opts.verbose) {
        keyValues.push([E.schema, schemaValue], [E.parentSchema, (0, codegen_1._)`${topSchemaRef}${schemaPath}`], [names_1.default.data, data]);
      }
      if (propertyName)
        keyValues.push([E.propertyName, propertyName]);
    }
  }
});

// node_modules/ajv/dist/compile/validate/boolSchema.js
var require_boolSchema = __commonJS({
  "node_modules/ajv/dist/compile/validate/boolSchema.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.boolOrEmptySchema = exports2.topBoolOrEmptySchema = void 0;
    var errors_1 = require_errors2();
    var codegen_1 = require_codegen();
    var names_1 = require_names();
    var boolError = {
      message: "boolean schema is false"
    };
    function topBoolOrEmptySchema(it) {
      const { gen, schema: schema2, validateName: validateName2 } = it;
      if (schema2 === false) {
        falseSchemaError(it, false);
      } else if (typeof schema2 == "object" && schema2.$async === true) {
        gen.return(names_1.default.data);
      } else {
        gen.assign((0, codegen_1._)`${validateName2}.errors`, null);
        gen.return(true);
      }
    }
    exports2.topBoolOrEmptySchema = topBoolOrEmptySchema;
    function boolOrEmptySchema(it, valid) {
      const { gen, schema: schema2 } = it;
      if (schema2 === false) {
        gen.var(valid, false);
        falseSchemaError(it);
      } else {
        gen.var(valid, true);
      }
    }
    exports2.boolOrEmptySchema = boolOrEmptySchema;
    function falseSchemaError(it, overrideAllErrors) {
      const { gen, data } = it;
      const cxt = {
        gen,
        keyword: "false schema",
        data,
        schema: false,
        schemaCode: false,
        schemaValue: false,
        params: {},
        it
      };
      (0, errors_1.reportError)(cxt, boolError, void 0, overrideAllErrors);
    }
  }
});

// node_modules/ajv/dist/compile/rules.js
var require_rules = __commonJS({
  "node_modules/ajv/dist/compile/rules.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getRules = exports2.isJSONType = void 0;
    var _jsonTypes = ["string", "number", "integer", "boolean", "null", "object", "array"];
    var jsonTypes = new Set(_jsonTypes);
    function isJSONType(x) {
      return typeof x == "string" && jsonTypes.has(x);
    }
    exports2.isJSONType = isJSONType;
    function getRules() {
      const groups = {
        number: { type: "number", rules: [] },
        string: { type: "string", rules: [] },
        array: { type: "array", rules: [] },
        object: { type: "object", rules: [] }
      };
      return {
        types: { ...groups, integer: true, boolean: true, null: true },
        rules: [{ rules: [] }, groups.number, groups.string, groups.array, groups.object],
        post: { rules: [] },
        all: {},
        keywords: {}
      };
    }
    exports2.getRules = getRules;
  }
});

// node_modules/ajv/dist/compile/validate/applicability.js
var require_applicability = __commonJS({
  "node_modules/ajv/dist/compile/validate/applicability.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.shouldUseRule = exports2.shouldUseGroup = exports2.schemaHasRulesForType = void 0;
    function schemaHasRulesForType({ schema: schema2, self: self2 }, type2) {
      const group = self2.RULES.types[type2];
      return group && group !== true && shouldUseGroup(schema2, group);
    }
    exports2.schemaHasRulesForType = schemaHasRulesForType;
    function shouldUseGroup(schema2, group) {
      return group.rules.some((rule) => shouldUseRule(schema2, rule));
    }
    exports2.shouldUseGroup = shouldUseGroup;
    function shouldUseRule(schema2, rule) {
      var _a;
      return schema2[rule.keyword] !== void 0 || ((_a = rule.definition.implements) === null || _a === void 0 ? void 0 : _a.some((kwd) => schema2[kwd] !== void 0));
    }
    exports2.shouldUseRule = shouldUseRule;
  }
});

// node_modules/ajv/dist/compile/validate/dataType.js
var require_dataType = __commonJS({
  "node_modules/ajv/dist/compile/validate/dataType.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.reportTypeError = exports2.checkDataTypes = exports2.checkDataType = exports2.coerceAndCheckDataType = exports2.getJSONTypes = exports2.getSchemaTypes = exports2.DataType = void 0;
    var rules_1 = require_rules();
    var applicability_1 = require_applicability();
    var errors_1 = require_errors2();
    var codegen_1 = require_codegen();
    var util_1 = require_util3();
    var DataType;
    (function(DataType2) {
      DataType2[DataType2["Correct"] = 0] = "Correct";
      DataType2[DataType2["Wrong"] = 1] = "Wrong";
    })(DataType || (exports2.DataType = DataType = {}));
    function getSchemaTypes(schema2) {
      const types3 = getJSONTypes(schema2.type);
      const hasNull = types3.includes("null");
      if (hasNull) {
        if (schema2.nullable === false)
          throw new Error("type: null contradicts nullable: false");
      } else {
        if (!types3.length && schema2.nullable !== void 0) {
          throw new Error('"nullable" cannot be used without "type"');
        }
        if (schema2.nullable === true)
          types3.push("null");
      }
      return types3;
    }
    exports2.getSchemaTypes = getSchemaTypes;
    function getJSONTypes(ts) {
      const types3 = Array.isArray(ts) ? ts : ts ? [ts] : [];
      if (types3.every(rules_1.isJSONType))
        return types3;
      throw new Error("type must be JSONType or JSONType[]: " + types3.join(","));
    }
    exports2.getJSONTypes = getJSONTypes;
    function coerceAndCheckDataType(it, types3) {
      const { gen, data, opts } = it;
      const coerceTo = coerceToTypes(types3, opts.coerceTypes);
      const checkTypes = types3.length > 0 && !(coerceTo.length === 0 && types3.length === 1 && (0, applicability_1.schemaHasRulesForType)(it, types3[0]));
      if (checkTypes) {
        const wrongType = checkDataTypes(types3, data, opts.strictNumbers, DataType.Wrong);
        gen.if(wrongType, () => {
          if (coerceTo.length)
            coerceData(it, types3, coerceTo);
          else
            reportTypeError(it);
        });
      }
      return checkTypes;
    }
    exports2.coerceAndCheckDataType = coerceAndCheckDataType;
    var COERCIBLE = /* @__PURE__ */ new Set(["string", "number", "integer", "boolean", "null"]);
    function coerceToTypes(types3, coerceTypes) {
      return coerceTypes ? types3.filter((t) => COERCIBLE.has(t) || coerceTypes === "array" && t === "array") : [];
    }
    function coerceData(it, types3, coerceTo) {
      const { gen, data, opts } = it;
      const dataType = gen.let("dataType", (0, codegen_1._)`typeof ${data}`);
      const coerced = gen.let("coerced", (0, codegen_1._)`undefined`);
      if (opts.coerceTypes === "array") {
        gen.if((0, codegen_1._)`${dataType} == 'object' && Array.isArray(${data}) && ${data}.length == 1`, () => gen.assign(data, (0, codegen_1._)`${data}[0]`).assign(dataType, (0, codegen_1._)`typeof ${data}`).if(checkDataTypes(types3, data, opts.strictNumbers), () => gen.assign(coerced, data)));
      }
      gen.if((0, codegen_1._)`${coerced} !== undefined`);
      for (const t of coerceTo) {
        if (COERCIBLE.has(t) || t === "array" && opts.coerceTypes === "array") {
          coerceSpecificType(t);
        }
      }
      gen.else();
      reportTypeError(it);
      gen.endIf();
      gen.if((0, codegen_1._)`${coerced} !== undefined`, () => {
        gen.assign(data, coerced);
        assignParentData(it, coerced);
      });
      function coerceSpecificType(t) {
        switch (t) {
          case "string":
            gen.elseIf((0, codegen_1._)`${dataType} == "number" || ${dataType} == "boolean"`).assign(coerced, (0, codegen_1._)`"" + ${data}`).elseIf((0, codegen_1._)`${data} === null`).assign(coerced, (0, codegen_1._)`""`);
            return;
          case "number":
            gen.elseIf((0, codegen_1._)`${dataType} == "boolean" || ${data} === null
              || (${dataType} == "string" && ${data} && ${data} == +${data})`).assign(coerced, (0, codegen_1._)`+${data}`);
            return;
          case "integer":
            gen.elseIf((0, codegen_1._)`${dataType} === "boolean" || ${data} === null
              || (${dataType} === "string" && ${data} && ${data} == +${data} && !(${data} % 1))`).assign(coerced, (0, codegen_1._)`+${data}`);
            return;
          case "boolean":
            gen.elseIf((0, codegen_1._)`${data} === "false" || ${data} === 0 || ${data} === null`).assign(coerced, false).elseIf((0, codegen_1._)`${data} === "true" || ${data} === 1`).assign(coerced, true);
            return;
          case "null":
            gen.elseIf((0, codegen_1._)`${data} === "" || ${data} === 0 || ${data} === false`);
            gen.assign(coerced, null);
            return;
          case "array":
            gen.elseIf((0, codegen_1._)`${dataType} === "string" || ${dataType} === "number"
              || ${dataType} === "boolean" || ${data} === null`).assign(coerced, (0, codegen_1._)`[${data}]`);
        }
      }
    }
    function assignParentData({ gen, parentData, parentDataProperty }, expr) {
      gen.if((0, codegen_1._)`${parentData} !== undefined`, () => gen.assign((0, codegen_1._)`${parentData}[${parentDataProperty}]`, expr));
    }
    function checkDataType(dataType, data, strictNums, correct = DataType.Correct) {
      const EQ = correct === DataType.Correct ? codegen_1.operators.EQ : codegen_1.operators.NEQ;
      let cond;
      switch (dataType) {
        case "null":
          return (0, codegen_1._)`${data} ${EQ} null`;
        case "array":
          cond = (0, codegen_1._)`Array.isArray(${data})`;
          break;
        case "object":
          cond = (0, codegen_1._)`${data} && typeof ${data} == "object" && !Array.isArray(${data})`;
          break;
        case "integer":
          cond = numCond((0, codegen_1._)`!(${data} % 1) && !isNaN(${data})`);
          break;
        case "number":
          cond = numCond();
          break;
        default:
          return (0, codegen_1._)`typeof ${data} ${EQ} ${dataType}`;
      }
      return correct === DataType.Correct ? cond : (0, codegen_1.not)(cond);
      function numCond(_cond = codegen_1.nil) {
        return (0, codegen_1.and)((0, codegen_1._)`typeof ${data} == "number"`, _cond, strictNums ? (0, codegen_1._)`isFinite(${data})` : codegen_1.nil);
      }
    }
    exports2.checkDataType = checkDataType;
    function checkDataTypes(dataTypes, data, strictNums, correct) {
      if (dataTypes.length === 1) {
        return checkDataType(dataTypes[0], data, strictNums, correct);
      }
      let cond;
      const types3 = (0, util_1.toHash)(dataTypes);
      if (types3.array && types3.object) {
        const notObj = (0, codegen_1._)`typeof ${data} != "object"`;
        cond = types3.null ? notObj : (0, codegen_1._)`!${data} || ${notObj}`;
        delete types3.null;
        delete types3.array;
        delete types3.object;
      } else {
        cond = codegen_1.nil;
      }
      if (types3.number)
        delete types3.integer;
      for (const t in types3)
        cond = (0, codegen_1.and)(cond, checkDataType(t, data, strictNums, correct));
      return cond;
    }
    exports2.checkDataTypes = checkDataTypes;
    var typeError = {
      message: ({ schema: schema2 }) => `must be ${schema2}`,
      params: ({ schema: schema2, schemaValue }) => typeof schema2 == "string" ? (0, codegen_1._)`{type: ${schema2}}` : (0, codegen_1._)`{type: ${schemaValue}}`
    };
    function reportTypeError(it) {
      const cxt = getTypeErrorContext(it);
      (0, errors_1.reportError)(cxt, typeError);
    }
    exports2.reportTypeError = reportTypeError;
    function getTypeErrorContext(it) {
      const { gen, data, schema: schema2 } = it;
      const schemaCode = (0, util_1.schemaRefOrVal)(it, schema2, "type");
      return {
        gen,
        keyword: "type",
        data,
        schema: schema2.type,
        schemaCode,
        schemaValue: schemaCode,
        parentSchema: schema2,
        params: {},
        it
      };
    }
  }
});

// node_modules/ajv/dist/compile/validate/defaults.js
var require_defaults2 = __commonJS({
  "node_modules/ajv/dist/compile/validate/defaults.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.assignDefaults = void 0;
    var codegen_1 = require_codegen();
    var util_1 = require_util3();
    function assignDefaults(it, ty) {
      const { properties, items } = it.schema;
      if (ty === "object" && properties) {
        for (const key in properties) {
          assignDefault(it, key, properties[key].default);
        }
      } else if (ty === "array" && Array.isArray(items)) {
        items.forEach((sch, i) => assignDefault(it, i, sch.default));
      }
    }
    exports2.assignDefaults = assignDefaults;
    function assignDefault(it, prop, defaultValue) {
      const { gen, compositeRule, data, opts } = it;
      if (defaultValue === void 0)
        return;
      const childData = (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(prop)}`;
      if (compositeRule) {
        (0, util_1.checkStrictMode)(it, `default is ignored for: ${childData}`);
        return;
      }
      let condition = (0, codegen_1._)`${childData} === undefined`;
      if (opts.useDefaults === "empty") {
        condition = (0, codegen_1._)`${condition} || ${childData} === null || ${childData} === ""`;
      }
      gen.if(condition, (0, codegen_1._)`${childData} = ${(0, codegen_1.stringify)(defaultValue)}`);
    }
  }
});

// node_modules/ajv/dist/vocabularies/code.js
var require_code2 = __commonJS({
  "node_modules/ajv/dist/vocabularies/code.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.validateUnion = exports2.validateArray = exports2.usePattern = exports2.callValidateCode = exports2.schemaProperties = exports2.allSchemaProperties = exports2.noPropertyInData = exports2.propertyInData = exports2.isOwnProperty = exports2.hasPropFunc = exports2.reportMissingProp = exports2.checkMissingProp = exports2.checkReportMissingProp = void 0;
    var codegen_1 = require_codegen();
    var util_1 = require_util3();
    var names_1 = require_names();
    var util_2 = require_util3();
    function checkReportMissingProp(cxt, prop) {
      const { gen, data, it } = cxt;
      gen.if(noPropertyInData(gen, data, prop, it.opts.ownProperties), () => {
        cxt.setParams({ missingProperty: (0, codegen_1._)`${prop}` }, true);
        cxt.error();
      });
    }
    exports2.checkReportMissingProp = checkReportMissingProp;
    function checkMissingProp({ gen, data, it: { opts } }, properties, missing) {
      return (0, codegen_1.or)(...properties.map((prop) => (0, codegen_1.and)(noPropertyInData(gen, data, prop, opts.ownProperties), (0, codegen_1._)`${missing} = ${prop}`)));
    }
    exports2.checkMissingProp = checkMissingProp;
    function reportMissingProp(cxt, missing) {
      cxt.setParams({ missingProperty: missing }, true);
      cxt.error();
    }
    exports2.reportMissingProp = reportMissingProp;
    function hasPropFunc(gen) {
      return gen.scopeValue("func", {
        // eslint-disable-next-line @typescript-eslint/unbound-method
        ref: Object.prototype.hasOwnProperty,
        code: (0, codegen_1._)`Object.prototype.hasOwnProperty`
      });
    }
    exports2.hasPropFunc = hasPropFunc;
    function isOwnProperty(gen, data, property) {
      return (0, codegen_1._)`${hasPropFunc(gen)}.call(${data}, ${property})`;
    }
    exports2.isOwnProperty = isOwnProperty;
    function propertyInData(gen, data, property, ownProperties) {
      const cond = (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(property)} !== undefined`;
      return ownProperties ? (0, codegen_1._)`${cond} && ${isOwnProperty(gen, data, property)}` : cond;
    }
    exports2.propertyInData = propertyInData;
    function noPropertyInData(gen, data, property, ownProperties) {
      const cond = (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(property)} === undefined`;
      return ownProperties ? (0, codegen_1.or)(cond, (0, codegen_1.not)(isOwnProperty(gen, data, property))) : cond;
    }
    exports2.noPropertyInData = noPropertyInData;
    function allSchemaProperties(schemaMap) {
      return schemaMap ? Object.keys(schemaMap).filter((p) => p !== "__proto__") : [];
    }
    exports2.allSchemaProperties = allSchemaProperties;
    function schemaProperties(it, schemaMap) {
      return allSchemaProperties(schemaMap).filter((p) => !(0, util_1.alwaysValidSchema)(it, schemaMap[p]));
    }
    exports2.schemaProperties = schemaProperties;
    function callValidateCode({ schemaCode, data, it: { gen, topSchemaRef, schemaPath, errorPath }, it }, func, context, passSchema) {
      const dataAndSchema = passSchema ? (0, codegen_1._)`${schemaCode}, ${data}, ${topSchemaRef}${schemaPath}` : data;
      const valCxt = [
        [names_1.default.instancePath, (0, codegen_1.strConcat)(names_1.default.instancePath, errorPath)],
        [names_1.default.parentData, it.parentData],
        [names_1.default.parentDataProperty, it.parentDataProperty],
        [names_1.default.rootData, names_1.default.rootData]
      ];
      if (it.opts.dynamicRef)
        valCxt.push([names_1.default.dynamicAnchors, names_1.default.dynamicAnchors]);
      const args = (0, codegen_1._)`${dataAndSchema}, ${gen.object(...valCxt)}`;
      return context !== codegen_1.nil ? (0, codegen_1._)`${func}.call(${context}, ${args})` : (0, codegen_1._)`${func}(${args})`;
    }
    exports2.callValidateCode = callValidateCode;
    var newRegExp = (0, codegen_1._)`new RegExp`;
    function usePattern({ gen, it: { opts } }, pattern) {
      const u = opts.unicodeRegExp ? "u" : "";
      const { regExp } = opts.code;
      const rx = regExp(pattern, u);
      return gen.scopeValue("pattern", {
        key: rx.toString(),
        ref: rx,
        code: (0, codegen_1._)`${regExp.code === "new RegExp" ? newRegExp : (0, util_2.useFunc)(gen, regExp)}(${pattern}, ${u})`
      });
    }
    exports2.usePattern = usePattern;
    function validateArray(cxt) {
      const { gen, data, keyword, it } = cxt;
      const valid = gen.name("valid");
      if (it.allErrors) {
        const validArr = gen.let("valid", true);
        validateItems(() => gen.assign(validArr, false));
        return validArr;
      }
      gen.var(valid, true);
      validateItems(() => gen.break());
      return valid;
      function validateItems(notValid) {
        const len = gen.const("len", (0, codegen_1._)`${data}.length`);
        gen.forRange("i", 0, len, (i) => {
          cxt.subschema({
            keyword,
            dataProp: i,
            dataPropType: util_1.Type.Num
          }, valid);
          gen.if((0, codegen_1.not)(valid), notValid);
        });
      }
    }
    exports2.validateArray = validateArray;
    function validateUnion(cxt) {
      const { gen, schema: schema2, keyword, it } = cxt;
      if (!Array.isArray(schema2))
        throw new Error("ajv implementation error");
      const alwaysValid = schema2.some((sch) => (0, util_1.alwaysValidSchema)(it, sch));
      if (alwaysValid && !it.opts.unevaluated)
        return;
      const valid = gen.let("valid", false);
      const schValid = gen.name("_valid");
      gen.block(() => schema2.forEach((_sch, i) => {
        const schCxt = cxt.subschema({
          keyword,
          schemaProp: i,
          compositeRule: true
        }, schValid);
        gen.assign(valid, (0, codegen_1._)`${valid} || ${schValid}`);
        const merged = cxt.mergeValidEvaluated(schCxt, schValid);
        if (!merged)
          gen.if((0, codegen_1.not)(valid));
      }));
      cxt.result(valid, () => cxt.reset(), () => cxt.error(true));
    }
    exports2.validateUnion = validateUnion;
  }
});

// node_modules/ajv/dist/compile/validate/keyword.js
var require_keyword2 = __commonJS({
  "node_modules/ajv/dist/compile/validate/keyword.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.validateKeywordUsage = exports2.validSchemaType = exports2.funcKeywordCode = exports2.macroKeywordCode = void 0;
    var codegen_1 = require_codegen();
    var names_1 = require_names();
    var code_1 = require_code2();
    var errors_1 = require_errors2();
    function macroKeywordCode(cxt, def) {
      const { gen, keyword, schema: schema2, parentSchema, it } = cxt;
      const macroSchema = def.macro.call(it.self, schema2, parentSchema, it);
      const schemaRef = useKeyword(gen, keyword, macroSchema);
      if (it.opts.validateSchema !== false)
        it.self.validateSchema(macroSchema, true);
      const valid = gen.name("valid");
      cxt.subschema({
        schema: macroSchema,
        schemaPath: codegen_1.nil,
        errSchemaPath: `${it.errSchemaPath}/${keyword}`,
        topSchemaRef: schemaRef,
        compositeRule: true
      }, valid);
      cxt.pass(valid, () => cxt.error(true));
    }
    exports2.macroKeywordCode = macroKeywordCode;
    function funcKeywordCode(cxt, def) {
      var _a;
      const { gen, keyword, schema: schema2, parentSchema, $data, it } = cxt;
      checkAsyncKeyword(it, def);
      const validate2 = !$data && def.compile ? def.compile.call(it.self, schema2, parentSchema, it) : def.validate;
      const validateRef = useKeyword(gen, keyword, validate2);
      const valid = gen.let("valid");
      cxt.block$data(valid, validateKeyword);
      cxt.ok((_a = def.valid) !== null && _a !== void 0 ? _a : valid);
      function validateKeyword() {
        if (def.errors === false) {
          assignValid();
          if (def.modifying)
            modifyData(cxt);
          reportErrs(() => cxt.error());
        } else {
          const ruleErrs = def.async ? validateAsync() : validateSync();
          if (def.modifying)
            modifyData(cxt);
          reportErrs(() => addErrs(cxt, ruleErrs));
        }
      }
      function validateAsync() {
        const ruleErrs = gen.let("ruleErrs", null);
        gen.try(() => assignValid((0, codegen_1._)`await `), (e) => gen.assign(valid, false).if((0, codegen_1._)`${e} instanceof ${it.ValidationError}`, () => gen.assign(ruleErrs, (0, codegen_1._)`${e}.errors`), () => gen.throw(e)));
        return ruleErrs;
      }
      function validateSync() {
        const validateErrs = (0, codegen_1._)`${validateRef}.errors`;
        gen.assign(validateErrs, null);
        assignValid(codegen_1.nil);
        return validateErrs;
      }
      function assignValid(_await = def.async ? (0, codegen_1._)`await ` : codegen_1.nil) {
        const passCxt = it.opts.passContext ? names_1.default.this : names_1.default.self;
        const passSchema = !("compile" in def && !$data || def.schema === false);
        gen.assign(valid, (0, codegen_1._)`${_await}${(0, code_1.callValidateCode)(cxt, validateRef, passCxt, passSchema)}`, def.modifying);
      }
      function reportErrs(errors) {
        var _a2;
        gen.if((0, codegen_1.not)((_a2 = def.valid) !== null && _a2 !== void 0 ? _a2 : valid), errors);
      }
    }
    exports2.funcKeywordCode = funcKeywordCode;
    function modifyData(cxt) {
      const { gen, data, it } = cxt;
      gen.if(it.parentData, () => gen.assign(data, (0, codegen_1._)`${it.parentData}[${it.parentDataProperty}]`));
    }
    function addErrs(cxt, errs) {
      const { gen } = cxt;
      gen.if((0, codegen_1._)`Array.isArray(${errs})`, () => {
        gen.assign(names_1.default.vErrors, (0, codegen_1._)`${names_1.default.vErrors} === null ? ${errs} : ${names_1.default.vErrors}.concat(${errs})`).assign(names_1.default.errors, (0, codegen_1._)`${names_1.default.vErrors}.length`);
        (0, errors_1.extendErrors)(cxt);
      }, () => cxt.error());
    }
    function checkAsyncKeyword({ schemaEnv }, def) {
      if (def.async && !schemaEnv.$async)
        throw new Error("async keyword in sync schema");
    }
    function useKeyword(gen, keyword, result) {
      if (result === void 0)
        throw new Error(`keyword "${keyword}" failed to compile`);
      return gen.scopeValue("keyword", typeof result == "function" ? { ref: result } : { ref: result, code: (0, codegen_1.stringify)(result) });
    }
    function validSchemaType(schema2, schemaType, allowUndefined = false) {
      return !schemaType.length || schemaType.some((st) => st === "array" ? Array.isArray(schema2) : st === "object" ? schema2 && typeof schema2 == "object" && !Array.isArray(schema2) : typeof schema2 == st || allowUndefined && typeof schema2 == "undefined");
    }
    exports2.validSchemaType = validSchemaType;
    function validateKeywordUsage({ schema: schema2, opts, self: self2, errSchemaPath }, def, keyword) {
      if (Array.isArray(def.keyword) ? !def.keyword.includes(keyword) : def.keyword !== keyword) {
        throw new Error("ajv implementation error");
      }
      const deps = def.dependencies;
      if (deps === null || deps === void 0 ? void 0 : deps.some((kwd) => !Object.prototype.hasOwnProperty.call(schema2, kwd))) {
        throw new Error(`parent schema must have dependencies of ${keyword}: ${deps.join(",")}`);
      }
      if (def.validateSchema) {
        const valid = def.validateSchema(schema2[keyword]);
        if (!valid) {
          const msg = `keyword "${keyword}" value is invalid at path "${errSchemaPath}": ` + self2.errorsText(def.validateSchema.errors);
          if (opts.validateSchema === "log")
            self2.logger.error(msg);
          else
            throw new Error(msg);
        }
      }
    }
    exports2.validateKeywordUsage = validateKeywordUsage;
  }
});

// node_modules/ajv/dist/compile/validate/subschema.js
var require_subschema = __commonJS({
  "node_modules/ajv/dist/compile/validate/subschema.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.extendSubschemaMode = exports2.extendSubschemaData = exports2.getSubschema = void 0;
    var codegen_1 = require_codegen();
    var util_1 = require_util3();
    function getSubschema(it, { keyword, schemaProp, schema: schema2, schemaPath, errSchemaPath, topSchemaRef }) {
      if (keyword !== void 0 && schema2 !== void 0) {
        throw new Error('both "keyword" and "schema" passed, only one allowed');
      }
      if (keyword !== void 0) {
        const sch = it.schema[keyword];
        return schemaProp === void 0 ? {
          schema: sch,
          schemaPath: (0, codegen_1._)`${it.schemaPath}${(0, codegen_1.getProperty)(keyword)}`,
          errSchemaPath: `${it.errSchemaPath}/${keyword}`
        } : {
          schema: sch[schemaProp],
          schemaPath: (0, codegen_1._)`${it.schemaPath}${(0, codegen_1.getProperty)(keyword)}${(0, codegen_1.getProperty)(schemaProp)}`,
          errSchemaPath: `${it.errSchemaPath}/${keyword}/${(0, util_1.escapeFragment)(schemaProp)}`
        };
      }
      if (schema2 !== void 0) {
        if (schemaPath === void 0 || errSchemaPath === void 0 || topSchemaRef === void 0) {
          throw new Error('"schemaPath", "errSchemaPath" and "topSchemaRef" are required with "schema"');
        }
        return {
          schema: schema2,
          schemaPath,
          topSchemaRef,
          errSchemaPath
        };
      }
      throw new Error('either "keyword" or "schema" must be passed');
    }
    exports2.getSubschema = getSubschema;
    function extendSubschemaData(subschema, it, { dataProp, dataPropType: dpType, data, dataTypes, propertyName }) {
      if (data !== void 0 && dataProp !== void 0) {
        throw new Error('both "data" and "dataProp" passed, only one allowed');
      }
      const { gen } = it;
      if (dataProp !== void 0) {
        const { errorPath, dataPathArr, opts } = it;
        const nextData = gen.let("data", (0, codegen_1._)`${it.data}${(0, codegen_1.getProperty)(dataProp)}`, true);
        dataContextProps(nextData);
        subschema.errorPath = (0, codegen_1.str)`${errorPath}${(0, util_1.getErrorPath)(dataProp, dpType, opts.jsPropertySyntax)}`;
        subschema.parentDataProperty = (0, codegen_1._)`${dataProp}`;
        subschema.dataPathArr = [...dataPathArr, subschema.parentDataProperty];
      }
      if (data !== void 0) {
        const nextData = data instanceof codegen_1.Name ? data : gen.let("data", data, true);
        dataContextProps(nextData);
        if (propertyName !== void 0)
          subschema.propertyName = propertyName;
      }
      if (dataTypes)
        subschema.dataTypes = dataTypes;
      function dataContextProps(_nextData) {
        subschema.data = _nextData;
        subschema.dataLevel = it.dataLevel + 1;
        subschema.dataTypes = [];
        it.definedProperties = /* @__PURE__ */ new Set();
        subschema.parentData = it.data;
        subschema.dataNames = [...it.dataNames, _nextData];
      }
    }
    exports2.extendSubschemaData = extendSubschemaData;
    function extendSubschemaMode(subschema, { jtdDiscriminator, jtdMetadata, compositeRule, createErrors, allErrors }) {
      if (compositeRule !== void 0)
        subschema.compositeRule = compositeRule;
      if (createErrors !== void 0)
        subschema.createErrors = createErrors;
      if (allErrors !== void 0)
        subschema.allErrors = allErrors;
      subschema.jtdDiscriminator = jtdDiscriminator;
      subschema.jtdMetadata = jtdMetadata;
    }
    exports2.extendSubschemaMode = extendSubschemaMode;
  }
});

// node_modules/fast-deep-equal/index.js
var require_fast_deep_equal = __commonJS({
  "node_modules/fast-deep-equal/index.js"(exports2, module2) {
    "use strict";
    module2.exports = function equal(a, b) {
      if (a === b) return true;
      if (a && b && typeof a == "object" && typeof b == "object") {
        if (a.constructor !== b.constructor) return false;
        var length, i, keys;
        if (Array.isArray(a)) {
          length = a.length;
          if (length != b.length) return false;
          for (i = length; i-- !== 0; )
            if (!equal(a[i], b[i])) return false;
          return true;
        }
        if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;
        if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();
        if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();
        keys = Object.keys(a);
        length = keys.length;
        if (length !== Object.keys(b).length) return false;
        for (i = length; i-- !== 0; )
          if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;
        for (i = length; i-- !== 0; ) {
          var key = keys[i];
          if (!equal(a[key], b[key])) return false;
        }
        return true;
      }
      return a !== a && b !== b;
    };
  }
});

// node_modules/json-schema-traverse/index.js
var require_json_schema_traverse = __commonJS({
  "node_modules/json-schema-traverse/index.js"(exports2, module2) {
    "use strict";
    var traverse = module2.exports = function(schema2, opts, cb) {
      if (typeof opts == "function") {
        cb = opts;
        opts = {};
      }
      cb = opts.cb || cb;
      var pre = typeof cb == "function" ? cb : cb.pre || function() {
      };
      var post = cb.post || function() {
      };
      _traverse(opts, pre, post, schema2, "", schema2);
    };
    traverse.keywords = {
      additionalItems: true,
      items: true,
      contains: true,
      additionalProperties: true,
      propertyNames: true,
      not: true,
      if: true,
      then: true,
      else: true
    };
    traverse.arrayKeywords = {
      items: true,
      allOf: true,
      anyOf: true,
      oneOf: true
    };
    traverse.propsKeywords = {
      $defs: true,
      definitions: true,
      properties: true,
      patternProperties: true,
      dependencies: true
    };
    traverse.skipKeywords = {
      default: true,
      enum: true,
      const: true,
      required: true,
      maximum: true,
      minimum: true,
      exclusiveMaximum: true,
      exclusiveMinimum: true,
      multipleOf: true,
      maxLength: true,
      minLength: true,
      pattern: true,
      format: true,
      maxItems: true,
      minItems: true,
      uniqueItems: true,
      maxProperties: true,
      minProperties: true
    };
    function _traverse(opts, pre, post, schema2, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {
      if (schema2 && typeof schema2 == "object" && !Array.isArray(schema2)) {
        pre(schema2, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
        for (var key in schema2) {
          var sch = schema2[key];
          if (Array.isArray(sch)) {
            if (key in traverse.arrayKeywords) {
              for (var i = 0; i < sch.length; i++)
                _traverse(opts, pre, post, sch[i], jsonPtr + "/" + key + "/" + i, rootSchema, jsonPtr, key, schema2, i);
            }
          } else if (key in traverse.propsKeywords) {
            if (sch && typeof sch == "object") {
              for (var prop in sch)
                _traverse(opts, pre, post, sch[prop], jsonPtr + "/" + key + "/" + escapeJsonPtr(prop), rootSchema, jsonPtr, key, schema2, prop);
            }
          } else if (key in traverse.keywords || opts.allKeys && !(key in traverse.skipKeywords)) {
            _traverse(opts, pre, post, sch, jsonPtr + "/" + key, rootSchema, jsonPtr, key, schema2);
          }
        }
        post(schema2, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
      }
    }
    function escapeJsonPtr(str2) {
      return str2.replace(/~/g, "~0").replace(/\//g, "~1");
    }
  }
});

// node_modules/ajv/dist/compile/resolve.js
var require_resolve = __commonJS({
  "node_modules/ajv/dist/compile/resolve.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getSchemaRefs = exports2.resolveUrl = exports2.normalizeId = exports2._getFullPath = exports2.getFullPath = exports2.inlineRef = void 0;
    var util_1 = require_util3();
    var equal = require_fast_deep_equal();
    var traverse = require_json_schema_traverse();
    var SIMPLE_INLINED = /* @__PURE__ */ new Set([
      "type",
      "format",
      "pattern",
      "maxLength",
      "minLength",
      "maxProperties",
      "minProperties",
      "maxItems",
      "minItems",
      "maximum",
      "minimum",
      "uniqueItems",
      "multipleOf",
      "required",
      "enum",
      "const"
    ]);
    function inlineRef(schema2, limit = true) {
      if (typeof schema2 == "boolean")
        return true;
      if (limit === true)
        return !hasRef(schema2);
      if (!limit)
        return false;
      return countKeys(schema2) <= limit;
    }
    exports2.inlineRef = inlineRef;
    var REF_KEYWORDS = /* @__PURE__ */ new Set([
      "$ref",
      "$recursiveRef",
      "$recursiveAnchor",
      "$dynamicRef",
      "$dynamicAnchor"
    ]);
    function hasRef(schema2) {
      for (const key in schema2) {
        if (REF_KEYWORDS.has(key))
          return true;
        const sch = schema2[key];
        if (Array.isArray(sch) && sch.some(hasRef))
          return true;
        if (typeof sch == "object" && hasRef(sch))
          return true;
      }
      return false;
    }
    function countKeys(schema2) {
      let count = 0;
      for (const key in schema2) {
        if (key === "$ref")
          return Infinity;
        count++;
        if (SIMPLE_INLINED.has(key))
          continue;
        if (typeof schema2[key] == "object") {
          (0, util_1.eachItem)(schema2[key], (sch) => count += countKeys(sch));
        }
        if (count === Infinity)
          return Infinity;
      }
      return count;
    }
    function getFullPath(resolver, id = "", normalize) {
      if (normalize !== false)
        id = normalizeId(id);
      const p = resolver.parse(id);
      return _getFullPath(resolver, p);
    }
    exports2.getFullPath = getFullPath;
    function _getFullPath(resolver, p) {
      const serialized = resolver.serialize(p);
      return serialized.split("#")[0] + "#";
    }
    exports2._getFullPath = _getFullPath;
    var TRAILING_SLASH_HASH = /#\/?$/;
    function normalizeId(id) {
      return id ? id.replace(TRAILING_SLASH_HASH, "") : "";
    }
    exports2.normalizeId = normalizeId;
    function resolveUrl(resolver, baseId, id) {
      id = normalizeId(id);
      return resolver.resolve(baseId, id);
    }
    exports2.resolveUrl = resolveUrl;
    var ANCHOR = /^[a-z_][-a-z0-9._]*$/i;
    function getSchemaRefs(schema2, baseId) {
      if (typeof schema2 == "boolean")
        return {};
      const { schemaId, uriResolver } = this.opts;
      const schId = normalizeId(schema2[schemaId] || baseId);
      const baseIds = { "": schId };
      const pathPrefix = getFullPath(uriResolver, schId, false);
      const localRefs = {};
      const schemaRefs = /* @__PURE__ */ new Set();
      traverse(schema2, { allKeys: true }, (sch, jsonPtr, _, parentJsonPtr) => {
        if (parentJsonPtr === void 0)
          return;
        const fullPath = pathPrefix + jsonPtr;
        let innerBaseId = baseIds[parentJsonPtr];
        if (typeof sch[schemaId] == "string")
          innerBaseId = addRef.call(this, sch[schemaId]);
        addAnchor.call(this, sch.$anchor);
        addAnchor.call(this, sch.$dynamicAnchor);
        baseIds[jsonPtr] = innerBaseId;
        function addRef(ref) {
          const _resolve = this.opts.uriResolver.resolve;
          ref = normalizeId(innerBaseId ? _resolve(innerBaseId, ref) : ref);
          if (schemaRefs.has(ref))
            throw ambiguos(ref);
          schemaRefs.add(ref);
          let schOrRef = this.refs[ref];
          if (typeof schOrRef == "string")
            schOrRef = this.refs[schOrRef];
          if (typeof schOrRef == "object") {
            checkAmbiguosRef(sch, schOrRef.schema, ref);
          } else if (ref !== normalizeId(fullPath)) {
            if (ref[0] === "#") {
              checkAmbiguosRef(sch, localRefs[ref], ref);
              localRefs[ref] = sch;
            } else {
              this.refs[ref] = fullPath;
            }
          }
          return ref;
        }
        function addAnchor(anchor) {
          if (typeof anchor == "string") {
            if (!ANCHOR.test(anchor))
              throw new Error(`invalid anchor "${anchor}"`);
            addRef.call(this, `#${anchor}`);
          }
        }
      });
      return localRefs;
      function checkAmbiguosRef(sch1, sch2, ref) {
        if (sch2 !== void 0 && !equal(sch1, sch2))
          throw ambiguos(ref);
      }
      function ambiguos(ref) {
        return new Error(`reference "${ref}" resolves to more than one schema`);
      }
    }
    exports2.getSchemaRefs = getSchemaRefs;
  }
});

// node_modules/ajv/dist/compile/validate/index.js
var require_validate = __commonJS({
  "node_modules/ajv/dist/compile/validate/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getData = exports2.KeywordCxt = exports2.validateFunctionCode = void 0;
    var boolSchema_1 = require_boolSchema();
    var dataType_1 = require_dataType();
    var applicability_1 = require_applicability();
    var dataType_2 = require_dataType();
    var defaults_1 = require_defaults2();
    var keyword_1 = require_keyword2();
    var subschema_1 = require_subschema();
    var codegen_1 = require_codegen();
    var names_1 = require_names();
    var resolve_1 = require_resolve();
    var util_1 = require_util3();
    var errors_1 = require_errors2();
    function validateFunctionCode(it) {
      if (isSchemaObj(it)) {
        checkKeywords(it);
        if (schemaCxtHasRules(it)) {
          topSchemaObjCode(it);
          return;
        }
      }
      validateFunction(it, () => (0, boolSchema_1.topBoolOrEmptySchema)(it));
    }
    exports2.validateFunctionCode = validateFunctionCode;
    function validateFunction({ gen, validateName: validateName2, schema: schema2, schemaEnv, opts }, body) {
      if (opts.code.es5) {
        gen.func(validateName2, (0, codegen_1._)`${names_1.default.data}, ${names_1.default.valCxt}`, schemaEnv.$async, () => {
          gen.code((0, codegen_1._)`"use strict"; ${funcSourceUrl(schema2, opts)}`);
          destructureValCxtES5(gen, opts);
          gen.code(body);
        });
      } else {
        gen.func(validateName2, (0, codegen_1._)`${names_1.default.data}, ${destructureValCxt(opts)}`, schemaEnv.$async, () => gen.code(funcSourceUrl(schema2, opts)).code(body));
      }
    }
    function destructureValCxt(opts) {
      return (0, codegen_1._)`{${names_1.default.instancePath}="", ${names_1.default.parentData}, ${names_1.default.parentDataProperty}, ${names_1.default.rootData}=${names_1.default.data}${opts.dynamicRef ? (0, codegen_1._)`, ${names_1.default.dynamicAnchors}={}` : codegen_1.nil}}={}`;
    }
    function destructureValCxtES5(gen, opts) {
      gen.if(names_1.default.valCxt, () => {
        gen.var(names_1.default.instancePath, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.instancePath}`);
        gen.var(names_1.default.parentData, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.parentData}`);
        gen.var(names_1.default.parentDataProperty, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.parentDataProperty}`);
        gen.var(names_1.default.rootData, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.rootData}`);
        if (opts.dynamicRef)
          gen.var(names_1.default.dynamicAnchors, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.dynamicAnchors}`);
      }, () => {
        gen.var(names_1.default.instancePath, (0, codegen_1._)`""`);
        gen.var(names_1.default.parentData, (0, codegen_1._)`undefined`);
        gen.var(names_1.default.parentDataProperty, (0, codegen_1._)`undefined`);
        gen.var(names_1.default.rootData, names_1.default.data);
        if (opts.dynamicRef)
          gen.var(names_1.default.dynamicAnchors, (0, codegen_1._)`{}`);
      });
    }
    function topSchemaObjCode(it) {
      const { schema: schema2, opts, gen } = it;
      validateFunction(it, () => {
        if (opts.$comment && schema2.$comment)
          commentKeyword(it);
        checkNoDefault(it);
        gen.let(names_1.default.vErrors, null);
        gen.let(names_1.default.errors, 0);
        if (opts.unevaluated)
          resetEvaluated(it);
        typeAndKeywords(it);
        returnResults(it);
      });
      return;
    }
    function resetEvaluated(it) {
      const { gen, validateName: validateName2 } = it;
      it.evaluated = gen.const("evaluated", (0, codegen_1._)`${validateName2}.evaluated`);
      gen.if((0, codegen_1._)`${it.evaluated}.dynamicProps`, () => gen.assign((0, codegen_1._)`${it.evaluated}.props`, (0, codegen_1._)`undefined`));
      gen.if((0, codegen_1._)`${it.evaluated}.dynamicItems`, () => gen.assign((0, codegen_1._)`${it.evaluated}.items`, (0, codegen_1._)`undefined`));
    }
    function funcSourceUrl(schema2, opts) {
      const schId = typeof schema2 == "object" && schema2[opts.schemaId];
      return schId && (opts.code.source || opts.code.process) ? (0, codegen_1._)`/*# sourceURL=${schId} */` : codegen_1.nil;
    }
    function subschemaCode(it, valid) {
      if (isSchemaObj(it)) {
        checkKeywords(it);
        if (schemaCxtHasRules(it)) {
          subSchemaObjCode(it, valid);
          return;
        }
      }
      (0, boolSchema_1.boolOrEmptySchema)(it, valid);
    }
    function schemaCxtHasRules({ schema: schema2, self: self2 }) {
      if (typeof schema2 == "boolean")
        return !schema2;
      for (const key in schema2)
        if (self2.RULES.all[key])
          return true;
      return false;
    }
    function isSchemaObj(it) {
      return typeof it.schema != "boolean";
    }
    function subSchemaObjCode(it, valid) {
      const { schema: schema2, gen, opts } = it;
      if (opts.$comment && schema2.$comment)
        commentKeyword(it);
      updateContext(it);
      checkAsyncSchema(it);
      const errsCount = gen.const("_errs", names_1.default.errors);
      typeAndKeywords(it, errsCount);
      gen.var(valid, (0, codegen_1._)`${errsCount} === ${names_1.default.errors}`);
    }
    function checkKeywords(it) {
      (0, util_1.checkUnknownRules)(it);
      checkRefsAndKeywords(it);
    }
    function typeAndKeywords(it, errsCount) {
      if (it.opts.jtd)
        return schemaKeywords(it, [], false, errsCount);
      const types3 = (0, dataType_1.getSchemaTypes)(it.schema);
      const checkedTypes = (0, dataType_1.coerceAndCheckDataType)(it, types3);
      schemaKeywords(it, types3, !checkedTypes, errsCount);
    }
    function checkRefsAndKeywords(it) {
      const { schema: schema2, errSchemaPath, opts, self: self2 } = it;
      if (schema2.$ref && opts.ignoreKeywordsWithRef && (0, util_1.schemaHasRulesButRef)(schema2, self2.RULES)) {
        self2.logger.warn(`$ref: keywords ignored in schema at path "${errSchemaPath}"`);
      }
    }
    function checkNoDefault(it) {
      const { schema: schema2, opts } = it;
      if (schema2.default !== void 0 && opts.useDefaults && opts.strictSchema) {
        (0, util_1.checkStrictMode)(it, "default is ignored in the schema root");
      }
    }
    function updateContext(it) {
      const schId = it.schema[it.opts.schemaId];
      if (schId)
        it.baseId = (0, resolve_1.resolveUrl)(it.opts.uriResolver, it.baseId, schId);
    }
    function checkAsyncSchema(it) {
      if (it.schema.$async && !it.schemaEnv.$async)
        throw new Error("async schema in sync schema");
    }
    function commentKeyword({ gen, schemaEnv, schema: schema2, errSchemaPath, opts }) {
      const msg = schema2.$comment;
      if (opts.$comment === true) {
        gen.code((0, codegen_1._)`${names_1.default.self}.logger.log(${msg})`);
      } else if (typeof opts.$comment == "function") {
        const schemaPath = (0, codegen_1.str)`${errSchemaPath}/$comment`;
        const rootName = gen.scopeValue("root", { ref: schemaEnv.root });
        gen.code((0, codegen_1._)`${names_1.default.self}.opts.$comment(${msg}, ${schemaPath}, ${rootName}.schema)`);
      }
    }
    function returnResults(it) {
      const { gen, schemaEnv, validateName: validateName2, ValidationError, opts } = it;
      if (schemaEnv.$async) {
        gen.if((0, codegen_1._)`${names_1.default.errors} === 0`, () => gen.return(names_1.default.data), () => gen.throw((0, codegen_1._)`new ${ValidationError}(${names_1.default.vErrors})`));
      } else {
        gen.assign((0, codegen_1._)`${validateName2}.errors`, names_1.default.vErrors);
        if (opts.unevaluated)
          assignEvaluated(it);
        gen.return((0, codegen_1._)`${names_1.default.errors} === 0`);
      }
    }
    function assignEvaluated({ gen, evaluated, props, items }) {
      if (props instanceof codegen_1.Name)
        gen.assign((0, codegen_1._)`${evaluated}.props`, props);
      if (items instanceof codegen_1.Name)
        gen.assign((0, codegen_1._)`${evaluated}.items`, items);
    }
    function schemaKeywords(it, types3, typeErrors, errsCount) {
      const { gen, schema: schema2, data, allErrors, opts, self: self2 } = it;
      const { RULES } = self2;
      if (schema2.$ref && (opts.ignoreKeywordsWithRef || !(0, util_1.schemaHasRulesButRef)(schema2, RULES))) {
        gen.block(() => keywordCode(it, "$ref", RULES.all.$ref.definition));
        return;
      }
      if (!opts.jtd)
        checkStrictTypes(it, types3);
      gen.block(() => {
        for (const group of RULES.rules)
          groupKeywords(group);
        groupKeywords(RULES.post);
      });
      function groupKeywords(group) {
        if (!(0, applicability_1.shouldUseGroup)(schema2, group))
          return;
        if (group.type) {
          gen.if((0, dataType_2.checkDataType)(group.type, data, opts.strictNumbers));
          iterateKeywords(it, group);
          if (types3.length === 1 && types3[0] === group.type && typeErrors) {
            gen.else();
            (0, dataType_2.reportTypeError)(it);
          }
          gen.endIf();
        } else {
          iterateKeywords(it, group);
        }
        if (!allErrors)
          gen.if((0, codegen_1._)`${names_1.default.errors} === ${errsCount || 0}`);
      }
    }
    function iterateKeywords(it, group) {
      const { gen, schema: schema2, opts: { useDefaults } } = it;
      if (useDefaults)
        (0, defaults_1.assignDefaults)(it, group.type);
      gen.block(() => {
        for (const rule of group.rules) {
          if ((0, applicability_1.shouldUseRule)(schema2, rule)) {
            keywordCode(it, rule.keyword, rule.definition, group.type);
          }
        }
      });
    }
    function checkStrictTypes(it, types3) {
      if (it.schemaEnv.meta || !it.opts.strictTypes)
        return;
      checkContextTypes(it, types3);
      if (!it.opts.allowUnionTypes)
        checkMultipleTypes(it, types3);
      checkKeywordTypes(it, it.dataTypes);
    }
    function checkContextTypes(it, types3) {
      if (!types3.length)
        return;
      if (!it.dataTypes.length) {
        it.dataTypes = types3;
        return;
      }
      types3.forEach((t) => {
        if (!includesType(it.dataTypes, t)) {
          strictTypesError(it, `type "${t}" not allowed by context "${it.dataTypes.join(",")}"`);
        }
      });
      narrowSchemaTypes(it, types3);
    }
    function checkMultipleTypes(it, ts) {
      if (ts.length > 1 && !(ts.length === 2 && ts.includes("null"))) {
        strictTypesError(it, "use allowUnionTypes to allow union type keyword");
      }
    }
    function checkKeywordTypes(it, ts) {
      const rules = it.self.RULES.all;
      for (const keyword in rules) {
        const rule = rules[keyword];
        if (typeof rule == "object" && (0, applicability_1.shouldUseRule)(it.schema, rule)) {
          const { type: type2 } = rule.definition;
          if (type2.length && !type2.some((t) => hasApplicableType(ts, t))) {
            strictTypesError(it, `missing type "${type2.join(",")}" for keyword "${keyword}"`);
          }
        }
      }
    }
    function hasApplicableType(schTs, kwdT) {
      return schTs.includes(kwdT) || kwdT === "number" && schTs.includes("integer");
    }
    function includesType(ts, t) {
      return ts.includes(t) || t === "integer" && ts.includes("number");
    }
    function narrowSchemaTypes(it, withTypes) {
      const ts = [];
      for (const t of it.dataTypes) {
        if (includesType(withTypes, t))
          ts.push(t);
        else if (withTypes.includes("integer") && t === "number")
          ts.push("integer");
      }
      it.dataTypes = ts;
    }
    function strictTypesError(it, msg) {
      const schemaPath = it.schemaEnv.baseId + it.errSchemaPath;
      msg += ` at "${schemaPath}" (strictTypes)`;
      (0, util_1.checkStrictMode)(it, msg, it.opts.strictTypes);
    }
    var KeywordCxt = class {
      constructor(it, def, keyword) {
        (0, keyword_1.validateKeywordUsage)(it, def, keyword);
        this.gen = it.gen;
        this.allErrors = it.allErrors;
        this.keyword = keyword;
        this.data = it.data;
        this.schema = it.schema[keyword];
        this.$data = def.$data && it.opts.$data && this.schema && this.schema.$data;
        this.schemaValue = (0, util_1.schemaRefOrVal)(it, this.schema, keyword, this.$data);
        this.schemaType = def.schemaType;
        this.parentSchema = it.schema;
        this.params = {};
        this.it = it;
        this.def = def;
        if (this.$data) {
          this.schemaCode = it.gen.const("vSchema", getData(this.$data, it));
        } else {
          this.schemaCode = this.schemaValue;
          if (!(0, keyword_1.validSchemaType)(this.schema, def.schemaType, def.allowUndefined)) {
            throw new Error(`${keyword} value must be ${JSON.stringify(def.schemaType)}`);
          }
        }
        if ("code" in def ? def.trackErrors : def.errors !== false) {
          this.errsCount = it.gen.const("_errs", names_1.default.errors);
        }
      }
      result(condition, successAction, failAction) {
        this.failResult((0, codegen_1.not)(condition), successAction, failAction);
      }
      failResult(condition, successAction, failAction) {
        this.gen.if(condition);
        if (failAction)
          failAction();
        else
          this.error();
        if (successAction) {
          this.gen.else();
          successAction();
          if (this.allErrors)
            this.gen.endIf();
        } else {
          if (this.allErrors)
            this.gen.endIf();
          else
            this.gen.else();
        }
      }
      pass(condition, failAction) {
        this.failResult((0, codegen_1.not)(condition), void 0, failAction);
      }
      fail(condition) {
        if (condition === void 0) {
          this.error();
          if (!this.allErrors)
            this.gen.if(false);
          return;
        }
        this.gen.if(condition);
        this.error();
        if (this.allErrors)
          this.gen.endIf();
        else
          this.gen.else();
      }
      fail$data(condition) {
        if (!this.$data)
          return this.fail(condition);
        const { schemaCode } = this;
        this.fail((0, codegen_1._)`${schemaCode} !== undefined && (${(0, codegen_1.or)(this.invalid$data(), condition)})`);
      }
      error(append, errorParams, errorPaths) {
        if (errorParams) {
          this.setParams(errorParams);
          this._error(append, errorPaths);
          this.setParams({});
          return;
        }
        this._error(append, errorPaths);
      }
      _error(append, errorPaths) {
        ;
        (append ? errors_1.reportExtraError : errors_1.reportError)(this, this.def.error, errorPaths);
      }
      $dataError() {
        (0, errors_1.reportError)(this, this.def.$dataError || errors_1.keyword$DataError);
      }
      reset() {
        if (this.errsCount === void 0)
          throw new Error('add "trackErrors" to keyword definition');
        (0, errors_1.resetErrorsCount)(this.gen, this.errsCount);
      }
      ok(cond) {
        if (!this.allErrors)
          this.gen.if(cond);
      }
      setParams(obj, assign) {
        if (assign)
          Object.assign(this.params, obj);
        else
          this.params = obj;
      }
      block$data(valid, codeBlock, $dataValid = codegen_1.nil) {
        this.gen.block(() => {
          this.check$data(valid, $dataValid);
          codeBlock();
        });
      }
      check$data(valid = codegen_1.nil, $dataValid = codegen_1.nil) {
        if (!this.$data)
          return;
        const { gen, schemaCode, schemaType, def } = this;
        gen.if((0, codegen_1.or)((0, codegen_1._)`${schemaCode} === undefined`, $dataValid));
        if (valid !== codegen_1.nil)
          gen.assign(valid, true);
        if (schemaType.length || def.validateSchema) {
          gen.elseIf(this.invalid$data());
          this.$dataError();
          if (valid !== codegen_1.nil)
            gen.assign(valid, false);
        }
        gen.else();
      }
      invalid$data() {
        const { gen, schemaCode, schemaType, def, it } = this;
        return (0, codegen_1.or)(wrong$DataType(), invalid$DataSchema());
        function wrong$DataType() {
          if (schemaType.length) {
            if (!(schemaCode instanceof codegen_1.Name))
              throw new Error("ajv implementation error");
            const st = Array.isArray(schemaType) ? schemaType : [schemaType];
            return (0, codegen_1._)`${(0, dataType_2.checkDataTypes)(st, schemaCode, it.opts.strictNumbers, dataType_2.DataType.Wrong)}`;
          }
          return codegen_1.nil;
        }
        function invalid$DataSchema() {
          if (def.validateSchema) {
            const validateSchemaRef = gen.scopeValue("validate$data", { ref: def.validateSchema });
            return (0, codegen_1._)`!${validateSchemaRef}(${schemaCode})`;
          }
          return codegen_1.nil;
        }
      }
      subschema(appl, valid) {
        const subschema = (0, subschema_1.getSubschema)(this.it, appl);
        (0, subschema_1.extendSubschemaData)(subschema, this.it, appl);
        (0, subschema_1.extendSubschemaMode)(subschema, appl);
        const nextContext = { ...this.it, ...subschema, items: void 0, props: void 0 };
        subschemaCode(nextContext, valid);
        return nextContext;
      }
      mergeEvaluated(schemaCxt, toName) {
        const { it, gen } = this;
        if (!it.opts.unevaluated)
          return;
        if (it.props !== true && schemaCxt.props !== void 0) {
          it.props = util_1.mergeEvaluated.props(gen, schemaCxt.props, it.props, toName);
        }
        if (it.items !== true && schemaCxt.items !== void 0) {
          it.items = util_1.mergeEvaluated.items(gen, schemaCxt.items, it.items, toName);
        }
      }
      mergeValidEvaluated(schemaCxt, valid) {
        const { it, gen } = this;
        if (it.opts.unevaluated && (it.props !== true || it.items !== true)) {
          gen.if(valid, () => this.mergeEvaluated(schemaCxt, codegen_1.Name));
          return true;
        }
      }
    };
    exports2.KeywordCxt = KeywordCxt;
    function keywordCode(it, keyword, def, ruleType) {
      const cxt = new KeywordCxt(it, def, keyword);
      if ("code" in def) {
        def.code(cxt, ruleType);
      } else if (cxt.$data && def.validate) {
        (0, keyword_1.funcKeywordCode)(cxt, def);
      } else if ("macro" in def) {
        (0, keyword_1.macroKeywordCode)(cxt, def);
      } else if (def.compile || def.validate) {
        (0, keyword_1.funcKeywordCode)(cxt, def);
      }
    }
    var JSON_POINTER = /^\/(?:[^~]|~0|~1)*$/;
    var RELATIVE_JSON_POINTER = /^([0-9]+)(#|\/(?:[^~]|~0|~1)*)?$/;
    function getData($data, { dataLevel, dataNames, dataPathArr }) {
      let jsonPointer;
      let data;
      if ($data === "")
        return names_1.default.rootData;
      if ($data[0] === "/") {
        if (!JSON_POINTER.test($data))
          throw new Error(`Invalid JSON-pointer: ${$data}`);
        jsonPointer = $data;
        data = names_1.default.rootData;
      } else {
        const matches = RELATIVE_JSON_POINTER.exec($data);
        if (!matches)
          throw new Error(`Invalid JSON-pointer: ${$data}`);
        const up = +matches[1];
        jsonPointer = matches[2];
        if (jsonPointer === "#") {
          if (up >= dataLevel)
            throw new Error(errorMsg("property/index", up));
          return dataPathArr[dataLevel - up];
        }
        if (up > dataLevel)
          throw new Error(errorMsg("data", up));
        data = dataNames[dataLevel - up];
        if (!jsonPointer)
          return data;
      }
      let expr = data;
      const segments = jsonPointer.split("/");
      for (const segment of segments) {
        if (segment) {
          data = (0, codegen_1._)`${data}${(0, codegen_1.getProperty)((0, util_1.unescapeJsonPointer)(segment))}`;
          expr = (0, codegen_1._)`${expr} && ${data}`;
        }
      }
      return expr;
      function errorMsg(pointerType, up) {
        return `Cannot access ${pointerType} ${up} levels up, current level is ${dataLevel}`;
      }
    }
    exports2.getData = getData;
  }
});

// node_modules/ajv/dist/runtime/validation_error.js
var require_validation_error = __commonJS({
  "node_modules/ajv/dist/runtime/validation_error.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var ValidationError = class extends Error {
      constructor(errors) {
        super("validation failed");
        this.errors = errors;
        this.ajv = this.validation = true;
      }
    };
    exports2.default = ValidationError;
  }
});

// node_modules/ajv/dist/compile/ref_error.js
var require_ref_error = __commonJS({
  "node_modules/ajv/dist/compile/ref_error.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var resolve_1 = require_resolve();
    var MissingRefError = class extends Error {
      constructor(resolver, baseId, ref, msg) {
        super(msg || `can't resolve reference ${ref} from id ${baseId}`);
        this.missingRef = (0, resolve_1.resolveUrl)(resolver, baseId, ref);
        this.missingSchema = (0, resolve_1.normalizeId)((0, resolve_1.getFullPath)(resolver, this.missingRef));
      }
    };
    exports2.default = MissingRefError;
  }
});

// node_modules/ajv/dist/compile/index.js
var require_compile = __commonJS({
  "node_modules/ajv/dist/compile/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.resolveSchema = exports2.getCompilingSchema = exports2.resolveRef = exports2.compileSchema = exports2.SchemaEnv = void 0;
    var codegen_1 = require_codegen();
    var validation_error_1 = require_validation_error();
    var names_1 = require_names();
    var resolve_1 = require_resolve();
    var util_1 = require_util3();
    var validate_1 = require_validate();
    var SchemaEnv = class {
      constructor(env) {
        var _a;
        this.refs = {};
        this.dynamicAnchors = {};
        let schema2;
        if (typeof env.schema == "object")
          schema2 = env.schema;
        this.schema = env.schema;
        this.schemaId = env.schemaId;
        this.root = env.root || this;
        this.baseId = (_a = env.baseId) !== null && _a !== void 0 ? _a : (0, resolve_1.normalizeId)(schema2 === null || schema2 === void 0 ? void 0 : schema2[env.schemaId || "$id"]);
        this.schemaPath = env.schemaPath;
        this.localRefs = env.localRefs;
        this.meta = env.meta;
        this.$async = schema2 === null || schema2 === void 0 ? void 0 : schema2.$async;
        this.refs = {};
      }
    };
    exports2.SchemaEnv = SchemaEnv;
    function compileSchema(sch) {
      const _sch = getCompilingSchema.call(this, sch);
      if (_sch)
        return _sch;
      const rootId = (0, resolve_1.getFullPath)(this.opts.uriResolver, sch.root.baseId);
      const { es5, lines } = this.opts.code;
      const { ownProperties } = this.opts;
      const gen = new codegen_1.CodeGen(this.scope, { es5, lines, ownProperties });
      let _ValidationError;
      if (sch.$async) {
        _ValidationError = gen.scopeValue("Error", {
          ref: validation_error_1.default,
          code: (0, codegen_1._)`require("ajv/dist/runtime/validation_error").default`
        });
      }
      const validateName2 = gen.scopeName("validate");
      sch.validateName = validateName2;
      const schemaCxt = {
        gen,
        allErrors: this.opts.allErrors,
        data: names_1.default.data,
        parentData: names_1.default.parentData,
        parentDataProperty: names_1.default.parentDataProperty,
        dataNames: [names_1.default.data],
        dataPathArr: [codegen_1.nil],
        // TODO can its length be used as dataLevel if nil is removed?
        dataLevel: 0,
        dataTypes: [],
        definedProperties: /* @__PURE__ */ new Set(),
        topSchemaRef: gen.scopeValue("schema", this.opts.code.source === true ? { ref: sch.schema, code: (0, codegen_1.stringify)(sch.schema) } : { ref: sch.schema }),
        validateName: validateName2,
        ValidationError: _ValidationError,
        schema: sch.schema,
        schemaEnv: sch,
        rootId,
        baseId: sch.baseId || rootId,
        schemaPath: codegen_1.nil,
        errSchemaPath: sch.schemaPath || (this.opts.jtd ? "" : "#"),
        errorPath: (0, codegen_1._)`""`,
        opts: this.opts,
        self: this
      };
      let sourceCode;
      try {
        this._compilations.add(sch);
        (0, validate_1.validateFunctionCode)(schemaCxt);
        gen.optimize(this.opts.code.optimize);
        const validateCode = gen.toString();
        sourceCode = `${gen.scopeRefs(names_1.default.scope)}return ${validateCode}`;
        if (this.opts.code.process)
          sourceCode = this.opts.code.process(sourceCode, sch);
        const makeValidate = new Function(`${names_1.default.self}`, `${names_1.default.scope}`, sourceCode);
        const validate2 = makeValidate(this, this.scope.get());
        this.scope.value(validateName2, { ref: validate2 });
        validate2.errors = null;
        validate2.schema = sch.schema;
        validate2.schemaEnv = sch;
        if (sch.$async)
          validate2.$async = true;
        if (this.opts.code.source === true) {
          validate2.source = { validateName: validateName2, validateCode, scopeValues: gen._values };
        }
        if (this.opts.unevaluated) {
          const { props, items } = schemaCxt;
          validate2.evaluated = {
            props: props instanceof codegen_1.Name ? void 0 : props,
            items: items instanceof codegen_1.Name ? void 0 : items,
            dynamicProps: props instanceof codegen_1.Name,
            dynamicItems: items instanceof codegen_1.Name
          };
          if (validate2.source)
            validate2.source.evaluated = (0, codegen_1.stringify)(validate2.evaluated);
        }
        sch.validate = validate2;
        return sch;
      } catch (e) {
        delete sch.validate;
        delete sch.validateName;
        if (sourceCode)
          this.logger.error("Error compiling schema, function code:", sourceCode);
        throw e;
      } finally {
        this._compilations.delete(sch);
      }
    }
    exports2.compileSchema = compileSchema;
    function resolveRef(root, baseId, ref) {
      var _a;
      ref = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, ref);
      const schOrFunc = root.refs[ref];
      if (schOrFunc)
        return schOrFunc;
      let _sch = resolve.call(this, root, ref);
      if (_sch === void 0) {
        const schema2 = (_a = root.localRefs) === null || _a === void 0 ? void 0 : _a[ref];
        const { schemaId } = this.opts;
        if (schema2)
          _sch = new SchemaEnv({ schema: schema2, schemaId, root, baseId });
      }
      if (_sch === void 0)
        return;
      return root.refs[ref] = inlineOrCompile.call(this, _sch);
    }
    exports2.resolveRef = resolveRef;
    function inlineOrCompile(sch) {
      if ((0, resolve_1.inlineRef)(sch.schema, this.opts.inlineRefs))
        return sch.schema;
      return sch.validate ? sch : compileSchema.call(this, sch);
    }
    function getCompilingSchema(schEnv) {
      for (const sch of this._compilations) {
        if (sameSchemaEnv(sch, schEnv))
          return sch;
      }
    }
    exports2.getCompilingSchema = getCompilingSchema;
    function sameSchemaEnv(s1, s2) {
      return s1.schema === s2.schema && s1.root === s2.root && s1.baseId === s2.baseId;
    }
    function resolve(root, ref) {
      let sch;
      while (typeof (sch = this.refs[ref]) == "string")
        ref = sch;
      return sch || this.schemas[ref] || resolveSchema.call(this, root, ref);
    }
    function resolveSchema(root, ref) {
      const p = this.opts.uriResolver.parse(ref);
      const refPath = (0, resolve_1._getFullPath)(this.opts.uriResolver, p);
      let baseId = (0, resolve_1.getFullPath)(this.opts.uriResolver, root.baseId, void 0);
      if (Object.keys(root.schema).length > 0 && refPath === baseId) {
        return getJsonPointer.call(this, p, root);
      }
      const id = (0, resolve_1.normalizeId)(refPath);
      const schOrRef = this.refs[id] || this.schemas[id];
      if (typeof schOrRef == "string") {
        const sch = resolveSchema.call(this, root, schOrRef);
        if (typeof (sch === null || sch === void 0 ? void 0 : sch.schema) !== "object")
          return;
        return getJsonPointer.call(this, p, sch);
      }
      if (typeof (schOrRef === null || schOrRef === void 0 ? void 0 : schOrRef.schema) !== "object")
        return;
      if (!schOrRef.validate)
        compileSchema.call(this, schOrRef);
      if (id === (0, resolve_1.normalizeId)(ref)) {
        const { schema: schema2 } = schOrRef;
        const { schemaId } = this.opts;
        const schId = schema2[schemaId];
        if (schId)
          baseId = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schId);
        return new SchemaEnv({ schema: schema2, schemaId, root, baseId });
      }
      return getJsonPointer.call(this, p, schOrRef);
    }
    exports2.resolveSchema = resolveSchema;
    var PREVENT_SCOPE_CHANGE = /* @__PURE__ */ new Set([
      "properties",
      "patternProperties",
      "enum",
      "dependencies",
      "definitions"
    ]);
    function getJsonPointer(parsedRef, { baseId, schema: schema2, root }) {
      var _a;
      if (((_a = parsedRef.fragment) === null || _a === void 0 ? void 0 : _a[0]) !== "/")
        return;
      for (const part of parsedRef.fragment.slice(1).split("/")) {
        if (typeof schema2 === "boolean")
          return;
        const partSchema = schema2[(0, util_1.unescapeFragment)(part)];
        if (partSchema === void 0)
          return;
        schema2 = partSchema;
        const schId = typeof schema2 === "object" && schema2[this.opts.schemaId];
        if (!PREVENT_SCOPE_CHANGE.has(part) && schId) {
          baseId = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schId);
        }
      }
      let env;
      if (typeof schema2 != "boolean" && schema2.$ref && !(0, util_1.schemaHasRulesButRef)(schema2, this.RULES)) {
        const $ref = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schema2.$ref);
        env = resolveSchema.call(this, root, $ref);
      }
      const { schemaId } = this.opts;
      env = env || new SchemaEnv({ schema: schema2, schemaId, root, baseId });
      if (env.schema !== env.root.schema)
        return env;
      return void 0;
    }
  }
});

// node_modules/ajv/dist/refs/data.json
var require_data = __commonJS({
  "node_modules/ajv/dist/refs/data.json"(exports2, module2) {
    module2.exports = {
      $id: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#",
      description: "Meta-schema for $data reference (JSON AnySchema extension proposal)",
      type: "object",
      required: ["$data"],
      properties: {
        $data: {
          type: "string",
          anyOf: [{ format: "relative-json-pointer" }, { format: "json-pointer" }]
        }
      },
      additionalProperties: false
    };
  }
});

// node_modules/uri-js/dist/es5/uri.all.js
var require_uri_all = __commonJS({
  "node_modules/uri-js/dist/es5/uri.all.js"(exports2, module2) {
    (function(global2, factory) {
      typeof exports2 === "object" && typeof module2 !== "undefined" ? factory(exports2) : typeof define === "function" && define.amd ? define(["exports"], factory) : factory(global2.URI = global2.URI || {});
    })(exports2, function(exports3) {
      "use strict";
      function merge2() {
        for (var _len = arguments.length, sets = Array(_len), _key = 0; _key < _len; _key++) {
          sets[_key] = arguments[_key];
        }
        if (sets.length > 1) {
          sets[0] = sets[0].slice(0, -1);
          var xl = sets.length - 1;
          for (var x = 1; x < xl; ++x) {
            sets[x] = sets[x].slice(1, -1);
          }
          sets[xl] = sets[xl].slice(1);
          return sets.join("");
        } else {
          return sets[0];
        }
      }
      function subexp(str2) {
        return "(?:" + str2 + ")";
      }
      function typeOf(o) {
        return o === void 0 ? "undefined" : o === null ? "null" : Object.prototype.toString.call(o).split(" ").pop().split("]").shift().toLowerCase();
      }
      function toUpperCase(str2) {
        return str2.toUpperCase();
      }
      function toArray2(obj) {
        return obj !== void 0 && obj !== null ? obj instanceof Array ? obj : typeof obj.length !== "number" || obj.split || obj.setInterval || obj.call ? [obj] : Array.prototype.slice.call(obj) : [];
      }
      function assign(target, source) {
        var obj = target;
        if (source) {
          for (var key in source) {
            obj[key] = source[key];
          }
        }
        return obj;
      }
      function buildExps(isIRI2) {
        var ALPHA$$ = "[A-Za-z]", CR$ = "[\\x0D]", DIGIT$$ = "[0-9]", DQUOTE$$ = "[\\x22]", HEXDIG$$2 = merge2(DIGIT$$, "[A-Fa-f]"), LF$$ = "[\\x0A]", SP$$ = "[\\x20]", PCT_ENCODED$2 = subexp(subexp("%[EFef]" + HEXDIG$$2 + "%" + HEXDIG$$2 + HEXDIG$$2 + "%" + HEXDIG$$2 + HEXDIG$$2) + "|" + subexp("%[89A-Fa-f]" + HEXDIG$$2 + "%" + HEXDIG$$2 + HEXDIG$$2) + "|" + subexp("%" + HEXDIG$$2 + HEXDIG$$2)), GEN_DELIMS$$ = "[\\:\\/\\?\\#\\[\\]\\@]", SUB_DELIMS$$ = "[\\!\\$\\&\\'\\(\\)\\*\\+\\,\\;\\=]", RESERVED$$ = merge2(GEN_DELIMS$$, SUB_DELIMS$$), UCSCHAR$$ = isIRI2 ? "[\\xA0-\\u200D\\u2010-\\u2029\\u202F-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]" : "[]", IPRIVATE$$ = isIRI2 ? "[\\uE000-\\uF8FF]" : "[]", UNRESERVED$$2 = merge2(ALPHA$$, DIGIT$$, "[\\-\\.\\_\\~]", UCSCHAR$$), SCHEME$ = subexp(ALPHA$$ + merge2(ALPHA$$, DIGIT$$, "[\\+\\-\\.]") + "*"), USERINFO$ = subexp(subexp(PCT_ENCODED$2 + "|" + merge2(UNRESERVED$$2, SUB_DELIMS$$, "[\\:]")) + "*"), DEC_OCTET$ = subexp(subexp("25[0-5]") + "|" + subexp("2[0-4]" + DIGIT$$) + "|" + subexp("1" + DIGIT$$ + DIGIT$$) + "|" + subexp("[1-9]" + DIGIT$$) + "|" + DIGIT$$), DEC_OCTET_RELAXED$ = subexp(subexp("25[0-5]") + "|" + subexp("2[0-4]" + DIGIT$$) + "|" + subexp("1" + DIGIT$$ + DIGIT$$) + "|" + subexp("0?[1-9]" + DIGIT$$) + "|0?0?" + DIGIT$$), IPV4ADDRESS$ = subexp(DEC_OCTET_RELAXED$ + "\\." + DEC_OCTET_RELAXED$ + "\\." + DEC_OCTET_RELAXED$ + "\\." + DEC_OCTET_RELAXED$), H16$ = subexp(HEXDIG$$2 + "{1,4}"), LS32$ = subexp(subexp(H16$ + "\\:" + H16$) + "|" + IPV4ADDRESS$), IPV6ADDRESS1$ = subexp(subexp(H16$ + "\\:") + "{6}" + LS32$), IPV6ADDRESS2$ = subexp("\\:\\:" + subexp(H16$ + "\\:") + "{5}" + LS32$), IPV6ADDRESS3$ = subexp(subexp(H16$) + "?\\:\\:" + subexp(H16$ + "\\:") + "{4}" + LS32$), IPV6ADDRESS4$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,1}" + H16$) + "?\\:\\:" + subexp(H16$ + "\\:") + "{3}" + LS32$), IPV6ADDRESS5$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,2}" + H16$) + "?\\:\\:" + subexp(H16$ + "\\:") + "{2}" + LS32$), IPV6ADDRESS6$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,3}" + H16$) + "?\\:\\:" + H16$ + "\\:" + LS32$), IPV6ADDRESS7$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,4}" + H16$) + "?\\:\\:" + LS32$), IPV6ADDRESS8$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,5}" + H16$) + "?\\:\\:" + H16$), IPV6ADDRESS9$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,6}" + H16$) + "?\\:\\:"), IPV6ADDRESS$ = subexp([IPV6ADDRESS1$, IPV6ADDRESS2$, IPV6ADDRESS3$, IPV6ADDRESS4$, IPV6ADDRESS5$, IPV6ADDRESS6$, IPV6ADDRESS7$, IPV6ADDRESS8$, IPV6ADDRESS9$].join("|")), ZONEID$ = subexp(subexp(UNRESERVED$$2 + "|" + PCT_ENCODED$2) + "+"), IPV6ADDRZ$ = subexp(IPV6ADDRESS$ + "\\%25" + ZONEID$), IPV6ADDRZ_RELAXED$ = subexp(IPV6ADDRESS$ + subexp("\\%25|\\%(?!" + HEXDIG$$2 + "{2})") + ZONEID$), IPVFUTURE$ = subexp("[vV]" + HEXDIG$$2 + "+\\." + merge2(UNRESERVED$$2, SUB_DELIMS$$, "[\\:]") + "+"), IP_LITERAL$ = subexp("\\[" + subexp(IPV6ADDRZ_RELAXED$ + "|" + IPV6ADDRESS$ + "|" + IPVFUTURE$) + "\\]"), REG_NAME$ = subexp(subexp(PCT_ENCODED$2 + "|" + merge2(UNRESERVED$$2, SUB_DELIMS$$)) + "*"), HOST$ = subexp(IP_LITERAL$ + "|" + IPV4ADDRESS$ + "(?!" + REG_NAME$ + ")|" + REG_NAME$), PORT$ = subexp(DIGIT$$ + "*"), AUTHORITY$ = subexp(subexp(USERINFO$ + "@") + "?" + HOST$ + subexp("\\:" + PORT$) + "?"), PCHAR$ = subexp(PCT_ENCODED$2 + "|" + merge2(UNRESERVED$$2, SUB_DELIMS$$, "[\\:\\@]")), SEGMENT$ = subexp(PCHAR$ + "*"), SEGMENT_NZ$ = subexp(PCHAR$ + "+"), SEGMENT_NZ_NC$ = subexp(subexp(PCT_ENCODED$2 + "|" + merge2(UNRESERVED$$2, SUB_DELIMS$$, "[\\@]")) + "+"), PATH_ABEMPTY$ = subexp(subexp("\\/" + SEGMENT$) + "*"), PATH_ABSOLUTE$ = subexp("\\/" + subexp(SEGMENT_NZ$ + PATH_ABEMPTY$) + "?"), PATH_NOSCHEME$ = subexp(SEGMENT_NZ_NC$ + PATH_ABEMPTY$), PATH_ROOTLESS$ = subexp(SEGMENT_NZ$ + PATH_ABEMPTY$), PATH_EMPTY$ = "(?!" + PCHAR$ + ")", PATH$ = subexp(PATH_ABEMPTY$ + "|" + PATH_ABSOLUTE$ + "|" + PATH_NOSCHEME$ + "|" + PATH_ROOTLESS$ + "|" + PATH_EMPTY$), QUERY$ = subexp(subexp(PCHAR$ + "|" + merge2("[\\/\\?]", IPRIVATE$$)) + "*"), FRAGMENT$ = subexp(subexp(PCHAR$ + "|[\\/\\?]") + "*"), HIER_PART$ = subexp(subexp("\\/\\/" + AUTHORITY$ + PATH_ABEMPTY$) + "|" + PATH_ABSOLUTE$ + "|" + PATH_ROOTLESS$ + "|" + PATH_EMPTY$), URI$ = subexp(SCHEME$ + "\\:" + HIER_PART$ + subexp("\\?" + QUERY$) + "?" + subexp("\\#" + FRAGMENT$) + "?"), RELATIVE_PART$ = subexp(subexp("\\/\\/" + AUTHORITY$ + PATH_ABEMPTY$) + "|" + PATH_ABSOLUTE$ + "|" + PATH_NOSCHEME$ + "|" + PATH_EMPTY$), RELATIVE$ = subexp(RELATIVE_PART$ + subexp("\\?" + QUERY$) + "?" + subexp("\\#" + FRAGMENT$) + "?"), URI_REFERENCE$ = subexp(URI$ + "|" + RELATIVE$), ABSOLUTE_URI$ = subexp(SCHEME$ + "\\:" + HIER_PART$ + subexp("\\?" + QUERY$) + "?"), GENERIC_REF$ = "^(" + SCHEME$ + ")\\:" + subexp(subexp("\\/\\/(" + subexp("(" + USERINFO$ + ")@") + "?(" + HOST$ + ")" + subexp("\\:(" + PORT$ + ")") + "?)") + "?(" + PATH_ABEMPTY$ + "|" + PATH_ABSOLUTE$ + "|" + PATH_ROOTLESS$ + "|" + PATH_EMPTY$ + ")") + subexp("\\?(" + QUERY$ + ")") + "?" + subexp("\\#(" + FRAGMENT$ + ")") + "?$", RELATIVE_REF$ = "^(){0}" + subexp(subexp("\\/\\/(" + subexp("(" + USERINFO$ + ")@") + "?(" + HOST$ + ")" + subexp("\\:(" + PORT$ + ")") + "?)") + "?(" + PATH_ABEMPTY$ + "|" + PATH_ABSOLUTE$ + "|" + PATH_NOSCHEME$ + "|" + PATH_EMPTY$ + ")") + subexp("\\?(" + QUERY$ + ")") + "?" + subexp("\\#(" + FRAGMENT$ + ")") + "?$", ABSOLUTE_REF$ = "^(" + SCHEME$ + ")\\:" + subexp(subexp("\\/\\/(" + subexp("(" + USERINFO$ + ")@") + "?(" + HOST$ + ")" + subexp("\\:(" + PORT$ + ")") + "?)") + "?(" + PATH_ABEMPTY$ + "|" + PATH_ABSOLUTE$ + "|" + PATH_ROOTLESS$ + "|" + PATH_EMPTY$ + ")") + subexp("\\?(" + QUERY$ + ")") + "?$", SAMEDOC_REF$ = "^" + subexp("\\#(" + FRAGMENT$ + ")") + "?$", AUTHORITY_REF$ = "^" + subexp("(" + USERINFO$ + ")@") + "?(" + HOST$ + ")" + subexp("\\:(" + PORT$ + ")") + "?$";
        return {
          NOT_SCHEME: new RegExp(merge2("[^]", ALPHA$$, DIGIT$$, "[\\+\\-\\.]"), "g"),
          NOT_USERINFO: new RegExp(merge2("[^\\%\\:]", UNRESERVED$$2, SUB_DELIMS$$), "g"),
          NOT_HOST: new RegExp(merge2("[^\\%\\[\\]\\:]", UNRESERVED$$2, SUB_DELIMS$$), "g"),
          NOT_PATH: new RegExp(merge2("[^\\%\\/\\:\\@]", UNRESERVED$$2, SUB_DELIMS$$), "g"),
          NOT_PATH_NOSCHEME: new RegExp(merge2("[^\\%\\/\\@]", UNRESERVED$$2, SUB_DELIMS$$), "g"),
          NOT_QUERY: new RegExp(merge2("[^\\%]", UNRESERVED$$2, SUB_DELIMS$$, "[\\:\\@\\/\\?]", IPRIVATE$$), "g"),
          NOT_FRAGMENT: new RegExp(merge2("[^\\%]", UNRESERVED$$2, SUB_DELIMS$$, "[\\:\\@\\/\\?]"), "g"),
          ESCAPE: new RegExp(merge2("[^]", UNRESERVED$$2, SUB_DELIMS$$), "g"),
          UNRESERVED: new RegExp(UNRESERVED$$2, "g"),
          OTHER_CHARS: new RegExp(merge2("[^\\%]", UNRESERVED$$2, RESERVED$$), "g"),
          PCT_ENCODED: new RegExp(PCT_ENCODED$2, "g"),
          IPV4ADDRESS: new RegExp("^(" + IPV4ADDRESS$ + ")$"),
          IPV6ADDRESS: new RegExp("^\\[?(" + IPV6ADDRESS$ + ")" + subexp(subexp("\\%25|\\%(?!" + HEXDIG$$2 + "{2})") + "(" + ZONEID$ + ")") + "?\\]?$")
          //RFC 6874, with relaxed parsing rules
        };
      }
      var URI_PROTOCOL = buildExps(false);
      var IRI_PROTOCOL = buildExps(true);
      var slicedToArray = /* @__PURE__ */ function() {
        function sliceIterator(arr, i) {
          var _arr = [];
          var _n = true;
          var _d = false;
          var _e = void 0;
          try {
            for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
              _arr.push(_s.value);
              if (i && _arr.length === i) break;
            }
          } catch (err) {
            _d = true;
            _e = err;
          } finally {
            try {
              if (!_n && _i["return"]) _i["return"]();
            } finally {
              if (_d) throw _e;
            }
          }
          return _arr;
        }
        return function(arr, i) {
          if (Array.isArray(arr)) {
            return arr;
          } else if (Symbol.iterator in Object(arr)) {
            return sliceIterator(arr, i);
          } else {
            throw new TypeError("Invalid attempt to destructure non-iterable instance");
          }
        };
      }();
      var toConsumableArray = function(arr) {
        if (Array.isArray(arr)) {
          for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];
          return arr2;
        } else {
          return Array.from(arr);
        }
      };
      var maxInt = 2147483647;
      var base = 36;
      var tMin = 1;
      var tMax = 26;
      var skew = 38;
      var damp = 700;
      var initialBias = 72;
      var initialN = 128;
      var delimiter = "-";
      var regexPunycode = /^xn--/;
      var regexNonASCII = /[^\0-\x7E]/;
      var regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g;
      var errors = {
        "overflow": "Overflow: input needs wider integers to process",
        "not-basic": "Illegal input >= 0x80 (not a basic code point)",
        "invalid-input": "Invalid input"
      };
      var baseMinusTMin = base - tMin;
      var floor = Math.floor;
      var stringFromCharCode = String.fromCharCode;
      function error$1(type2) {
        throw new RangeError(errors[type2]);
      }
      function map2(array, fn) {
        var result = [];
        var length = array.length;
        while (length--) {
          result[length] = fn(array[length]);
        }
        return result;
      }
      function mapDomain(string, fn) {
        var parts = string.split("@");
        var result = "";
        if (parts.length > 1) {
          result = parts[0] + "@";
          string = parts[1];
        }
        string = string.replace(regexSeparators, ".");
        var labels = string.split(".");
        var encoded = map2(labels, fn).join(".");
        return result + encoded;
      }
      function ucs2decode(string) {
        var output = [];
        var counter = 0;
        var length = string.length;
        while (counter < length) {
          var value = string.charCodeAt(counter++);
          if (value >= 55296 && value <= 56319 && counter < length) {
            var extra = string.charCodeAt(counter++);
            if ((extra & 64512) == 56320) {
              output.push(((value & 1023) << 10) + (extra & 1023) + 65536);
            } else {
              output.push(value);
              counter--;
            }
          } else {
            output.push(value);
          }
        }
        return output;
      }
      var ucs2encode = function ucs2encode2(array) {
        return String.fromCodePoint.apply(String, toConsumableArray(array));
      };
      var basicToDigit = function basicToDigit2(codePoint) {
        if (codePoint - 48 < 10) {
          return codePoint - 22;
        }
        if (codePoint - 65 < 26) {
          return codePoint - 65;
        }
        if (codePoint - 97 < 26) {
          return codePoint - 97;
        }
        return base;
      };
      var digitToBasic = function digitToBasic2(digit, flag) {
        return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
      };
      var adapt = function adapt2(delta, numPoints, firstTime) {
        var k = 0;
        delta = firstTime ? floor(delta / damp) : delta >> 1;
        delta += floor(delta / numPoints);
        for (
          ;
          /* no initialization */
          delta > baseMinusTMin * tMax >> 1;
          k += base
        ) {
          delta = floor(delta / baseMinusTMin);
        }
        return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
      };
      var decode = function decode2(input) {
        var output = [];
        var inputLength = input.length;
        var i = 0;
        var n = initialN;
        var bias = initialBias;
        var basic = input.lastIndexOf(delimiter);
        if (basic < 0) {
          basic = 0;
        }
        for (var j = 0; j < basic; ++j) {
          if (input.charCodeAt(j) >= 128) {
            error$1("not-basic");
          }
          output.push(input.charCodeAt(j));
        }
        for (var index = basic > 0 ? basic + 1 : 0; index < inputLength; ) {
          var oldi = i;
          for (
            var w = 1, k = base;
            ;
            /* no condition */
            k += base
          ) {
            if (index >= inputLength) {
              error$1("invalid-input");
            }
            var digit = basicToDigit(input.charCodeAt(index++));
            if (digit >= base || digit > floor((maxInt - i) / w)) {
              error$1("overflow");
            }
            i += digit * w;
            var t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
            if (digit < t) {
              break;
            }
            var baseMinusT = base - t;
            if (w > floor(maxInt / baseMinusT)) {
              error$1("overflow");
            }
            w *= baseMinusT;
          }
          var out = output.length + 1;
          bias = adapt(i - oldi, out, oldi == 0);
          if (floor(i / out) > maxInt - n) {
            error$1("overflow");
          }
          n += floor(i / out);
          i %= out;
          output.splice(i++, 0, n);
        }
        return String.fromCodePoint.apply(String, output);
      };
      var encode = function encode2(input) {
        var output = [];
        input = ucs2decode(input);
        var inputLength = input.length;
        var n = initialN;
        var delta = 0;
        var bias = initialBias;
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = void 0;
        try {
          for (var _iterator = input[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var _currentValue2 = _step.value;
            if (_currentValue2 < 128) {
              output.push(stringFromCharCode(_currentValue2));
            }
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator.return) {
              _iterator.return();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }
        var basicLength = output.length;
        var handledCPCount = basicLength;
        if (basicLength) {
          output.push(delimiter);
        }
        while (handledCPCount < inputLength) {
          var m = maxInt;
          var _iteratorNormalCompletion2 = true;
          var _didIteratorError2 = false;
          var _iteratorError2 = void 0;
          try {
            for (var _iterator2 = input[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
              var currentValue = _step2.value;
              if (currentValue >= n && currentValue < m) {
                m = currentValue;
              }
            }
          } catch (err) {
            _didIteratorError2 = true;
            _iteratorError2 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion2 && _iterator2.return) {
                _iterator2.return();
              }
            } finally {
              if (_didIteratorError2) {
                throw _iteratorError2;
              }
            }
          }
          var handledCPCountPlusOne = handledCPCount + 1;
          if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
            error$1("overflow");
          }
          delta += (m - n) * handledCPCountPlusOne;
          n = m;
          var _iteratorNormalCompletion3 = true;
          var _didIteratorError3 = false;
          var _iteratorError3 = void 0;
          try {
            for (var _iterator3 = input[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
              var _currentValue = _step3.value;
              if (_currentValue < n && ++delta > maxInt) {
                error$1("overflow");
              }
              if (_currentValue == n) {
                var q = delta;
                for (
                  var k = base;
                  ;
                  /* no condition */
                  k += base
                ) {
                  var t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
                  if (q < t) {
                    break;
                  }
                  var qMinusT = q - t;
                  var baseMinusT = base - t;
                  output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0)));
                  q = floor(qMinusT / baseMinusT);
                }
                output.push(stringFromCharCode(digitToBasic(q, 0)));
                bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
                delta = 0;
                ++handledCPCount;
              }
            }
          } catch (err) {
            _didIteratorError3 = true;
            _iteratorError3 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion3 && _iterator3.return) {
                _iterator3.return();
              }
            } finally {
              if (_didIteratorError3) {
                throw _iteratorError3;
              }
            }
          }
          ++delta;
          ++n;
        }
        return output.join("");
      };
      var toUnicode = function toUnicode2(input) {
        return mapDomain(input, function(string) {
          return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;
        });
      };
      var toASCII = function toASCII2(input) {
        return mapDomain(input, function(string) {
          return regexNonASCII.test(string) ? "xn--" + encode(string) : string;
        });
      };
      var punycode = {
        /**
         * A string representing the current Punycode.js version number.
         * @memberOf punycode
         * @type String
         */
        "version": "2.1.0",
        /**
         * An object of methods to convert from JavaScript's internal character
         * representation (UCS-2) to Unicode code points, and back.
         * @see <https://mathiasbynens.be/notes/javascript-encoding>
         * @memberOf punycode
         * @type Object
         */
        "ucs2": {
          "decode": ucs2decode,
          "encode": ucs2encode
        },
        "decode": decode,
        "encode": encode,
        "toASCII": toASCII,
        "toUnicode": toUnicode
      };
      var SCHEMES = {};
      function pctEncChar(chr) {
        var c2 = chr.charCodeAt(0);
        var e = void 0;
        if (c2 < 16) e = "%0" + c2.toString(16).toUpperCase();
        else if (c2 < 128) e = "%" + c2.toString(16).toUpperCase();
        else if (c2 < 2048) e = "%" + (c2 >> 6 | 192).toString(16).toUpperCase() + "%" + (c2 & 63 | 128).toString(16).toUpperCase();
        else e = "%" + (c2 >> 12 | 224).toString(16).toUpperCase() + "%" + (c2 >> 6 & 63 | 128).toString(16).toUpperCase() + "%" + (c2 & 63 | 128).toString(16).toUpperCase();
        return e;
      }
      function pctDecChars(str2) {
        var newStr = "";
        var i = 0;
        var il = str2.length;
        while (i < il) {
          var c2 = parseInt(str2.substr(i + 1, 2), 16);
          if (c2 < 128) {
            newStr += String.fromCharCode(c2);
            i += 3;
          } else if (c2 >= 194 && c2 < 224) {
            if (il - i >= 6) {
              var c22 = parseInt(str2.substr(i + 4, 2), 16);
              newStr += String.fromCharCode((c2 & 31) << 6 | c22 & 63);
            } else {
              newStr += str2.substr(i, 6);
            }
            i += 6;
          } else if (c2 >= 224) {
            if (il - i >= 9) {
              var _c = parseInt(str2.substr(i + 4, 2), 16);
              var c3 = parseInt(str2.substr(i + 7, 2), 16);
              newStr += String.fromCharCode((c2 & 15) << 12 | (_c & 63) << 6 | c3 & 63);
            } else {
              newStr += str2.substr(i, 9);
            }
            i += 9;
          } else {
            newStr += str2.substr(i, 3);
            i += 3;
          }
        }
        return newStr;
      }
      function _normalizeComponentEncoding(components, protocol) {
        function decodeUnreserved2(str2) {
          var decStr = pctDecChars(str2);
          return !decStr.match(protocol.UNRESERVED) ? str2 : decStr;
        }
        if (components.scheme) components.scheme = String(components.scheme).replace(protocol.PCT_ENCODED, decodeUnreserved2).toLowerCase().replace(protocol.NOT_SCHEME, "");
        if (components.userinfo !== void 0) components.userinfo = String(components.userinfo).replace(protocol.PCT_ENCODED, decodeUnreserved2).replace(protocol.NOT_USERINFO, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
        if (components.host !== void 0) components.host = String(components.host).replace(protocol.PCT_ENCODED, decodeUnreserved2).toLowerCase().replace(protocol.NOT_HOST, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
        if (components.path !== void 0) components.path = String(components.path).replace(protocol.PCT_ENCODED, decodeUnreserved2).replace(components.scheme ? protocol.NOT_PATH : protocol.NOT_PATH_NOSCHEME, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
        if (components.query !== void 0) components.query = String(components.query).replace(protocol.PCT_ENCODED, decodeUnreserved2).replace(protocol.NOT_QUERY, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
        if (components.fragment !== void 0) components.fragment = String(components.fragment).replace(protocol.PCT_ENCODED, decodeUnreserved2).replace(protocol.NOT_FRAGMENT, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
        return components;
      }
      function _stripLeadingZeros(str2) {
        return str2.replace(/^0*(.*)/, "$1") || "0";
      }
      function _normalizeIPv4(host, protocol) {
        var matches = host.match(protocol.IPV4ADDRESS) || [];
        var _matches = slicedToArray(matches, 2), address = _matches[1];
        if (address) {
          return address.split(".").map(_stripLeadingZeros).join(".");
        } else {
          return host;
        }
      }
      function _normalizeIPv6(host, protocol) {
        var matches = host.match(protocol.IPV6ADDRESS) || [];
        var _matches2 = slicedToArray(matches, 3), address = _matches2[1], zone = _matches2[2];
        if (address) {
          var _address$toLowerCase$ = address.toLowerCase().split("::").reverse(), _address$toLowerCase$2 = slicedToArray(_address$toLowerCase$, 2), last = _address$toLowerCase$2[0], first = _address$toLowerCase$2[1];
          var firstFields = first ? first.split(":").map(_stripLeadingZeros) : [];
          var lastFields = last.split(":").map(_stripLeadingZeros);
          var isLastFieldIPv4Address = protocol.IPV4ADDRESS.test(lastFields[lastFields.length - 1]);
          var fieldCount = isLastFieldIPv4Address ? 7 : 8;
          var lastFieldsStart = lastFields.length - fieldCount;
          var fields = Array(fieldCount);
          for (var x = 0; x < fieldCount; ++x) {
            fields[x] = firstFields[x] || lastFields[lastFieldsStart + x] || "";
          }
          if (isLastFieldIPv4Address) {
            fields[fieldCount - 1] = _normalizeIPv4(fields[fieldCount - 1], protocol);
          }
          var allZeroFields = fields.reduce(function(acc, field, index) {
            if (!field || field === "0") {
              var lastLongest = acc[acc.length - 1];
              if (lastLongest && lastLongest.index + lastLongest.length === index) {
                lastLongest.length++;
              } else {
                acc.push({ index, length: 1 });
              }
            }
            return acc;
          }, []);
          var longestZeroFields = allZeroFields.sort(function(a, b) {
            return b.length - a.length;
          })[0];
          var newHost = void 0;
          if (longestZeroFields && longestZeroFields.length > 1) {
            var newFirst = fields.slice(0, longestZeroFields.index);
            var newLast = fields.slice(longestZeroFields.index + longestZeroFields.length);
            newHost = newFirst.join(":") + "::" + newLast.join(":");
          } else {
            newHost = fields.join(":");
          }
          if (zone) {
            newHost += "%" + zone;
          }
          return newHost;
        } else {
          return host;
        }
      }
      var URI_PARSE = /^(?:([^:\/?#]+):)?(?:\/\/((?:([^\/?#@]*)@)?(\[[^\/?#\]]+\]|[^\/?#:]*)(?:\:(\d*))?))?([^?#]*)(?:\?([^#]*))?(?:#((?:.|\n|\r)*))?/i;
      var NO_MATCH_IS_UNDEFINED = "".match(/(){0}/)[1] === void 0;
      function parse6(uriString) {
        var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        var components = {};
        var protocol = options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL;
        if (options.reference === "suffix") uriString = (options.scheme ? options.scheme + ":" : "") + "//" + uriString;
        var matches = uriString.match(URI_PARSE);
        if (matches) {
          if (NO_MATCH_IS_UNDEFINED) {
            components.scheme = matches[1];
            components.userinfo = matches[3];
            components.host = matches[4];
            components.port = parseInt(matches[5], 10);
            components.path = matches[6] || "";
            components.query = matches[7];
            components.fragment = matches[8];
            if (isNaN(components.port)) {
              components.port = matches[5];
            }
          } else {
            components.scheme = matches[1] || void 0;
            components.userinfo = uriString.indexOf("@") !== -1 ? matches[3] : void 0;
            components.host = uriString.indexOf("//") !== -1 ? matches[4] : void 0;
            components.port = parseInt(matches[5], 10);
            components.path = matches[6] || "";
            components.query = uriString.indexOf("?") !== -1 ? matches[7] : void 0;
            components.fragment = uriString.indexOf("#") !== -1 ? matches[8] : void 0;
            if (isNaN(components.port)) {
              components.port = uriString.match(/\/\/(?:.|\n)*\:(?:\/|\?|\#|$)/) ? matches[4] : void 0;
            }
          }
          if (components.host) {
            components.host = _normalizeIPv6(_normalizeIPv4(components.host, protocol), protocol);
          }
          if (components.scheme === void 0 && components.userinfo === void 0 && components.host === void 0 && components.port === void 0 && !components.path && components.query === void 0) {
            components.reference = "same-document";
          } else if (components.scheme === void 0) {
            components.reference = "relative";
          } else if (components.fragment === void 0) {
            components.reference = "absolute";
          } else {
            components.reference = "uri";
          }
          if (options.reference && options.reference !== "suffix" && options.reference !== components.reference) {
            components.error = components.error || "URI is not a " + options.reference + " reference.";
          }
          var schemeHandler = SCHEMES[(options.scheme || components.scheme || "").toLowerCase()];
          if (!options.unicodeSupport && (!schemeHandler || !schemeHandler.unicodeSupport)) {
            if (components.host && (options.domainHost || schemeHandler && schemeHandler.domainHost)) {
              try {
                components.host = punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase());
              } catch (e) {
                components.error = components.error || "Host's domain name can not be converted to ASCII via punycode: " + e;
              }
            }
            _normalizeComponentEncoding(components, URI_PROTOCOL);
          } else {
            _normalizeComponentEncoding(components, protocol);
          }
          if (schemeHandler && schemeHandler.parse) {
            schemeHandler.parse(components, options);
          }
        } else {
          components.error = components.error || "URI can not be parsed.";
        }
        return components;
      }
      function _recomposeAuthority(components, options) {
        var protocol = options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL;
        var uriTokens = [];
        if (components.userinfo !== void 0) {
          uriTokens.push(components.userinfo);
          uriTokens.push("@");
        }
        if (components.host !== void 0) {
          uriTokens.push(_normalizeIPv6(_normalizeIPv4(String(components.host), protocol), protocol).replace(protocol.IPV6ADDRESS, function(_, $1, $2) {
            return "[" + $1 + ($2 ? "%25" + $2 : "") + "]";
          }));
        }
        if (typeof components.port === "number" || typeof components.port === "string") {
          uriTokens.push(":");
          uriTokens.push(String(components.port));
        }
        return uriTokens.length ? uriTokens.join("") : void 0;
      }
      var RDS1 = /^\.\.?\//;
      var RDS2 = /^\/\.(\/|$)/;
      var RDS3 = /^\/\.\.(\/|$)/;
      var RDS5 = /^\/?(?:.|\n)*?(?=\/|$)/;
      function removeDotSegments(input) {
        var output = [];
        while (input.length) {
          if (input.match(RDS1)) {
            input = input.replace(RDS1, "");
          } else if (input.match(RDS2)) {
            input = input.replace(RDS2, "/");
          } else if (input.match(RDS3)) {
            input = input.replace(RDS3, "/");
            output.pop();
          } else if (input === "." || input === "..") {
            input = "";
          } else {
            var im = input.match(RDS5);
            if (im) {
              var s = im[0];
              input = input.slice(s.length);
              output.push(s);
            } else {
              throw new Error("Unexpected dot segment condition");
            }
          }
        }
        return output.join("");
      }
      function serialize(components) {
        var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        var protocol = options.iri ? IRI_PROTOCOL : URI_PROTOCOL;
        var uriTokens = [];
        var schemeHandler = SCHEMES[(options.scheme || components.scheme || "").toLowerCase()];
        if (schemeHandler && schemeHandler.serialize) schemeHandler.serialize(components, options);
        if (components.host) {
          if (protocol.IPV6ADDRESS.test(components.host)) {
          } else if (options.domainHost || schemeHandler && schemeHandler.domainHost) {
            try {
              components.host = !options.iri ? punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase()) : punycode.toUnicode(components.host);
            } catch (e) {
              components.error = components.error || "Host's domain name can not be converted to " + (!options.iri ? "ASCII" : "Unicode") + " via punycode: " + e;
            }
          }
        }
        _normalizeComponentEncoding(components, protocol);
        if (options.reference !== "suffix" && components.scheme) {
          uriTokens.push(components.scheme);
          uriTokens.push(":");
        }
        var authority = _recomposeAuthority(components, options);
        if (authority !== void 0) {
          if (options.reference !== "suffix") {
            uriTokens.push("//");
          }
          uriTokens.push(authority);
          if (components.path && components.path.charAt(0) !== "/") {
            uriTokens.push("/");
          }
        }
        if (components.path !== void 0) {
          var s = components.path;
          if (!options.absolutePath && (!schemeHandler || !schemeHandler.absolutePath)) {
            s = removeDotSegments(s);
          }
          if (authority === void 0) {
            s = s.replace(/^\/\//, "/%2F");
          }
          uriTokens.push(s);
        }
        if (components.query !== void 0) {
          uriTokens.push("?");
          uriTokens.push(components.query);
        }
        if (components.fragment !== void 0) {
          uriTokens.push("#");
          uriTokens.push(components.fragment);
        }
        return uriTokens.join("");
      }
      function resolveComponents(base2, relative) {
        var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        var skipNormalization = arguments[3];
        var target = {};
        if (!skipNormalization) {
          base2 = parse6(serialize(base2, options), options);
          relative = parse6(serialize(relative, options), options);
        }
        options = options || {};
        if (!options.tolerant && relative.scheme) {
          target.scheme = relative.scheme;
          target.userinfo = relative.userinfo;
          target.host = relative.host;
          target.port = relative.port;
          target.path = removeDotSegments(relative.path || "");
          target.query = relative.query;
        } else {
          if (relative.userinfo !== void 0 || relative.host !== void 0 || relative.port !== void 0) {
            target.userinfo = relative.userinfo;
            target.host = relative.host;
            target.port = relative.port;
            target.path = removeDotSegments(relative.path || "");
            target.query = relative.query;
          } else {
            if (!relative.path) {
              target.path = base2.path;
              if (relative.query !== void 0) {
                target.query = relative.query;
              } else {
                target.query = base2.query;
              }
            } else {
              if (relative.path.charAt(0) === "/") {
                target.path = removeDotSegments(relative.path);
              } else {
                if ((base2.userinfo !== void 0 || base2.host !== void 0 || base2.port !== void 0) && !base2.path) {
                  target.path = "/" + relative.path;
                } else if (!base2.path) {
                  target.path = relative.path;
                } else {
                  target.path = base2.path.slice(0, base2.path.lastIndexOf("/") + 1) + relative.path;
                }
                target.path = removeDotSegments(target.path);
              }
              target.query = relative.query;
            }
            target.userinfo = base2.userinfo;
            target.host = base2.host;
            target.port = base2.port;
          }
          target.scheme = base2.scheme;
        }
        target.fragment = relative.fragment;
        return target;
      }
      function resolve(baseURI, relativeURI, options) {
        var schemelessOptions = assign({ scheme: "null" }, options);
        return serialize(resolveComponents(parse6(baseURI, schemelessOptions), parse6(relativeURI, schemelessOptions), schemelessOptions, true), schemelessOptions);
      }
      function normalize(uri, options) {
        if (typeof uri === "string") {
          uri = serialize(parse6(uri, options), options);
        } else if (typeOf(uri) === "object") {
          uri = parse6(serialize(uri, options), options);
        }
        return uri;
      }
      function equal(uriA, uriB, options) {
        if (typeof uriA === "string") {
          uriA = serialize(parse6(uriA, options), options);
        } else if (typeOf(uriA) === "object") {
          uriA = serialize(uriA, options);
        }
        if (typeof uriB === "string") {
          uriB = serialize(parse6(uriB, options), options);
        } else if (typeOf(uriB) === "object") {
          uriB = serialize(uriB, options);
        }
        return uriA === uriB;
      }
      function escapeComponent(str2, options) {
        return str2 && str2.toString().replace(!options || !options.iri ? URI_PROTOCOL.ESCAPE : IRI_PROTOCOL.ESCAPE, pctEncChar);
      }
      function unescapeComponent(str2, options) {
        return str2 && str2.toString().replace(!options || !options.iri ? URI_PROTOCOL.PCT_ENCODED : IRI_PROTOCOL.PCT_ENCODED, pctDecChars);
      }
      var handler = {
        scheme: "http",
        domainHost: true,
        parse: function parse7(components, options) {
          if (!components.host) {
            components.error = components.error || "HTTP URIs must have a host.";
          }
          return components;
        },
        serialize: function serialize2(components, options) {
          var secure = String(components.scheme).toLowerCase() === "https";
          if (components.port === (secure ? 443 : 80) || components.port === "") {
            components.port = void 0;
          }
          if (!components.path) {
            components.path = "/";
          }
          return components;
        }
      };
      var handler$1 = {
        scheme: "https",
        domainHost: handler.domainHost,
        parse: handler.parse,
        serialize: handler.serialize
      };
      function isSecure(wsComponents) {
        return typeof wsComponents.secure === "boolean" ? wsComponents.secure : String(wsComponents.scheme).toLowerCase() === "wss";
      }
      var handler$2 = {
        scheme: "ws",
        domainHost: true,
        parse: function parse7(components, options) {
          var wsComponents = components;
          wsComponents.secure = isSecure(wsComponents);
          wsComponents.resourceName = (wsComponents.path || "/") + (wsComponents.query ? "?" + wsComponents.query : "");
          wsComponents.path = void 0;
          wsComponents.query = void 0;
          return wsComponents;
        },
        serialize: function serialize2(wsComponents, options) {
          if (wsComponents.port === (isSecure(wsComponents) ? 443 : 80) || wsComponents.port === "") {
            wsComponents.port = void 0;
          }
          if (typeof wsComponents.secure === "boolean") {
            wsComponents.scheme = wsComponents.secure ? "wss" : "ws";
            wsComponents.secure = void 0;
          }
          if (wsComponents.resourceName) {
            var _wsComponents$resourc = wsComponents.resourceName.split("?"), _wsComponents$resourc2 = slicedToArray(_wsComponents$resourc, 2), path = _wsComponents$resourc2[0], query = _wsComponents$resourc2[1];
            wsComponents.path = path && path !== "/" ? path : void 0;
            wsComponents.query = query;
            wsComponents.resourceName = void 0;
          }
          wsComponents.fragment = void 0;
          return wsComponents;
        }
      };
      var handler$3 = {
        scheme: "wss",
        domainHost: handler$2.domainHost,
        parse: handler$2.parse,
        serialize: handler$2.serialize
      };
      var O = {};
      var isIRI = true;
      var UNRESERVED$$ = "[A-Za-z0-9\\-\\.\\_\\~" + (isIRI ? "\\xA0-\\u200D\\u2010-\\u2029\\u202F-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF" : "") + "]";
      var HEXDIG$$ = "[0-9A-Fa-f]";
      var PCT_ENCODED$ = subexp(subexp("%[EFef]" + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$) + "|" + subexp("%[89A-Fa-f]" + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$) + "|" + subexp("%" + HEXDIG$$ + HEXDIG$$));
      var ATEXT$$ = "[A-Za-z0-9\\!\\$\\%\\'\\*\\+\\-\\^\\_\\`\\{\\|\\}\\~]";
      var QTEXT$$ = "[\\!\\$\\%\\'\\(\\)\\*\\+\\,\\-\\.0-9\\<\\>A-Z\\x5E-\\x7E]";
      var VCHAR$$ = merge2(QTEXT$$, '[\\"\\\\]');
      var SOME_DELIMS$$ = "[\\!\\$\\'\\(\\)\\*\\+\\,\\;\\:\\@]";
      var UNRESERVED = new RegExp(UNRESERVED$$, "g");
      var PCT_ENCODED = new RegExp(PCT_ENCODED$, "g");
      var NOT_LOCAL_PART = new RegExp(merge2("[^]", ATEXT$$, "[\\.]", '[\\"]', VCHAR$$), "g");
      var NOT_HFNAME = new RegExp(merge2("[^]", UNRESERVED$$, SOME_DELIMS$$), "g");
      var NOT_HFVALUE = NOT_HFNAME;
      function decodeUnreserved(str2) {
        var decStr = pctDecChars(str2);
        return !decStr.match(UNRESERVED) ? str2 : decStr;
      }
      var handler$4 = {
        scheme: "mailto",
        parse: function parse$$1(components, options) {
          var mailtoComponents = components;
          var to = mailtoComponents.to = mailtoComponents.path ? mailtoComponents.path.split(",") : [];
          mailtoComponents.path = void 0;
          if (mailtoComponents.query) {
            var unknownHeaders = false;
            var headers = {};
            var hfields = mailtoComponents.query.split("&");
            for (var x = 0, xl = hfields.length; x < xl; ++x) {
              var hfield = hfields[x].split("=");
              switch (hfield[0]) {
                case "to":
                  var toAddrs = hfield[1].split(",");
                  for (var _x = 0, _xl = toAddrs.length; _x < _xl; ++_x) {
                    to.push(toAddrs[_x]);
                  }
                  break;
                case "subject":
                  mailtoComponents.subject = unescapeComponent(hfield[1], options);
                  break;
                case "body":
                  mailtoComponents.body = unescapeComponent(hfield[1], options);
                  break;
                default:
                  unknownHeaders = true;
                  headers[unescapeComponent(hfield[0], options)] = unescapeComponent(hfield[1], options);
                  break;
              }
            }
            if (unknownHeaders) mailtoComponents.headers = headers;
          }
          mailtoComponents.query = void 0;
          for (var _x2 = 0, _xl2 = to.length; _x2 < _xl2; ++_x2) {
            var addr = to[_x2].split("@");
            addr[0] = unescapeComponent(addr[0]);
            if (!options.unicodeSupport) {
              try {
                addr[1] = punycode.toASCII(unescapeComponent(addr[1], options).toLowerCase());
              } catch (e) {
                mailtoComponents.error = mailtoComponents.error || "Email address's domain name can not be converted to ASCII via punycode: " + e;
              }
            } else {
              addr[1] = unescapeComponent(addr[1], options).toLowerCase();
            }
            to[_x2] = addr.join("@");
          }
          return mailtoComponents;
        },
        serialize: function serialize$$1(mailtoComponents, options) {
          var components = mailtoComponents;
          var to = toArray2(mailtoComponents.to);
          if (to) {
            for (var x = 0, xl = to.length; x < xl; ++x) {
              var toAddr = String(to[x]);
              var atIdx = toAddr.lastIndexOf("@");
              var localPart = toAddr.slice(0, atIdx).replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_LOCAL_PART, pctEncChar);
              var domain = toAddr.slice(atIdx + 1);
              try {
                domain = !options.iri ? punycode.toASCII(unescapeComponent(domain, options).toLowerCase()) : punycode.toUnicode(domain);
              } catch (e) {
                components.error = components.error || "Email address's domain name can not be converted to " + (!options.iri ? "ASCII" : "Unicode") + " via punycode: " + e;
              }
              to[x] = localPart + "@" + domain;
            }
            components.path = to.join(",");
          }
          var headers = mailtoComponents.headers = mailtoComponents.headers || {};
          if (mailtoComponents.subject) headers["subject"] = mailtoComponents.subject;
          if (mailtoComponents.body) headers["body"] = mailtoComponents.body;
          var fields = [];
          for (var name in headers) {
            if (headers[name] !== O[name]) {
              fields.push(name.replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFNAME, pctEncChar) + "=" + headers[name].replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFVALUE, pctEncChar));
            }
          }
          if (fields.length) {
            components.query = fields.join("&");
          }
          return components;
        }
      };
      var URN_PARSE = /^([^\:]+)\:(.*)/;
      var handler$5 = {
        scheme: "urn",
        parse: function parse$$1(components, options) {
          var matches = components.path && components.path.match(URN_PARSE);
          var urnComponents = components;
          if (matches) {
            var scheme = options.scheme || urnComponents.scheme || "urn";
            var nid = matches[1].toLowerCase();
            var nss = matches[2];
            var urnScheme = scheme + ":" + (options.nid || nid);
            var schemeHandler = SCHEMES[urnScheme];
            urnComponents.nid = nid;
            urnComponents.nss = nss;
            urnComponents.path = void 0;
            if (schemeHandler) {
              urnComponents = schemeHandler.parse(urnComponents, options);
            }
          } else {
            urnComponents.error = urnComponents.error || "URN can not be parsed.";
          }
          return urnComponents;
        },
        serialize: function serialize$$1(urnComponents, options) {
          var scheme = options.scheme || urnComponents.scheme || "urn";
          var nid = urnComponents.nid;
          var urnScheme = scheme + ":" + (options.nid || nid);
          var schemeHandler = SCHEMES[urnScheme];
          if (schemeHandler) {
            urnComponents = schemeHandler.serialize(urnComponents, options);
          }
          var uriComponents = urnComponents;
          var nss = urnComponents.nss;
          uriComponents.path = (nid || options.nid) + ":" + nss;
          return uriComponents;
        }
      };
      var UUID = /^[0-9A-Fa-f]{8}(?:\-[0-9A-Fa-f]{4}){3}\-[0-9A-Fa-f]{12}$/;
      var handler$6 = {
        scheme: "urn:uuid",
        parse: function parse7(urnComponents, options) {
          var uuidComponents = urnComponents;
          uuidComponents.uuid = uuidComponents.nss;
          uuidComponents.nss = void 0;
          if (!options.tolerant && (!uuidComponents.uuid || !uuidComponents.uuid.match(UUID))) {
            uuidComponents.error = uuidComponents.error || "UUID is not valid.";
          }
          return uuidComponents;
        },
        serialize: function serialize2(uuidComponents, options) {
          var urnComponents = uuidComponents;
          urnComponents.nss = (uuidComponents.uuid || "").toLowerCase();
          return urnComponents;
        }
      };
      SCHEMES[handler.scheme] = handler;
      SCHEMES[handler$1.scheme] = handler$1;
      SCHEMES[handler$2.scheme] = handler$2;
      SCHEMES[handler$3.scheme] = handler$3;
      SCHEMES[handler$4.scheme] = handler$4;
      SCHEMES[handler$5.scheme] = handler$5;
      SCHEMES[handler$6.scheme] = handler$6;
      exports3.SCHEMES = SCHEMES;
      exports3.pctEncChar = pctEncChar;
      exports3.pctDecChars = pctDecChars;
      exports3.parse = parse6;
      exports3.removeDotSegments = removeDotSegments;
      exports3.serialize = serialize;
      exports3.resolveComponents = resolveComponents;
      exports3.resolve = resolve;
      exports3.normalize = normalize;
      exports3.equal = equal;
      exports3.escapeComponent = escapeComponent;
      exports3.unescapeComponent = unescapeComponent;
      Object.defineProperty(exports3, "__esModule", { value: true });
    });
  }
});

// node_modules/ajv/dist/runtime/uri.js
var require_uri2 = __commonJS({
  "node_modules/ajv/dist/runtime/uri.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var uri = require_uri_all();
    uri.code = 'require("ajv/dist/runtime/uri").default';
    exports2.default = uri;
  }
});

// node_modules/ajv/dist/core.js
var require_core2 = __commonJS({
  "node_modules/ajv/dist/core.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CodeGen = exports2.Name = exports2.nil = exports2.stringify = exports2.str = exports2._ = exports2.KeywordCxt = void 0;
    var validate_1 = require_validate();
    Object.defineProperty(exports2, "KeywordCxt", { enumerable: true, get: function() {
      return validate_1.KeywordCxt;
    } });
    var codegen_1 = require_codegen();
    Object.defineProperty(exports2, "_", { enumerable: true, get: function() {
      return codegen_1._;
    } });
    Object.defineProperty(exports2, "str", { enumerable: true, get: function() {
      return codegen_1.str;
    } });
    Object.defineProperty(exports2, "stringify", { enumerable: true, get: function() {
      return codegen_1.stringify;
    } });
    Object.defineProperty(exports2, "nil", { enumerable: true, get: function() {
      return codegen_1.nil;
    } });
    Object.defineProperty(exports2, "Name", { enumerable: true, get: function() {
      return codegen_1.Name;
    } });
    Object.defineProperty(exports2, "CodeGen", { enumerable: true, get: function() {
      return codegen_1.CodeGen;
    } });
    var validation_error_1 = require_validation_error();
    var ref_error_1 = require_ref_error();
    var rules_1 = require_rules();
    var compile_1 = require_compile();
    var codegen_2 = require_codegen();
    var resolve_1 = require_resolve();
    var dataType_1 = require_dataType();
    var util_1 = require_util3();
    var $dataRefSchema = require_data();
    var uri_1 = require_uri2();
    var defaultRegExp = (str2, flags2) => new RegExp(str2, flags2);
    defaultRegExp.code = "new RegExp";
    var META_IGNORE_OPTIONS = ["removeAdditional", "useDefaults", "coerceTypes"];
    var EXT_SCOPE_NAMES = /* @__PURE__ */ new Set([
      "validate",
      "serialize",
      "parse",
      "wrapper",
      "root",
      "schema",
      "keyword",
      "pattern",
      "formats",
      "validate$data",
      "func",
      "obj",
      "Error"
    ]);
    var removedOptions = {
      errorDataPath: "",
      format: "`validateFormats: false` can be used instead.",
      nullable: '"nullable" keyword is supported by default.',
      jsonPointers: "Deprecated jsPropertySyntax can be used instead.",
      extendRefs: "Deprecated ignoreKeywordsWithRef can be used instead.",
      missingRefs: "Pass empty schema with $id that should be ignored to ajv.addSchema.",
      processCode: "Use option `code: {process: (code, schemaEnv: object) => string}`",
      sourceCode: "Use option `code: {source: true}`",
      strictDefaults: "It is default now, see option `strict`.",
      strictKeywords: "It is default now, see option `strict`.",
      uniqueItems: '"uniqueItems" keyword is always validated.',
      unknownFormats: "Disable strict mode or pass `true` to `ajv.addFormat` (or `formats` option).",
      cache: "Map is used as cache, schema object as key.",
      serialize: "Map is used as cache, schema object as key.",
      ajvErrors: "It is default now."
    };
    var deprecatedOptions = {
      ignoreKeywordsWithRef: "",
      jsPropertySyntax: "",
      unicode: '"minLength"/"maxLength" account for unicode characters by default.'
    };
    var MAX_EXPRESSION = 200;
    function requiredOptions(o) {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0;
      const s = o.strict;
      const _optz = (_a = o.code) === null || _a === void 0 ? void 0 : _a.optimize;
      const optimize = _optz === true || _optz === void 0 ? 1 : _optz || 0;
      const regExp = (_c = (_b = o.code) === null || _b === void 0 ? void 0 : _b.regExp) !== null && _c !== void 0 ? _c : defaultRegExp;
      const uriResolver = (_d = o.uriResolver) !== null && _d !== void 0 ? _d : uri_1.default;
      return {
        strictSchema: (_f = (_e = o.strictSchema) !== null && _e !== void 0 ? _e : s) !== null && _f !== void 0 ? _f : true,
        strictNumbers: (_h = (_g = o.strictNumbers) !== null && _g !== void 0 ? _g : s) !== null && _h !== void 0 ? _h : true,
        strictTypes: (_k = (_j = o.strictTypes) !== null && _j !== void 0 ? _j : s) !== null && _k !== void 0 ? _k : "log",
        strictTuples: (_m = (_l = o.strictTuples) !== null && _l !== void 0 ? _l : s) !== null && _m !== void 0 ? _m : "log",
        strictRequired: (_p = (_o = o.strictRequired) !== null && _o !== void 0 ? _o : s) !== null && _p !== void 0 ? _p : false,
        code: o.code ? { ...o.code, optimize, regExp } : { optimize, regExp },
        loopRequired: (_q = o.loopRequired) !== null && _q !== void 0 ? _q : MAX_EXPRESSION,
        loopEnum: (_r = o.loopEnum) !== null && _r !== void 0 ? _r : MAX_EXPRESSION,
        meta: (_s = o.meta) !== null && _s !== void 0 ? _s : true,
        messages: (_t = o.messages) !== null && _t !== void 0 ? _t : true,
        inlineRefs: (_u = o.inlineRefs) !== null && _u !== void 0 ? _u : true,
        schemaId: (_v = o.schemaId) !== null && _v !== void 0 ? _v : "$id",
        addUsedSchema: (_w = o.addUsedSchema) !== null && _w !== void 0 ? _w : true,
        validateSchema: (_x = o.validateSchema) !== null && _x !== void 0 ? _x : true,
        validateFormats: (_y = o.validateFormats) !== null && _y !== void 0 ? _y : true,
        unicodeRegExp: (_z = o.unicodeRegExp) !== null && _z !== void 0 ? _z : true,
        int32range: (_0 = o.int32range) !== null && _0 !== void 0 ? _0 : true,
        uriResolver
      };
    }
    var Ajv = class {
      constructor(opts = {}) {
        this.schemas = {};
        this.refs = {};
        this.formats = {};
        this._compilations = /* @__PURE__ */ new Set();
        this._loading = {};
        this._cache = /* @__PURE__ */ new Map();
        opts = this.opts = { ...opts, ...requiredOptions(opts) };
        const { es5, lines } = this.opts.code;
        this.scope = new codegen_2.ValueScope({ scope: {}, prefixes: EXT_SCOPE_NAMES, es5, lines });
        this.logger = getLogger(opts.logger);
        const formatOpt = opts.validateFormats;
        opts.validateFormats = false;
        this.RULES = (0, rules_1.getRules)();
        checkOptions.call(this, removedOptions, opts, "NOT SUPPORTED");
        checkOptions.call(this, deprecatedOptions, opts, "DEPRECATED", "warn");
        this._metaOpts = getMetaSchemaOptions.call(this);
        if (opts.formats)
          addInitialFormats.call(this);
        this._addVocabularies();
        this._addDefaultMetaSchema();
        if (opts.keywords)
          addInitialKeywords.call(this, opts.keywords);
        if (typeof opts.meta == "object")
          this.addMetaSchema(opts.meta);
        addInitialSchemas.call(this);
        opts.validateFormats = formatOpt;
      }
      _addVocabularies() {
        this.addKeyword("$async");
      }
      _addDefaultMetaSchema() {
        const { $data, meta, schemaId } = this.opts;
        let _dataRefSchema = $dataRefSchema;
        if (schemaId === "id") {
          _dataRefSchema = { ...$dataRefSchema };
          _dataRefSchema.id = _dataRefSchema.$id;
          delete _dataRefSchema.$id;
        }
        if (meta && $data)
          this.addMetaSchema(_dataRefSchema, _dataRefSchema[schemaId], false);
      }
      defaultMeta() {
        const { meta, schemaId } = this.opts;
        return this.opts.defaultMeta = typeof meta == "object" ? meta[schemaId] || meta : void 0;
      }
      validate(schemaKeyRef, data) {
        let v;
        if (typeof schemaKeyRef == "string") {
          v = this.getSchema(schemaKeyRef);
          if (!v)
            throw new Error(`no schema with key or ref "${schemaKeyRef}"`);
        } else {
          v = this.compile(schemaKeyRef);
        }
        const valid = v(data);
        if (!("$async" in v))
          this.errors = v.errors;
        return valid;
      }
      compile(schema2, _meta) {
        const sch = this._addSchema(schema2, _meta);
        return sch.validate || this._compileSchemaEnv(sch);
      }
      compileAsync(schema2, meta) {
        if (typeof this.opts.loadSchema != "function") {
          throw new Error("options.loadSchema should be a function");
        }
        const { loadSchema } = this.opts;
        return runCompileAsync.call(this, schema2, meta);
        async function runCompileAsync(_schema, _meta) {
          await loadMetaSchema.call(this, _schema.$schema);
          const sch = this._addSchema(_schema, _meta);
          return sch.validate || _compileAsync.call(this, sch);
        }
        async function loadMetaSchema($ref) {
          if ($ref && !this.getSchema($ref)) {
            await runCompileAsync.call(this, { $ref }, true);
          }
        }
        async function _compileAsync(sch) {
          try {
            return this._compileSchemaEnv(sch);
          } catch (e) {
            if (!(e instanceof ref_error_1.default))
              throw e;
            checkLoaded.call(this, e);
            await loadMissingSchema.call(this, e.missingSchema);
            return _compileAsync.call(this, sch);
          }
        }
        function checkLoaded({ missingSchema: ref, missingRef }) {
          if (this.refs[ref]) {
            throw new Error(`AnySchema ${ref} is loaded but ${missingRef} cannot be resolved`);
          }
        }
        async function loadMissingSchema(ref) {
          const _schema = await _loadSchema.call(this, ref);
          if (!this.refs[ref])
            await loadMetaSchema.call(this, _schema.$schema);
          if (!this.refs[ref])
            this.addSchema(_schema, ref, meta);
        }
        async function _loadSchema(ref) {
          const p = this._loading[ref];
          if (p)
            return p;
          try {
            return await (this._loading[ref] = loadSchema(ref));
          } finally {
            delete this._loading[ref];
          }
        }
      }
      // Adds schema to the instance
      addSchema(schema2, key, _meta, _validateSchema = this.opts.validateSchema) {
        if (Array.isArray(schema2)) {
          for (const sch of schema2)
            this.addSchema(sch, void 0, _meta, _validateSchema);
          return this;
        }
        let id;
        if (typeof schema2 === "object") {
          const { schemaId } = this.opts;
          id = schema2[schemaId];
          if (id !== void 0 && typeof id != "string") {
            throw new Error(`schema ${schemaId} must be string`);
          }
        }
        key = (0, resolve_1.normalizeId)(key || id);
        this._checkUnique(key);
        this.schemas[key] = this._addSchema(schema2, _meta, key, _validateSchema, true);
        return this;
      }
      // Add schema that will be used to validate other schemas
      // options in META_IGNORE_OPTIONS are alway set to false
      addMetaSchema(schema2, key, _validateSchema = this.opts.validateSchema) {
        this.addSchema(schema2, key, true, _validateSchema);
        return this;
      }
      //  Validate schema against its meta-schema
      validateSchema(schema2, throwOrLogError) {
        if (typeof schema2 == "boolean")
          return true;
        let $schema;
        $schema = schema2.$schema;
        if ($schema !== void 0 && typeof $schema != "string") {
          throw new Error("$schema must be a string");
        }
        $schema = $schema || this.opts.defaultMeta || this.defaultMeta();
        if (!$schema) {
          this.logger.warn("meta-schema not available");
          this.errors = null;
          return true;
        }
        const valid = this.validate($schema, schema2);
        if (!valid && throwOrLogError) {
          const message = "schema is invalid: " + this.errorsText();
          if (this.opts.validateSchema === "log")
            this.logger.error(message);
          else
            throw new Error(message);
        }
        return valid;
      }
      // Get compiled schema by `key` or `ref`.
      // (`key` that was passed to `addSchema` or full schema reference - `schema.$id` or resolved id)
      getSchema(keyRef) {
        let sch;
        while (typeof (sch = getSchEnv.call(this, keyRef)) == "string")
          keyRef = sch;
        if (sch === void 0) {
          const { schemaId } = this.opts;
          const root = new compile_1.SchemaEnv({ schema: {}, schemaId });
          sch = compile_1.resolveSchema.call(this, root, keyRef);
          if (!sch)
            return;
          this.refs[keyRef] = sch;
        }
        return sch.validate || this._compileSchemaEnv(sch);
      }
      // Remove cached schema(s).
      // If no parameter is passed all schemas but meta-schemas are removed.
      // If RegExp is passed all schemas with key/id matching pattern but meta-schemas are removed.
      // Even if schema is referenced by other schemas it still can be removed as other schemas have local references.
      removeSchema(schemaKeyRef) {
        if (schemaKeyRef instanceof RegExp) {
          this._removeAllSchemas(this.schemas, schemaKeyRef);
          this._removeAllSchemas(this.refs, schemaKeyRef);
          return this;
        }
        switch (typeof schemaKeyRef) {
          case "undefined":
            this._removeAllSchemas(this.schemas);
            this._removeAllSchemas(this.refs);
            this._cache.clear();
            return this;
          case "string": {
            const sch = getSchEnv.call(this, schemaKeyRef);
            if (typeof sch == "object")
              this._cache.delete(sch.schema);
            delete this.schemas[schemaKeyRef];
            delete this.refs[schemaKeyRef];
            return this;
          }
          case "object": {
            const cacheKey = schemaKeyRef;
            this._cache.delete(cacheKey);
            let id = schemaKeyRef[this.opts.schemaId];
            if (id) {
              id = (0, resolve_1.normalizeId)(id);
              delete this.schemas[id];
              delete this.refs[id];
            }
            return this;
          }
          default:
            throw new Error("ajv.removeSchema: invalid parameter");
        }
      }
      // add "vocabulary" - a collection of keywords
      addVocabulary(definitions) {
        for (const def of definitions)
          this.addKeyword(def);
        return this;
      }
      addKeyword(kwdOrDef, def) {
        let keyword;
        if (typeof kwdOrDef == "string") {
          keyword = kwdOrDef;
          if (typeof def == "object") {
            this.logger.warn("these parameters are deprecated, see docs for addKeyword");
            def.keyword = keyword;
          }
        } else if (typeof kwdOrDef == "object" && def === void 0) {
          def = kwdOrDef;
          keyword = def.keyword;
          if (Array.isArray(keyword) && !keyword.length) {
            throw new Error("addKeywords: keyword must be string or non-empty array");
          }
        } else {
          throw new Error("invalid addKeywords parameters");
        }
        checkKeyword.call(this, keyword, def);
        if (!def) {
          (0, util_1.eachItem)(keyword, (kwd) => addRule.call(this, kwd));
          return this;
        }
        keywordMetaschema.call(this, def);
        const definition = {
          ...def,
          type: (0, dataType_1.getJSONTypes)(def.type),
          schemaType: (0, dataType_1.getJSONTypes)(def.schemaType)
        };
        (0, util_1.eachItem)(keyword, definition.type.length === 0 ? (k) => addRule.call(this, k, definition) : (k) => definition.type.forEach((t) => addRule.call(this, k, definition, t)));
        return this;
      }
      getKeyword(keyword) {
        const rule = this.RULES.all[keyword];
        return typeof rule == "object" ? rule.definition : !!rule;
      }
      // Remove keyword
      removeKeyword(keyword) {
        const { RULES } = this;
        delete RULES.keywords[keyword];
        delete RULES.all[keyword];
        for (const group of RULES.rules) {
          const i = group.rules.findIndex((rule) => rule.keyword === keyword);
          if (i >= 0)
            group.rules.splice(i, 1);
        }
        return this;
      }
      // Add format
      addFormat(name, format6) {
        if (typeof format6 == "string")
          format6 = new RegExp(format6);
        this.formats[name] = format6;
        return this;
      }
      errorsText(errors = this.errors, { separator = ", ", dataVar = "data" } = {}) {
        if (!errors || errors.length === 0)
          return "No errors";
        return errors.map((e) => `${dataVar}${e.instancePath} ${e.message}`).reduce((text, msg) => text + separator + msg);
      }
      $dataMetaSchema(metaSchema, keywordsJsonPointers) {
        const rules = this.RULES.all;
        metaSchema = JSON.parse(JSON.stringify(metaSchema));
        for (const jsonPointer of keywordsJsonPointers) {
          const segments = jsonPointer.split("/").slice(1);
          let keywords = metaSchema;
          for (const seg of segments)
            keywords = keywords[seg];
          for (const key in rules) {
            const rule = rules[key];
            if (typeof rule != "object")
              continue;
            const { $data } = rule.definition;
            const schema2 = keywords[key];
            if ($data && schema2)
              keywords[key] = schemaOrData(schema2);
          }
        }
        return metaSchema;
      }
      _removeAllSchemas(schemas, regex) {
        for (const keyRef in schemas) {
          const sch = schemas[keyRef];
          if (!regex || regex.test(keyRef)) {
            if (typeof sch == "string") {
              delete schemas[keyRef];
            } else if (sch && !sch.meta) {
              this._cache.delete(sch.schema);
              delete schemas[keyRef];
            }
          }
        }
      }
      _addSchema(schema2, meta, baseId, validateSchema = this.opts.validateSchema, addSchema = this.opts.addUsedSchema) {
        let id;
        const { schemaId } = this.opts;
        if (typeof schema2 == "object") {
          id = schema2[schemaId];
        } else {
          if (this.opts.jtd)
            throw new Error("schema must be object");
          else if (typeof schema2 != "boolean")
            throw new Error("schema must be object or boolean");
        }
        let sch = this._cache.get(schema2);
        if (sch !== void 0)
          return sch;
        baseId = (0, resolve_1.normalizeId)(id || baseId);
        const localRefs = resolve_1.getSchemaRefs.call(this, schema2, baseId);
        sch = new compile_1.SchemaEnv({ schema: schema2, schemaId, meta, baseId, localRefs });
        this._cache.set(sch.schema, sch);
        if (addSchema && !baseId.startsWith("#")) {
          if (baseId)
            this._checkUnique(baseId);
          this.refs[baseId] = sch;
        }
        if (validateSchema)
          this.validateSchema(schema2, true);
        return sch;
      }
      _checkUnique(id) {
        if (this.schemas[id] || this.refs[id]) {
          throw new Error(`schema with key or id "${id}" already exists`);
        }
      }
      _compileSchemaEnv(sch) {
        if (sch.meta)
          this._compileMetaSchema(sch);
        else
          compile_1.compileSchema.call(this, sch);
        if (!sch.validate)
          throw new Error("ajv implementation error");
        return sch.validate;
      }
      _compileMetaSchema(sch) {
        const currentOpts = this.opts;
        this.opts = this._metaOpts;
        try {
          compile_1.compileSchema.call(this, sch);
        } finally {
          this.opts = currentOpts;
        }
      }
    };
    Ajv.ValidationError = validation_error_1.default;
    Ajv.MissingRefError = ref_error_1.default;
    exports2.default = Ajv;
    function checkOptions(checkOpts, options, msg, log = "error") {
      for (const key in checkOpts) {
        const opt = key;
        if (opt in options)
          this.logger[log](`${msg}: option ${key}. ${checkOpts[opt]}`);
      }
    }
    function getSchEnv(keyRef) {
      keyRef = (0, resolve_1.normalizeId)(keyRef);
      return this.schemas[keyRef] || this.refs[keyRef];
    }
    function addInitialSchemas() {
      const optsSchemas = this.opts.schemas;
      if (!optsSchemas)
        return;
      if (Array.isArray(optsSchemas))
        this.addSchema(optsSchemas);
      else
        for (const key in optsSchemas)
          this.addSchema(optsSchemas[key], key);
    }
    function addInitialFormats() {
      for (const name in this.opts.formats) {
        const format6 = this.opts.formats[name];
        if (format6)
          this.addFormat(name, format6);
      }
    }
    function addInitialKeywords(defs) {
      if (Array.isArray(defs)) {
        this.addVocabulary(defs);
        return;
      }
      this.logger.warn("keywords option as map is deprecated, pass array");
      for (const keyword in defs) {
        const def = defs[keyword];
        if (!def.keyword)
          def.keyword = keyword;
        this.addKeyword(def);
      }
    }
    function getMetaSchemaOptions() {
      const metaOpts = { ...this.opts };
      for (const opt of META_IGNORE_OPTIONS)
        delete metaOpts[opt];
      return metaOpts;
    }
    var noLogs = { log() {
    }, warn() {
    }, error() {
    } };
    function getLogger(logger) {
      if (logger === false)
        return noLogs;
      if (logger === void 0)
        return console;
      if (logger.log && logger.warn && logger.error)
        return logger;
      throw new Error("logger must implement log, warn and error methods");
    }
    var KEYWORD_NAME = /^[a-z_$][a-z0-9_$:-]*$/i;
    function checkKeyword(keyword, def) {
      const { RULES } = this;
      (0, util_1.eachItem)(keyword, (kwd) => {
        if (RULES.keywords[kwd])
          throw new Error(`Keyword ${kwd} is already defined`);
        if (!KEYWORD_NAME.test(kwd))
          throw new Error(`Keyword ${kwd} has invalid name`);
      });
      if (!def)
        return;
      if (def.$data && !("code" in def || "validate" in def)) {
        throw new Error('$data keyword must have "code" or "validate" function');
      }
    }
    function addRule(keyword, definition, dataType) {
      var _a;
      const post = definition === null || definition === void 0 ? void 0 : definition.post;
      if (dataType && post)
        throw new Error('keyword with "post" flag cannot have "type"');
      const { RULES } = this;
      let ruleGroup = post ? RULES.post : RULES.rules.find(({ type: t }) => t === dataType);
      if (!ruleGroup) {
        ruleGroup = { type: dataType, rules: [] };
        RULES.rules.push(ruleGroup);
      }
      RULES.keywords[keyword] = true;
      if (!definition)
        return;
      const rule = {
        keyword,
        definition: {
          ...definition,
          type: (0, dataType_1.getJSONTypes)(definition.type),
          schemaType: (0, dataType_1.getJSONTypes)(definition.schemaType)
        }
      };
      if (definition.before)
        addBeforeRule.call(this, ruleGroup, rule, definition.before);
      else
        ruleGroup.rules.push(rule);
      RULES.all[keyword] = rule;
      (_a = definition.implements) === null || _a === void 0 ? void 0 : _a.forEach((kwd) => this.addKeyword(kwd));
    }
    function addBeforeRule(ruleGroup, rule, before) {
      const i = ruleGroup.rules.findIndex((_rule) => _rule.keyword === before);
      if (i >= 0) {
        ruleGroup.rules.splice(i, 0, rule);
      } else {
        ruleGroup.rules.push(rule);
        this.logger.warn(`rule ${before} is not defined`);
      }
    }
    function keywordMetaschema(def) {
      let { metaSchema } = def;
      if (metaSchema === void 0)
        return;
      if (def.$data && this.opts.$data)
        metaSchema = schemaOrData(metaSchema);
      def.validateSchema = this.compile(metaSchema, true);
    }
    var $dataRef = {
      $ref: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#"
    };
    function schemaOrData(schema2) {
      return { anyOf: [schema2, $dataRef] };
    }
  }
});

// node_modules/ajv/dist/vocabularies/core/id.js
var require_id = __commonJS({
  "node_modules/ajv/dist/vocabularies/core/id.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var def = {
      keyword: "id",
      code() {
        throw new Error('NOT SUPPORTED: keyword "id", use "$id" for schema ID');
      }
    };
    exports2.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/core/ref.js
var require_ref3 = __commonJS({
  "node_modules/ajv/dist/vocabularies/core/ref.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.callRef = exports2.getValidate = void 0;
    var ref_error_1 = require_ref_error();
    var code_1 = require_code2();
    var codegen_1 = require_codegen();
    var names_1 = require_names();
    var compile_1 = require_compile();
    var util_1 = require_util3();
    var def = {
      keyword: "$ref",
      schemaType: "string",
      code(cxt) {
        const { gen, schema: $ref, it } = cxt;
        const { baseId, schemaEnv: env, validateName: validateName2, opts, self: self2 } = it;
        const { root } = env;
        if (($ref === "#" || $ref === "#/") && baseId === root.baseId)
          return callRootRef();
        const schOrEnv = compile_1.resolveRef.call(self2, root, baseId, $ref);
        if (schOrEnv === void 0)
          throw new ref_error_1.default(it.opts.uriResolver, baseId, $ref);
        if (schOrEnv instanceof compile_1.SchemaEnv)
          return callValidate(schOrEnv);
        return inlineRefSchema(schOrEnv);
        function callRootRef() {
          if (env === root)
            return callRef(cxt, validateName2, env, env.$async);
          const rootName = gen.scopeValue("root", { ref: root });
          return callRef(cxt, (0, codegen_1._)`${rootName}.validate`, root, root.$async);
        }
        function callValidate(sch) {
          const v = getValidate(cxt, sch);
          callRef(cxt, v, sch, sch.$async);
        }
        function inlineRefSchema(sch) {
          const schName = gen.scopeValue("schema", opts.code.source === true ? { ref: sch, code: (0, codegen_1.stringify)(sch) } : { ref: sch });
          const valid = gen.name("valid");
          const schCxt = cxt.subschema({
            schema: sch,
            dataTypes: [],
            schemaPath: codegen_1.nil,
            topSchemaRef: schName,
            errSchemaPath: $ref
          }, valid);
          cxt.mergeEvaluated(schCxt);
          cxt.ok(valid);
        }
      }
    };
    function getValidate(cxt, sch) {
      const { gen } = cxt;
      return sch.validate ? gen.scopeValue("validate", { ref: sch.validate }) : (0, codegen_1._)`${gen.scopeValue("wrapper", { ref: sch })}.validate`;
    }
    exports2.getValidate = getValidate;
    function callRef(cxt, v, sch, $async) {
      const { gen, it } = cxt;
      const { allErrors, schemaEnv: env, opts } = it;
      const passCxt = opts.passContext ? names_1.default.this : codegen_1.nil;
      if ($async)
        callAsyncRef();
      else
        callSyncRef();
      function callAsyncRef() {
        if (!env.$async)
          throw new Error("async schema referenced by sync schema");
        const valid = gen.let("valid");
        gen.try(() => {
          gen.code((0, codegen_1._)`await ${(0, code_1.callValidateCode)(cxt, v, passCxt)}`);
          addEvaluatedFrom(v);
          if (!allErrors)
            gen.assign(valid, true);
        }, (e) => {
          gen.if((0, codegen_1._)`!(${e} instanceof ${it.ValidationError})`, () => gen.throw(e));
          addErrorsFrom(e);
          if (!allErrors)
            gen.assign(valid, false);
        });
        cxt.ok(valid);
      }
      function callSyncRef() {
        cxt.result((0, code_1.callValidateCode)(cxt, v, passCxt), () => addEvaluatedFrom(v), () => addErrorsFrom(v));
      }
      function addErrorsFrom(source) {
        const errs = (0, codegen_1._)`${source}.errors`;
        gen.assign(names_1.default.vErrors, (0, codegen_1._)`${names_1.default.vErrors} === null ? ${errs} : ${names_1.default.vErrors}.concat(${errs})`);
        gen.assign(names_1.default.errors, (0, codegen_1._)`${names_1.default.vErrors}.length`);
      }
      function addEvaluatedFrom(source) {
        var _a;
        if (!it.opts.unevaluated)
          return;
        const schEvaluated = (_a = sch === null || sch === void 0 ? void 0 : sch.validate) === null || _a === void 0 ? void 0 : _a.evaluated;
        if (it.props !== true) {
          if (schEvaluated && !schEvaluated.dynamicProps) {
            if (schEvaluated.props !== void 0) {
              it.props = util_1.mergeEvaluated.props(gen, schEvaluated.props, it.props);
            }
          } else {
            const props = gen.var("props", (0, codegen_1._)`${source}.evaluated.props`);
            it.props = util_1.mergeEvaluated.props(gen, props, it.props, codegen_1.Name);
          }
        }
        if (it.items !== true) {
          if (schEvaluated && !schEvaluated.dynamicItems) {
            if (schEvaluated.items !== void 0) {
              it.items = util_1.mergeEvaluated.items(gen, schEvaluated.items, it.items);
            }
          } else {
            const items = gen.var("items", (0, codegen_1._)`${source}.evaluated.items`);
            it.items = util_1.mergeEvaluated.items(gen, items, it.items, codegen_1.Name);
          }
        }
      }
    }
    exports2.callRef = callRef;
    exports2.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/core/index.js
var require_core3 = __commonJS({
  "node_modules/ajv/dist/vocabularies/core/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var id_1 = require_id();
    var ref_1 = require_ref3();
    var core2 = [
      "$schema",
      "$id",
      "$defs",
      "$vocabulary",
      { keyword: "$comment" },
      "definitions",
      id_1.default,
      ref_1.default
    ];
    exports2.default = core2;
  }
});

// node_modules/ajv/dist/vocabularies/validation/limitNumber.js
var require_limitNumber = __commonJS({
  "node_modules/ajv/dist/vocabularies/validation/limitNumber.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var ops = codegen_1.operators;
    var KWDs = {
      maximum: { okStr: "<=", ok: ops.LTE, fail: ops.GT },
      minimum: { okStr: ">=", ok: ops.GTE, fail: ops.LT },
      exclusiveMaximum: { okStr: "<", ok: ops.LT, fail: ops.GTE },
      exclusiveMinimum: { okStr: ">", ok: ops.GT, fail: ops.LTE }
    };
    var error = {
      message: ({ keyword, schemaCode }) => (0, codegen_1.str)`must be ${KWDs[keyword].okStr} ${schemaCode}`,
      params: ({ keyword, schemaCode }) => (0, codegen_1._)`{comparison: ${KWDs[keyword].okStr}, limit: ${schemaCode}}`
    };
    var def = {
      keyword: Object.keys(KWDs),
      type: "number",
      schemaType: "number",
      $data: true,
      error,
      code(cxt) {
        const { keyword, data, schemaCode } = cxt;
        cxt.fail$data((0, codegen_1._)`${data} ${KWDs[keyword].fail} ${schemaCode} || isNaN(${data})`);
      }
    };
    exports2.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/validation/multipleOf.js
var require_multipleOf = __commonJS({
  "node_modules/ajv/dist/vocabularies/validation/multipleOf.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var error = {
      message: ({ schemaCode }) => (0, codegen_1.str)`must be multiple of ${schemaCode}`,
      params: ({ schemaCode }) => (0, codegen_1._)`{multipleOf: ${schemaCode}}`
    };
    var def = {
      keyword: "multipleOf",
      type: "number",
      schemaType: "number",
      $data: true,
      error,
      code(cxt) {
        const { gen, data, schemaCode, it } = cxt;
        const prec = it.opts.multipleOfPrecision;
        const res = gen.let("res");
        const invalid = prec ? (0, codegen_1._)`Math.abs(Math.round(${res}) - ${res}) > 1e-${prec}` : (0, codegen_1._)`${res} !== parseInt(${res})`;
        cxt.fail$data((0, codegen_1._)`(${schemaCode} === 0 || (${res} = ${data}/${schemaCode}, ${invalid}))`);
      }
    };
    exports2.default = def;
  }
});

// node_modules/ajv/dist/runtime/ucs2length.js
var require_ucs2length = __commonJS({
  "node_modules/ajv/dist/runtime/ucs2length.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    function ucs2length(str2) {
      const len = str2.length;
      let length = 0;
      let pos = 0;
      let value;
      while (pos < len) {
        length++;
        value = str2.charCodeAt(pos++);
        if (value >= 55296 && value <= 56319 && pos < len) {
          value = str2.charCodeAt(pos);
          if ((value & 64512) === 56320)
            pos++;
        }
      }
      return length;
    }
    exports2.default = ucs2length;
    ucs2length.code = 'require("ajv/dist/runtime/ucs2length").default';
  }
});

// node_modules/ajv/dist/vocabularies/validation/limitLength.js
var require_limitLength = __commonJS({
  "node_modules/ajv/dist/vocabularies/validation/limitLength.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var util_1 = require_util3();
    var ucs2length_1 = require_ucs2length();
    var error = {
      message({ keyword, schemaCode }) {
        const comp = keyword === "maxLength" ? "more" : "fewer";
        return (0, codegen_1.str)`must NOT have ${comp} than ${schemaCode} characters`;
      },
      params: ({ schemaCode }) => (0, codegen_1._)`{limit: ${schemaCode}}`
    };
    var def = {
      keyword: ["maxLength", "minLength"],
      type: "string",
      schemaType: "number",
      $data: true,
      error,
      code(cxt) {
        const { keyword, data, schemaCode, it } = cxt;
        const op = keyword === "maxLength" ? codegen_1.operators.GT : codegen_1.operators.LT;
        const len = it.opts.unicode === false ? (0, codegen_1._)`${data}.length` : (0, codegen_1._)`${(0, util_1.useFunc)(cxt.gen, ucs2length_1.default)}(${data})`;
        cxt.fail$data((0, codegen_1._)`${len} ${op} ${schemaCode}`);
      }
    };
    exports2.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/validation/pattern.js
var require_pattern2 = __commonJS({
  "node_modules/ajv/dist/vocabularies/validation/pattern.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var code_1 = require_code2();
    var codegen_1 = require_codegen();
    var error = {
      message: ({ schemaCode }) => (0, codegen_1.str)`must match pattern "${schemaCode}"`,
      params: ({ schemaCode }) => (0, codegen_1._)`{pattern: ${schemaCode}}`
    };
    var def = {
      keyword: "pattern",
      type: "string",
      schemaType: "string",
      $data: true,
      error,
      code(cxt) {
        const { data, $data, schema: schema2, schemaCode, it } = cxt;
        const u = it.opts.unicodeRegExp ? "u" : "";
        const regExp = $data ? (0, codegen_1._)`(new RegExp(${schemaCode}, ${u}))` : (0, code_1.usePattern)(cxt, schema2);
        cxt.fail$data((0, codegen_1._)`!${regExp}.test(${data})`);
      }
    };
    exports2.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/validation/limitProperties.js
var require_limitProperties = __commonJS({
  "node_modules/ajv/dist/vocabularies/validation/limitProperties.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var error = {
      message({ keyword, schemaCode }) {
        const comp = keyword === "maxProperties" ? "more" : "fewer";
        return (0, codegen_1.str)`must NOT have ${comp} than ${schemaCode} properties`;
      },
      params: ({ schemaCode }) => (0, codegen_1._)`{limit: ${schemaCode}}`
    };
    var def = {
      keyword: ["maxProperties", "minProperties"],
      type: "object",
      schemaType: "number",
      $data: true,
      error,
      code(cxt) {
        const { keyword, data, schemaCode } = cxt;
        const op = keyword === "maxProperties" ? codegen_1.operators.GT : codegen_1.operators.LT;
        cxt.fail$data((0, codegen_1._)`Object.keys(${data}).length ${op} ${schemaCode}`);
      }
    };
    exports2.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/validation/required.js
var require_required2 = __commonJS({
  "node_modules/ajv/dist/vocabularies/validation/required.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var code_1 = require_code2();
    var codegen_1 = require_codegen();
    var util_1 = require_util3();
    var error = {
      message: ({ params: { missingProperty } }) => (0, codegen_1.str)`must have required property '${missingProperty}'`,
      params: ({ params: { missingProperty } }) => (0, codegen_1._)`{missingProperty: ${missingProperty}}`
    };
    var def = {
      keyword: "required",
      type: "object",
      schemaType: "array",
      $data: true,
      error,
      code(cxt) {
        const { gen, schema: schema2, schemaCode, data, $data, it } = cxt;
        const { opts } = it;
        if (!$data && schema2.length === 0)
          return;
        const useLoop = schema2.length >= opts.loopRequired;
        if (it.allErrors)
          allErrorsMode();
        else
          exitOnErrorMode();
        if (opts.strictRequired) {
          const props = cxt.parentSchema.properties;
          const { definedProperties } = cxt.it;
          for (const requiredKey of schema2) {
            if ((props === null || props === void 0 ? void 0 : props[requiredKey]) === void 0 && !definedProperties.has(requiredKey)) {
              const schemaPath = it.schemaEnv.baseId + it.errSchemaPath;
              const msg = `required property "${requiredKey}" is not defined at "${schemaPath}" (strictRequired)`;
              (0, util_1.checkStrictMode)(it, msg, it.opts.strictRequired);
            }
          }
        }
        function allErrorsMode() {
          if (useLoop || $data) {
            cxt.block$data(codegen_1.nil, loopAllRequired);
          } else {
            for (const prop of schema2) {
              (0, code_1.checkReportMissingProp)(cxt, prop);
            }
          }
        }
        function exitOnErrorMode() {
          const missing = gen.let("missing");
          if (useLoop || $data) {
            const valid = gen.let("valid", true);
            cxt.block$data(valid, () => loopUntilMissing(missing, valid));
            cxt.ok(valid);
          } else {
            gen.if((0, code_1.checkMissingProp)(cxt, schema2, missing));
            (0, code_1.reportMissingProp)(cxt, missing);
            gen.else();
          }
        }
        function loopAllRequired() {
          gen.forOf("prop", schemaCode, (prop) => {
            cxt.setParams({ missingProperty: prop });
            gen.if((0, code_1.noPropertyInData)(gen, data, prop, opts.ownProperties), () => cxt.error());
          });
        }
        function loopUntilMissing(missing, valid) {
          cxt.setParams({ missingProperty: missing });
          gen.forOf(missing, schemaCode, () => {
            gen.assign(valid, (0, code_1.propertyInData)(gen, data, missing, opts.ownProperties));
            gen.if((0, codegen_1.not)(valid), () => {
              cxt.error();
              gen.break();
            });
          }, codegen_1.nil);
        }
      }
    };
    exports2.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/validation/limitItems.js
var require_limitItems = __commonJS({
  "node_modules/ajv/dist/vocabularies/validation/limitItems.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var error = {
      message({ keyword, schemaCode }) {
        const comp = keyword === "maxItems" ? "more" : "fewer";
        return (0, codegen_1.str)`must NOT have ${comp} than ${schemaCode} items`;
      },
      params: ({ schemaCode }) => (0, codegen_1._)`{limit: ${schemaCode}}`
    };
    var def = {
      keyword: ["maxItems", "minItems"],
      type: "array",
      schemaType: "number",
      $data: true,
      error,
      code(cxt) {
        const { keyword, data, schemaCode } = cxt;
        const op = keyword === "maxItems" ? codegen_1.operators.GT : codegen_1.operators.LT;
        cxt.fail$data((0, codegen_1._)`${data}.length ${op} ${schemaCode}`);
      }
    };
    exports2.default = def;
  }
});

// node_modules/ajv/dist/runtime/equal.js
var require_equal = __commonJS({
  "node_modules/ajv/dist/runtime/equal.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var equal = require_fast_deep_equal();
    equal.code = 'require("ajv/dist/runtime/equal").default';
    exports2.default = equal;
  }
});

// node_modules/ajv/dist/vocabularies/validation/uniqueItems.js
var require_uniqueItems = __commonJS({
  "node_modules/ajv/dist/vocabularies/validation/uniqueItems.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var dataType_1 = require_dataType();
    var codegen_1 = require_codegen();
    var util_1 = require_util3();
    var equal_1 = require_equal();
    var error = {
      message: ({ params: { i, j } }) => (0, codegen_1.str)`must NOT have duplicate items (items ## ${j} and ${i} are identical)`,
      params: ({ params: { i, j } }) => (0, codegen_1._)`{i: ${i}, j: ${j}}`
    };
    var def = {
      keyword: "uniqueItems",
      type: "array",
      schemaType: "boolean",
      $data: true,
      error,
      code(cxt) {
        const { gen, data, $data, schema: schema2, parentSchema, schemaCode, it } = cxt;
        if (!$data && !schema2)
          return;
        const valid = gen.let("valid");
        const itemTypes = parentSchema.items ? (0, dataType_1.getSchemaTypes)(parentSchema.items) : [];
        cxt.block$data(valid, validateUniqueItems, (0, codegen_1._)`${schemaCode} === false`);
        cxt.ok(valid);
        function validateUniqueItems() {
          const i = gen.let("i", (0, codegen_1._)`${data}.length`);
          const j = gen.let("j");
          cxt.setParams({ i, j });
          gen.assign(valid, true);
          gen.if((0, codegen_1._)`${i} > 1`, () => (canOptimize() ? loopN : loopN2)(i, j));
        }
        function canOptimize() {
          return itemTypes.length > 0 && !itemTypes.some((t) => t === "object" || t === "array");
        }
        function loopN(i, j) {
          const item = gen.name("item");
          const wrongType = (0, dataType_1.checkDataTypes)(itemTypes, item, it.opts.strictNumbers, dataType_1.DataType.Wrong);
          const indices = gen.const("indices", (0, codegen_1._)`{}`);
          gen.for((0, codegen_1._)`;${i}--;`, () => {
            gen.let(item, (0, codegen_1._)`${data}[${i}]`);
            gen.if(wrongType, (0, codegen_1._)`continue`);
            if (itemTypes.length > 1)
              gen.if((0, codegen_1._)`typeof ${item} == "string"`, (0, codegen_1._)`${item} += "_"`);
            gen.if((0, codegen_1._)`typeof ${indices}[${item}] == "number"`, () => {
              gen.assign(j, (0, codegen_1._)`${indices}[${item}]`);
              cxt.error();
              gen.assign(valid, false).break();
            }).code((0, codegen_1._)`${indices}[${item}] = ${i}`);
          });
        }
        function loopN2(i, j) {
          const eql = (0, util_1.useFunc)(gen, equal_1.default);
          const outer = gen.name("outer");
          gen.label(outer).for((0, codegen_1._)`;${i}--;`, () => gen.for((0, codegen_1._)`${j} = ${i}; ${j}--;`, () => gen.if((0, codegen_1._)`${eql}(${data}[${i}], ${data}[${j}])`, () => {
            cxt.error();
            gen.assign(valid, false).break(outer);
          })));
        }
      }
    };
    exports2.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/validation/const.js
var require_const = __commonJS({
  "node_modules/ajv/dist/vocabularies/validation/const.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var util_1 = require_util3();
    var equal_1 = require_equal();
    var error = {
      message: "must be equal to constant",
      params: ({ schemaCode }) => (0, codegen_1._)`{allowedValue: ${schemaCode}}`
    };
    var def = {
      keyword: "const",
      $data: true,
      error,
      code(cxt) {
        const { gen, data, $data, schemaCode, schema: schema2 } = cxt;
        if ($data || schema2 && typeof schema2 == "object") {
          cxt.fail$data((0, codegen_1._)`!${(0, util_1.useFunc)(gen, equal_1.default)}(${data}, ${schemaCode})`);
        } else {
          cxt.fail((0, codegen_1._)`${schema2} !== ${data}`);
        }
      }
    };
    exports2.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/validation/enum.js
var require_enum2 = __commonJS({
  "node_modules/ajv/dist/vocabularies/validation/enum.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var util_1 = require_util3();
    var equal_1 = require_equal();
    var error = {
      message: "must be equal to one of the allowed values",
      params: ({ schemaCode }) => (0, codegen_1._)`{allowedValues: ${schemaCode}}`
    };
    var def = {
      keyword: "enum",
      schemaType: "array",
      $data: true,
      error,
      code(cxt) {
        const { gen, data, $data, schema: schema2, schemaCode, it } = cxt;
        if (!$data && schema2.length === 0)
          throw new Error("enum must have non-empty array");
        const useLoop = schema2.length >= it.opts.loopEnum;
        let eql;
        const getEql = () => eql !== null && eql !== void 0 ? eql : eql = (0, util_1.useFunc)(gen, equal_1.default);
        let valid;
        if (useLoop || $data) {
          valid = gen.let("valid");
          cxt.block$data(valid, loopEnum);
        } else {
          if (!Array.isArray(schema2))
            throw new Error("ajv implementation error");
          const vSchema = gen.const("vSchema", schemaCode);
          valid = (0, codegen_1.or)(...schema2.map((_x, i) => equalCode(vSchema, i)));
        }
        cxt.pass(valid);
        function loopEnum() {
          gen.assign(valid, false);
          gen.forOf("v", schemaCode, (v) => gen.if((0, codegen_1._)`${getEql()}(${data}, ${v})`, () => gen.assign(valid, true).break()));
        }
        function equalCode(vSchema, i) {
          const sch = schema2[i];
          return typeof sch === "object" && sch !== null ? (0, codegen_1._)`${getEql()}(${data}, ${vSchema}[${i}])` : (0, codegen_1._)`${data} === ${sch}`;
        }
      }
    };
    exports2.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/validation/index.js
var require_validation = __commonJS({
  "node_modules/ajv/dist/vocabularies/validation/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var limitNumber_1 = require_limitNumber();
    var multipleOf_1 = require_multipleOf();
    var limitLength_1 = require_limitLength();
    var pattern_1 = require_pattern2();
    var limitProperties_1 = require_limitProperties();
    var required_1 = require_required2();
    var limitItems_1 = require_limitItems();
    var uniqueItems_1 = require_uniqueItems();
    var const_1 = require_const();
    var enum_1 = require_enum2();
    var validation = [
      // number
      limitNumber_1.default,
      multipleOf_1.default,
      // string
      limitLength_1.default,
      pattern_1.default,
      // object
      limitProperties_1.default,
      required_1.default,
      // array
      limitItems_1.default,
      uniqueItems_1.default,
      // any
      { keyword: "type", schemaType: ["string", "array"] },
      { keyword: "nullable", schemaType: "boolean" },
      const_1.default,
      enum_1.default
    ];
    exports2.default = validation;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/additionalItems.js
var require_additionalItems = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/additionalItems.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.validateAdditionalItems = void 0;
    var codegen_1 = require_codegen();
    var util_1 = require_util3();
    var error = {
      message: ({ params: { len } }) => (0, codegen_1.str)`must NOT have more than ${len} items`,
      params: ({ params: { len } }) => (0, codegen_1._)`{limit: ${len}}`
    };
    var def = {
      keyword: "additionalItems",
      type: "array",
      schemaType: ["boolean", "object"],
      before: "uniqueItems",
      error,
      code(cxt) {
        const { parentSchema, it } = cxt;
        const { items } = parentSchema;
        if (!Array.isArray(items)) {
          (0, util_1.checkStrictMode)(it, '"additionalItems" is ignored when "items" is not an array of schemas');
          return;
        }
        validateAdditionalItems(cxt, items);
      }
    };
    function validateAdditionalItems(cxt, items) {
      const { gen, schema: schema2, data, keyword, it } = cxt;
      it.items = true;
      const len = gen.const("len", (0, codegen_1._)`${data}.length`);
      if (schema2 === false) {
        cxt.setParams({ len: items.length });
        cxt.pass((0, codegen_1._)`${len} <= ${items.length}`);
      } else if (typeof schema2 == "object" && !(0, util_1.alwaysValidSchema)(it, schema2)) {
        const valid = gen.var("valid", (0, codegen_1._)`${len} <= ${items.length}`);
        gen.if((0, codegen_1.not)(valid), () => validateItems(valid));
        cxt.ok(valid);
      }
      function validateItems(valid) {
        gen.forRange("i", items.length, len, (i) => {
          cxt.subschema({ keyword, dataProp: i, dataPropType: util_1.Type.Num }, valid);
          if (!it.allErrors)
            gen.if((0, codegen_1.not)(valid), () => gen.break());
        });
      }
    }
    exports2.validateAdditionalItems = validateAdditionalItems;
    exports2.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/items.js
var require_items2 = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/items.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.validateTuple = void 0;
    var codegen_1 = require_codegen();
    var util_1 = require_util3();
    var code_1 = require_code2();
    var def = {
      keyword: "items",
      type: "array",
      schemaType: ["object", "array", "boolean"],
      before: "uniqueItems",
      code(cxt) {
        const { schema: schema2, it } = cxt;
        if (Array.isArray(schema2))
          return validateTuple(cxt, "additionalItems", schema2);
        it.items = true;
        if ((0, util_1.alwaysValidSchema)(it, schema2))
          return;
        cxt.ok((0, code_1.validateArray)(cxt));
      }
    };
    function validateTuple(cxt, extraItems, schArr = cxt.schema) {
      const { gen, parentSchema, data, keyword, it } = cxt;
      checkStrictTuple(parentSchema);
      if (it.opts.unevaluated && schArr.length && it.items !== true) {
        it.items = util_1.mergeEvaluated.items(gen, schArr.length, it.items);
      }
      const valid = gen.name("valid");
      const len = gen.const("len", (0, codegen_1._)`${data}.length`);
      schArr.forEach((sch, i) => {
        if ((0, util_1.alwaysValidSchema)(it, sch))
          return;
        gen.if((0, codegen_1._)`${len} > ${i}`, () => cxt.subschema({
          keyword,
          schemaProp: i,
          dataProp: i
        }, valid));
        cxt.ok(valid);
      });
      function checkStrictTuple(sch) {
        const { opts, errSchemaPath } = it;
        const l = schArr.length;
        const fullTuple = l === sch.minItems && (l === sch.maxItems || sch[extraItems] === false);
        if (opts.strictTuples && !fullTuple) {
          const msg = `"${keyword}" is ${l}-tuple, but minItems or maxItems/${extraItems} are not specified or different at path "${errSchemaPath}"`;
          (0, util_1.checkStrictMode)(it, msg, opts.strictTuples);
        }
      }
    }
    exports2.validateTuple = validateTuple;
    exports2.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/prefixItems.js
var require_prefixItems = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/prefixItems.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var items_1 = require_items2();
    var def = {
      keyword: "prefixItems",
      type: "array",
      schemaType: ["array"],
      before: "uniqueItems",
      code: (cxt) => (0, items_1.validateTuple)(cxt, "items")
    };
    exports2.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/items2020.js
var require_items2020 = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/items2020.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var util_1 = require_util3();
    var code_1 = require_code2();
    var additionalItems_1 = require_additionalItems();
    var error = {
      message: ({ params: { len } }) => (0, codegen_1.str)`must NOT have more than ${len} items`,
      params: ({ params: { len } }) => (0, codegen_1._)`{limit: ${len}}`
    };
    var def = {
      keyword: "items",
      type: "array",
      schemaType: ["object", "boolean"],
      before: "uniqueItems",
      error,
      code(cxt) {
        const { schema: schema2, parentSchema, it } = cxt;
        const { prefixItems } = parentSchema;
        it.items = true;
        if ((0, util_1.alwaysValidSchema)(it, schema2))
          return;
        if (prefixItems)
          (0, additionalItems_1.validateAdditionalItems)(cxt, prefixItems);
        else
          cxt.ok((0, code_1.validateArray)(cxt));
      }
    };
    exports2.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/contains.js
var require_contains2 = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/contains.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var util_1 = require_util3();
    var error = {
      message: ({ params: { min, max } }) => max === void 0 ? (0, codegen_1.str)`must contain at least ${min} valid item(s)` : (0, codegen_1.str)`must contain at least ${min} and no more than ${max} valid item(s)`,
      params: ({ params: { min, max } }) => max === void 0 ? (0, codegen_1._)`{minContains: ${min}}` : (0, codegen_1._)`{minContains: ${min}, maxContains: ${max}}`
    };
    var def = {
      keyword: "contains",
      type: "array",
      schemaType: ["object", "boolean"],
      before: "uniqueItems",
      trackErrors: true,
      error,
      code(cxt) {
        const { gen, schema: schema2, parentSchema, data, it } = cxt;
        let min;
        let max;
        const { minContains, maxContains } = parentSchema;
        if (it.opts.next) {
          min = minContains === void 0 ? 1 : minContains;
          max = maxContains;
        } else {
          min = 1;
        }
        const len = gen.const("len", (0, codegen_1._)`${data}.length`);
        cxt.setParams({ min, max });
        if (max === void 0 && min === 0) {
          (0, util_1.checkStrictMode)(it, `"minContains" == 0 without "maxContains": "contains" keyword ignored`);
          return;
        }
        if (max !== void 0 && min > max) {
          (0, util_1.checkStrictMode)(it, `"minContains" > "maxContains" is always invalid`);
          cxt.fail();
          return;
        }
        if ((0, util_1.alwaysValidSchema)(it, schema2)) {
          let cond = (0, codegen_1._)`${len} >= ${min}`;
          if (max !== void 0)
            cond = (0, codegen_1._)`${cond} && ${len} <= ${max}`;
          cxt.pass(cond);
          return;
        }
        it.items = true;
        const valid = gen.name("valid");
        if (max === void 0 && min === 1) {
          validateItems(valid, () => gen.if(valid, () => gen.break()));
        } else if (min === 0) {
          gen.let(valid, true);
          if (max !== void 0)
            gen.if((0, codegen_1._)`${data}.length > 0`, validateItemsWithCount);
        } else {
          gen.let(valid, false);
          validateItemsWithCount();
        }
        cxt.result(valid, () => cxt.reset());
        function validateItemsWithCount() {
          const schValid = gen.name("_valid");
          const count = gen.let("count", 0);
          validateItems(schValid, () => gen.if(schValid, () => checkLimits(count)));
        }
        function validateItems(_valid, block) {
          gen.forRange("i", 0, len, (i) => {
            cxt.subschema({
              keyword: "contains",
              dataProp: i,
              dataPropType: util_1.Type.Num,
              compositeRule: true
            }, _valid);
            block();
          });
        }
        function checkLimits(count) {
          gen.code((0, codegen_1._)`${count}++`);
          if (max === void 0) {
            gen.if((0, codegen_1._)`${count} >= ${min}`, () => gen.assign(valid, true).break());
          } else {
            gen.if((0, codegen_1._)`${count} > ${max}`, () => gen.assign(valid, false).break());
            if (min === 1)
              gen.assign(valid, true);
            else
              gen.if((0, codegen_1._)`${count} >= ${min}`, () => gen.assign(valid, true));
          }
        }
      }
    };
    exports2.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/dependencies.js
var require_dependencies = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/dependencies.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.validateSchemaDeps = exports2.validatePropertyDeps = exports2.error = void 0;
    var codegen_1 = require_codegen();
    var util_1 = require_util3();
    var code_1 = require_code2();
    exports2.error = {
      message: ({ params: { property, depsCount, deps } }) => {
        const property_ies = depsCount === 1 ? "property" : "properties";
        return (0, codegen_1.str)`must have ${property_ies} ${deps} when property ${property} is present`;
      },
      params: ({ params: { property, depsCount, deps, missingProperty } }) => (0, codegen_1._)`{property: ${property},
    missingProperty: ${missingProperty},
    depsCount: ${depsCount},
    deps: ${deps}}`
      // TODO change to reference
    };
    var def = {
      keyword: "dependencies",
      type: "object",
      schemaType: "object",
      error: exports2.error,
      code(cxt) {
        const [propDeps, schDeps] = splitDependencies(cxt);
        validatePropertyDeps(cxt, propDeps);
        validateSchemaDeps(cxt, schDeps);
      }
    };
    function splitDependencies({ schema: schema2 }) {
      const propertyDeps = {};
      const schemaDeps = {};
      for (const key in schema2) {
        if (key === "__proto__")
          continue;
        const deps = Array.isArray(schema2[key]) ? propertyDeps : schemaDeps;
        deps[key] = schema2[key];
      }
      return [propertyDeps, schemaDeps];
    }
    function validatePropertyDeps(cxt, propertyDeps = cxt.schema) {
      const { gen, data, it } = cxt;
      if (Object.keys(propertyDeps).length === 0)
        return;
      const missing = gen.let("missing");
      for (const prop in propertyDeps) {
        const deps = propertyDeps[prop];
        if (deps.length === 0)
          continue;
        const hasProperty = (0, code_1.propertyInData)(gen, data, prop, it.opts.ownProperties);
        cxt.setParams({
          property: prop,
          depsCount: deps.length,
          deps: deps.join(", ")
        });
        if (it.allErrors) {
          gen.if(hasProperty, () => {
            for (const depProp of deps) {
              (0, code_1.checkReportMissingProp)(cxt, depProp);
            }
          });
        } else {
          gen.if((0, codegen_1._)`${hasProperty} && (${(0, code_1.checkMissingProp)(cxt, deps, missing)})`);
          (0, code_1.reportMissingProp)(cxt, missing);
          gen.else();
        }
      }
    }
    exports2.validatePropertyDeps = validatePropertyDeps;
    function validateSchemaDeps(cxt, schemaDeps = cxt.schema) {
      const { gen, data, keyword, it } = cxt;
      const valid = gen.name("valid");
      for (const prop in schemaDeps) {
        if ((0, util_1.alwaysValidSchema)(it, schemaDeps[prop]))
          continue;
        gen.if(
          (0, code_1.propertyInData)(gen, data, prop, it.opts.ownProperties),
          () => {
            const schCxt = cxt.subschema({ keyword, schemaProp: prop }, valid);
            cxt.mergeValidEvaluated(schCxt, valid);
          },
          () => gen.var(valid, true)
          // TODO var
        );
        cxt.ok(valid);
      }
    }
    exports2.validateSchemaDeps = validateSchemaDeps;
    exports2.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/propertyNames.js
var require_propertyNames = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/propertyNames.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var util_1 = require_util3();
    var error = {
      message: "property name must be valid",
      params: ({ params: params2 }) => (0, codegen_1._)`{propertyName: ${params2.propertyName}}`
    };
    var def = {
      keyword: "propertyNames",
      type: "object",
      schemaType: ["object", "boolean"],
      error,
      code(cxt) {
        const { gen, schema: schema2, data, it } = cxt;
        if ((0, util_1.alwaysValidSchema)(it, schema2))
          return;
        const valid = gen.name("valid");
        gen.forIn("key", data, (key) => {
          cxt.setParams({ propertyName: key });
          cxt.subschema({
            keyword: "propertyNames",
            data: key,
            dataTypes: ["string"],
            propertyName: key,
            compositeRule: true
          }, valid);
          gen.if((0, codegen_1.not)(valid), () => {
            cxt.error(true);
            if (!it.allErrors)
              gen.break();
          });
        });
        cxt.ok(valid);
      }
    };
    exports2.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/additionalProperties.js
var require_additionalProperties = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/additionalProperties.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var code_1 = require_code2();
    var codegen_1 = require_codegen();
    var names_1 = require_names();
    var util_1 = require_util3();
    var error = {
      message: "must NOT have additional properties",
      params: ({ params: params2 }) => (0, codegen_1._)`{additionalProperty: ${params2.additionalProperty}}`
    };
    var def = {
      keyword: "additionalProperties",
      type: ["object"],
      schemaType: ["boolean", "object"],
      allowUndefined: true,
      trackErrors: true,
      error,
      code(cxt) {
        const { gen, schema: schema2, parentSchema, data, errsCount, it } = cxt;
        if (!errsCount)
          throw new Error("ajv implementation error");
        const { allErrors, opts } = it;
        it.props = true;
        if (opts.removeAdditional !== "all" && (0, util_1.alwaysValidSchema)(it, schema2))
          return;
        const props = (0, code_1.allSchemaProperties)(parentSchema.properties);
        const patProps = (0, code_1.allSchemaProperties)(parentSchema.patternProperties);
        checkAdditionalProperties();
        cxt.ok((0, codegen_1._)`${errsCount} === ${names_1.default.errors}`);
        function checkAdditionalProperties() {
          gen.forIn("key", data, (key) => {
            if (!props.length && !patProps.length)
              additionalPropertyCode(key);
            else
              gen.if(isAdditional(key), () => additionalPropertyCode(key));
          });
        }
        function isAdditional(key) {
          let definedProp;
          if (props.length > 8) {
            const propsSchema = (0, util_1.schemaRefOrVal)(it, parentSchema.properties, "properties");
            definedProp = (0, code_1.isOwnProperty)(gen, propsSchema, key);
          } else if (props.length) {
            definedProp = (0, codegen_1.or)(...props.map((p) => (0, codegen_1._)`${key} === ${p}`));
          } else {
            definedProp = codegen_1.nil;
          }
          if (patProps.length) {
            definedProp = (0, codegen_1.or)(definedProp, ...patProps.map((p) => (0, codegen_1._)`${(0, code_1.usePattern)(cxt, p)}.test(${key})`));
          }
          return (0, codegen_1.not)(definedProp);
        }
        function deleteAdditional(key) {
          gen.code((0, codegen_1._)`delete ${data}[${key}]`);
        }
        function additionalPropertyCode(key) {
          if (opts.removeAdditional === "all" || opts.removeAdditional && schema2 === false) {
            deleteAdditional(key);
            return;
          }
          if (schema2 === false) {
            cxt.setParams({ additionalProperty: key });
            cxt.error();
            if (!allErrors)
              gen.break();
            return;
          }
          if (typeof schema2 == "object" && !(0, util_1.alwaysValidSchema)(it, schema2)) {
            const valid = gen.name("valid");
            if (opts.removeAdditional === "failing") {
              applyAdditionalSchema(key, valid, false);
              gen.if((0, codegen_1.not)(valid), () => {
                cxt.reset();
                deleteAdditional(key);
              });
            } else {
              applyAdditionalSchema(key, valid);
              if (!allErrors)
                gen.if((0, codegen_1.not)(valid), () => gen.break());
            }
          }
        }
        function applyAdditionalSchema(key, valid, errors) {
          const subschema = {
            keyword: "additionalProperties",
            dataProp: key,
            dataPropType: util_1.Type.Str
          };
          if (errors === false) {
            Object.assign(subschema, {
              compositeRule: true,
              createErrors: false,
              allErrors: false
            });
          }
          cxt.subschema(subschema, valid);
        }
      }
    };
    exports2.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/properties.js
var require_properties2 = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/properties.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var validate_1 = require_validate();
    var code_1 = require_code2();
    var util_1 = require_util3();
    var additionalProperties_1 = require_additionalProperties();
    var def = {
      keyword: "properties",
      type: "object",
      schemaType: "object",
      code(cxt) {
        const { gen, schema: schema2, parentSchema, data, it } = cxt;
        if (it.opts.removeAdditional === "all" && parentSchema.additionalProperties === void 0) {
          additionalProperties_1.default.code(new validate_1.KeywordCxt(it, additionalProperties_1.default, "additionalProperties"));
        }
        const allProps = (0, code_1.allSchemaProperties)(schema2);
        for (const prop of allProps) {
          it.definedProperties.add(prop);
        }
        if (it.opts.unevaluated && allProps.length && it.props !== true) {
          it.props = util_1.mergeEvaluated.props(gen, (0, util_1.toHash)(allProps), it.props);
        }
        const properties = allProps.filter((p) => !(0, util_1.alwaysValidSchema)(it, schema2[p]));
        if (properties.length === 0)
          return;
        const valid = gen.name("valid");
        for (const prop of properties) {
          if (hasDefault(prop)) {
            applyPropertySchema(prop);
          } else {
            gen.if((0, code_1.propertyInData)(gen, data, prop, it.opts.ownProperties));
            applyPropertySchema(prop);
            if (!it.allErrors)
              gen.else().var(valid, true);
            gen.endIf();
          }
          cxt.it.definedProperties.add(prop);
          cxt.ok(valid);
        }
        function hasDefault(prop) {
          return it.opts.useDefaults && !it.compositeRule && schema2[prop].default !== void 0;
        }
        function applyPropertySchema(prop) {
          cxt.subschema({
            keyword: "properties",
            schemaProp: prop,
            dataProp: prop
          }, valid);
        }
      }
    };
    exports2.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/patternProperties.js
var require_patternProperties = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/patternProperties.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var code_1 = require_code2();
    var codegen_1 = require_codegen();
    var util_1 = require_util3();
    var util_2 = require_util3();
    var def = {
      keyword: "patternProperties",
      type: "object",
      schemaType: "object",
      code(cxt) {
        const { gen, schema: schema2, data, parentSchema, it } = cxt;
        const { opts } = it;
        const patterns = (0, code_1.allSchemaProperties)(schema2);
        const alwaysValidPatterns = patterns.filter((p) => (0, util_1.alwaysValidSchema)(it, schema2[p]));
        if (patterns.length === 0 || alwaysValidPatterns.length === patterns.length && (!it.opts.unevaluated || it.props === true)) {
          return;
        }
        const checkProperties = opts.strictSchema && !opts.allowMatchingProperties && parentSchema.properties;
        const valid = gen.name("valid");
        if (it.props !== true && !(it.props instanceof codegen_1.Name)) {
          it.props = (0, util_2.evaluatedPropsToName)(gen, it.props);
        }
        const { props } = it;
        validatePatternProperties();
        function validatePatternProperties() {
          for (const pat of patterns) {
            if (checkProperties)
              checkMatchingProperties(pat);
            if (it.allErrors) {
              validateProperties(pat);
            } else {
              gen.var(valid, true);
              validateProperties(pat);
              gen.if(valid);
            }
          }
        }
        function checkMatchingProperties(pat) {
          for (const prop in checkProperties) {
            if (new RegExp(pat).test(prop)) {
              (0, util_1.checkStrictMode)(it, `property ${prop} matches pattern ${pat} (use allowMatchingProperties)`);
            }
          }
        }
        function validateProperties(pat) {
          gen.forIn("key", data, (key) => {
            gen.if((0, codegen_1._)`${(0, code_1.usePattern)(cxt, pat)}.test(${key})`, () => {
              const alwaysValid = alwaysValidPatterns.includes(pat);
              if (!alwaysValid) {
                cxt.subschema({
                  keyword: "patternProperties",
                  schemaProp: pat,
                  dataProp: key,
                  dataPropType: util_2.Type.Str
                }, valid);
              }
              if (it.opts.unevaluated && props !== true) {
                gen.assign((0, codegen_1._)`${props}[${key}]`, true);
              } else if (!alwaysValid && !it.allErrors) {
                gen.if((0, codegen_1.not)(valid), () => gen.break());
              }
            });
          });
        }
      }
    };
    exports2.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/not.js
var require_not = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/not.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var util_1 = require_util3();
    var def = {
      keyword: "not",
      schemaType: ["object", "boolean"],
      trackErrors: true,
      code(cxt) {
        const { gen, schema: schema2, it } = cxt;
        if ((0, util_1.alwaysValidSchema)(it, schema2)) {
          cxt.fail();
          return;
        }
        const valid = gen.name("valid");
        cxt.subschema({
          keyword: "not",
          compositeRule: true,
          createErrors: false,
          allErrors: false
        }, valid);
        cxt.failResult(valid, () => cxt.reset(), () => cxt.error());
      },
      error: { message: "must NOT be valid" }
    };
    exports2.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/anyOf.js
var require_anyOf = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/anyOf.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var code_1 = require_code2();
    var def = {
      keyword: "anyOf",
      schemaType: "array",
      trackErrors: true,
      code: code_1.validateUnion,
      error: { message: "must match a schema in anyOf" }
    };
    exports2.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/oneOf.js
var require_oneOf = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/oneOf.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var util_1 = require_util3();
    var error = {
      message: "must match exactly one schema in oneOf",
      params: ({ params: params2 }) => (0, codegen_1._)`{passingSchemas: ${params2.passing}}`
    };
    var def = {
      keyword: "oneOf",
      schemaType: "array",
      trackErrors: true,
      error,
      code(cxt) {
        const { gen, schema: schema2, parentSchema, it } = cxt;
        if (!Array.isArray(schema2))
          throw new Error("ajv implementation error");
        if (it.opts.discriminator && parentSchema.discriminator)
          return;
        const schArr = schema2;
        const valid = gen.let("valid", false);
        const passing = gen.let("passing", null);
        const schValid = gen.name("_valid");
        cxt.setParams({ passing });
        gen.block(validateOneOf);
        cxt.result(valid, () => cxt.reset(), () => cxt.error(true));
        function validateOneOf() {
          schArr.forEach((sch, i) => {
            let schCxt;
            if ((0, util_1.alwaysValidSchema)(it, sch)) {
              gen.var(schValid, true);
            } else {
              schCxt = cxt.subschema({
                keyword: "oneOf",
                schemaProp: i,
                compositeRule: true
              }, schValid);
            }
            if (i > 0) {
              gen.if((0, codegen_1._)`${schValid} && ${valid}`).assign(valid, false).assign(passing, (0, codegen_1._)`[${passing}, ${i}]`).else();
            }
            gen.if(schValid, () => {
              gen.assign(valid, true);
              gen.assign(passing, i);
              if (schCxt)
                cxt.mergeEvaluated(schCxt, codegen_1.Name);
            });
          });
        }
      }
    };
    exports2.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/allOf.js
var require_allOf = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/allOf.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var util_1 = require_util3();
    var def = {
      keyword: "allOf",
      schemaType: "array",
      code(cxt) {
        const { gen, schema: schema2, it } = cxt;
        if (!Array.isArray(schema2))
          throw new Error("ajv implementation error");
        const valid = gen.name("valid");
        schema2.forEach((sch, i) => {
          if ((0, util_1.alwaysValidSchema)(it, sch))
            return;
          const schCxt = cxt.subschema({ keyword: "allOf", schemaProp: i }, valid);
          cxt.ok(valid);
          cxt.mergeEvaluated(schCxt);
        });
      }
    };
    exports2.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/if.js
var require_if = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/if.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var util_1 = require_util3();
    var error = {
      message: ({ params: params2 }) => (0, codegen_1.str)`must match "${params2.ifClause}" schema`,
      params: ({ params: params2 }) => (0, codegen_1._)`{failingKeyword: ${params2.ifClause}}`
    };
    var def = {
      keyword: "if",
      schemaType: ["object", "boolean"],
      trackErrors: true,
      error,
      code(cxt) {
        const { gen, parentSchema, it } = cxt;
        if (parentSchema.then === void 0 && parentSchema.else === void 0) {
          (0, util_1.checkStrictMode)(it, '"if" without "then" and "else" is ignored');
        }
        const hasThen = hasSchema(it, "then");
        const hasElse = hasSchema(it, "else");
        if (!hasThen && !hasElse)
          return;
        const valid = gen.let("valid", true);
        const schValid = gen.name("_valid");
        validateIf();
        cxt.reset();
        if (hasThen && hasElse) {
          const ifClause = gen.let("ifClause");
          cxt.setParams({ ifClause });
          gen.if(schValid, validateClause("then", ifClause), validateClause("else", ifClause));
        } else if (hasThen) {
          gen.if(schValid, validateClause("then"));
        } else {
          gen.if((0, codegen_1.not)(schValid), validateClause("else"));
        }
        cxt.pass(valid, () => cxt.error(true));
        function validateIf() {
          const schCxt = cxt.subschema({
            keyword: "if",
            compositeRule: true,
            createErrors: false,
            allErrors: false
          }, schValid);
          cxt.mergeEvaluated(schCxt);
        }
        function validateClause(keyword, ifClause) {
          return () => {
            const schCxt = cxt.subschema({ keyword }, schValid);
            gen.assign(valid, schValid);
            cxt.mergeValidEvaluated(schCxt, valid);
            if (ifClause)
              gen.assign(ifClause, (0, codegen_1._)`${keyword}`);
            else
              cxt.setParams({ ifClause: keyword });
          };
        }
      }
    };
    function hasSchema(it, keyword) {
      const schema2 = it.schema[keyword];
      return schema2 !== void 0 && !(0, util_1.alwaysValidSchema)(it, schema2);
    }
    exports2.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/thenElse.js
var require_thenElse = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/thenElse.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var util_1 = require_util3();
    var def = {
      keyword: ["then", "else"],
      schemaType: ["object", "boolean"],
      code({ keyword, parentSchema, it }) {
        if (parentSchema.if === void 0)
          (0, util_1.checkStrictMode)(it, `"${keyword}" without "if" is ignored`);
      }
    };
    exports2.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/index.js
var require_applicator = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var additionalItems_1 = require_additionalItems();
    var prefixItems_1 = require_prefixItems();
    var items_1 = require_items2();
    var items2020_1 = require_items2020();
    var contains_1 = require_contains2();
    var dependencies_1 = require_dependencies();
    var propertyNames_1 = require_propertyNames();
    var additionalProperties_1 = require_additionalProperties();
    var properties_1 = require_properties2();
    var patternProperties_1 = require_patternProperties();
    var not_1 = require_not();
    var anyOf_1 = require_anyOf();
    var oneOf_1 = require_oneOf();
    var allOf_1 = require_allOf();
    var if_1 = require_if();
    var thenElse_1 = require_thenElse();
    function getApplicator(draft2020 = false) {
      const applicator = [
        // any
        not_1.default,
        anyOf_1.default,
        oneOf_1.default,
        allOf_1.default,
        if_1.default,
        thenElse_1.default,
        // object
        propertyNames_1.default,
        additionalProperties_1.default,
        dependencies_1.default,
        properties_1.default,
        patternProperties_1.default
      ];
      if (draft2020)
        applicator.push(prefixItems_1.default, items2020_1.default);
      else
        applicator.push(additionalItems_1.default, items_1.default);
      applicator.push(contains_1.default);
      return applicator;
    }
    exports2.default = getApplicator;
  }
});

// node_modules/ajv/dist/vocabularies/dynamic/dynamicAnchor.js
var require_dynamicAnchor = __commonJS({
  "node_modules/ajv/dist/vocabularies/dynamic/dynamicAnchor.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.dynamicAnchor = void 0;
    var codegen_1 = require_codegen();
    var names_1 = require_names();
    var compile_1 = require_compile();
    var ref_1 = require_ref3();
    var def = {
      keyword: "$dynamicAnchor",
      schemaType: "string",
      code: (cxt) => dynamicAnchor(cxt, cxt.schema)
    };
    function dynamicAnchor(cxt, anchor) {
      const { gen, it } = cxt;
      it.schemaEnv.root.dynamicAnchors[anchor] = true;
      const v = (0, codegen_1._)`${names_1.default.dynamicAnchors}${(0, codegen_1.getProperty)(anchor)}`;
      const validate2 = it.errSchemaPath === "#" ? it.validateName : _getValidate(cxt);
      gen.if((0, codegen_1._)`!${v}`, () => gen.assign(v, validate2));
    }
    exports2.dynamicAnchor = dynamicAnchor;
    function _getValidate(cxt) {
      const { schemaEnv, schema: schema2, self: self2 } = cxt.it;
      const { root, baseId, localRefs, meta } = schemaEnv.root;
      const { schemaId } = self2.opts;
      const sch = new compile_1.SchemaEnv({ schema: schema2, schemaId, root, baseId, localRefs, meta });
      compile_1.compileSchema.call(self2, sch);
      return (0, ref_1.getValidate)(cxt, sch);
    }
    exports2.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/dynamic/dynamicRef.js
var require_dynamicRef = __commonJS({
  "node_modules/ajv/dist/vocabularies/dynamic/dynamicRef.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.dynamicRef = void 0;
    var codegen_1 = require_codegen();
    var names_1 = require_names();
    var ref_1 = require_ref3();
    var def = {
      keyword: "$dynamicRef",
      schemaType: "string",
      code: (cxt) => dynamicRef(cxt, cxt.schema)
    };
    function dynamicRef(cxt, ref) {
      const { gen, keyword, it } = cxt;
      if (ref[0] !== "#")
        throw new Error(`"${keyword}" only supports hash fragment reference`);
      const anchor = ref.slice(1);
      if (it.allErrors) {
        _dynamicRef();
      } else {
        const valid = gen.let("valid", false);
        _dynamicRef(valid);
        cxt.ok(valid);
      }
      function _dynamicRef(valid) {
        if (it.schemaEnv.root.dynamicAnchors[anchor]) {
          const v = gen.let("_v", (0, codegen_1._)`${names_1.default.dynamicAnchors}${(0, codegen_1.getProperty)(anchor)}`);
          gen.if(v, _callRef(v, valid), _callRef(it.validateName, valid));
        } else {
          _callRef(it.validateName, valid)();
        }
      }
      function _callRef(validate2, valid) {
        return valid ? () => gen.block(() => {
          (0, ref_1.callRef)(cxt, validate2);
          gen.let(valid, true);
        }) : () => (0, ref_1.callRef)(cxt, validate2);
      }
    }
    exports2.dynamicRef = dynamicRef;
    exports2.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/dynamic/recursiveAnchor.js
var require_recursiveAnchor = __commonJS({
  "node_modules/ajv/dist/vocabularies/dynamic/recursiveAnchor.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var dynamicAnchor_1 = require_dynamicAnchor();
    var util_1 = require_util3();
    var def = {
      keyword: "$recursiveAnchor",
      schemaType: "boolean",
      code(cxt) {
        if (cxt.schema)
          (0, dynamicAnchor_1.dynamicAnchor)(cxt, "");
        else
          (0, util_1.checkStrictMode)(cxt.it, "$recursiveAnchor: false is ignored");
      }
    };
    exports2.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/dynamic/recursiveRef.js
var require_recursiveRef = __commonJS({
  "node_modules/ajv/dist/vocabularies/dynamic/recursiveRef.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var dynamicRef_1 = require_dynamicRef();
    var def = {
      keyword: "$recursiveRef",
      schemaType: "string",
      code: (cxt) => (0, dynamicRef_1.dynamicRef)(cxt, cxt.schema)
    };
    exports2.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/dynamic/index.js
var require_dynamic = __commonJS({
  "node_modules/ajv/dist/vocabularies/dynamic/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var dynamicAnchor_1 = require_dynamicAnchor();
    var dynamicRef_1 = require_dynamicRef();
    var recursiveAnchor_1 = require_recursiveAnchor();
    var recursiveRef_1 = require_recursiveRef();
    var dynamic = [dynamicAnchor_1.default, dynamicRef_1.default, recursiveAnchor_1.default, recursiveRef_1.default];
    exports2.default = dynamic;
  }
});

// node_modules/ajv/dist/vocabularies/validation/dependentRequired.js
var require_dependentRequired = __commonJS({
  "node_modules/ajv/dist/vocabularies/validation/dependentRequired.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var dependencies_1 = require_dependencies();
    var def = {
      keyword: "dependentRequired",
      type: "object",
      schemaType: "object",
      error: dependencies_1.error,
      code: (cxt) => (0, dependencies_1.validatePropertyDeps)(cxt)
    };
    exports2.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/dependentSchemas.js
var require_dependentSchemas = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/dependentSchemas.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var dependencies_1 = require_dependencies();
    var def = {
      keyword: "dependentSchemas",
      type: "object",
      schemaType: "object",
      code: (cxt) => (0, dependencies_1.validateSchemaDeps)(cxt)
    };
    exports2.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/validation/limitContains.js
var require_limitContains = __commonJS({
  "node_modules/ajv/dist/vocabularies/validation/limitContains.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var util_1 = require_util3();
    var def = {
      keyword: ["maxContains", "minContains"],
      type: "array",
      schemaType: "number",
      code({ keyword, parentSchema, it }) {
        if (parentSchema.contains === void 0) {
          (0, util_1.checkStrictMode)(it, `"${keyword}" without "contains" is ignored`);
        }
      }
    };
    exports2.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/next.js
var require_next2 = __commonJS({
  "node_modules/ajv/dist/vocabularies/next.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var dependentRequired_1 = require_dependentRequired();
    var dependentSchemas_1 = require_dependentSchemas();
    var limitContains_1 = require_limitContains();
    var next = [dependentRequired_1.default, dependentSchemas_1.default, limitContains_1.default];
    exports2.default = next;
  }
});

// node_modules/ajv/dist/vocabularies/unevaluated/unevaluatedProperties.js
var require_unevaluatedProperties = __commonJS({
  "node_modules/ajv/dist/vocabularies/unevaluated/unevaluatedProperties.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var util_1 = require_util3();
    var names_1 = require_names();
    var error = {
      message: "must NOT have unevaluated properties",
      params: ({ params: params2 }) => (0, codegen_1._)`{unevaluatedProperty: ${params2.unevaluatedProperty}}`
    };
    var def = {
      keyword: "unevaluatedProperties",
      type: "object",
      schemaType: ["boolean", "object"],
      trackErrors: true,
      error,
      code(cxt) {
        const { gen, schema: schema2, data, errsCount, it } = cxt;
        if (!errsCount)
          throw new Error("ajv implementation error");
        const { allErrors, props } = it;
        if (props instanceof codegen_1.Name) {
          gen.if((0, codegen_1._)`${props} !== true`, () => gen.forIn("key", data, (key) => gen.if(unevaluatedDynamic(props, key), () => unevaluatedPropCode(key))));
        } else if (props !== true) {
          gen.forIn("key", data, (key) => props === void 0 ? unevaluatedPropCode(key) : gen.if(unevaluatedStatic(props, key), () => unevaluatedPropCode(key)));
        }
        it.props = true;
        cxt.ok((0, codegen_1._)`${errsCount} === ${names_1.default.errors}`);
        function unevaluatedPropCode(key) {
          if (schema2 === false) {
            cxt.setParams({ unevaluatedProperty: key });
            cxt.error();
            if (!allErrors)
              gen.break();
            return;
          }
          if (!(0, util_1.alwaysValidSchema)(it, schema2)) {
            const valid = gen.name("valid");
            cxt.subschema({
              keyword: "unevaluatedProperties",
              dataProp: key,
              dataPropType: util_1.Type.Str
            }, valid);
            if (!allErrors)
              gen.if((0, codegen_1.not)(valid), () => gen.break());
          }
        }
        function unevaluatedDynamic(evaluatedProps, key) {
          return (0, codegen_1._)`!${evaluatedProps} || !${evaluatedProps}[${key}]`;
        }
        function unevaluatedStatic(evaluatedProps, key) {
          const ps = [];
          for (const p in evaluatedProps) {
            if (evaluatedProps[p] === true)
              ps.push((0, codegen_1._)`${key} !== ${p}`);
          }
          return (0, codegen_1.and)(...ps);
        }
      }
    };
    exports2.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/unevaluated/unevaluatedItems.js
var require_unevaluatedItems = __commonJS({
  "node_modules/ajv/dist/vocabularies/unevaluated/unevaluatedItems.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var util_1 = require_util3();
    var error = {
      message: ({ params: { len } }) => (0, codegen_1.str)`must NOT have more than ${len} items`,
      params: ({ params: { len } }) => (0, codegen_1._)`{limit: ${len}}`
    };
    var def = {
      keyword: "unevaluatedItems",
      type: "array",
      schemaType: ["boolean", "object"],
      error,
      code(cxt) {
        const { gen, schema: schema2, data, it } = cxt;
        const items = it.items || 0;
        if (items === true)
          return;
        const len = gen.const("len", (0, codegen_1._)`${data}.length`);
        if (schema2 === false) {
          cxt.setParams({ len: items });
          cxt.fail((0, codegen_1._)`${len} > ${items}`);
        } else if (typeof schema2 == "object" && !(0, util_1.alwaysValidSchema)(it, schema2)) {
          const valid = gen.var("valid", (0, codegen_1._)`${len} <= ${items}`);
          gen.if((0, codegen_1.not)(valid), () => validateItems(valid, items));
          cxt.ok(valid);
        }
        it.items = true;
        function validateItems(valid, from) {
          gen.forRange("i", from, len, (i) => {
            cxt.subschema({ keyword: "unevaluatedItems", dataProp: i, dataPropType: util_1.Type.Num }, valid);
            if (!it.allErrors)
              gen.if((0, codegen_1.not)(valid), () => gen.break());
          });
        }
      }
    };
    exports2.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/unevaluated/index.js
var require_unevaluated = __commonJS({
  "node_modules/ajv/dist/vocabularies/unevaluated/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var unevaluatedProperties_1 = require_unevaluatedProperties();
    var unevaluatedItems_1 = require_unevaluatedItems();
    var unevaluated = [unevaluatedProperties_1.default, unevaluatedItems_1.default];
    exports2.default = unevaluated;
  }
});

// node_modules/ajv/dist/vocabularies/format/format.js
var require_format = __commonJS({
  "node_modules/ajv/dist/vocabularies/format/format.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var error = {
      message: ({ schemaCode }) => (0, codegen_1.str)`must match format "${schemaCode}"`,
      params: ({ schemaCode }) => (0, codegen_1._)`{format: ${schemaCode}}`
    };
    var def = {
      keyword: "format",
      type: ["number", "string"],
      schemaType: "string",
      $data: true,
      error,
      code(cxt, ruleType) {
        const { gen, data, $data, schema: schema2, schemaCode, it } = cxt;
        const { opts, errSchemaPath, schemaEnv, self: self2 } = it;
        if (!opts.validateFormats)
          return;
        if ($data)
          validate$DataFormat();
        else
          validateFormat();
        function validate$DataFormat() {
          const fmts = gen.scopeValue("formats", {
            ref: self2.formats,
            code: opts.code.formats
          });
          const fDef = gen.const("fDef", (0, codegen_1._)`${fmts}[${schemaCode}]`);
          const fType = gen.let("fType");
          const format6 = gen.let("format");
          gen.if((0, codegen_1._)`typeof ${fDef} == "object" && !(${fDef} instanceof RegExp)`, () => gen.assign(fType, (0, codegen_1._)`${fDef}.type || "string"`).assign(format6, (0, codegen_1._)`${fDef}.validate`), () => gen.assign(fType, (0, codegen_1._)`"string"`).assign(format6, fDef));
          cxt.fail$data((0, codegen_1.or)(unknownFmt(), invalidFmt()));
          function unknownFmt() {
            if (opts.strictSchema === false)
              return codegen_1.nil;
            return (0, codegen_1._)`${schemaCode} && !${format6}`;
          }
          function invalidFmt() {
            const callFormat = schemaEnv.$async ? (0, codegen_1._)`(${fDef}.async ? await ${format6}(${data}) : ${format6}(${data}))` : (0, codegen_1._)`${format6}(${data})`;
            const validData = (0, codegen_1._)`(typeof ${format6} == "function" ? ${callFormat} : ${format6}.test(${data}))`;
            return (0, codegen_1._)`${format6} && ${format6} !== true && ${fType} === ${ruleType} && !${validData}`;
          }
        }
        function validateFormat() {
          const formatDef = self2.formats[schema2];
          if (!formatDef) {
            unknownFormat();
            return;
          }
          if (formatDef === true)
            return;
          const [fmtType, format6, fmtRef] = getFormat(formatDef);
          if (fmtType === ruleType)
            cxt.pass(validCondition());
          function unknownFormat() {
            if (opts.strictSchema === false) {
              self2.logger.warn(unknownMsg());
              return;
            }
            throw new Error(unknownMsg());
            function unknownMsg() {
              return `unknown format "${schema2}" ignored in schema at path "${errSchemaPath}"`;
            }
          }
          function getFormat(fmtDef) {
            const code = fmtDef instanceof RegExp ? (0, codegen_1.regexpCode)(fmtDef) : opts.code.formats ? (0, codegen_1._)`${opts.code.formats}${(0, codegen_1.getProperty)(schema2)}` : void 0;
            const fmt = gen.scopeValue("formats", { key: schema2, ref: fmtDef, code });
            if (typeof fmtDef == "object" && !(fmtDef instanceof RegExp)) {
              return [fmtDef.type || "string", fmtDef.validate, (0, codegen_1._)`${fmt}.validate`];
            }
            return ["string", fmtDef, fmt];
          }
          function validCondition() {
            if (typeof formatDef == "object" && !(formatDef instanceof RegExp) && formatDef.async) {
              if (!schemaEnv.$async)
                throw new Error("async format in sync schema");
              return (0, codegen_1._)`await ${fmtRef}(${data})`;
            }
            return typeof format6 == "function" ? (0, codegen_1._)`${fmtRef}(${data})` : (0, codegen_1._)`${fmtRef}.test(${data})`;
          }
        }
      }
    };
    exports2.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/format/index.js
var require_format2 = __commonJS({
  "node_modules/ajv/dist/vocabularies/format/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var format_1 = require_format();
    var format6 = [format_1.default];
    exports2.default = format6;
  }
});

// node_modules/ajv/dist/vocabularies/metadata.js
var require_metadata = __commonJS({
  "node_modules/ajv/dist/vocabularies/metadata.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.contentVocabulary = exports2.metadataVocabulary = void 0;
    exports2.metadataVocabulary = [
      "title",
      "description",
      "default",
      "deprecated",
      "readOnly",
      "writeOnly",
      "examples"
    ];
    exports2.contentVocabulary = [
      "contentMediaType",
      "contentEncoding",
      "contentSchema"
    ];
  }
});

// node_modules/ajv/dist/vocabularies/draft2020.js
var require_draft2020 = __commonJS({
  "node_modules/ajv/dist/vocabularies/draft2020.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var core_1 = require_core3();
    var validation_1 = require_validation();
    var applicator_1 = require_applicator();
    var dynamic_1 = require_dynamic();
    var next_1 = require_next2();
    var unevaluated_1 = require_unevaluated();
    var format_1 = require_format2();
    var metadata_1 = require_metadata();
    var draft2020Vocabularies = [
      dynamic_1.default,
      core_1.default,
      validation_1.default,
      (0, applicator_1.default)(true),
      format_1.default,
      metadata_1.metadataVocabulary,
      metadata_1.contentVocabulary,
      next_1.default,
      unevaluated_1.default
    ];
    exports2.default = draft2020Vocabularies;
  }
});

// node_modules/ajv/dist/vocabularies/discriminator/types.js
var require_types = __commonJS({
  "node_modules/ajv/dist/vocabularies/discriminator/types.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DiscrError = void 0;
    var DiscrError;
    (function(DiscrError2) {
      DiscrError2["Tag"] = "tag";
      DiscrError2["Mapping"] = "mapping";
    })(DiscrError || (exports2.DiscrError = DiscrError = {}));
  }
});

// node_modules/ajv/dist/vocabularies/discriminator/index.js
var require_discriminator = __commonJS({
  "node_modules/ajv/dist/vocabularies/discriminator/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var types_1 = require_types();
    var compile_1 = require_compile();
    var ref_error_1 = require_ref_error();
    var util_1 = require_util3();
    var error = {
      message: ({ params: { discrError, tagName } }) => discrError === types_1.DiscrError.Tag ? `tag "${tagName}" must be string` : `value of tag "${tagName}" must be in oneOf`,
      params: ({ params: { discrError, tag, tagName } }) => (0, codegen_1._)`{error: ${discrError}, tag: ${tagName}, tagValue: ${tag}}`
    };
    var def = {
      keyword: "discriminator",
      type: "object",
      schemaType: "object",
      error,
      code(cxt) {
        const { gen, data, schema: schema2, parentSchema, it } = cxt;
        const { oneOf } = parentSchema;
        if (!it.opts.discriminator) {
          throw new Error("discriminator: requires discriminator option");
        }
        const tagName = schema2.propertyName;
        if (typeof tagName != "string")
          throw new Error("discriminator: requires propertyName");
        if (schema2.mapping)
          throw new Error("discriminator: mapping is not supported");
        if (!oneOf)
          throw new Error("discriminator: requires oneOf keyword");
        const valid = gen.let("valid", false);
        const tag = gen.const("tag", (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(tagName)}`);
        gen.if((0, codegen_1._)`typeof ${tag} == "string"`, () => validateMapping(), () => cxt.error(false, { discrError: types_1.DiscrError.Tag, tag, tagName }));
        cxt.ok(valid);
        function validateMapping() {
          const mapping = getMapping();
          gen.if(false);
          for (const tagValue in mapping) {
            gen.elseIf((0, codegen_1._)`${tag} === ${tagValue}`);
            gen.assign(valid, applyTagSchema(mapping[tagValue]));
          }
          gen.else();
          cxt.error(false, { discrError: types_1.DiscrError.Mapping, tag, tagName });
          gen.endIf();
        }
        function applyTagSchema(schemaProp) {
          const _valid = gen.name("valid");
          const schCxt = cxt.subschema({ keyword: "oneOf", schemaProp }, _valid);
          cxt.mergeEvaluated(schCxt, codegen_1.Name);
          return _valid;
        }
        function getMapping() {
          var _a;
          const oneOfMapping = {};
          const topRequired = hasRequired(parentSchema);
          let tagRequired = true;
          for (let i = 0; i < oneOf.length; i++) {
            let sch = oneOf[i];
            if ((sch === null || sch === void 0 ? void 0 : sch.$ref) && !(0, util_1.schemaHasRulesButRef)(sch, it.self.RULES)) {
              const ref = sch.$ref;
              sch = compile_1.resolveRef.call(it.self, it.schemaEnv.root, it.baseId, ref);
              if (sch instanceof compile_1.SchemaEnv)
                sch = sch.schema;
              if (sch === void 0)
                throw new ref_error_1.default(it.opts.uriResolver, it.baseId, ref);
            }
            const propSch = (_a = sch === null || sch === void 0 ? void 0 : sch.properties) === null || _a === void 0 ? void 0 : _a[tagName];
            if (typeof propSch != "object") {
              throw new Error(`discriminator: oneOf subschemas (or referenced schemas) must have "properties/${tagName}"`);
            }
            tagRequired = tagRequired && (topRequired || hasRequired(sch));
            addMappings(propSch, i);
          }
          if (!tagRequired)
            throw new Error(`discriminator: "${tagName}" must be required`);
          return oneOfMapping;
          function hasRequired({ required }) {
            return Array.isArray(required) && required.includes(tagName);
          }
          function addMappings(sch, i) {
            if (sch.const) {
              addMapping(sch.const, i);
            } else if (sch.enum) {
              for (const tagValue of sch.enum) {
                addMapping(tagValue, i);
              }
            } else {
              throw new Error(`discriminator: "properties/${tagName}" must have "const" or "enum"`);
            }
          }
          function addMapping(tagValue, i) {
            if (typeof tagValue != "string" || tagValue in oneOfMapping) {
              throw new Error(`discriminator: "${tagName}" values must be unique strings`);
            }
            oneOfMapping[tagValue] = i;
          }
        }
      }
    };
    exports2.default = def;
  }
});

// node_modules/ajv/dist/refs/json-schema-2020-12/schema.json
var require_schema2 = __commonJS({
  "node_modules/ajv/dist/refs/json-schema-2020-12/schema.json"(exports2, module2) {
    module2.exports = {
      $schema: "https://json-schema.org/draft/2020-12/schema",
      $id: "https://json-schema.org/draft/2020-12/schema",
      $vocabulary: {
        "https://json-schema.org/draft/2020-12/vocab/core": true,
        "https://json-schema.org/draft/2020-12/vocab/applicator": true,
        "https://json-schema.org/draft/2020-12/vocab/unevaluated": true,
        "https://json-schema.org/draft/2020-12/vocab/validation": true,
        "https://json-schema.org/draft/2020-12/vocab/meta-data": true,
        "https://json-schema.org/draft/2020-12/vocab/format-annotation": true,
        "https://json-schema.org/draft/2020-12/vocab/content": true
      },
      $dynamicAnchor: "meta",
      title: "Core and Validation specifications meta-schema",
      allOf: [
        { $ref: "meta/core" },
        { $ref: "meta/applicator" },
        { $ref: "meta/unevaluated" },
        { $ref: "meta/validation" },
        { $ref: "meta/meta-data" },
        { $ref: "meta/format-annotation" },
        { $ref: "meta/content" }
      ],
      type: ["object", "boolean"],
      $comment: "This meta-schema also defines keywords that have appeared in previous drafts in order to prevent incompatible extensions as they remain in common use.",
      properties: {
        definitions: {
          $comment: '"definitions" has been replaced by "$defs".',
          type: "object",
          additionalProperties: { $dynamicRef: "#meta" },
          deprecated: true,
          default: {}
        },
        dependencies: {
          $comment: '"dependencies" has been split and replaced by "dependentSchemas" and "dependentRequired" in order to serve their differing semantics.',
          type: "object",
          additionalProperties: {
            anyOf: [{ $dynamicRef: "#meta" }, { $ref: "meta/validation#/$defs/stringArray" }]
          },
          deprecated: true,
          default: {}
        },
        $recursiveAnchor: {
          $comment: '"$recursiveAnchor" has been replaced by "$dynamicAnchor".',
          $ref: "meta/core#/$defs/anchorString",
          deprecated: true
        },
        $recursiveRef: {
          $comment: '"$recursiveRef" has been replaced by "$dynamicRef".',
          $ref: "meta/core#/$defs/uriReferenceString",
          deprecated: true
        }
      }
    };
  }
});

// node_modules/ajv/dist/refs/json-schema-2020-12/meta/applicator.json
var require_applicator2 = __commonJS({
  "node_modules/ajv/dist/refs/json-schema-2020-12/meta/applicator.json"(exports2, module2) {
    module2.exports = {
      $schema: "https://json-schema.org/draft/2020-12/schema",
      $id: "https://json-schema.org/draft/2020-12/meta/applicator",
      $vocabulary: {
        "https://json-schema.org/draft/2020-12/vocab/applicator": true
      },
      $dynamicAnchor: "meta",
      title: "Applicator vocabulary meta-schema",
      type: ["object", "boolean"],
      properties: {
        prefixItems: { $ref: "#/$defs/schemaArray" },
        items: { $dynamicRef: "#meta" },
        contains: { $dynamicRef: "#meta" },
        additionalProperties: { $dynamicRef: "#meta" },
        properties: {
          type: "object",
          additionalProperties: { $dynamicRef: "#meta" },
          default: {}
        },
        patternProperties: {
          type: "object",
          additionalProperties: { $dynamicRef: "#meta" },
          propertyNames: { format: "regex" },
          default: {}
        },
        dependentSchemas: {
          type: "object",
          additionalProperties: { $dynamicRef: "#meta" },
          default: {}
        },
        propertyNames: { $dynamicRef: "#meta" },
        if: { $dynamicRef: "#meta" },
        then: { $dynamicRef: "#meta" },
        else: { $dynamicRef: "#meta" },
        allOf: { $ref: "#/$defs/schemaArray" },
        anyOf: { $ref: "#/$defs/schemaArray" },
        oneOf: { $ref: "#/$defs/schemaArray" },
        not: { $dynamicRef: "#meta" }
      },
      $defs: {
        schemaArray: {
          type: "array",
          minItems: 1,
          items: { $dynamicRef: "#meta" }
        }
      }
    };
  }
});

// node_modules/ajv/dist/refs/json-schema-2020-12/meta/unevaluated.json
var require_unevaluated2 = __commonJS({
  "node_modules/ajv/dist/refs/json-schema-2020-12/meta/unevaluated.json"(exports2, module2) {
    module2.exports = {
      $schema: "https://json-schema.org/draft/2020-12/schema",
      $id: "https://json-schema.org/draft/2020-12/meta/unevaluated",
      $vocabulary: {
        "https://json-schema.org/draft/2020-12/vocab/unevaluated": true
      },
      $dynamicAnchor: "meta",
      title: "Unevaluated applicator vocabulary meta-schema",
      type: ["object", "boolean"],
      properties: {
        unevaluatedItems: { $dynamicRef: "#meta" },
        unevaluatedProperties: { $dynamicRef: "#meta" }
      }
    };
  }
});

// node_modules/ajv/dist/refs/json-schema-2020-12/meta/content.json
var require_content = __commonJS({
  "node_modules/ajv/dist/refs/json-schema-2020-12/meta/content.json"(exports2, module2) {
    module2.exports = {
      $schema: "https://json-schema.org/draft/2020-12/schema",
      $id: "https://json-schema.org/draft/2020-12/meta/content",
      $vocabulary: {
        "https://json-schema.org/draft/2020-12/vocab/content": true
      },
      $dynamicAnchor: "meta",
      title: "Content vocabulary meta-schema",
      type: ["object", "boolean"],
      properties: {
        contentEncoding: { type: "string" },
        contentMediaType: { type: "string" },
        contentSchema: { $dynamicRef: "#meta" }
      }
    };
  }
});

// node_modules/ajv/dist/refs/json-schema-2020-12/meta/core.json
var require_core4 = __commonJS({
  "node_modules/ajv/dist/refs/json-schema-2020-12/meta/core.json"(exports2, module2) {
    module2.exports = {
      $schema: "https://json-schema.org/draft/2020-12/schema",
      $id: "https://json-schema.org/draft/2020-12/meta/core",
      $vocabulary: {
        "https://json-schema.org/draft/2020-12/vocab/core": true
      },
      $dynamicAnchor: "meta",
      title: "Core vocabulary meta-schema",
      type: ["object", "boolean"],
      properties: {
        $id: {
          $ref: "#/$defs/uriReferenceString",
          $comment: "Non-empty fragments not allowed.",
          pattern: "^[^#]*#?$"
        },
        $schema: { $ref: "#/$defs/uriString" },
        $ref: { $ref: "#/$defs/uriReferenceString" },
        $anchor: { $ref: "#/$defs/anchorString" },
        $dynamicRef: { $ref: "#/$defs/uriReferenceString" },
        $dynamicAnchor: { $ref: "#/$defs/anchorString" },
        $vocabulary: {
          type: "object",
          propertyNames: { $ref: "#/$defs/uriString" },
          additionalProperties: {
            type: "boolean"
          }
        },
        $comment: {
          type: "string"
        },
        $defs: {
          type: "object",
          additionalProperties: { $dynamicRef: "#meta" }
        }
      },
      $defs: {
        anchorString: {
          type: "string",
          pattern: "^[A-Za-z_][-A-Za-z0-9._]*$"
        },
        uriString: {
          type: "string",
          format: "uri"
        },
        uriReferenceString: {
          type: "string",
          format: "uri-reference"
        }
      }
    };
  }
});

// node_modules/ajv/dist/refs/json-schema-2020-12/meta/format-annotation.json
var require_format_annotation = __commonJS({
  "node_modules/ajv/dist/refs/json-schema-2020-12/meta/format-annotation.json"(exports2, module2) {
    module2.exports = {
      $schema: "https://json-schema.org/draft/2020-12/schema",
      $id: "https://json-schema.org/draft/2020-12/meta/format-annotation",
      $vocabulary: {
        "https://json-schema.org/draft/2020-12/vocab/format-annotation": true
      },
      $dynamicAnchor: "meta",
      title: "Format vocabulary meta-schema for annotation results",
      type: ["object", "boolean"],
      properties: {
        format: { type: "string" }
      }
    };
  }
});

// node_modules/ajv/dist/refs/json-schema-2020-12/meta/meta-data.json
var require_meta_data = __commonJS({
  "node_modules/ajv/dist/refs/json-schema-2020-12/meta/meta-data.json"(exports2, module2) {
    module2.exports = {
      $schema: "https://json-schema.org/draft/2020-12/schema",
      $id: "https://json-schema.org/draft/2020-12/meta/meta-data",
      $vocabulary: {
        "https://json-schema.org/draft/2020-12/vocab/meta-data": true
      },
      $dynamicAnchor: "meta",
      title: "Meta-data vocabulary meta-schema",
      type: ["object", "boolean"],
      properties: {
        title: {
          type: "string"
        },
        description: {
          type: "string"
        },
        default: true,
        deprecated: {
          type: "boolean",
          default: false
        },
        readOnly: {
          type: "boolean",
          default: false
        },
        writeOnly: {
          type: "boolean",
          default: false
        },
        examples: {
          type: "array",
          items: true
        }
      }
    };
  }
});

// node_modules/ajv/dist/refs/json-schema-2020-12/meta/validation.json
var require_validation2 = __commonJS({
  "node_modules/ajv/dist/refs/json-schema-2020-12/meta/validation.json"(exports2, module2) {
    module2.exports = {
      $schema: "https://json-schema.org/draft/2020-12/schema",
      $id: "https://json-schema.org/draft/2020-12/meta/validation",
      $vocabulary: {
        "https://json-schema.org/draft/2020-12/vocab/validation": true
      },
      $dynamicAnchor: "meta",
      title: "Validation vocabulary meta-schema",
      type: ["object", "boolean"],
      properties: {
        type: {
          anyOf: [
            { $ref: "#/$defs/simpleTypes" },
            {
              type: "array",
              items: { $ref: "#/$defs/simpleTypes" },
              minItems: 1,
              uniqueItems: true
            }
          ]
        },
        const: true,
        enum: {
          type: "array",
          items: true
        },
        multipleOf: {
          type: "number",
          exclusiveMinimum: 0
        },
        maximum: {
          type: "number"
        },
        exclusiveMaximum: {
          type: "number"
        },
        minimum: {
          type: "number"
        },
        exclusiveMinimum: {
          type: "number"
        },
        maxLength: { $ref: "#/$defs/nonNegativeInteger" },
        minLength: { $ref: "#/$defs/nonNegativeIntegerDefault0" },
        pattern: {
          type: "string",
          format: "regex"
        },
        maxItems: { $ref: "#/$defs/nonNegativeInteger" },
        minItems: { $ref: "#/$defs/nonNegativeIntegerDefault0" },
        uniqueItems: {
          type: "boolean",
          default: false
        },
        maxContains: { $ref: "#/$defs/nonNegativeInteger" },
        minContains: {
          $ref: "#/$defs/nonNegativeInteger",
          default: 1
        },
        maxProperties: { $ref: "#/$defs/nonNegativeInteger" },
        minProperties: { $ref: "#/$defs/nonNegativeIntegerDefault0" },
        required: { $ref: "#/$defs/stringArray" },
        dependentRequired: {
          type: "object",
          additionalProperties: {
            $ref: "#/$defs/stringArray"
          }
        }
      },
      $defs: {
        nonNegativeInteger: {
          type: "integer",
          minimum: 0
        },
        nonNegativeIntegerDefault0: {
          $ref: "#/$defs/nonNegativeInteger",
          default: 0
        },
        simpleTypes: {
          enum: ["array", "boolean", "integer", "null", "number", "object", "string"]
        },
        stringArray: {
          type: "array",
          items: { type: "string" },
          uniqueItems: true,
          default: []
        }
      }
    };
  }
});

// node_modules/ajv/dist/refs/json-schema-2020-12/index.js
var require_json_schema_2020_12 = __commonJS({
  "node_modules/ajv/dist/refs/json-schema-2020-12/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var metaSchema = require_schema2();
    var applicator = require_applicator2();
    var unevaluated = require_unevaluated2();
    var content = require_content();
    var core2 = require_core4();
    var format6 = require_format_annotation();
    var metadata = require_meta_data();
    var validation = require_validation2();
    var META_SUPPORT_DATA = ["/properties"];
    function addMetaSchema2020($data) {
      ;
      [
        metaSchema,
        applicator,
        unevaluated,
        content,
        core2,
        with$data(this, format6),
        metadata,
        with$data(this, validation)
      ].forEach((sch) => this.addMetaSchema(sch, void 0, false));
      return this;
      function with$data(ajv, sch) {
        return $data ? ajv.$dataMetaSchema(sch, META_SUPPORT_DATA) : sch;
      }
    }
    exports2.default = addMetaSchema2020;
  }
});

// node_modules/ajv/dist/2020.js
var require__ = __commonJS({
  "node_modules/ajv/dist/2020.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MissingRefError = exports2.ValidationError = exports2.CodeGen = exports2.Name = exports2.nil = exports2.stringify = exports2.str = exports2._ = exports2.KeywordCxt = exports2.Ajv2020 = void 0;
    var core_1 = require_core2();
    var draft2020_1 = require_draft2020();
    var discriminator_1 = require_discriminator();
    var json_schema_2020_12_1 = require_json_schema_2020_12();
    var META_SCHEMA_ID = "https://json-schema.org/draft/2020-12/schema";
    var Ajv2020 = class extends core_1.default {
      constructor(opts = {}) {
        super({
          ...opts,
          dynamicRef: true,
          next: true,
          unevaluated: true
        });
      }
      _addVocabularies() {
        super._addVocabularies();
        draft2020_1.default.forEach((v) => this.addVocabulary(v));
        if (this.opts.discriminator)
          this.addKeyword(discriminator_1.default);
      }
      _addDefaultMetaSchema() {
        super._addDefaultMetaSchema();
        const { $data, meta } = this.opts;
        if (!meta)
          return;
        json_schema_2020_12_1.default.call(this, $data);
        this.refs["http://json-schema.org/schema"] = META_SCHEMA_ID;
      }
      defaultMeta() {
        return this.opts.defaultMeta = super.defaultMeta() || (this.getSchema(META_SCHEMA_ID) ? META_SCHEMA_ID : void 0);
      }
    };
    exports2.Ajv2020 = Ajv2020;
    module2.exports = exports2 = Ajv2020;
    module2.exports.Ajv2020 = Ajv2020;
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.default = Ajv2020;
    var validate_1 = require_validate();
    Object.defineProperty(exports2, "KeywordCxt", { enumerable: true, get: function() {
      return validate_1.KeywordCxt;
    } });
    var codegen_1 = require_codegen();
    Object.defineProperty(exports2, "_", { enumerable: true, get: function() {
      return codegen_1._;
    } });
    Object.defineProperty(exports2, "str", { enumerable: true, get: function() {
      return codegen_1.str;
    } });
    Object.defineProperty(exports2, "stringify", { enumerable: true, get: function() {
      return codegen_1.stringify;
    } });
    Object.defineProperty(exports2, "nil", { enumerable: true, get: function() {
      return codegen_1.nil;
    } });
    Object.defineProperty(exports2, "Name", { enumerable: true, get: function() {
      return codegen_1.Name;
    } });
    Object.defineProperty(exports2, "CodeGen", { enumerable: true, get: function() {
      return codegen_1.CodeGen;
    } });
    var validation_error_1 = require_validation_error();
    Object.defineProperty(exports2, "ValidationError", { enumerable: true, get: function() {
      return validation_error_1.default;
    } });
    var ref_error_1 = require_ref_error();
    Object.defineProperty(exports2, "MissingRefError", { enumerable: true, get: function() {
      return ref_error_1.default;
    } });
  }
});

// node_modules/ajv-draft-04/dist/vocabulary/core.js
var require_core5 = __commonJS({
  "node_modules/ajv-draft-04/dist/vocabulary/core.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var ref_1 = require_ref3();
    var core2 = [
      "$schema",
      "id",
      "$defs",
      { keyword: "$comment" },
      "definitions",
      ref_1.default
    ];
    exports2.default = core2;
  }
});

// node_modules/ajv-draft-04/dist/vocabulary/validation/limitNumber.js
var require_limitNumber2 = __commonJS({
  "node_modules/ajv-draft-04/dist/vocabulary/validation/limitNumber.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var core_1 = require_core2();
    var codegen_1 = require_codegen();
    var ops = codegen_1.operators;
    var KWDs = {
      maximum: {
        exclusive: "exclusiveMaximum",
        ops: [
          { okStr: "<=", ok: ops.LTE, fail: ops.GT },
          { okStr: "<", ok: ops.LT, fail: ops.GTE }
        ]
      },
      minimum: {
        exclusive: "exclusiveMinimum",
        ops: [
          { okStr: ">=", ok: ops.GTE, fail: ops.LT },
          { okStr: ">", ok: ops.GT, fail: ops.LTE }
        ]
      }
    };
    var error = {
      message: (cxt) => core_1.str`must be ${kwdOp(cxt).okStr} ${cxt.schemaCode}`,
      params: (cxt) => core_1._`{comparison: ${kwdOp(cxt).okStr}, limit: ${cxt.schemaCode}}`
    };
    var def = {
      keyword: Object.keys(KWDs),
      type: "number",
      schemaType: "number",
      $data: true,
      error,
      code(cxt) {
        const { data, schemaCode } = cxt;
        cxt.fail$data(core_1._`${data} ${kwdOp(cxt).fail} ${schemaCode} || isNaN(${data})`);
      }
    };
    function kwdOp(cxt) {
      var _a;
      const keyword = cxt.keyword;
      const opsIdx = ((_a = cxt.parentSchema) === null || _a === void 0 ? void 0 : _a[KWDs[keyword].exclusive]) ? 1 : 0;
      return KWDs[keyword].ops[opsIdx];
    }
    exports2.default = def;
  }
});

// node_modules/ajv-draft-04/dist/vocabulary/validation/limitNumberExclusive.js
var require_limitNumberExclusive = __commonJS({
  "node_modules/ajv-draft-04/dist/vocabulary/validation/limitNumberExclusive.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var KWDs = {
      exclusiveMaximum: "maximum",
      exclusiveMinimum: "minimum"
    };
    var def = {
      keyword: Object.keys(KWDs),
      type: "number",
      schemaType: "boolean",
      code({ keyword, parentSchema }) {
        const limitKwd = KWDs[keyword];
        if (parentSchema[limitKwd] === void 0) {
          throw new Error(`${keyword} can only be used with ${limitKwd}`);
        }
      }
    };
    exports2.default = def;
  }
});

// node_modules/ajv-draft-04/dist/vocabulary/validation/index.js
var require_validation3 = __commonJS({
  "node_modules/ajv-draft-04/dist/vocabulary/validation/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var limitNumber_1 = require_limitNumber2();
    var limitNumberExclusive_1 = require_limitNumberExclusive();
    var multipleOf_1 = require_multipleOf();
    var limitLength_1 = require_limitLength();
    var pattern_1 = require_pattern2();
    var limitProperties_1 = require_limitProperties();
    var required_1 = require_required2();
    var limitItems_1 = require_limitItems();
    var uniqueItems_1 = require_uniqueItems();
    var const_1 = require_const();
    var enum_1 = require_enum2();
    var validation = [
      // number
      limitNumber_1.default,
      limitNumberExclusive_1.default,
      multipleOf_1.default,
      // string
      limitLength_1.default,
      pattern_1.default,
      // object
      limitProperties_1.default,
      required_1.default,
      // array
      limitItems_1.default,
      uniqueItems_1.default,
      // any
      { keyword: "type", schemaType: ["string", "array"] },
      { keyword: "nullable", schemaType: "boolean" },
      const_1.default,
      enum_1.default
    ];
    exports2.default = validation;
  }
});

// node_modules/ajv-draft-04/dist/vocabulary/draft4.js
var require_draft4 = __commonJS({
  "node_modules/ajv-draft-04/dist/vocabulary/draft4.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var core_1 = require_core5();
    var validation_1 = require_validation3();
    var applicator_1 = require_applicator();
    var format_1 = require_format2();
    var metadataVocabulary = ["title", "description", "default"];
    var draft4Vocabularies = [
      core_1.default,
      validation_1.default,
      applicator_1.default(),
      format_1.default,
      metadataVocabulary
    ];
    exports2.default = draft4Vocabularies;
  }
});

// node_modules/ajv-draft-04/dist/refs/json-schema-draft-04.json
var require_json_schema_draft_04 = __commonJS({
  "node_modules/ajv-draft-04/dist/refs/json-schema-draft-04.json"(exports2, module2) {
    module2.exports = {
      id: "http://json-schema.org/draft-04/schema#",
      $schema: "http://json-schema.org/draft-04/schema#",
      description: "Core schema meta-schema",
      definitions: {
        schemaArray: {
          type: "array",
          minItems: 1,
          items: { $ref: "#" }
        },
        positiveInteger: {
          type: "integer",
          minimum: 0
        },
        positiveIntegerDefault0: {
          allOf: [{ $ref: "#/definitions/positiveInteger" }, { default: 0 }]
        },
        simpleTypes: {
          enum: ["array", "boolean", "integer", "null", "number", "object", "string"]
        },
        stringArray: {
          type: "array",
          items: { type: "string" },
          minItems: 1,
          uniqueItems: true
        }
      },
      type: "object",
      properties: {
        id: {
          type: "string",
          format: "uri"
        },
        $schema: {
          type: "string",
          format: "uri"
        },
        title: {
          type: "string"
        },
        description: {
          type: "string"
        },
        default: {},
        multipleOf: {
          type: "number",
          minimum: 0,
          exclusiveMinimum: true
        },
        maximum: {
          type: "number"
        },
        exclusiveMaximum: {
          type: "boolean",
          default: false
        },
        minimum: {
          type: "number"
        },
        exclusiveMinimum: {
          type: "boolean",
          default: false
        },
        maxLength: { $ref: "#/definitions/positiveInteger" },
        minLength: { $ref: "#/definitions/positiveIntegerDefault0" },
        pattern: {
          type: "string",
          format: "regex"
        },
        additionalItems: {
          anyOf: [{ type: "boolean" }, { $ref: "#" }],
          default: {}
        },
        items: {
          anyOf: [{ $ref: "#" }, { $ref: "#/definitions/schemaArray" }],
          default: {}
        },
        maxItems: { $ref: "#/definitions/positiveInteger" },
        minItems: { $ref: "#/definitions/positiveIntegerDefault0" },
        uniqueItems: {
          type: "boolean",
          default: false
        },
        maxProperties: { $ref: "#/definitions/positiveInteger" },
        minProperties: { $ref: "#/definitions/positiveIntegerDefault0" },
        required: { $ref: "#/definitions/stringArray" },
        additionalProperties: {
          anyOf: [{ type: "boolean" }, { $ref: "#" }],
          default: {}
        },
        definitions: {
          type: "object",
          additionalProperties: { $ref: "#" },
          default: {}
        },
        properties: {
          type: "object",
          additionalProperties: { $ref: "#" },
          default: {}
        },
        patternProperties: {
          type: "object",
          additionalProperties: { $ref: "#" },
          default: {}
        },
        dependencies: {
          type: "object",
          additionalProperties: {
            anyOf: [{ $ref: "#" }, { $ref: "#/definitions/stringArray" }]
          }
        },
        enum: {
          type: "array",
          minItems: 1,
          uniqueItems: true
        },
        type: {
          anyOf: [
            { $ref: "#/definitions/simpleTypes" },
            {
              type: "array",
              items: { $ref: "#/definitions/simpleTypes" },
              minItems: 1,
              uniqueItems: true
            }
          ]
        },
        allOf: { $ref: "#/definitions/schemaArray" },
        anyOf: { $ref: "#/definitions/schemaArray" },
        oneOf: { $ref: "#/definitions/schemaArray" },
        not: { $ref: "#" }
      },
      dependencies: {
        exclusiveMaximum: ["maximum"],
        exclusiveMinimum: ["minimum"]
      },
      default: {}
    };
  }
});

// node_modules/ajv-draft-04/dist/index.js
var require_dist3 = __commonJS({
  "node_modules/ajv-draft-04/dist/index.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CodeGen = exports2.Name = exports2.nil = exports2.stringify = exports2.str = exports2._ = exports2.KeywordCxt = void 0;
    var core_1 = require_core2();
    var draft4_1 = require_draft4();
    var discriminator_1 = require_discriminator();
    var draft4MetaSchema = require_json_schema_draft_04();
    var META_SUPPORT_DATA = ["/properties"];
    var META_SCHEMA_ID = "http://json-schema.org/draft-04/schema";
    var Ajv = class extends core_1.default {
      constructor(opts = {}) {
        super({
          ...opts,
          schemaId: "id"
        });
      }
      _addVocabularies() {
        super._addVocabularies();
        draft4_1.default.forEach((v) => this.addVocabulary(v));
        if (this.opts.discriminator)
          this.addKeyword(discriminator_1.default);
      }
      _addDefaultMetaSchema() {
        super._addDefaultMetaSchema();
        if (!this.opts.meta)
          return;
        const metaSchema = this.opts.$data ? this.$dataMetaSchema(draft4MetaSchema, META_SUPPORT_DATA) : draft4MetaSchema;
        this.addMetaSchema(metaSchema, META_SCHEMA_ID, false);
        this.refs["http://json-schema.org/schema"] = META_SCHEMA_ID;
      }
      defaultMeta() {
        return this.opts.defaultMeta = super.defaultMeta() || (this.getSchema(META_SCHEMA_ID) ? META_SCHEMA_ID : void 0);
      }
    };
    module2.exports = exports2 = Ajv;
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.default = Ajv;
    var core_2 = require_core2();
    Object.defineProperty(exports2, "KeywordCxt", { enumerable: true, get: function() {
      return core_2.KeywordCxt;
    } });
    var core_3 = require_core2();
    Object.defineProperty(exports2, "_", { enumerable: true, get: function() {
      return core_3._;
    } });
    Object.defineProperty(exports2, "str", { enumerable: true, get: function() {
      return core_3.str;
    } });
    Object.defineProperty(exports2, "stringify", { enumerable: true, get: function() {
      return core_3.stringify;
    } });
    Object.defineProperty(exports2, "nil", { enumerable: true, get: function() {
      return core_3.nil;
    } });
    Object.defineProperty(exports2, "Name", { enumerable: true, get: function() {
      return core_3.Name;
    } });
    Object.defineProperty(exports2, "CodeGen", { enumerable: true, get: function() {
      return core_3.CodeGen;
    } });
  }
});

// node_modules/@readme/openapi-parser/lib/validators/schema.js
var require_schema3 = __commonJS({
  "node_modules/@readme/openapi-parser/lib/validators/schema.js"(exports2, module2) {
    var { ono: ono2 } = (init_esm(), __toCommonJS(esm_exports));
    var betterAjvErrors = require_lib14();
    var { openapi } = require_dist2();
    var Ajv = require__();
    var AjvDraft4 = require_dist3();
    var { getSpecificationName } = require_util();
    var LARGE_SPEC_ERROR_CAP = 20;
    var LARGE_SPEC_SIZE_CAP = 5e6;
    module2.exports = validateSchema;
    function validateSchema(api, options) {
      let ajv;
      let schema2;
      if (api.swagger) {
        schema2 = openapi.v2;
        ajv = initializeAjv();
      } else if (api.openapi.startsWith("3.1")) {
        schema2 = openapi.v31legacy;
        const schemaDynamicRef = schema2.$defs.schema;
        delete schemaDynamicRef.$dynamicAnchor;
        schema2.$defs.components.properties.schemas.additionalProperties = schemaDynamicRef;
        schema2.$defs.header.dependentSchemas.schema.properties.schema = schemaDynamicRef;
        schema2.$defs["media-type"].properties.schema = schemaDynamicRef;
        schema2.$defs.parameter.properties.schema = schemaDynamicRef;
        ajv = initializeAjv(false);
      } else {
        schema2 = openapi.v3;
        ajv = initializeAjv();
      }
      const isValid = ajv.validate(schema2, api);
      if (!isValid) {
        const err = ajv.errors;
        let additionalErrors = 0;
        let reducedErrors = reduceAjvErrors(err);
        const totalErrors = reducedErrors.length;
        if (reducedErrors.length >= LARGE_SPEC_ERROR_CAP) {
          try {
            if (JSON.stringify(api).length >= LARGE_SPEC_SIZE_CAP) {
              additionalErrors = reducedErrors.length - 20;
              reducedErrors = reducedErrors.slice(0, 20);
            }
          } catch (error) {
          }
        }
        let message = `${getSpecificationName(api)} schema validation failed.
`;
        message += "\n";
        message += betterAjvErrors(schema2, api, reducedErrors, {
          colorize: options.validate.colorizeErrors,
          indent: 2
        });
        if (additionalErrors) {
          message += "\n\n";
          message += `Plus an additional ${additionalErrors} errors. Please resolve the above and re-run validation to see more.`;
        }
        throw ono2.syntax(err, { details: err, totalErrors }, message);
      }
    }
    function initializeAjv(draft04 = true) {
      const opts = {
        allErrors: true,
        strict: false,
        validateFormats: false
      };
      if (draft04) {
        return new AjvDraft4(opts);
      }
      return new Ajv(opts);
    }
    function reduceAjvErrors(errors) {
      const flattened = /* @__PURE__ */ new Map();
      errors.forEach((err) => {
        if (["must have required property '$ref'", "must match exactly one schema in oneOf"].includes(err.message)) {
          return;
        }
        if (!flattened.size) {
          flattened.set(err.instancePath, err);
          return;
        } else if (flattened.has(err.instancePath)) {
          return;
        }
        let shouldRecordError = true;
        flattened.forEach((flat) => {
          if (flat.instancePath.includes(err.instancePath)) {
            shouldRecordError = false;
          }
        });
        if (shouldRecordError) {
          flattened.set(err.instancePath, err);
        }
      });
      if (!flattened.size) {
        return errors;
      }
      return [...flattened.values()];
    }
  }
});

// node_modules/@apidevtools/swagger-methods/lib/index.js
var require_lib15 = __commonJS({
  "node_modules/@apidevtools/swagger-methods/lib/index.js"(exports2, module2) {
    "use strict";
    module2.exports = [
      "get",
      "put",
      "post",
      "delete",
      "options",
      "head",
      "patch"
    ];
  }
});

// node_modules/@readme/openapi-parser/lib/validators/spec/openapi.js
var require_openapi = __commonJS({
  "node_modules/@readme/openapi-parser/lib/validators/spec/openapi.js"(exports2, module2) {
    var swaggerMethods = require_lib15();
    var { ono: ono2 } = (init_esm(), __toCommonJS(esm_exports));
    var util2 = require_util();
    module2.exports = validateSpec;
    function validateSpec(api) {
      const operationIds = [];
      Object.keys(api.paths || {}).forEach((pathName) => {
        const path = api.paths[pathName];
        const pathId = `/paths${pathName}`;
        if (path && pathName.indexOf("/") === 0) {
          validatePath(api, path, pathId, operationIds);
        }
      });
      if (api.openapi.startsWith("3.0")) {
        if (api.components) {
          Object.keys(api.components).forEach((componentType) => {
            Object.keys(api.components[componentType]).forEach((componentName) => {
              const componentId = `/components/${componentType}/${componentName}`;
              if (!/^[a-zA-Z0-9.\-_]+$/.test(componentName)) {
                throw ono2.syntax(
                  `Validation failed. ${componentId} has an invalid name. Component names should match against: /^[a-zA-Z0-9.-_]+$/`
                );
              }
            });
          });
        }
      }
    }
    function validatePath(api, path, pathId, operationIds) {
      [...swaggerMethods, "trace"].forEach((operationName) => {
        const operation = path[operationName];
        const operationId = `${pathId}/${operationName}`;
        if (operation) {
          const declaredOperationId = operation.operationId;
          if (declaredOperationId) {
            if (operationIds.indexOf(declaredOperationId) === -1) {
              operationIds.push(declaredOperationId);
            } else {
              throw ono2.syntax(`Validation failed. Duplicate operation id '${declaredOperationId}'`);
            }
          }
          validateParameters(api, path, pathId, operation, operationId);
          Object.keys(operation.responses || {}).forEach((responseCode) => {
            const response = operation.responses[responseCode];
            const responseId = `${operationId}/responses/${responseCode}`;
            validateResponse(responseCode, response || {}, responseId);
          });
        }
      });
    }
    function validateParameters(api, path, pathId, operation, operationId) {
      const pathParams = path.parameters || [];
      const operationParams = operation.parameters || [];
      try {
        checkForDuplicates(pathParams);
      } catch (e) {
        throw ono2.syntax(e, `Validation failed. ${pathId} has duplicate parameters`);
      }
      try {
        checkForDuplicates(operationParams);
      } catch (e) {
        throw ono2.syntax(e, `Validation failed. ${operationId} has duplicate parameters`);
      }
      const params2 = pathParams.reduce((combinedParams, value) => {
        const duplicate = combinedParams.some((param) => {
          return param.in === value.in && param.name === value.name;
        });
        if (!duplicate) {
          combinedParams.push(value);
        }
        return combinedParams;
      }, operationParams.slice());
      validatePathParameters(params2, pathId, operationId);
      validateParameterTypes(params2, api, operation, operationId);
    }
    function validatePathParameters(params2, pathId, operationId) {
      const placeholders = [...new Set(pathId.match(util2.swaggerParamRegExp) || [])];
      params2.filter((param) => param.in === "path").forEach((param) => {
        if (param.required !== true) {
          throw ono2.syntax(
            `Validation failed. Path parameters cannot be optional. Set required=true for the "${param.name}" parameter at ${operationId}`
          );
        }
        const match2 = placeholders.indexOf(`{${param.name}}`);
        if (match2 === -1) {
          throw ono2.syntax(
            `Validation failed. ${operationId} has a path parameter named "${param.name}", but there is no corresponding {${param.name}} in the path string`
          );
        }
        placeholders.splice(match2, 1);
      });
      if (placeholders.length > 0) {
        throw ono2.syntax(`Validation failed. ${operationId} is missing path parameter(s) for ${placeholders}`);
      }
    }
    function validateParameterTypes(params2, api, operation, operationId) {
      params2.forEach((param) => {
        if (!param.schema && param.content) {
          return;
        }
        const parameterId = `${operationId}/parameters/${param.name}`;
        validateSchema(param.schema, parameterId);
      });
    }
    function checkForDuplicates(params2) {
      for (let i = 0; i < params2.length - 1; i++) {
        const outer = params2[i];
        for (let j = i + 1; j < params2.length; j++) {
          const inner = params2[j];
          if (outer.name === inner.name && outer.in === inner.in) {
            throw ono2.syntax(`Validation failed. Found multiple ${outer.in} parameters named "${outer.name}"`);
          }
        }
      }
    }
    function validateResponse(code, response, responseId) {
      Object.keys(response.headers || {}).forEach((headerName) => {
        const header = response.headers[headerName];
        const headerId = `${responseId}/headers/${headerName}`;
        if (header.schema) {
          validateSchema(header.schema, headerId);
        } else if (header.content) {
          Object.keys(header.content).forEach((mediaType) => {
            if (header.content[mediaType].schema) {
              validateSchema(header.content[mediaType].schema || {}, `${headerId}/content/${mediaType}/schema`);
            }
          });
        }
      });
      if (response.content) {
        Object.keys(response.content).forEach((mediaType) => {
          if (response.content[mediaType].schema) {
            validateSchema(response.content[mediaType].schema || {}, `${responseId}/content/${mediaType}/schema`);
          }
        });
      }
    }
    function validateSchema(schema2, schemaId) {
      if (schema2.type === "array" && !schema2.items) {
        throw ono2.syntax(`Validation failed. ${schemaId} is an array, so it must include an "items" schema`);
      }
    }
  }
});

// node_modules/@readme/openapi-parser/lib/validators/spec/swagger.js
var require_swagger = __commonJS({
  "node_modules/@readme/openapi-parser/lib/validators/spec/swagger.js"(exports2, module2) {
    var swaggerMethods = require_lib15();
    var { ono: ono2 } = (init_esm(), __toCommonJS(esm_exports));
    var util2 = require_util();
    var primitiveTypes = ["array", "boolean", "integer", "number", "string"];
    var schemaTypes = ["array", "boolean", "integer", "number", "string", "object", "null", void 0];
    module2.exports = validateSpec;
    function validateSpec(api) {
      const operationIds = [];
      Object.keys(api.paths || {}).forEach((pathName) => {
        const path = api.paths[pathName];
        const pathId = `/paths${pathName}`;
        if (path && pathName.indexOf("/") === 0) {
          validatePath(api, path, pathId, operationIds);
        }
      });
      Object.keys(api.definitions || {}).forEach((definitionName) => {
        const definition = api.definitions[definitionName];
        const definitionId = `/definitions/${definitionName}`;
        if (!/^[a-zA-Z0-9.\-_]+$/.test(definitionName)) {
          throw ono2.syntax(
            `Validation failed. ${definitionId} has an invalid name. Definition names should match against: /^[a-zA-Z0-9.-_]+$/`
          );
        }
        validateRequiredPropertiesExist(definition, definitionId);
      });
    }
    function validatePath(api, path, pathId, operationIds) {
      swaggerMethods.forEach((operationName) => {
        const operation = path[operationName];
        const operationId = `${pathId}/${operationName}`;
        if (operation) {
          const declaredOperationId = operation.operationId;
          if (declaredOperationId) {
            if (operationIds.indexOf(declaredOperationId) === -1) {
              operationIds.push(declaredOperationId);
            } else {
              throw ono2.syntax(`Validation failed. Duplicate operation id '${declaredOperationId}'`);
            }
          }
          validateParameters(api, path, pathId, operation, operationId);
          Object.keys(operation.responses || {}).forEach((responseName) => {
            const response = operation.responses[responseName];
            const responseId = `${operationId}/responses/${responseName}`;
            validateResponse(responseName, response || {}, responseId);
          });
        }
      });
    }
    function validateParameters(api, path, pathId, operation, operationId) {
      const pathParams = path.parameters || [];
      const operationParams = operation.parameters || [];
      try {
        checkForDuplicates(pathParams);
      } catch (e) {
        throw ono2.syntax(e, `Validation failed. ${pathId} has duplicate parameters`);
      }
      try {
        checkForDuplicates(operationParams);
      } catch (e) {
        throw ono2.syntax(e, `Validation failed. ${operationId} has duplicate parameters`);
      }
      const params2 = pathParams.reduce((combinedParams, value) => {
        const duplicate = combinedParams.some((param) => {
          return param.in === value.in && param.name === value.name;
        });
        if (!duplicate) {
          combinedParams.push(value);
        }
        return combinedParams;
      }, operationParams.slice());
      validateBodyParameters(params2, operationId);
      validatePathParameters(params2, pathId, operationId);
      validateParameterTypes(params2, api, operation, operationId);
    }
    function validateBodyParameters(params2, operationId) {
      const bodyParams = params2.filter((param) => {
        return param.in === "body";
      });
      const formParams = params2.filter((param) => {
        return param.in === "formData";
      });
      if (bodyParams.length > 1) {
        throw ono2.syntax(
          `Validation failed. ${operationId} has ${bodyParams.length} body parameters. Only one is allowed.`
        );
      } else if (bodyParams.length > 0 && formParams.length > 0) {
        throw ono2.syntax(
          `Validation failed. ${operationId} has body parameters and formData parameters. Only one or the other is allowed.`
        );
      }
    }
    function validatePathParameters(params2, pathId, operationId) {
      const placeholders = pathId.match(util2.swaggerParamRegExp) || [];
      for (let i = 0; i < placeholders.length; i++) {
        for (let j = i + 1; j < placeholders.length; j++) {
          if (placeholders[i] === placeholders[j]) {
            throw ono2.syntax(`Validation failed. ${operationId} has multiple path placeholders named ${placeholders[i]}`);
          }
        }
      }
      params2.filter((param) => param.in === "path").forEach((param) => {
        if (param.required !== true) {
          throw ono2.syntax(
            `Validation failed. Path parameters cannot be optional. Set required=true for the "${param.name}" parameter at ${operationId}`
          );
        }
        const match2 = placeholders.indexOf(`{${param.name}}`);
        if (match2 === -1) {
          throw ono2.syntax(
            `Validation failed. ${operationId} has a path parameter named "${param.name}", but there is no corresponding {${param.name}} in the path string`
          );
        }
        placeholders.splice(match2, 1);
      });
      if (placeholders.length > 0) {
        throw ono2.syntax(`Validation failed. ${operationId} is missing path parameter(s) for ${placeholders}`);
      }
    }
    function validateParameterTypes(params2, api, operation, operationId) {
      params2.forEach((param) => {
        const parameterId = `${operationId}/parameters/${param.name}`;
        let schema2;
        let validTypes;
        switch (param.in) {
          case "body":
            schema2 = param.schema;
            validTypes = schemaTypes;
            break;
          case "formData":
            schema2 = param;
            validTypes = primitiveTypes.concat("file");
            break;
          default:
            schema2 = param;
            validTypes = primitiveTypes;
        }
        validateSchema(schema2, parameterId, validTypes);
        validateRequiredPropertiesExist(schema2, parameterId);
        if (schema2.type === "file") {
          const formData = /multipart\/(.*\+)?form-data/;
          const urlEncoded = /application\/(.*\+)?x-www-form-urlencoded/;
          const consumes = operation.consumes || api.consumes || [];
          const hasValidMimeType = consumes.some((consume) => {
            return formData.test(consume) || urlEncoded.test(consume);
          });
          if (!hasValidMimeType) {
            throw ono2.syntax(
              `Validation failed. ${operationId} has a file parameter, so it must consume multipart/form-data or application/x-www-form-urlencoded`
            );
          }
        }
      });
    }
    function checkForDuplicates(params2) {
      for (let i = 0; i < params2.length - 1; i++) {
        const outer = params2[i];
        for (let j = i + 1; j < params2.length; j++) {
          const inner = params2[j];
          if (outer.name === inner.name && outer.in === inner.in) {
            throw ono2.syntax(`Validation failed. Found multiple ${outer.in} parameters named "${outer.name}"`);
          }
        }
      }
    }
    function validateResponse(code, response, responseId) {
      if (code !== "default" && (code < 100 || code > 599)) {
        throw ono2.syntax(`Validation failed. ${responseId} has an invalid response code (${code})`);
      }
      Object.keys(response.headers || {}).forEach((headerName) => {
        const header = response.headers[headerName];
        const headerId = `${responseId}/headers/${headerName}`;
        validateSchema(header, headerId, primitiveTypes);
      });
      if (response.schema) {
        const validTypes = schemaTypes.concat("file");
        if (validTypes.indexOf(response.schema.type) === -1) {
          throw ono2.syntax(
            `Validation failed. ${responseId} has an invalid response schema type (${response.schema.type})`
          );
        } else {
          validateSchema(response.schema, `${responseId}/schema`, validTypes);
        }
      }
    }
    function validateSchema(schema2, schemaId, validTypes) {
      if (validTypes.indexOf(schema2.type) === -1) {
        throw ono2.syntax(`Validation failed. ${schemaId} has an invalid type (${schema2.type})`);
      }
      if (schema2.type === "array" && !schema2.items) {
        throw ono2.syntax(`Validation failed. ${schemaId} is an array, so it must include an "items" schema`);
      }
    }
    function validateRequiredPropertiesExist(schema2, schemaId) {
      function collectProperties(schemaObj, props) {
        if (schemaObj.properties) {
          Object.keys(schemaObj.properties).forEach((property) => {
            if (schemaObj.properties.hasOwnProperty(property)) {
              props[property] = schemaObj.properties[property];
            }
          });
        }
        if (schemaObj.allOf) {
          schemaObj.allOf.forEach((parent) => {
            collectProperties(parent, props);
          });
        }
      }
      if (schema2.required && Array.isArray(schema2.required)) {
        const props = {};
        collectProperties(schema2, props);
        schema2.required.forEach((requiredProperty) => {
          if (!props[requiredProperty]) {
            throw ono2.syntax(
              `Validation failed. Property '${requiredProperty}' listed as required but does not exist in '${schemaId}'`
            );
          }
        });
      }
    }
  }
});

// node_modules/@readme/openapi-parser/lib/validators/spec.js
var require_spec = __commonJS({
  "node_modules/@readme/openapi-parser/lib/validators/spec.js"(exports2, module2) {
    var validateOpenAPI = require_openapi();
    var validateSwagger = require_swagger();
    module2.exports = function validateSpec(api) {
      if (api.openapi) {
        return validateOpenAPI(api);
      }
      return validateSwagger(api);
    };
  }
});

// node_modules/@readme/openapi-parser/lib/options.js
var require_options2 = __commonJS({
  "node_modules/@readme/openapi-parser/lib/options.js"(exports2, module2) {
    var $RefParserOptions = require_options();
    var util2 = require_util();
    var schemaValidator = require_schema3();
    var specValidator = require_spec();
    module2.exports = ParserOptions;
    function ParserOptions(_options) {
      $RefParserOptions.call(this, ParserOptions.defaults);
      $RefParserOptions.apply(this, arguments);
    }
    ParserOptions.defaults = {
      /**
       * Determines how the API definition will be validated.
       *
       * You can add additional validators of your own, replace an existing one with
       * your own implemenation, or disable any validator by setting it to false.
       */
      validate: {
        colorizeErrors: false,
        schema: schemaValidator,
        spec: specValidator
      }
    };
    util2.inherits(ParserOptions, $RefParserOptions);
  }
});

// node_modules/@readme/openapi-parser/lib/index.js
var require_lib16 = __commonJS({
  "node_modules/@readme/openapi-parser/lib/index.js"(exports2, module2) {
    var { ono: ono2 } = (init_esm(), __toCommonJS(esm_exports));
    var $RefParser2 = require_lib9();
    var dereference = require_dereference();
    var normalizeArgs2 = require_normalize_args();
    var maybe = require_maybe();
    var Options = require_options2();
    var util2 = require_util();
    var validateSchema = require_schema3();
    var validateSpec = require_spec();
    module2.exports = OpenAPIParser;
    function OpenAPIParser() {
      $RefParser2.apply(this, arguments);
    }
    util2.inherits(OpenAPIParser, $RefParser2);
    OpenAPIParser.parse = $RefParser2.parse;
    OpenAPIParser.resolve = $RefParser2.resolve;
    OpenAPIParser.bundle = $RefParser2.bundle;
    OpenAPIParser.dereference = $RefParser2.dereference;
    Object.defineProperty(OpenAPIParser.prototype, "api", {
      configurable: true,
      enumerable: true,
      get() {
        return this.schema;
      }
    });
    OpenAPIParser.prototype.parse = async function(path, api, options, callback) {
      const args = normalizeArgs2(arguments);
      args.options = new Options(args.options);
      try {
        const schema2 = await $RefParser2.prototype.parse.call(this, args.path, args.schema, args.options);
        if (schema2.swagger) {
          if (schema2.swagger === void 0 || schema2.info === void 0 || schema2.paths === void 0) {
            throw ono2.syntax(`${args.path || "Supplied schema"} is not a valid Swagger API definition.`);
          } else if (typeof schema2.swagger === "number") {
            throw ono2.syntax('Swagger version number must be a string (e.g. "2.0") not a number.');
          } else if (typeof schema2.info.version === "number") {
            throw ono2.syntax('API version number must be a string (e.g. "1.0.0") not a number.');
          } else if (schema2.swagger !== "2.0") {
            throw ono2.syntax(`Unrecognized Swagger version: ${schema2.swagger}. Expected 2.0`);
          }
        } else {
          const supportedVersions = ["3.0.0", "3.0.1", "3.0.2", "3.0.3", "3.1.0"];
          if (schema2.openapi === void 0 || schema2.info === void 0) {
            throw ono2.syntax(`${args.path || "Supplied schema"} is not a valid OpenAPI definition.`);
          } else if (schema2.paths === void 0) {
            if (schema2.openapi === "3.1.0") {
              if (schema2.webhooks === void 0) {
                throw ono2.syntax(`${args.path || "Supplied schema"} is not a valid OpenAPI definition.`);
              }
            } else {
              throw ono2.syntax(`${args.path || "Supplied schema"} is not a valid OpenAPI definition.`);
            }
          } else if (typeof schema2.openapi === "number") {
            throw ono2.syntax('OpenAPI version number must be a string (e.g. "3.0.0") not a number.');
          } else if (typeof schema2.info.version === "number") {
            throw ono2.syntax('API version number must be a string (e.g. "1.0.0") not a number.');
          } else if (supportedVersions.indexOf(schema2.openapi) === -1) {
            throw ono2.syntax(
              `Unsupported OpenAPI version: ${schema2.openapi}. Swagger Parser only supports versions ${supportedVersions.join(", ")}`
            );
          }
          util2.fixOasRelativeServers(schema2, args.path);
        }
        return maybe(args.callback, Promise.resolve(schema2));
      } catch (err) {
        return maybe(args.callback, Promise.reject(err));
      }
    };
    OpenAPIParser.validate = function(path, api, options, callback) {
      const Class = this;
      const instance = new Class();
      return instance.validate.apply(instance, arguments);
    };
    OpenAPIParser.prototype.validate = async function(path, api, options, callback) {
      const me = this;
      const args = normalizeArgs2(arguments);
      args.options = new Options(args.options);
      const circular$RefOption = args.options.dereference.circular;
      if (args.options.validate.schema) {
        args.options.dereference.circular = "ignore";
      }
      try {
        await this.dereference(args.path, args.schema, args.options);
        args.options.dereference.circular = circular$RefOption;
        if (args.options.validate.schema) {
          validateSchema(me.api, args.options);
          if (me.$refs.circular) {
            if (circular$RefOption === true) {
              dereference(me, args.options);
            } else if (circular$RefOption === false) {
              throw ono2.reference("The API contains circular references");
            }
          }
        }
        if (args.options.validate.spec) {
          validateSpec(me.api);
        }
        return maybe(args.callback, Promise.resolve(me.schema));
      } catch (err) {
        return maybe(args.callback, Promise.reject(err));
      }
    };
  }
});

// node_modules/@readme/http-status-codes/src/index.js
var require_src3 = __commonJS({
  "node_modules/@readme/http-status-codes/src/index.js"(exports2, module2) {
    var codes = {
      default: ["Default", true],
      "1XX": ["Informational", true],
      100: ["Continue", true],
      101: ["Switching Protocols", true],
      102: ["Processing", true],
      103: ["Early Hints", true],
      // Also informally used as "Checkpoint".
      "2XX": ["Success", true],
      200: ["OK", true],
      201: ["Created", true],
      202: ["Accepted", true],
      203: ["Non-Authoritative Information", true],
      204: ["No Content", true],
      205: ["Reset Content", true],
      206: ["Partial Content", true],
      207: ["Multi-Status", true],
      208: ["Already Reported", true],
      218: ["This is fine", true],
      // Unofficial
      226: ["IM Used", true],
      "3XX": ["Redirection", true],
      300: ["Multiple Choices", true],
      301: ["Moved Permanently", true],
      302: ["Found", true],
      303: ["See Other", true],
      304: ["Not Modified", true],
      305: ["Use Proxy", true],
      306: ["Switch Proxy", true],
      307: ["Temporary Redirect", true],
      308: ["Permanent Redirect", true],
      "4XX": ["Client Error", false],
      400: ["Bad Request", false],
      401: ["Unauthorized", false],
      402: ["Payment Required", false],
      403: ["Forbidden", false],
      404: ["Not Found", false],
      405: ["Method Not Allowed", false],
      406: ["Not Acceptable", false],
      407: ["Proxy Authentication Required", false],
      408: ["Request Timeout", false],
      409: ["Conflict", false],
      410: ["Gone", false],
      411: ["Length Required", false],
      412: ["Precondition Failed", false],
      413: ["Payload Too Large", false],
      414: ["URI Too Long", false],
      415: ["Unsupported Media Type", false],
      416: ["Range Not Satisfiable", false],
      417: ["Expectation Failed", false],
      418: ["I'm a teapot", false],
      419: ["Page Expired", false],
      // Unofficial
      420: ["Enhance Your Calm", false],
      // Unofficial
      421: ["Misdirected Request", false],
      422: ["Unprocessable Entity", false],
      423: ["Locked", false],
      424: ["Failed Dependency", false],
      425: ["Too Early", false],
      426: ["Upgrade Required", false],
      428: ["Precondition Required", false],
      429: ["Too Many Requests", false],
      430: ["Request Header Fields Too Large", false],
      // Unofficial
      431: ["Request Header Fields Too Large", false],
      440: ["Login Time-out", false],
      // Unofficial
      444: ["No Response", false],
      // Unofficial
      449: ["Retry With", false],
      // Unofficial
      450: ["Blocked by Windows Parental Controls", false],
      // Unofficial
      451: ["Unavailable For Legal Reasons", false],
      494: ["Request Header Too Large", false],
      // Unofficial
      495: ["SSL Certificate Error", false],
      // Unofficial
      496: ["SSL Certificate Required", false],
      // Unofficial
      497: ["HTTP Request Sent to HTTPS Port", false],
      // Unofficial
      498: ["Invalid Token", false],
      // Unofficial
      499: ["Client Error", false],
      // "Token Request" on ArcGIS, "Client Closed Request" on nginx
      "5XX": ["Server Error", false],
      500: ["Internal Server Error", false],
      501: ["Not Implemented", false],
      502: ["Bad Gateway", false],
      503: ["Service Unavailable", false],
      504: ["Gateway Timeout", false],
      505: ["HTTP Version Not Supported", false],
      506: ["Variant Also Negotiates", false],
      507: ["Insufficient Storage", false],
      508: ["Loop Detected", false],
      509: ["Bandwidth Limit Exceeded", false],
      510: ["Not Extended", false],
      511: ["Network Authentication Required", false],
      520: ["Web Server Returned an Unknown Error", false],
      // Unofficial
      521: ["Web Server Is Down", false],
      // Unofficial
      522: ["Connection Timed Out", false],
      // Unofficial
      523: ["Origin Is Unreachable", false],
      // Unofficial
      524: ["A Timeout Occurred", false],
      // Unofficial
      525: ["SSL Handshake Failed", false],
      // Unofficial
      526: ["Invalid SSL Certificate", false],
      // Unofficial
      527: ["Railgun Error", false],
      // Unofficial
      529: ["Site is Overloaded", false],
      // Unofficial
      530: ["Site is Frozen", false],
      // Unofficial
      598: ["Network Read Timeout Error", false]
      // Unofficial
    };
    function isStatusCodeValid(code) {
      return code in codes;
    }
    function getStatusCode(code) {
      if (!isStatusCodeValid(code)) {
        throw new Error(`${code} is not a known HTTP status code.`);
      }
      return {
        // Since there's no HTTP status code that can really match up with `default`, code should just be empty.
        code: code === "default" ? "" : code,
        message: codes[code][0],
        success: codes[code][1]
      };
    }
    function getStatusCodeMessage(code) {
      const res = getStatusCode(code);
      return `${res.code} ${res.message}`;
    }
    function isStatusCodeSuccessful(code) {
      try {
        return getStatusCode(code).success;
      } catch (e) {
        return false;
      }
    }
    module2.exports = {
      codes,
      getStatusCode,
      getStatusCodeMessage,
      isStatusCodeSuccessful,
      isStatusCodeValid
    };
  }
});

// node_modules/jsonc-parser/lib/esm/impl/scanner.js
function createScanner(text, ignoreTrivia = false) {
  const len = text.length;
  let pos = 0, value = "", tokenOffset = 0, token = 16, lineNumber = 0, lineStartOffset = 0, tokenLineStartOffset = 0, prevTokenLineStartOffset = 0, scanError = 0;
  function scanHexDigits(count, exact) {
    let digits = 0;
    let value2 = 0;
    while (digits < count || !exact) {
      let ch = text.charCodeAt(pos);
      if (ch >= 48 && ch <= 57) {
        value2 = value2 * 16 + ch - 48;
      } else if (ch >= 65 && ch <= 70) {
        value2 = value2 * 16 + ch - 65 + 10;
      } else if (ch >= 97 && ch <= 102) {
        value2 = value2 * 16 + ch - 97 + 10;
      } else {
        break;
      }
      pos++;
      digits++;
    }
    if (digits < count) {
      value2 = -1;
    }
    return value2;
  }
  function setPosition(newPosition) {
    pos = newPosition;
    value = "";
    tokenOffset = 0;
    token = 16;
    scanError = 0;
  }
  function scanNumber() {
    let start = pos;
    if (text.charCodeAt(pos) === 48) {
      pos++;
    } else {
      pos++;
      while (pos < text.length && isDigit(text.charCodeAt(pos))) {
        pos++;
      }
    }
    if (pos < text.length && text.charCodeAt(pos) === 46) {
      pos++;
      if (pos < text.length && isDigit(text.charCodeAt(pos))) {
        pos++;
        while (pos < text.length && isDigit(text.charCodeAt(pos))) {
          pos++;
        }
      } else {
        scanError = 3;
        return text.substring(start, pos);
      }
    }
    let end = pos;
    if (pos < text.length && (text.charCodeAt(pos) === 69 || text.charCodeAt(pos) === 101)) {
      pos++;
      if (pos < text.length && text.charCodeAt(pos) === 43 || text.charCodeAt(pos) === 45) {
        pos++;
      }
      if (pos < text.length && isDigit(text.charCodeAt(pos))) {
        pos++;
        while (pos < text.length && isDigit(text.charCodeAt(pos))) {
          pos++;
        }
        end = pos;
      } else {
        scanError = 3;
      }
    }
    return text.substring(start, end);
  }
  function scanString() {
    let result = "", start = pos;
    while (true) {
      if (pos >= len) {
        result += text.substring(start, pos);
        scanError = 2;
        break;
      }
      const ch = text.charCodeAt(pos);
      if (ch === 34) {
        result += text.substring(start, pos);
        pos++;
        break;
      }
      if (ch === 92) {
        result += text.substring(start, pos);
        pos++;
        if (pos >= len) {
          scanError = 2;
          break;
        }
        const ch2 = text.charCodeAt(pos++);
        switch (ch2) {
          case 34:
            result += '"';
            break;
          case 92:
            result += "\\";
            break;
          case 47:
            result += "/";
            break;
          case 98:
            result += "\b";
            break;
          case 102:
            result += "\f";
            break;
          case 110:
            result += "\n";
            break;
          case 114:
            result += "\r";
            break;
          case 116:
            result += "	";
            break;
          case 117:
            const ch3 = scanHexDigits(4, true);
            if (ch3 >= 0) {
              result += String.fromCharCode(ch3);
            } else {
              scanError = 4;
            }
            break;
          default:
            scanError = 5;
        }
        start = pos;
        continue;
      }
      if (ch >= 0 && ch <= 31) {
        if (isLineBreak(ch)) {
          result += text.substring(start, pos);
          scanError = 2;
          break;
        } else {
          scanError = 6;
        }
      }
      pos++;
    }
    return result;
  }
  function scanNext() {
    value = "";
    scanError = 0;
    tokenOffset = pos;
    lineStartOffset = lineNumber;
    prevTokenLineStartOffset = tokenLineStartOffset;
    if (pos >= len) {
      tokenOffset = len;
      return token = 17;
    }
    let code = text.charCodeAt(pos);
    if (isWhiteSpace(code)) {
      do {
        pos++;
        value += String.fromCharCode(code);
        code = text.charCodeAt(pos);
      } while (isWhiteSpace(code));
      return token = 15;
    }
    if (isLineBreak(code)) {
      pos++;
      value += String.fromCharCode(code);
      if (code === 13 && text.charCodeAt(pos) === 10) {
        pos++;
        value += "\n";
      }
      lineNumber++;
      tokenLineStartOffset = pos;
      return token = 14;
    }
    switch (code) {
      case 123:
        pos++;
        return token = 1;
      case 125:
        pos++;
        return token = 2;
      case 91:
        pos++;
        return token = 3;
      case 93:
        pos++;
        return token = 4;
      case 58:
        pos++;
        return token = 6;
      case 44:
        pos++;
        return token = 5;
      case 34:
        pos++;
        value = scanString();
        return token = 10;
      case 47:
        const start = pos - 1;
        if (text.charCodeAt(pos + 1) === 47) {
          pos += 2;
          while (pos < len) {
            if (isLineBreak(text.charCodeAt(pos))) {
              break;
            }
            pos++;
          }
          value = text.substring(start, pos);
          return token = 12;
        }
        if (text.charCodeAt(pos + 1) === 42) {
          pos += 2;
          const safeLength = len - 1;
          let commentClosed = false;
          while (pos < safeLength) {
            const ch = text.charCodeAt(pos);
            if (ch === 42 && text.charCodeAt(pos + 1) === 47) {
              pos += 2;
              commentClosed = true;
              break;
            }
            pos++;
            if (isLineBreak(ch)) {
              if (ch === 13 && text.charCodeAt(pos) === 10) {
                pos++;
              }
              lineNumber++;
              tokenLineStartOffset = pos;
            }
          }
          if (!commentClosed) {
            pos++;
            scanError = 1;
          }
          value = text.substring(start, pos);
          return token = 13;
        }
        value += String.fromCharCode(code);
        pos++;
        return token = 16;
      case 45:
        value += String.fromCharCode(code);
        pos++;
        if (pos === len || !isDigit(text.charCodeAt(pos))) {
          return token = 16;
        }
      case 48:
      case 49:
      case 50:
      case 51:
      case 52:
      case 53:
      case 54:
      case 55:
      case 56:
      case 57:
        value += scanNumber();
        return token = 11;
      default:
        while (pos < len && isUnknownContentCharacter(code)) {
          pos++;
          code = text.charCodeAt(pos);
        }
        if (tokenOffset !== pos) {
          value = text.substring(tokenOffset, pos);
          switch (value) {
            case "true":
              return token = 8;
            case "false":
              return token = 9;
            case "null":
              return token = 7;
          }
          return token = 16;
        }
        value += String.fromCharCode(code);
        pos++;
        return token = 16;
    }
  }
  function isUnknownContentCharacter(code) {
    if (isWhiteSpace(code) || isLineBreak(code)) {
      return false;
    }
    switch (code) {
      case 125:
      case 93:
      case 123:
      case 91:
      case 34:
      case 58:
      case 44:
      case 47:
        return false;
    }
    return true;
  }
  function scanNextNonTrivia() {
    let result;
    do {
      result = scanNext();
    } while (result >= 12 && result <= 15);
    return result;
  }
  return {
    setPosition,
    getPosition: () => pos,
    scan: ignoreTrivia ? scanNextNonTrivia : scanNext,
    getToken: () => token,
    getTokenValue: () => value,
    getTokenOffset: () => tokenOffset,
    getTokenLength: () => pos - tokenOffset,
    getTokenStartLine: () => lineStartOffset,
    getTokenStartCharacter: () => tokenOffset - prevTokenLineStartOffset,
    getTokenError: () => scanError
  };
}
function isWhiteSpace(ch) {
  return ch === 32 || ch === 9;
}
function isLineBreak(ch) {
  return ch === 10 || ch === 13;
}
function isDigit(ch) {
  return ch >= 48 && ch <= 57;
}
var CharacterCodes;
var init_scanner = __esm({
  "node_modules/jsonc-parser/lib/esm/impl/scanner.js"() {
    "use strict";
    (function(CharacterCodes2) {
      CharacterCodes2[CharacterCodes2["lineFeed"] = 10] = "lineFeed";
      CharacterCodes2[CharacterCodes2["carriageReturn"] = 13] = "carriageReturn";
      CharacterCodes2[CharacterCodes2["space"] = 32] = "space";
      CharacterCodes2[CharacterCodes2["_0"] = 48] = "_0";
      CharacterCodes2[CharacterCodes2["_1"] = 49] = "_1";
      CharacterCodes2[CharacterCodes2["_2"] = 50] = "_2";
      CharacterCodes2[CharacterCodes2["_3"] = 51] = "_3";
      CharacterCodes2[CharacterCodes2["_4"] = 52] = "_4";
      CharacterCodes2[CharacterCodes2["_5"] = 53] = "_5";
      CharacterCodes2[CharacterCodes2["_6"] = 54] = "_6";
      CharacterCodes2[CharacterCodes2["_7"] = 55] = "_7";
      CharacterCodes2[CharacterCodes2["_8"] = 56] = "_8";
      CharacterCodes2[CharacterCodes2["_9"] = 57] = "_9";
      CharacterCodes2[CharacterCodes2["a"] = 97] = "a";
      CharacterCodes2[CharacterCodes2["b"] = 98] = "b";
      CharacterCodes2[CharacterCodes2["c"] = 99] = "c";
      CharacterCodes2[CharacterCodes2["d"] = 100] = "d";
      CharacterCodes2[CharacterCodes2["e"] = 101] = "e";
      CharacterCodes2[CharacterCodes2["f"] = 102] = "f";
      CharacterCodes2[CharacterCodes2["g"] = 103] = "g";
      CharacterCodes2[CharacterCodes2["h"] = 104] = "h";
      CharacterCodes2[CharacterCodes2["i"] = 105] = "i";
      CharacterCodes2[CharacterCodes2["j"] = 106] = "j";
      CharacterCodes2[CharacterCodes2["k"] = 107] = "k";
      CharacterCodes2[CharacterCodes2["l"] = 108] = "l";
      CharacterCodes2[CharacterCodes2["m"] = 109] = "m";
      CharacterCodes2[CharacterCodes2["n"] = 110] = "n";
      CharacterCodes2[CharacterCodes2["o"] = 111] = "o";
      CharacterCodes2[CharacterCodes2["p"] = 112] = "p";
      CharacterCodes2[CharacterCodes2["q"] = 113] = "q";
      CharacterCodes2[CharacterCodes2["r"] = 114] = "r";
      CharacterCodes2[CharacterCodes2["s"] = 115] = "s";
      CharacterCodes2[CharacterCodes2["t"] = 116] = "t";
      CharacterCodes2[CharacterCodes2["u"] = 117] = "u";
      CharacterCodes2[CharacterCodes2["v"] = 118] = "v";
      CharacterCodes2[CharacterCodes2["w"] = 119] = "w";
      CharacterCodes2[CharacterCodes2["x"] = 120] = "x";
      CharacterCodes2[CharacterCodes2["y"] = 121] = "y";
      CharacterCodes2[CharacterCodes2["z"] = 122] = "z";
      CharacterCodes2[CharacterCodes2["A"] = 65] = "A";
      CharacterCodes2[CharacterCodes2["B"] = 66] = "B";
      CharacterCodes2[CharacterCodes2["C"] = 67] = "C";
      CharacterCodes2[CharacterCodes2["D"] = 68] = "D";
      CharacterCodes2[CharacterCodes2["E"] = 69] = "E";
      CharacterCodes2[CharacterCodes2["F"] = 70] = "F";
      CharacterCodes2[CharacterCodes2["G"] = 71] = "G";
      CharacterCodes2[CharacterCodes2["H"] = 72] = "H";
      CharacterCodes2[CharacterCodes2["I"] = 73] = "I";
      CharacterCodes2[CharacterCodes2["J"] = 74] = "J";
      CharacterCodes2[CharacterCodes2["K"] = 75] = "K";
      CharacterCodes2[CharacterCodes2["L"] = 76] = "L";
      CharacterCodes2[CharacterCodes2["M"] = 77] = "M";
      CharacterCodes2[CharacterCodes2["N"] = 78] = "N";
      CharacterCodes2[CharacterCodes2["O"] = 79] = "O";
      CharacterCodes2[CharacterCodes2["P"] = 80] = "P";
      CharacterCodes2[CharacterCodes2["Q"] = 81] = "Q";
      CharacterCodes2[CharacterCodes2["R"] = 82] = "R";
      CharacterCodes2[CharacterCodes2["S"] = 83] = "S";
      CharacterCodes2[CharacterCodes2["T"] = 84] = "T";
      CharacterCodes2[CharacterCodes2["U"] = 85] = "U";
      CharacterCodes2[CharacterCodes2["V"] = 86] = "V";
      CharacterCodes2[CharacterCodes2["W"] = 87] = "W";
      CharacterCodes2[CharacterCodes2["X"] = 88] = "X";
      CharacterCodes2[CharacterCodes2["Y"] = 89] = "Y";
      CharacterCodes2[CharacterCodes2["Z"] = 90] = "Z";
      CharacterCodes2[CharacterCodes2["asterisk"] = 42] = "asterisk";
      CharacterCodes2[CharacterCodes2["backslash"] = 92] = "backslash";
      CharacterCodes2[CharacterCodes2["closeBrace"] = 125] = "closeBrace";
      CharacterCodes2[CharacterCodes2["closeBracket"] = 93] = "closeBracket";
      CharacterCodes2[CharacterCodes2["colon"] = 58] = "colon";
      CharacterCodes2[CharacterCodes2["comma"] = 44] = "comma";
      CharacterCodes2[CharacterCodes2["dot"] = 46] = "dot";
      CharacterCodes2[CharacterCodes2["doubleQuote"] = 34] = "doubleQuote";
      CharacterCodes2[CharacterCodes2["minus"] = 45] = "minus";
      CharacterCodes2[CharacterCodes2["openBrace"] = 123] = "openBrace";
      CharacterCodes2[CharacterCodes2["openBracket"] = 91] = "openBracket";
      CharacterCodes2[CharacterCodes2["plus"] = 43] = "plus";
      CharacterCodes2[CharacterCodes2["slash"] = 47] = "slash";
      CharacterCodes2[CharacterCodes2["formFeed"] = 12] = "formFeed";
      CharacterCodes2[CharacterCodes2["tab"] = 9] = "tab";
    })(CharacterCodes || (CharacterCodes = {}));
  }
});

// node_modules/jsonc-parser/lib/esm/impl/format.js
function format4(documentText, range, options) {
  let initialIndentLevel;
  let formatText;
  let formatTextStart;
  let rangeStart;
  let rangeEnd;
  if (range) {
    rangeStart = range.offset;
    rangeEnd = rangeStart + range.length;
    formatTextStart = rangeStart;
    while (formatTextStart > 0 && !isEOL(documentText, formatTextStart - 1)) {
      formatTextStart--;
    }
    let endOffset = rangeEnd;
    while (endOffset < documentText.length && !isEOL(documentText, endOffset)) {
      endOffset++;
    }
    formatText = documentText.substring(formatTextStart, endOffset);
    initialIndentLevel = computeIndentLevel(formatText, options);
  } else {
    formatText = documentText;
    initialIndentLevel = 0;
    formatTextStart = 0;
    rangeStart = 0;
    rangeEnd = documentText.length;
  }
  const eol = getEOL(options, documentText);
  let numberLineBreaks = 0;
  let indentLevel = 0;
  let indentValue;
  if (options.insertSpaces) {
    indentValue = repeat(" ", options.tabSize || 4);
  } else {
    indentValue = "	";
  }
  let scanner = createScanner(formatText, false);
  let hasError = false;
  function newLinesAndIndent() {
    if (numberLineBreaks > 1) {
      return repeat(eol, numberLineBreaks) + repeat(indentValue, initialIndentLevel + indentLevel);
    } else {
      return eol + repeat(indentValue, initialIndentLevel + indentLevel);
    }
  }
  function scanNext() {
    let token = scanner.scan();
    numberLineBreaks = 0;
    while (token === 15 || token === 14) {
      if (token === 14 && options.keepLines) {
        numberLineBreaks += 1;
      } else if (token === 14) {
        numberLineBreaks = 1;
      }
      token = scanner.scan();
    }
    hasError = token === 16 || scanner.getTokenError() !== 0;
    return token;
  }
  const editOperations = [];
  function addEdit(text, startOffset, endOffset) {
    if (!hasError && (!range || startOffset < rangeEnd && endOffset > rangeStart) && documentText.substring(startOffset, endOffset) !== text) {
      editOperations.push({ offset: startOffset, length: endOffset - startOffset, content: text });
    }
  }
  let firstToken = scanNext();
  if (options.keepLines && numberLineBreaks > 0) {
    addEdit(repeat(eol, numberLineBreaks), 0, 0);
  }
  if (firstToken !== 17) {
    let firstTokenStart = scanner.getTokenOffset() + formatTextStart;
    let initialIndent = repeat(indentValue, initialIndentLevel);
    addEdit(initialIndent, formatTextStart, firstTokenStart);
  }
  while (firstToken !== 17) {
    let firstTokenEnd = scanner.getTokenOffset() + scanner.getTokenLength() + formatTextStart;
    let secondToken = scanNext();
    let replaceContent = "";
    let needsLineBreak = false;
    while (numberLineBreaks === 0 && (secondToken === 12 || secondToken === 13)) {
      let commentTokenStart = scanner.getTokenOffset() + formatTextStart;
      addEdit(" ", firstTokenEnd, commentTokenStart);
      firstTokenEnd = scanner.getTokenOffset() + scanner.getTokenLength() + formatTextStart;
      needsLineBreak = secondToken === 12;
      replaceContent = needsLineBreak ? newLinesAndIndent() : "";
      secondToken = scanNext();
    }
    if (secondToken === 2) {
      if (firstToken !== 1) {
        indentLevel--;
      }
      ;
      if (options.keepLines && numberLineBreaks > 0 || !options.keepLines && firstToken !== 1) {
        replaceContent = newLinesAndIndent();
      } else if (options.keepLines) {
        replaceContent = " ";
      }
    } else if (secondToken === 4) {
      if (firstToken !== 3) {
        indentLevel--;
      }
      ;
      if (options.keepLines && numberLineBreaks > 0 || !options.keepLines && firstToken !== 3) {
        replaceContent = newLinesAndIndent();
      } else if (options.keepLines) {
        replaceContent = " ";
      }
    } else {
      switch (firstToken) {
        case 3:
        case 1:
          indentLevel++;
          if (options.keepLines && numberLineBreaks > 0 || !options.keepLines) {
            replaceContent = newLinesAndIndent();
          } else {
            replaceContent = " ";
          }
          break;
        case 5:
          if (options.keepLines && numberLineBreaks > 0 || !options.keepLines) {
            replaceContent = newLinesAndIndent();
          } else {
            replaceContent = " ";
          }
          break;
        case 12:
          replaceContent = newLinesAndIndent();
          break;
        case 13:
          if (numberLineBreaks > 0) {
            replaceContent = newLinesAndIndent();
          } else if (!needsLineBreak) {
            replaceContent = " ";
          }
          break;
        case 6:
          if (options.keepLines && numberLineBreaks > 0) {
            replaceContent = newLinesAndIndent();
          } else if (!needsLineBreak) {
            replaceContent = " ";
          }
          break;
        case 10:
          if (options.keepLines && numberLineBreaks > 0) {
            replaceContent = newLinesAndIndent();
          } else if (secondToken === 6 && !needsLineBreak) {
            replaceContent = "";
          }
          break;
        case 7:
        case 8:
        case 9:
        case 11:
        case 2:
        case 4:
          if (options.keepLines && numberLineBreaks > 0) {
            replaceContent = newLinesAndIndent();
          } else {
            if ((secondToken === 12 || secondToken === 13) && !needsLineBreak) {
              replaceContent = " ";
            } else if (secondToken !== 5 && secondToken !== 17) {
              hasError = true;
            }
          }
          break;
        case 16:
          hasError = true;
          break;
      }
      if (numberLineBreaks > 0 && (secondToken === 12 || secondToken === 13)) {
        replaceContent = newLinesAndIndent();
      }
    }
    if (secondToken === 17) {
      if (options.keepLines && numberLineBreaks > 0) {
        replaceContent = newLinesAndIndent();
      } else {
        replaceContent = options.insertFinalNewline ? eol : "";
      }
    }
    const secondTokenStart = scanner.getTokenOffset() + formatTextStart;
    addEdit(replaceContent, firstTokenEnd, secondTokenStart);
    firstToken = secondToken;
  }
  return editOperations;
}
function repeat(s, count) {
  let result = "";
  for (let i = 0; i < count; i++) {
    result += s;
  }
  return result;
}
function computeIndentLevel(content, options) {
  let i = 0;
  let nChars = 0;
  const tabSize = options.tabSize || 4;
  while (i < content.length) {
    let ch = content.charAt(i);
    if (ch === " ") {
      nChars++;
    } else if (ch === "	") {
      nChars += tabSize;
    } else {
      break;
    }
    i++;
  }
  return Math.floor(nChars / tabSize);
}
function getEOL(options, text) {
  for (let i = 0; i < text.length; i++) {
    const ch = text.charAt(i);
    if (ch === "\r") {
      if (i + 1 < text.length && text.charAt(i + 1) === "\n") {
        return "\r\n";
      }
      return "\r";
    } else if (ch === "\n") {
      return "\n";
    }
  }
  return options && options.eol || "\n";
}
function isEOL(text, offset) {
  return "\r\n".indexOf(text.charAt(offset)) !== -1;
}
var init_format = __esm({
  "node_modules/jsonc-parser/lib/esm/impl/format.js"() {
    "use strict";
    init_scanner();
  }
});

// node_modules/jsonc-parser/lib/esm/impl/parser.js
function getLocation(text, position) {
  const segments = [];
  const earlyReturnException = new Object();
  let previousNode = void 0;
  const previousNodeInst = {
    value: {},
    offset: 0,
    length: 0,
    type: "object",
    parent: void 0
  };
  let isAtPropertyKey = false;
  function setPreviousNode(value, offset, length, type2) {
    previousNodeInst.value = value;
    previousNodeInst.offset = offset;
    previousNodeInst.length = length;
    previousNodeInst.type = type2;
    previousNodeInst.colonOffset = void 0;
    previousNode = previousNodeInst;
  }
  try {
    visit(text, {
      onObjectBegin: (offset, length) => {
        if (position <= offset) {
          throw earlyReturnException;
        }
        previousNode = void 0;
        isAtPropertyKey = position > offset;
        segments.push("");
      },
      onObjectProperty: (name, offset, length) => {
        if (position < offset) {
          throw earlyReturnException;
        }
        setPreviousNode(name, offset, length, "property");
        segments[segments.length - 1] = name;
        if (position <= offset + length) {
          throw earlyReturnException;
        }
      },
      onObjectEnd: (offset, length) => {
        if (position <= offset) {
          throw earlyReturnException;
        }
        previousNode = void 0;
        segments.pop();
      },
      onArrayBegin: (offset, length) => {
        if (position <= offset) {
          throw earlyReturnException;
        }
        previousNode = void 0;
        segments.push(0);
      },
      onArrayEnd: (offset, length) => {
        if (position <= offset) {
          throw earlyReturnException;
        }
        previousNode = void 0;
        segments.pop();
      },
      onLiteralValue: (value, offset, length) => {
        if (position < offset) {
          throw earlyReturnException;
        }
        setPreviousNode(value, offset, length, getNodeType(value));
        if (position <= offset + length) {
          throw earlyReturnException;
        }
      },
      onSeparator: (sep, offset, length) => {
        if (position <= offset) {
          throw earlyReturnException;
        }
        if (sep === ":" && previousNode && previousNode.type === "property") {
          previousNode.colonOffset = offset;
          isAtPropertyKey = false;
          previousNode = void 0;
        } else if (sep === ",") {
          const last = segments[segments.length - 1];
          if (typeof last === "number") {
            segments[segments.length - 1] = last + 1;
          } else {
            isAtPropertyKey = true;
            segments[segments.length - 1] = "";
          }
          previousNode = void 0;
        }
      }
    });
  } catch (e) {
    if (e !== earlyReturnException) {
      throw e;
    }
  }
  return {
    path: segments,
    previousNode,
    isAtPropertyKey,
    matches: (pattern) => {
      let k = 0;
      for (let i = 0; k < pattern.length && i < segments.length; i++) {
        if (pattern[k] === segments[i] || pattern[k] === "*") {
          k++;
        } else if (pattern[k] !== "**") {
          return false;
        }
      }
      return k === pattern.length;
    }
  };
}
function parse4(text, errors = [], options = ParseOptions.DEFAULT) {
  let currentProperty = null;
  let currentParent = [];
  const previousParents = [];
  function onValue(value) {
    if (Array.isArray(currentParent)) {
      currentParent.push(value);
    } else if (currentProperty !== null) {
      currentParent[currentProperty] = value;
    }
  }
  const visitor = {
    onObjectBegin: () => {
      const object = {};
      onValue(object);
      previousParents.push(currentParent);
      currentParent = object;
      currentProperty = null;
    },
    onObjectProperty: (name) => {
      currentProperty = name;
    },
    onObjectEnd: () => {
      currentParent = previousParents.pop();
    },
    onArrayBegin: () => {
      const array = [];
      onValue(array);
      previousParents.push(currentParent);
      currentParent = array;
      currentProperty = null;
    },
    onArrayEnd: () => {
      currentParent = previousParents.pop();
    },
    onLiteralValue: onValue,
    onError: (error, offset, length) => {
      errors.push({ error, offset, length });
    }
  };
  visit(text, visitor, options);
  return currentParent[0];
}
function parseTree(text, errors = [], options = ParseOptions.DEFAULT) {
  let currentParent = { type: "array", offset: -1, length: -1, children: [], parent: void 0 };
  function ensurePropertyComplete(endOffset) {
    if (currentParent.type === "property") {
      currentParent.length = endOffset - currentParent.offset;
      currentParent = currentParent.parent;
    }
  }
  function onValue(valueNode) {
    currentParent.children.push(valueNode);
    return valueNode;
  }
  const visitor = {
    onObjectBegin: (offset) => {
      currentParent = onValue({ type: "object", offset, length: -1, parent: currentParent, children: [] });
    },
    onObjectProperty: (name, offset, length) => {
      currentParent = onValue({ type: "property", offset, length: -1, parent: currentParent, children: [] });
      currentParent.children.push({ type: "string", value: name, offset, length, parent: currentParent });
    },
    onObjectEnd: (offset, length) => {
      ensurePropertyComplete(offset + length);
      currentParent.length = offset + length - currentParent.offset;
      currentParent = currentParent.parent;
      ensurePropertyComplete(offset + length);
    },
    onArrayBegin: (offset, length) => {
      currentParent = onValue({ type: "array", offset, length: -1, parent: currentParent, children: [] });
    },
    onArrayEnd: (offset, length) => {
      currentParent.length = offset + length - currentParent.offset;
      currentParent = currentParent.parent;
      ensurePropertyComplete(offset + length);
    },
    onLiteralValue: (value, offset, length) => {
      onValue({ type: getNodeType(value), offset, length, parent: currentParent, value });
      ensurePropertyComplete(offset + length);
    },
    onSeparator: (sep, offset, length) => {
      if (currentParent.type === "property") {
        if (sep === ":") {
          currentParent.colonOffset = offset;
        } else if (sep === ",") {
          ensurePropertyComplete(offset);
        }
      }
    },
    onError: (error, offset, length) => {
      errors.push({ error, offset, length });
    }
  };
  visit(text, visitor, options);
  const result = currentParent.children[0];
  if (result) {
    delete result.parent;
  }
  return result;
}
function findNodeAtLocation(root, path) {
  if (!root) {
    return void 0;
  }
  let node2 = root;
  for (let segment of path) {
    if (typeof segment === "string") {
      if (node2.type !== "object" || !Array.isArray(node2.children)) {
        return void 0;
      }
      let found = false;
      for (const propertyNode of node2.children) {
        if (Array.isArray(propertyNode.children) && propertyNode.children[0].value === segment && propertyNode.children.length === 2) {
          node2 = propertyNode.children[1];
          found = true;
          break;
        }
      }
      if (!found) {
        return void 0;
      }
    } else {
      const index = segment;
      if (node2.type !== "array" || index < 0 || !Array.isArray(node2.children) || index >= node2.children.length) {
        return void 0;
      }
      node2 = node2.children[index];
    }
  }
  return node2;
}
function getNodePath(node2) {
  if (!node2.parent || !node2.parent.children) {
    return [];
  }
  const path = getNodePath(node2.parent);
  if (node2.parent.type === "property") {
    const key = node2.parent.children[0].value;
    path.push(key);
  } else if (node2.parent.type === "array") {
    const index = node2.parent.children.indexOf(node2);
    if (index !== -1) {
      path.push(index);
    }
  }
  return path;
}
function getNodeValue(node2) {
  switch (node2.type) {
    case "array":
      return node2.children.map(getNodeValue);
    case "object":
      const obj = /* @__PURE__ */ Object.create(null);
      for (let prop of node2.children) {
        const valueNode = prop.children[1];
        if (valueNode) {
          obj[prop.children[0].value] = getNodeValue(valueNode);
        }
      }
      return obj;
    case "null":
    case "string":
    case "number":
    case "boolean":
      return node2.value;
    default:
      return void 0;
  }
}
function contains(node2, offset, includeRightBound = false) {
  return offset >= node2.offset && offset < node2.offset + node2.length || includeRightBound && offset === node2.offset + node2.length;
}
function findNodeAtOffset(node2, offset, includeRightBound = false) {
  if (contains(node2, offset, includeRightBound)) {
    const children = node2.children;
    if (Array.isArray(children)) {
      for (let i = 0; i < children.length && children[i].offset <= offset; i++) {
        const item = findNodeAtOffset(children[i], offset, includeRightBound);
        if (item) {
          return item;
        }
      }
    }
    return node2;
  }
  return void 0;
}
function visit(text, visitor, options = ParseOptions.DEFAULT) {
  const _scanner = createScanner(text, false);
  const _jsonPath = [];
  function toNoArgVisit(visitFunction) {
    return visitFunction ? () => visitFunction(_scanner.getTokenOffset(), _scanner.getTokenLength(), _scanner.getTokenStartLine(), _scanner.getTokenStartCharacter()) : () => true;
  }
  function toNoArgVisitWithPath(visitFunction) {
    return visitFunction ? () => visitFunction(_scanner.getTokenOffset(), _scanner.getTokenLength(), _scanner.getTokenStartLine(), _scanner.getTokenStartCharacter(), () => _jsonPath.slice()) : () => true;
  }
  function toOneArgVisit(visitFunction) {
    return visitFunction ? (arg) => visitFunction(arg, _scanner.getTokenOffset(), _scanner.getTokenLength(), _scanner.getTokenStartLine(), _scanner.getTokenStartCharacter()) : () => true;
  }
  function toOneArgVisitWithPath(visitFunction) {
    return visitFunction ? (arg) => visitFunction(arg, _scanner.getTokenOffset(), _scanner.getTokenLength(), _scanner.getTokenStartLine(), _scanner.getTokenStartCharacter(), () => _jsonPath.slice()) : () => true;
  }
  const onObjectBegin = toNoArgVisitWithPath(visitor.onObjectBegin), onObjectProperty = toOneArgVisitWithPath(visitor.onObjectProperty), onObjectEnd = toNoArgVisit(visitor.onObjectEnd), onArrayBegin = toNoArgVisitWithPath(visitor.onArrayBegin), onArrayEnd = toNoArgVisit(visitor.onArrayEnd), onLiteralValue = toOneArgVisitWithPath(visitor.onLiteralValue), onSeparator = toOneArgVisit(visitor.onSeparator), onComment = toNoArgVisit(visitor.onComment), onError = toOneArgVisit(visitor.onError);
  const disallowComments = options && options.disallowComments;
  const allowTrailingComma = options && options.allowTrailingComma;
  function scanNext() {
    while (true) {
      const token = _scanner.scan();
      switch (_scanner.getTokenError()) {
        case 4:
          handleError(
            14
            /* ParseErrorCode.InvalidUnicode */
          );
          break;
        case 5:
          handleError(
            15
            /* ParseErrorCode.InvalidEscapeCharacter */
          );
          break;
        case 3:
          handleError(
            13
            /* ParseErrorCode.UnexpectedEndOfNumber */
          );
          break;
        case 1:
          if (!disallowComments) {
            handleError(
              11
              /* ParseErrorCode.UnexpectedEndOfComment */
            );
          }
          break;
        case 2:
          handleError(
            12
            /* ParseErrorCode.UnexpectedEndOfString */
          );
          break;
        case 6:
          handleError(
            16
            /* ParseErrorCode.InvalidCharacter */
          );
          break;
      }
      switch (token) {
        case 12:
        case 13:
          if (disallowComments) {
            handleError(
              10
              /* ParseErrorCode.InvalidCommentToken */
            );
          } else {
            onComment();
          }
          break;
        case 16:
          handleError(
            1
            /* ParseErrorCode.InvalidSymbol */
          );
          break;
        case 15:
        case 14:
          break;
        default:
          return token;
      }
    }
  }
  function handleError(error, skipUntilAfter = [], skipUntil = []) {
    onError(error);
    if (skipUntilAfter.length + skipUntil.length > 0) {
      let token = _scanner.getToken();
      while (token !== 17) {
        if (skipUntilAfter.indexOf(token) !== -1) {
          scanNext();
          break;
        } else if (skipUntil.indexOf(token) !== -1) {
          break;
        }
        token = scanNext();
      }
    }
  }
  function parseString(isValue) {
    const value = _scanner.getTokenValue();
    if (isValue) {
      onLiteralValue(value);
    } else {
      onObjectProperty(value);
      _jsonPath.push(value);
    }
    scanNext();
    return true;
  }
  function parseLiteral() {
    switch (_scanner.getToken()) {
      case 11:
        const tokenValue = _scanner.getTokenValue();
        let value = Number(tokenValue);
        if (isNaN(value)) {
          handleError(
            2
            /* ParseErrorCode.InvalidNumberFormat */
          );
          value = 0;
        }
        onLiteralValue(value);
        break;
      case 7:
        onLiteralValue(null);
        break;
      case 8:
        onLiteralValue(true);
        break;
      case 9:
        onLiteralValue(false);
        break;
      default:
        return false;
    }
    scanNext();
    return true;
  }
  function parseProperty() {
    if (_scanner.getToken() !== 10) {
      handleError(3, [], [
        2,
        5
        /* SyntaxKind.CommaToken */
      ]);
      return false;
    }
    parseString(false);
    if (_scanner.getToken() === 6) {
      onSeparator(":");
      scanNext();
      if (!parseValue()) {
        handleError(4, [], [
          2,
          5
          /* SyntaxKind.CommaToken */
        ]);
      }
    } else {
      handleError(5, [], [
        2,
        5
        /* SyntaxKind.CommaToken */
      ]);
    }
    _jsonPath.pop();
    return true;
  }
  function parseObject() {
    onObjectBegin();
    scanNext();
    let needsComma = false;
    while (_scanner.getToken() !== 2 && _scanner.getToken() !== 17) {
      if (_scanner.getToken() === 5) {
        if (!needsComma) {
          handleError(4, [], []);
        }
        onSeparator(",");
        scanNext();
        if (_scanner.getToken() === 2 && allowTrailingComma) {
          break;
        }
      } else if (needsComma) {
        handleError(6, [], []);
      }
      if (!parseProperty()) {
        handleError(4, [], [
          2,
          5
          /* SyntaxKind.CommaToken */
        ]);
      }
      needsComma = true;
    }
    onObjectEnd();
    if (_scanner.getToken() !== 2) {
      handleError(7, [
        2
        /* SyntaxKind.CloseBraceToken */
      ], []);
    } else {
      scanNext();
    }
    return true;
  }
  function parseArray() {
    onArrayBegin();
    scanNext();
    let isFirstElement = true;
    let needsComma = false;
    while (_scanner.getToken() !== 4 && _scanner.getToken() !== 17) {
      if (_scanner.getToken() === 5) {
        if (!needsComma) {
          handleError(4, [], []);
        }
        onSeparator(",");
        scanNext();
        if (_scanner.getToken() === 4 && allowTrailingComma) {
          break;
        }
      } else if (needsComma) {
        handleError(6, [], []);
      }
      if (isFirstElement) {
        _jsonPath.push(0);
        isFirstElement = false;
      } else {
        _jsonPath[_jsonPath.length - 1]++;
      }
      if (!parseValue()) {
        handleError(4, [], [
          4,
          5
          /* SyntaxKind.CommaToken */
        ]);
      }
      needsComma = true;
    }
    onArrayEnd();
    if (!isFirstElement) {
      _jsonPath.pop();
    }
    if (_scanner.getToken() !== 4) {
      handleError(8, [
        4
        /* SyntaxKind.CloseBracketToken */
      ], []);
    } else {
      scanNext();
    }
    return true;
  }
  function parseValue() {
    switch (_scanner.getToken()) {
      case 3:
        return parseArray();
      case 1:
        return parseObject();
      case 10:
        return parseString(true);
      default:
        return parseLiteral();
    }
  }
  scanNext();
  if (_scanner.getToken() === 17) {
    if (options.allowEmptyContent) {
      return true;
    }
    handleError(4, [], []);
    return false;
  }
  if (!parseValue()) {
    handleError(4, [], []);
    return false;
  }
  if (_scanner.getToken() !== 17) {
    handleError(9, [], []);
  }
  return true;
}
function stripComments(text, replaceCh) {
  let _scanner = createScanner(text), parts = [], kind, offset = 0, pos;
  do {
    pos = _scanner.getPosition();
    kind = _scanner.scan();
    switch (kind) {
      case 12:
      case 13:
      case 17:
        if (offset !== pos) {
          parts.push(text.substring(offset, pos));
        }
        if (replaceCh !== void 0) {
          parts.push(_scanner.getTokenValue().replace(/[^\r\n]/g, replaceCh));
        }
        offset = _scanner.getPosition();
        break;
    }
  } while (kind !== 17);
  return parts.join("");
}
function getNodeType(value) {
  switch (typeof value) {
    case "boolean":
      return "boolean";
    case "number":
      return "number";
    case "string":
      return "string";
    case "object": {
      if (!value) {
        return "null";
      } else if (Array.isArray(value)) {
        return "array";
      }
      return "object";
    }
    default:
      return "null";
  }
}
var ParseOptions;
var init_parser = __esm({
  "node_modules/jsonc-parser/lib/esm/impl/parser.js"() {
    "use strict";
    init_scanner();
    (function(ParseOptions2) {
      ParseOptions2.DEFAULT = {
        allowTrailingComma: false
      };
    })(ParseOptions || (ParseOptions = {}));
  }
});

// node_modules/jsonc-parser/lib/esm/impl/edit.js
function setProperty(text, originalPath, value, options) {
  const path = originalPath.slice();
  const errors = [];
  const root = parseTree(text, errors);
  let parent = void 0;
  let lastSegment = void 0;
  while (path.length > 0) {
    lastSegment = path.pop();
    parent = findNodeAtLocation(root, path);
    if (parent === void 0 && value !== void 0) {
      if (typeof lastSegment === "string") {
        value = { [lastSegment]: value };
      } else {
        value = [value];
      }
    } else {
      break;
    }
  }
  if (!parent) {
    if (value === void 0) {
      throw new Error("Can not delete in empty document");
    }
    return withFormatting(text, { offset: root ? root.offset : 0, length: root ? root.length : 0, content: JSON.stringify(value) }, options);
  } else if (parent.type === "object" && typeof lastSegment === "string" && Array.isArray(parent.children)) {
    const existing = findNodeAtLocation(parent, [lastSegment]);
    if (existing !== void 0) {
      if (value === void 0) {
        if (!existing.parent) {
          throw new Error("Malformed AST");
        }
        const propertyIndex = parent.children.indexOf(existing.parent);
        let removeBegin;
        let removeEnd = existing.parent.offset + existing.parent.length;
        if (propertyIndex > 0) {
          let previous = parent.children[propertyIndex - 1];
          removeBegin = previous.offset + previous.length;
        } else {
          removeBegin = parent.offset + 1;
          if (parent.children.length > 1) {
            let next = parent.children[1];
            removeEnd = next.offset;
          }
        }
        return withFormatting(text, { offset: removeBegin, length: removeEnd - removeBegin, content: "" }, options);
      } else {
        return withFormatting(text, { offset: existing.offset, length: existing.length, content: JSON.stringify(value) }, options);
      }
    } else {
      if (value === void 0) {
        return [];
      }
      const newProperty = `${JSON.stringify(lastSegment)}: ${JSON.stringify(value)}`;
      const index = options.getInsertionIndex ? options.getInsertionIndex(parent.children.map((p) => p.children[0].value)) : parent.children.length;
      let edit;
      if (index > 0) {
        let previous = parent.children[index - 1];
        edit = { offset: previous.offset + previous.length, length: 0, content: "," + newProperty };
      } else if (parent.children.length === 0) {
        edit = { offset: parent.offset + 1, length: 0, content: newProperty };
      } else {
        edit = { offset: parent.offset + 1, length: 0, content: newProperty + "," };
      }
      return withFormatting(text, edit, options);
    }
  } else if (parent.type === "array" && typeof lastSegment === "number" && Array.isArray(parent.children)) {
    const insertIndex = lastSegment;
    if (insertIndex === -1) {
      const newProperty = `${JSON.stringify(value)}`;
      let edit;
      if (parent.children.length === 0) {
        edit = { offset: parent.offset + 1, length: 0, content: newProperty };
      } else {
        const previous = parent.children[parent.children.length - 1];
        edit = { offset: previous.offset + previous.length, length: 0, content: "," + newProperty };
      }
      return withFormatting(text, edit, options);
    } else if (value === void 0 && parent.children.length >= 0) {
      const removalIndex = lastSegment;
      const toRemove = parent.children[removalIndex];
      let edit;
      if (parent.children.length === 1) {
        edit = { offset: parent.offset + 1, length: parent.length - 2, content: "" };
      } else if (parent.children.length - 1 === removalIndex) {
        let previous = parent.children[removalIndex - 1];
        let offset = previous.offset + previous.length;
        let parentEndOffset = parent.offset + parent.length;
        edit = { offset, length: parentEndOffset - 2 - offset, content: "" };
      } else {
        edit = { offset: toRemove.offset, length: parent.children[removalIndex + 1].offset - toRemove.offset, content: "" };
      }
      return withFormatting(text, edit, options);
    } else if (value !== void 0) {
      let edit;
      const newProperty = `${JSON.stringify(value)}`;
      if (!options.isArrayInsertion && parent.children.length > lastSegment) {
        const toModify = parent.children[lastSegment];
        edit = { offset: toModify.offset, length: toModify.length, content: newProperty };
      } else if (parent.children.length === 0 || lastSegment === 0) {
        edit = { offset: parent.offset + 1, length: 0, content: parent.children.length === 0 ? newProperty : newProperty + "," };
      } else {
        const index = lastSegment > parent.children.length ? parent.children.length : lastSegment;
        const previous = parent.children[index - 1];
        edit = { offset: previous.offset + previous.length, length: 0, content: "," + newProperty };
      }
      return withFormatting(text, edit, options);
    } else {
      throw new Error(`Can not ${value === void 0 ? "remove" : options.isArrayInsertion ? "insert" : "modify"} Array index ${insertIndex} as length is not sufficient`);
    }
  } else {
    throw new Error(`Can not add ${typeof lastSegment !== "number" ? "index" : "property"} to parent of type ${parent.type}`);
  }
}
function withFormatting(text, edit, options) {
  if (!options.formattingOptions) {
    return [edit];
  }
  let newText = applyEdit(text, edit);
  let begin = edit.offset;
  let end = edit.offset + edit.content.length;
  if (edit.length === 0 || edit.content.length === 0) {
    while (begin > 0 && !isEOL(newText, begin - 1)) {
      begin--;
    }
    while (end < newText.length && !isEOL(newText, end)) {
      end++;
    }
  }
  const edits = format4(newText, { offset: begin, length: end - begin }, { ...options.formattingOptions, keepLines: false });
  for (let i = edits.length - 1; i >= 0; i--) {
    const edit2 = edits[i];
    newText = applyEdit(newText, edit2);
    begin = Math.min(begin, edit2.offset);
    end = Math.max(end, edit2.offset + edit2.length);
    end += edit2.content.length - edit2.length;
  }
  const editLength = text.length - (newText.length - end) - begin;
  return [{ offset: begin, length: editLength, content: newText.substring(begin, end) }];
}
function applyEdit(text, edit) {
  return text.substring(0, edit.offset) + edit.content + text.substring(edit.offset + edit.length);
}
var init_edit = __esm({
  "node_modules/jsonc-parser/lib/esm/impl/edit.js"() {
    "use strict";
    init_format();
    init_parser();
  }
});

// node_modules/jsonc-parser/lib/esm/main.js
var main_exports = {};
__export(main_exports, {
  ParseErrorCode: () => ParseErrorCode,
  ScanError: () => ScanError,
  SyntaxKind: () => SyntaxKind,
  applyEdits: () => applyEdits,
  createScanner: () => createScanner2,
  findNodeAtLocation: () => findNodeAtLocation2,
  findNodeAtOffset: () => findNodeAtOffset2,
  format: () => format5,
  getLocation: () => getLocation2,
  getNodePath: () => getNodePath2,
  getNodeValue: () => getNodeValue2,
  modify: () => modify,
  parse: () => parse5,
  parseTree: () => parseTree2,
  printParseErrorCode: () => printParseErrorCode,
  stripComments: () => stripComments2,
  visit: () => visit2
});
function printParseErrorCode(code) {
  switch (code) {
    case 1:
      return "InvalidSymbol";
    case 2:
      return "InvalidNumberFormat";
    case 3:
      return "PropertyNameExpected";
    case 4:
      return "ValueExpected";
    case 5:
      return "ColonExpected";
    case 6:
      return "CommaExpected";
    case 7:
      return "CloseBraceExpected";
    case 8:
      return "CloseBracketExpected";
    case 9:
      return "EndOfFileExpected";
    case 10:
      return "InvalidCommentToken";
    case 11:
      return "UnexpectedEndOfComment";
    case 12:
      return "UnexpectedEndOfString";
    case 13:
      return "UnexpectedEndOfNumber";
    case 14:
      return "InvalidUnicode";
    case 15:
      return "InvalidEscapeCharacter";
    case 16:
      return "InvalidCharacter";
  }
  return "<unknown ParseErrorCode>";
}
function format5(documentText, range, options) {
  return format4(documentText, range, options);
}
function modify(text, path, value, options) {
  return setProperty(text, path, value, options);
}
function applyEdits(text, edits) {
  let sortedEdits = edits.slice(0).sort((a, b) => {
    const diff = a.offset - b.offset;
    if (diff === 0) {
      return a.length - b.length;
    }
    return diff;
  });
  let lastModifiedOffset = text.length;
  for (let i = sortedEdits.length - 1; i >= 0; i--) {
    let e = sortedEdits[i];
    if (e.offset + e.length <= lastModifiedOffset) {
      text = applyEdit(text, e);
    } else {
      throw new Error("Overlapping edit");
    }
    lastModifiedOffset = e.offset;
  }
  return text;
}
var createScanner2, ScanError, SyntaxKind, getLocation2, parse5, parseTree2, findNodeAtLocation2, findNodeAtOffset2, getNodePath2, getNodeValue2, visit2, stripComments2, ParseErrorCode;
var init_main = __esm({
  "node_modules/jsonc-parser/lib/esm/main.js"() {
    "use strict";
    init_format();
    init_edit();
    init_scanner();
    init_parser();
    createScanner2 = createScanner;
    (function(ScanError2) {
      ScanError2[ScanError2["None"] = 0] = "None";
      ScanError2[ScanError2["UnexpectedEndOfComment"] = 1] = "UnexpectedEndOfComment";
      ScanError2[ScanError2["UnexpectedEndOfString"] = 2] = "UnexpectedEndOfString";
      ScanError2[ScanError2["UnexpectedEndOfNumber"] = 3] = "UnexpectedEndOfNumber";
      ScanError2[ScanError2["InvalidUnicode"] = 4] = "InvalidUnicode";
      ScanError2[ScanError2["InvalidEscapeCharacter"] = 5] = "InvalidEscapeCharacter";
      ScanError2[ScanError2["InvalidCharacter"] = 6] = "InvalidCharacter";
    })(ScanError || (ScanError = {}));
    (function(SyntaxKind2) {
      SyntaxKind2[SyntaxKind2["OpenBraceToken"] = 1] = "OpenBraceToken";
      SyntaxKind2[SyntaxKind2["CloseBraceToken"] = 2] = "CloseBraceToken";
      SyntaxKind2[SyntaxKind2["OpenBracketToken"] = 3] = "OpenBracketToken";
      SyntaxKind2[SyntaxKind2["CloseBracketToken"] = 4] = "CloseBracketToken";
      SyntaxKind2[SyntaxKind2["CommaToken"] = 5] = "CommaToken";
      SyntaxKind2[SyntaxKind2["ColonToken"] = 6] = "ColonToken";
      SyntaxKind2[SyntaxKind2["NullKeyword"] = 7] = "NullKeyword";
      SyntaxKind2[SyntaxKind2["TrueKeyword"] = 8] = "TrueKeyword";
      SyntaxKind2[SyntaxKind2["FalseKeyword"] = 9] = "FalseKeyword";
      SyntaxKind2[SyntaxKind2["StringLiteral"] = 10] = "StringLiteral";
      SyntaxKind2[SyntaxKind2["NumericLiteral"] = 11] = "NumericLiteral";
      SyntaxKind2[SyntaxKind2["LineCommentTrivia"] = 12] = "LineCommentTrivia";
      SyntaxKind2[SyntaxKind2["BlockCommentTrivia"] = 13] = "BlockCommentTrivia";
      SyntaxKind2[SyntaxKind2["LineBreakTrivia"] = 14] = "LineBreakTrivia";
      SyntaxKind2[SyntaxKind2["Trivia"] = 15] = "Trivia";
      SyntaxKind2[SyntaxKind2["Unknown"] = 16] = "Unknown";
      SyntaxKind2[SyntaxKind2["EOF"] = 17] = "EOF";
    })(SyntaxKind || (SyntaxKind = {}));
    getLocation2 = getLocation;
    parse5 = parse4;
    parseTree2 = parseTree;
    findNodeAtLocation2 = findNodeAtLocation;
    findNodeAtOffset2 = findNodeAtOffset;
    getNodePath2 = getNodePath;
    getNodeValue2 = getNodeValue;
    visit2 = visit;
    stripComments2 = stripComments;
    (function(ParseErrorCode2) {
      ParseErrorCode2[ParseErrorCode2["InvalidSymbol"] = 1] = "InvalidSymbol";
      ParseErrorCode2[ParseErrorCode2["InvalidNumberFormat"] = 2] = "InvalidNumberFormat";
      ParseErrorCode2[ParseErrorCode2["PropertyNameExpected"] = 3] = "PropertyNameExpected";
      ParseErrorCode2[ParseErrorCode2["ValueExpected"] = 4] = "ValueExpected";
      ParseErrorCode2[ParseErrorCode2["ColonExpected"] = 5] = "ColonExpected";
      ParseErrorCode2[ParseErrorCode2["CommaExpected"] = 6] = "CommaExpected";
      ParseErrorCode2[ParseErrorCode2["CloseBraceExpected"] = 7] = "CloseBraceExpected";
      ParseErrorCode2[ParseErrorCode2["CloseBracketExpected"] = 8] = "CloseBracketExpected";
      ParseErrorCode2[ParseErrorCode2["EndOfFileExpected"] = 9] = "EndOfFileExpected";
      ParseErrorCode2[ParseErrorCode2["InvalidCommentToken"] = 10] = "InvalidCommentToken";
      ParseErrorCode2[ParseErrorCode2["UnexpectedEndOfComment"] = 11] = "UnexpectedEndOfComment";
      ParseErrorCode2[ParseErrorCode2["UnexpectedEndOfString"] = 12] = "UnexpectedEndOfString";
      ParseErrorCode2[ParseErrorCode2["UnexpectedEndOfNumber"] = 13] = "UnexpectedEndOfNumber";
      ParseErrorCode2[ParseErrorCode2["InvalidUnicode"] = 14] = "InvalidUnicode";
      ParseErrorCode2[ParseErrorCode2["InvalidEscapeCharacter"] = 15] = "InvalidEscapeCharacter";
      ParseErrorCode2[ParseErrorCode2["InvalidCharacter"] = 16] = "InvalidCharacter";
    })(ParseErrorCode || (ParseErrorCode = {}));
  }
});

// node_modules/marked/lib/marked.cjs
var require_marked = __commonJS({
  "node_modules/marked/lib/marked.cjs"(exports2) {
    "use strict";
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps) _defineProperties(Constructor.prototype, protoProps);
      if (staticProps) _defineProperties(Constructor, staticProps);
      Object.defineProperty(Constructor, "prototype", {
        writable: false
      });
      return Constructor;
    }
    function _extends() {
      _extends = Object.assign ? Object.assign.bind() : function(target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];
          for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }
        return target;
      };
      return _extends.apply(this, arguments);
    }
    function _unsupportedIterableToArray(o, minLen) {
      if (!o) return;
      if (typeof o === "string") return _arrayLikeToArray(o, minLen);
      var n = Object.prototype.toString.call(o).slice(8, -1);
      if (n === "Object" && o.constructor) n = o.constructor.name;
      if (n === "Map" || n === "Set") return Array.from(o);
      if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
    }
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length) len = arr.length;
      for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
      return arr2;
    }
    function _createForOfIteratorHelperLoose(o, allowArrayLike) {
      var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
      if (it) return (it = it.call(o)).next.bind(it);
      if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it) o = it;
        var i = 0;
        return function() {
          if (i >= o.length) return {
            done: true
          };
          return {
            done: false,
            value: o[i++]
          };
        };
      }
      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _toPrimitive(input, hint) {
      if (typeof input !== "object" || input === null) return input;
      var prim = input[Symbol.toPrimitive];
      if (prim !== void 0) {
        var res = prim.call(input, hint || "default");
        if (typeof res !== "object") return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return (hint === "string" ? String : Number)(input);
    }
    function _toPropertyKey(arg) {
      var key = _toPrimitive(arg, "string");
      return typeof key === "symbol" ? key : String(key);
    }
    function getDefaults() {
      return {
        async: false,
        baseUrl: null,
        breaks: false,
        extensions: null,
        gfm: true,
        headerIds: true,
        headerPrefix: "",
        highlight: null,
        hooks: null,
        langPrefix: "language-",
        mangle: true,
        pedantic: false,
        renderer: null,
        sanitize: false,
        sanitizer: null,
        silent: false,
        smartypants: false,
        tokenizer: null,
        walkTokens: null,
        xhtml: false
      };
    }
    exports2.defaults = getDefaults();
    function changeDefaults(newDefaults) {
      exports2.defaults = newDefaults;
    }
    var escapeTest = /[&<>"']/;
    var escapeReplace = new RegExp(escapeTest.source, "g");
    var escapeTestNoEncode = /[<>"']|&(?!(#\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\w+);)/;
    var escapeReplaceNoEncode = new RegExp(escapeTestNoEncode.source, "g");
    var escapeReplacements = {
      "&": "&amp;",
      "<": "&lt;",
      ">": "&gt;",
      '"': "&quot;",
      "'": "&#39;"
    };
    var getEscapeReplacement = function getEscapeReplacement2(ch) {
      return escapeReplacements[ch];
    };
    function escape3(html, encode) {
      if (encode) {
        if (escapeTest.test(html)) {
          return html.replace(escapeReplace, getEscapeReplacement);
        }
      } else {
        if (escapeTestNoEncode.test(html)) {
          return html.replace(escapeReplaceNoEncode, getEscapeReplacement);
        }
      }
      return html;
    }
    var unescapeTest = /&(#(?:\d+)|(?:#x[0-9A-Fa-f]+)|(?:\w+));?/ig;
    function unescape2(html) {
      return html.replace(unescapeTest, function(_, n) {
        n = n.toLowerCase();
        if (n === "colon") return ":";
        if (n.charAt(0) === "#") {
          return n.charAt(1) === "x" ? String.fromCharCode(parseInt(n.substring(2), 16)) : String.fromCharCode(+n.substring(1));
        }
        return "";
      });
    }
    var caret = /(^|[^\[])\^/g;
    function edit(regex, opt) {
      regex = typeof regex === "string" ? regex : regex.source;
      opt = opt || "";
      var obj = {
        replace: function replace(name, val) {
          val = val.source || val;
          val = val.replace(caret, "$1");
          regex = regex.replace(name, val);
          return obj;
        },
        getRegex: function getRegex() {
          return new RegExp(regex, opt);
        }
      };
      return obj;
    }
    var nonWordAndColonTest = /[^\w:]/g;
    var originIndependentUrl = /^$|^[a-z][a-z0-9+.-]*:|^[?#]/i;
    function cleanUrl(sanitize, base, href) {
      if (sanitize) {
        var prot;
        try {
          prot = decodeURIComponent(unescape2(href)).replace(nonWordAndColonTest, "").toLowerCase();
        } catch (e) {
          return null;
        }
        if (prot.indexOf("javascript:") === 0 || prot.indexOf("vbscript:") === 0 || prot.indexOf("data:") === 0) {
          return null;
        }
      }
      if (base && !originIndependentUrl.test(href)) {
        href = resolveUrl(base, href);
      }
      try {
        href = encodeURI(href).replace(/%25/g, "%");
      } catch (e) {
        return null;
      }
      return href;
    }
    var baseUrls = {};
    var justDomain = /^[^:]+:\/*[^/]*$/;
    var protocol = /^([^:]+:)[\s\S]*$/;
    var domain = /^([^:]+:\/*[^/]*)[\s\S]*$/;
    function resolveUrl(base, href) {
      if (!baseUrls[" " + base]) {
        if (justDomain.test(base)) {
          baseUrls[" " + base] = base + "/";
        } else {
          baseUrls[" " + base] = rtrim(base, "/", true);
        }
      }
      base = baseUrls[" " + base];
      var relativeBase = base.indexOf(":") === -1;
      if (href.substring(0, 2) === "//") {
        if (relativeBase) {
          return href;
        }
        return base.replace(protocol, "$1") + href;
      } else if (href.charAt(0) === "/") {
        if (relativeBase) {
          return href;
        }
        return base.replace(domain, "$1") + href;
      } else {
        return base + href;
      }
    }
    var noopTest = {
      exec: function noopTest2() {
      }
    };
    function splitCells(tableRow, count) {
      var row = tableRow.replace(/\|/g, function(match2, offset, str2) {
        var escaped = false, curr = offset;
        while (--curr >= 0 && str2[curr] === "\\") {
          escaped = !escaped;
        }
        if (escaped) {
          return "|";
        } else {
          return " |";
        }
      }), cells = row.split(/ \|/);
      var i = 0;
      if (!cells[0].trim()) {
        cells.shift();
      }
      if (cells.length > 0 && !cells[cells.length - 1].trim()) {
        cells.pop();
      }
      if (cells.length > count) {
        cells.splice(count);
      } else {
        while (cells.length < count) {
          cells.push("");
        }
      }
      for (; i < cells.length; i++) {
        cells[i] = cells[i].trim().replace(/\\\|/g, "|");
      }
      return cells;
    }
    function rtrim(str2, c2, invert) {
      var l = str2.length;
      if (l === 0) {
        return "";
      }
      var suffLen = 0;
      while (suffLen < l) {
        var currChar = str2.charAt(l - suffLen - 1);
        if (currChar === c2 && !invert) {
          suffLen++;
        } else if (currChar !== c2 && invert) {
          suffLen++;
        } else {
          break;
        }
      }
      return str2.slice(0, l - suffLen);
    }
    function findClosingBracket(str2, b) {
      if (str2.indexOf(b[1]) === -1) {
        return -1;
      }
      var l = str2.length;
      var level = 0, i = 0;
      for (; i < l; i++) {
        if (str2[i] === "\\") {
          i++;
        } else if (str2[i] === b[0]) {
          level++;
        } else if (str2[i] === b[1]) {
          level--;
          if (level < 0) {
            return i;
          }
        }
      }
      return -1;
    }
    function checkSanitizeDeprecation(opt) {
      if (opt && opt.sanitize && !opt.silent) {
        console.warn("marked(): sanitize and sanitizer parameters are deprecated since version 0.7.0, should not be used and will be removed in the future. Read more here: https://marked.js.org/#/USING_ADVANCED.md#options");
      }
    }
    function repeatString(pattern, count) {
      if (count < 1) {
        return "";
      }
      var result = "";
      while (count > 1) {
        if (count & 1) {
          result += pattern;
        }
        count >>= 1;
        pattern += pattern;
      }
      return result + pattern;
    }
    function outputLink(cap, link, raw, lexer3) {
      var href = link.href;
      var title2 = link.title ? escape3(link.title) : null;
      var text = cap[1].replace(/\\([\[\]])/g, "$1");
      if (cap[0].charAt(0) !== "!") {
        lexer3.state.inLink = true;
        var token = {
          type: "link",
          raw,
          href,
          title: title2,
          text,
          tokens: lexer3.inlineTokens(text)
        };
        lexer3.state.inLink = false;
        return token;
      }
      return {
        type: "image",
        raw,
        href,
        title: title2,
        text: escape3(text)
      };
    }
    function indentCodeCompensation(raw, text) {
      var matchIndentToCode = raw.match(/^(\s+)(?:```)/);
      if (matchIndentToCode === null) {
        return text;
      }
      var indentToCode = matchIndentToCode[1];
      return text.split("\n").map(function(node2) {
        var matchIndentInNode = node2.match(/^\s+/);
        if (matchIndentInNode === null) {
          return node2;
        }
        var indentInNode = matchIndentInNode[0];
        if (indentInNode.length >= indentToCode.length) {
          return node2.slice(indentToCode.length);
        }
        return node2;
      }).join("\n");
    }
    var Tokenizer = /* @__PURE__ */ function() {
      function Tokenizer2(options2) {
        this.options = options2 || exports2.defaults;
      }
      var _proto = Tokenizer2.prototype;
      _proto.space = function space(src) {
        var cap = this.rules.block.newline.exec(src);
        if (cap && cap[0].length > 0) {
          return {
            type: "space",
            raw: cap[0]
          };
        }
      };
      _proto.code = function code(src) {
        var cap = this.rules.block.code.exec(src);
        if (cap) {
          var text = cap[0].replace(/^ {1,4}/gm, "");
          return {
            type: "code",
            raw: cap[0],
            codeBlockStyle: "indented",
            text: !this.options.pedantic ? rtrim(text, "\n") : text
          };
        }
      };
      _proto.fences = function fences(src) {
        var cap = this.rules.block.fences.exec(src);
        if (cap) {
          var raw = cap[0];
          var text = indentCodeCompensation(raw, cap[3] || "");
          return {
            type: "code",
            raw,
            lang: cap[2] ? cap[2].trim().replace(this.rules.inline._escapes, "$1") : cap[2],
            text
          };
        }
      };
      _proto.heading = function heading(src) {
        var cap = this.rules.block.heading.exec(src);
        if (cap) {
          var text = cap[2].trim();
          if (/#$/.test(text)) {
            var trimmed = rtrim(text, "#");
            if (this.options.pedantic) {
              text = trimmed.trim();
            } else if (!trimmed || / $/.test(trimmed)) {
              text = trimmed.trim();
            }
          }
          return {
            type: "heading",
            raw: cap[0],
            depth: cap[1].length,
            text,
            tokens: this.lexer.inline(text)
          };
        }
      };
      _proto.hr = function hr(src) {
        var cap = this.rules.block.hr.exec(src);
        if (cap) {
          return {
            type: "hr",
            raw: cap[0]
          };
        }
      };
      _proto.blockquote = function blockquote(src) {
        var cap = this.rules.block.blockquote.exec(src);
        if (cap) {
          var text = cap[0].replace(/^ *>[ \t]?/gm, "");
          var top = this.lexer.state.top;
          this.lexer.state.top = true;
          var tokens = this.lexer.blockTokens(text);
          this.lexer.state.top = top;
          return {
            type: "blockquote",
            raw: cap[0],
            tokens,
            text
          };
        }
      };
      _proto.list = function list(src) {
        var cap = this.rules.block.list.exec(src);
        if (cap) {
          var raw, istask, ischecked, indent, i, blankLine, endsWithBlankLine, line, nextLine, rawLine, itemContents, endEarly;
          var bull = cap[1].trim();
          var isordered = bull.length > 1;
          var list2 = {
            type: "list",
            raw: "",
            ordered: isordered,
            start: isordered ? +bull.slice(0, -1) : "",
            loose: false,
            items: []
          };
          bull = isordered ? "\\d{1,9}\\" + bull.slice(-1) : "\\" + bull;
          if (this.options.pedantic) {
            bull = isordered ? bull : "[*+-]";
          }
          var itemRegex = new RegExp("^( {0,3}" + bull + ")((?:[	 ][^\\n]*)?(?:\\n|$))");
          while (src) {
            endEarly = false;
            if (!(cap = itemRegex.exec(src))) {
              break;
            }
            if (this.rules.block.hr.test(src)) {
              break;
            }
            raw = cap[0];
            src = src.substring(raw.length);
            line = cap[2].split("\n", 1)[0].replace(/^\t+/, function(t) {
              return " ".repeat(3 * t.length);
            });
            nextLine = src.split("\n", 1)[0];
            if (this.options.pedantic) {
              indent = 2;
              itemContents = line.trimLeft();
            } else {
              indent = cap[2].search(/[^ ]/);
              indent = indent > 4 ? 1 : indent;
              itemContents = line.slice(indent);
              indent += cap[1].length;
            }
            blankLine = false;
            if (!line && /^ *$/.test(nextLine)) {
              raw += nextLine + "\n";
              src = src.substring(nextLine.length + 1);
              endEarly = true;
            }
            if (!endEarly) {
              var nextBulletRegex = new RegExp("^ {0," + Math.min(3, indent - 1) + "}(?:[*+-]|\\d{1,9}[.)])((?:[ 	][^\\n]*)?(?:\\n|$))");
              var hrRegex = new RegExp("^ {0," + Math.min(3, indent - 1) + "}((?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$)");
              var fencesBeginRegex = new RegExp("^ {0," + Math.min(3, indent - 1) + "}(?:```|~~~)");
              var headingBeginRegex = new RegExp("^ {0," + Math.min(3, indent - 1) + "}#");
              while (src) {
                rawLine = src.split("\n", 1)[0];
                nextLine = rawLine;
                if (this.options.pedantic) {
                  nextLine = nextLine.replace(/^ {1,4}(?=( {4})*[^ ])/g, "  ");
                }
                if (fencesBeginRegex.test(nextLine)) {
                  break;
                }
                if (headingBeginRegex.test(nextLine)) {
                  break;
                }
                if (nextBulletRegex.test(nextLine)) {
                  break;
                }
                if (hrRegex.test(src)) {
                  break;
                }
                if (nextLine.search(/[^ ]/) >= indent || !nextLine.trim()) {
                  itemContents += "\n" + nextLine.slice(indent);
                } else {
                  if (blankLine) {
                    break;
                  }
                  if (line.search(/[^ ]/) >= 4) {
                    break;
                  }
                  if (fencesBeginRegex.test(line)) {
                    break;
                  }
                  if (headingBeginRegex.test(line)) {
                    break;
                  }
                  if (hrRegex.test(line)) {
                    break;
                  }
                  itemContents += "\n" + nextLine;
                }
                if (!blankLine && !nextLine.trim()) {
                  blankLine = true;
                }
                raw += rawLine + "\n";
                src = src.substring(rawLine.length + 1);
                line = nextLine.slice(indent);
              }
            }
            if (!list2.loose) {
              if (endsWithBlankLine) {
                list2.loose = true;
              } else if (/\n *\n *$/.test(raw)) {
                endsWithBlankLine = true;
              }
            }
            if (this.options.gfm) {
              istask = /^\[[ xX]\] /.exec(itemContents);
              if (istask) {
                ischecked = istask[0] !== "[ ] ";
                itemContents = itemContents.replace(/^\[[ xX]\] +/, "");
              }
            }
            list2.items.push({
              type: "list_item",
              raw,
              task: !!istask,
              checked: ischecked,
              loose: false,
              text: itemContents
            });
            list2.raw += raw;
          }
          list2.items[list2.items.length - 1].raw = raw.trimRight();
          list2.items[list2.items.length - 1].text = itemContents.trimRight();
          list2.raw = list2.raw.trimRight();
          var l = list2.items.length;
          for (i = 0; i < l; i++) {
            this.lexer.state.top = false;
            list2.items[i].tokens = this.lexer.blockTokens(list2.items[i].text, []);
            if (!list2.loose) {
              var spacers = list2.items[i].tokens.filter(function(t) {
                return t.type === "space";
              });
              var hasMultipleLineBreaks = spacers.length > 0 && spacers.some(function(t) {
                return /\n.*\n/.test(t.raw);
              });
              list2.loose = hasMultipleLineBreaks;
            }
          }
          if (list2.loose) {
            for (i = 0; i < l; i++) {
              list2.items[i].loose = true;
            }
          }
          return list2;
        }
      };
      _proto.html = function html(src) {
        var cap = this.rules.block.html.exec(src);
        if (cap) {
          var token = {
            type: "html",
            raw: cap[0],
            pre: !this.options.sanitizer && (cap[1] === "pre" || cap[1] === "script" || cap[1] === "style"),
            text: cap[0]
          };
          if (this.options.sanitize) {
            var text = this.options.sanitizer ? this.options.sanitizer(cap[0]) : escape3(cap[0]);
            token.type = "paragraph";
            token.text = text;
            token.tokens = this.lexer.inline(text);
          }
          return token;
        }
      };
      _proto.def = function def(src) {
        var cap = this.rules.block.def.exec(src);
        if (cap) {
          var tag = cap[1].toLowerCase().replace(/\s+/g, " ");
          var href = cap[2] ? cap[2].replace(/^<(.*)>$/, "$1").replace(this.rules.inline._escapes, "$1") : "";
          var title2 = cap[3] ? cap[3].substring(1, cap[3].length - 1).replace(this.rules.inline._escapes, "$1") : cap[3];
          return {
            type: "def",
            tag,
            raw: cap[0],
            href,
            title: title2
          };
        }
      };
      _proto.table = function table(src) {
        var cap = this.rules.block.table.exec(src);
        if (cap) {
          var item = {
            type: "table",
            header: splitCells(cap[1]).map(function(c2) {
              return {
                text: c2
              };
            }),
            align: cap[2].replace(/^ *|\| *$/g, "").split(/ *\| */),
            rows: cap[3] && cap[3].trim() ? cap[3].replace(/\n[ \t]*$/, "").split("\n") : []
          };
          if (item.header.length === item.align.length) {
            item.raw = cap[0];
            var l = item.align.length;
            var i, j, k, row;
            for (i = 0; i < l; i++) {
              if (/^ *-+: *$/.test(item.align[i])) {
                item.align[i] = "right";
              } else if (/^ *:-+: *$/.test(item.align[i])) {
                item.align[i] = "center";
              } else if (/^ *:-+ *$/.test(item.align[i])) {
                item.align[i] = "left";
              } else {
                item.align[i] = null;
              }
            }
            l = item.rows.length;
            for (i = 0; i < l; i++) {
              item.rows[i] = splitCells(item.rows[i], item.header.length).map(function(c2) {
                return {
                  text: c2
                };
              });
            }
            l = item.header.length;
            for (j = 0; j < l; j++) {
              item.header[j].tokens = this.lexer.inline(item.header[j].text);
            }
            l = item.rows.length;
            for (j = 0; j < l; j++) {
              row = item.rows[j];
              for (k = 0; k < row.length; k++) {
                row[k].tokens = this.lexer.inline(row[k].text);
              }
            }
            return item;
          }
        }
      };
      _proto.lheading = function lheading(src) {
        var cap = this.rules.block.lheading.exec(src);
        if (cap) {
          return {
            type: "heading",
            raw: cap[0],
            depth: cap[2].charAt(0) === "=" ? 1 : 2,
            text: cap[1],
            tokens: this.lexer.inline(cap[1])
          };
        }
      };
      _proto.paragraph = function paragraph(src) {
        var cap = this.rules.block.paragraph.exec(src);
        if (cap) {
          var text = cap[1].charAt(cap[1].length - 1) === "\n" ? cap[1].slice(0, -1) : cap[1];
          return {
            type: "paragraph",
            raw: cap[0],
            text,
            tokens: this.lexer.inline(text)
          };
        }
      };
      _proto.text = function text(src) {
        var cap = this.rules.block.text.exec(src);
        if (cap) {
          return {
            type: "text",
            raw: cap[0],
            text: cap[0],
            tokens: this.lexer.inline(cap[0])
          };
        }
      };
      _proto.escape = function escape$1(src) {
        var cap = this.rules.inline.escape.exec(src);
        if (cap) {
          return {
            type: "escape",
            raw: cap[0],
            text: escape3(cap[1])
          };
        }
      };
      _proto.tag = function tag(src) {
        var cap = this.rules.inline.tag.exec(src);
        if (cap) {
          if (!this.lexer.state.inLink && /^<a /i.test(cap[0])) {
            this.lexer.state.inLink = true;
          } else if (this.lexer.state.inLink && /^<\/a>/i.test(cap[0])) {
            this.lexer.state.inLink = false;
          }
          if (!this.lexer.state.inRawBlock && /^<(pre|code|kbd|script)(\s|>)/i.test(cap[0])) {
            this.lexer.state.inRawBlock = true;
          } else if (this.lexer.state.inRawBlock && /^<\/(pre|code|kbd|script)(\s|>)/i.test(cap[0])) {
            this.lexer.state.inRawBlock = false;
          }
          return {
            type: this.options.sanitize ? "text" : "html",
            raw: cap[0],
            inLink: this.lexer.state.inLink,
            inRawBlock: this.lexer.state.inRawBlock,
            text: this.options.sanitize ? this.options.sanitizer ? this.options.sanitizer(cap[0]) : escape3(cap[0]) : cap[0]
          };
        }
      };
      _proto.link = function link(src) {
        var cap = this.rules.inline.link.exec(src);
        if (cap) {
          var trimmedUrl = cap[2].trim();
          if (!this.options.pedantic && /^</.test(trimmedUrl)) {
            if (!/>$/.test(trimmedUrl)) {
              return;
            }
            var rtrimSlash = rtrim(trimmedUrl.slice(0, -1), "\\");
            if ((trimmedUrl.length - rtrimSlash.length) % 2 === 0) {
              return;
            }
          } else {
            var lastParenIndex = findClosingBracket(cap[2], "()");
            if (lastParenIndex > -1) {
              var start = cap[0].indexOf("!") === 0 ? 5 : 4;
              var linkLen = start + cap[1].length + lastParenIndex;
              cap[2] = cap[2].substring(0, lastParenIndex);
              cap[0] = cap[0].substring(0, linkLen).trim();
              cap[3] = "";
            }
          }
          var href = cap[2];
          var title2 = "";
          if (this.options.pedantic) {
            var link2 = /^([^'"]*[^\s])\s+(['"])(.*)\2/.exec(href);
            if (link2) {
              href = link2[1];
              title2 = link2[3];
            }
          } else {
            title2 = cap[3] ? cap[3].slice(1, -1) : "";
          }
          href = href.trim();
          if (/^</.test(href)) {
            if (this.options.pedantic && !/>$/.test(trimmedUrl)) {
              href = href.slice(1);
            } else {
              href = href.slice(1, -1);
            }
          }
          return outputLink(cap, {
            href: href ? href.replace(this.rules.inline._escapes, "$1") : href,
            title: title2 ? title2.replace(this.rules.inline._escapes, "$1") : title2
          }, cap[0], this.lexer);
        }
      };
      _proto.reflink = function reflink(src, links) {
        var cap;
        if ((cap = this.rules.inline.reflink.exec(src)) || (cap = this.rules.inline.nolink.exec(src))) {
          var link = (cap[2] || cap[1]).replace(/\s+/g, " ");
          link = links[link.toLowerCase()];
          if (!link) {
            var text = cap[0].charAt(0);
            return {
              type: "text",
              raw: text,
              text
            };
          }
          return outputLink(cap, link, cap[0], this.lexer);
        }
      };
      _proto.emStrong = function emStrong(src, maskedSrc, prevChar) {
        if (prevChar === void 0) {
          prevChar = "";
        }
        var match2 = this.rules.inline.emStrong.lDelim.exec(src);
        if (!match2) return;
        if (match2[3] && prevChar.match(/(?:[0-9A-Za-z\xAA\xB2\xB3\xB5\xB9\xBA\xBC-\xBE\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u0660-\u0669\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07C0-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0966-\u096F\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09E6-\u09F1\u09F4-\u09F9\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A66-\u0A6F\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AE6-\u0AEF\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B66-\u0B6F\u0B71-\u0B77\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0BE6-\u0BF2\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C66-\u0C6F\u0C78-\u0C7E\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CE6-\u0CEF\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D58-\u0D61\u0D66-\u0D78\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DE6-\u0DEF\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F20-\u0F33\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F-\u1049\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u1090-\u1099\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1369-\u137C\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u17E0-\u17E9\u17F0-\u17F9\u1810-\u1819\u1820-\u1878\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A16\u1A20-\u1A54\u1A80-\u1A89\u1A90-\u1A99\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B50-\u1B59\u1B83-\u1BA0\u1BAE-\u1BE5\u1C00-\u1C23\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2070\u2071\u2074-\u2079\u207F-\u2089\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2150-\u2189\u2460-\u249B\u24EA-\u24FF\u2776-\u2793\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2CFD\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u3192-\u3195\u31A0-\u31BF\u31F0-\u31FF\u3220-\u3229\u3248-\u324F\u3251-\u325F\u3280-\u3289\u32B1-\u32BF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA830-\uA835\uA840-\uA873\uA882-\uA8B3\uA8D0-\uA8D9\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA900-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF-\uA9D9\uA9E0-\uA9E4\uA9E6-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA50-\uAA59\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD07-\uDD33\uDD40-\uDD78\uDD8A\uDD8B\uDE80-\uDE9C\uDEA0-\uDED0\uDEE1-\uDEFB\uDF00-\uDF23\uDF2D-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDD70-\uDD7A\uDD7C-\uDD8A\uDD8C-\uDD92\uDD94\uDD95\uDD97-\uDDA1\uDDA3-\uDDB1\uDDB3-\uDDB9\uDDBB\uDDBC\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67\uDF80-\uDF85\uDF87-\uDFB0\uDFB2-\uDFBA]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC58-\uDC76\uDC79-\uDC9E\uDCA7-\uDCAF\uDCE0-\uDCF2\uDCF4\uDCF5\uDCFB-\uDD1B\uDD20-\uDD39\uDD80-\uDDB7\uDDBC-\uDDCF\uDDD2-\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE35\uDE40-\uDE48\uDE60-\uDE7E\uDE80-\uDE9F\uDEC0-\uDEC7\uDEC9-\uDEE4\uDEEB-\uDEEF\uDF00-\uDF35\uDF40-\uDF55\uDF58-\uDF72\uDF78-\uDF91\uDFA9-\uDFAF]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2\uDCFA-\uDD23\uDD30-\uDD39\uDE60-\uDE7E\uDE80-\uDEA9\uDEB0\uDEB1\uDF00-\uDF27\uDF30-\uDF45\uDF51-\uDF54\uDF70-\uDF81\uDFB0-\uDFCB\uDFE0-\uDFF6]|\uD804[\uDC03-\uDC37\uDC52-\uDC6F\uDC71\uDC72\uDC75\uDC83-\uDCAF\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD03-\uDD26\uDD36-\uDD3F\uDD44\uDD47\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDD0-\uDDDA\uDDDC\uDDE1-\uDDF4\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDEF0-\uDEF9\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC50-\uDC59\uDC5F-\uDC61\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE50-\uDE59\uDE80-\uDEAA\uDEB8\uDEC0-\uDEC9\uDF00-\uDF1A\uDF30-\uDF3B\uDF40-\uDF46]|\uD806[\uDC00-\uDC2B\uDCA0-\uDCF2\uDCFF-\uDD06\uDD09\uDD0C-\uDD13\uDD15\uDD16\uDD18-\uDD2F\uDD3F\uDD41\uDD50-\uDD59\uDDA0-\uDDA7\uDDAA-\uDDD0\uDDE1\uDDE3\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE89\uDE9D\uDEB0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC50-\uDC6C\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46\uDD50-\uDD59\uDD60-\uDD65\uDD67\uDD68\uDD6A-\uDD89\uDD98\uDDA0-\uDDA9\uDEE0-\uDEF2\uDFB0\uDFC0-\uDFD4]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|\uD80B[\uDF90-\uDFF0]|[\uD80C\uD81C-\uD820\uD822\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879\uD880-\uD883][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDE70-\uDEBE\uDEC0-\uDEC9\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF50-\uDF59\uDF5B-\uDF61\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDE40-\uDE96\uDF00-\uDF4A\uDF50\uDF93-\uDF9F\uDFE0\uDFE1\uDFE3]|\uD821[\uDC00-\uDFF7]|\uD823[\uDC00-\uDCD5\uDD00-\uDD08]|\uD82B[\uDFF0-\uDFF3\uDFF5-\uDFFB\uDFFD\uDFFE]|\uD82C[\uDC00-\uDD22\uDD50-\uDD52\uDD64-\uDD67\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD834[\uDEE0-\uDEF3\uDF60-\uDF78]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD837[\uDF00-\uDF1E]|\uD838[\uDD00-\uDD2C\uDD37-\uDD3D\uDD40-\uDD49\uDD4E\uDE90-\uDEAD\uDEC0-\uDEEB\uDEF0-\uDEF9]|\uD839[\uDFE0-\uDFE6\uDFE8-\uDFEB\uDFED\uDFEE\uDFF0-\uDFFE]|\uD83A[\uDC00-\uDCC4\uDCC7-\uDCCF\uDD00-\uDD43\uDD4B\uDD50-\uDD59]|\uD83B[\uDC71-\uDCAB\uDCAD-\uDCAF\uDCB1-\uDCB4\uDD01-\uDD2D\uDD2F-\uDD3D\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD83C[\uDD00-\uDD0C]|\uD83E[\uDFF0-\uDFF9]|\uD869[\uDC00-\uDEDF\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF38\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]|\uD884[\uDC00-\uDF4A])/)) return;
        var nextChar = match2[1] || match2[2] || "";
        if (!nextChar || nextChar && (prevChar === "" || this.rules.inline.punctuation.exec(prevChar))) {
          var lLength = match2[0].length - 1;
          var rDelim, rLength, delimTotal = lLength, midDelimTotal = 0;
          var endReg = match2[0][0] === "*" ? this.rules.inline.emStrong.rDelimAst : this.rules.inline.emStrong.rDelimUnd;
          endReg.lastIndex = 0;
          maskedSrc = maskedSrc.slice(-1 * src.length + lLength);
          while ((match2 = endReg.exec(maskedSrc)) != null) {
            rDelim = match2[1] || match2[2] || match2[3] || match2[4] || match2[5] || match2[6];
            if (!rDelim) continue;
            rLength = rDelim.length;
            if (match2[3] || match2[4]) {
              delimTotal += rLength;
              continue;
            } else if (match2[5] || match2[6]) {
              if (lLength % 3 && !((lLength + rLength) % 3)) {
                midDelimTotal += rLength;
                continue;
              }
            }
            delimTotal -= rLength;
            if (delimTotal > 0) continue;
            rLength = Math.min(rLength, rLength + delimTotal + midDelimTotal);
            var raw = src.slice(0, lLength + match2.index + (match2[0].length - rDelim.length) + rLength);
            if (Math.min(lLength, rLength) % 2) {
              var _text = raw.slice(1, -1);
              return {
                type: "em",
                raw,
                text: _text,
                tokens: this.lexer.inlineTokens(_text)
              };
            }
            var text = raw.slice(2, -2);
            return {
              type: "strong",
              raw,
              text,
              tokens: this.lexer.inlineTokens(text)
            };
          }
        }
      };
      _proto.codespan = function codespan(src) {
        var cap = this.rules.inline.code.exec(src);
        if (cap) {
          var text = cap[2].replace(/\n/g, " ");
          var hasNonSpaceChars = /[^ ]/.test(text);
          var hasSpaceCharsOnBothEnds = /^ /.test(text) && / $/.test(text);
          if (hasNonSpaceChars && hasSpaceCharsOnBothEnds) {
            text = text.substring(1, text.length - 1);
          }
          text = escape3(text, true);
          return {
            type: "codespan",
            raw: cap[0],
            text
          };
        }
      };
      _proto.br = function br(src) {
        var cap = this.rules.inline.br.exec(src);
        if (cap) {
          return {
            type: "br",
            raw: cap[0]
          };
        }
      };
      _proto.del = function del(src) {
        var cap = this.rules.inline.del.exec(src);
        if (cap) {
          return {
            type: "del",
            raw: cap[0],
            text: cap[2],
            tokens: this.lexer.inlineTokens(cap[2])
          };
        }
      };
      _proto.autolink = function autolink(src, mangle2) {
        var cap = this.rules.inline.autolink.exec(src);
        if (cap) {
          var text, href;
          if (cap[2] === "@") {
            text = escape3(this.options.mangle ? mangle2(cap[1]) : cap[1]);
            href = "mailto:" + text;
          } else {
            text = escape3(cap[1]);
            href = text;
          }
          return {
            type: "link",
            raw: cap[0],
            text,
            href,
            tokens: [{
              type: "text",
              raw: text,
              text
            }]
          };
        }
      };
      _proto.url = function url(src, mangle2) {
        var cap;
        if (cap = this.rules.inline.url.exec(src)) {
          var text, href;
          if (cap[2] === "@") {
            text = escape3(this.options.mangle ? mangle2(cap[0]) : cap[0]);
            href = "mailto:" + text;
          } else {
            var prevCapZero;
            do {
              prevCapZero = cap[0];
              cap[0] = this.rules.inline._backpedal.exec(cap[0])[0];
            } while (prevCapZero !== cap[0]);
            text = escape3(cap[0]);
            if (cap[1] === "www.") {
              href = "http://" + cap[0];
            } else {
              href = cap[0];
            }
          }
          return {
            type: "link",
            raw: cap[0],
            text,
            href,
            tokens: [{
              type: "text",
              raw: text,
              text
            }]
          };
        }
      };
      _proto.inlineText = function inlineText(src, smartypants2) {
        var cap = this.rules.inline.text.exec(src);
        if (cap) {
          var text;
          if (this.lexer.state.inRawBlock) {
            text = this.options.sanitize ? this.options.sanitizer ? this.options.sanitizer(cap[0]) : escape3(cap[0]) : cap[0];
          } else {
            text = escape3(this.options.smartypants ? smartypants2(cap[0]) : cap[0]);
          }
          return {
            type: "text",
            raw: cap[0],
            text
          };
        }
      };
      return Tokenizer2;
    }();
    var block = {
      newline: /^(?: *(?:\n|$))+/,
      code: /^( {4}[^\n]+(?:\n(?: *(?:\n|$))*)?)+/,
      fences: /^ {0,3}(`{3,}(?=[^`\n]*(?:\n|$))|~{3,})([^\n]*)(?:\n|$)(?:|([\s\S]*?)(?:\n|$))(?: {0,3}\1[~`]* *(?=\n|$)|$)/,
      hr: /^ {0,3}((?:-[\t ]*){3,}|(?:_[ \t]*){3,}|(?:\*[ \t]*){3,})(?:\n+|$)/,
      heading: /^ {0,3}(#{1,6})(?=\s|$)(.*)(?:\n+|$)/,
      blockquote: /^( {0,3}> ?(paragraph|[^\n]*)(?:\n|$))+/,
      list: /^( {0,3}bull)([ \t][^\n]+?)?(?:\n|$)/,
      html: "^ {0,3}(?:<(script|pre|style|textarea)[\\s>][\\s\\S]*?(?:</\\1>[^\\n]*\\n+|$)|comment[^\\n]*(\\n+|$)|<\\?[\\s\\S]*?(?:\\?>\\n*|$)|<![A-Z][\\s\\S]*?(?:>\\n*|$)|<!\\[CDATA\\[[\\s\\S]*?(?:\\]\\]>\\n*|$)|</?(tag)(?: +|\\n|/?>)[\\s\\S]*?(?:(?:\\n *)+\\n|$)|<(?!script|pre|style|textarea)([a-z][\\w-]*)(?:attribute)*? */?>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n *)+\\n|$)|</(?!script|pre|style|textarea)[a-z][\\w-]*\\s*>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n *)+\\n|$))",
      def: /^ {0,3}\[(label)\]: *(?:\n *)?([^<\s][^\s]*|<.*?>)(?:(?: +(?:\n *)?| *\n *)(title))? *(?:\n+|$)/,
      table: noopTest,
      lheading: /^((?:.|\n(?!\n))+?)\n {0,3}(=+|-+) *(?:\n+|$)/,
      // regex template, placeholders will be replaced according to different paragraph
      // interruption rules of commonmark and the original markdown spec:
      _paragraph: /^([^\n]+(?:\n(?!hr|heading|lheading|blockquote|fences|list|html|table| +\n)[^\n]+)*)/,
      text: /^[^\n]+/
    };
    block._label = /(?!\s*\])(?:\\.|[^\[\]\\])+/;
    block._title = /(?:"(?:\\"?|[^"\\])*"|'[^'\n]*(?:\n[^'\n]+)*\n?'|\([^()]*\))/;
    block.def = edit(block.def).replace("label", block._label).replace("title", block._title).getRegex();
    block.bullet = /(?:[*+-]|\d{1,9}[.)])/;
    block.listItemStart = edit(/^( *)(bull) */).replace("bull", block.bullet).getRegex();
    block.list = edit(block.list).replace(/bull/g, block.bullet).replace("hr", "\\n+(?=\\1?(?:(?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$))").replace("def", "\\n+(?=" + block.def.source + ")").getRegex();
    block._tag = "address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option|p|param|section|source|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul";
    block._comment = /<!--(?!-?>)[\s\S]*?(?:-->|$)/;
    block.html = edit(block.html, "i").replace("comment", block._comment).replace("tag", block._tag).replace("attribute", / +[a-zA-Z:_][\w.:-]*(?: *= *"[^"\n]*"| *= *'[^'\n]*'| *= *[^\s"'=<>`]+)?/).getRegex();
    block.paragraph = edit(block._paragraph).replace("hr", block.hr).replace("heading", " {0,3}#{1,6} ").replace("|lheading", "").replace("|table", "").replace("blockquote", " {0,3}>").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", block._tag).getRegex();
    block.blockquote = edit(block.blockquote).replace("paragraph", block.paragraph).getRegex();
    block.normal = _extends({}, block);
    block.gfm = _extends({}, block.normal, {
      table: "^ *([^\\n ].*\\|.*)\\n {0,3}(?:\\| *)?(:?-+:? *(?:\\| *:?-+:? *)*)(?:\\| *)?(?:\\n((?:(?! *\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\n|$))*)\\n*|$)"
      // Cells
    });
    block.gfm.table = edit(block.gfm.table).replace("hr", block.hr).replace("heading", " {0,3}#{1,6} ").replace("blockquote", " {0,3}>").replace("code", " {4}[^\\n]").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", block._tag).getRegex();
    block.gfm.paragraph = edit(block._paragraph).replace("hr", block.hr).replace("heading", " {0,3}#{1,6} ").replace("|lheading", "").replace("table", block.gfm.table).replace("blockquote", " {0,3}>").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", block._tag).getRegex();
    block.pedantic = _extends({}, block.normal, {
      html: edit(`^ *(?:comment *(?:\\n|\\s*$)|<(tag)[\\s\\S]+?</\\1> *(?:\\n{2,}|\\s*$)|<tag(?:"[^"]*"|'[^']*'|\\s[^'"/>\\s]*)*?/?> *(?:\\n{2,}|\\s*$))`).replace("comment", block._comment).replace(/tag/g, "(?!(?:a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)\\b)\\w+(?!:|[^\\w\\s@]*@)\\b").getRegex(),
      def: /^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +(["(][^\n]+[")]))? *(?:\n+|$)/,
      heading: /^(#{1,6})(.*)(?:\n+|$)/,
      fences: noopTest,
      // fences not supported
      lheading: /^(.+?)\n {0,3}(=+|-+) *(?:\n+|$)/,
      paragraph: edit(block.normal._paragraph).replace("hr", block.hr).replace("heading", " *#{1,6} *[^\n]").replace("lheading", block.lheading).replace("blockquote", " {0,3}>").replace("|fences", "").replace("|list", "").replace("|html", "").getRegex()
    });
    var inline = {
      escape: /^\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/,
      autolink: /^<(scheme:[^\s\x00-\x1f<>]*|email)>/,
      url: noopTest,
      tag: "^comment|^</[a-zA-Z][\\w:-]*\\s*>|^<[a-zA-Z][\\w-]*(?:attribute)*?\\s*/?>|^<\\?[\\s\\S]*?\\?>|^<![a-zA-Z]+\\s[\\s\\S]*?>|^<!\\[CDATA\\[[\\s\\S]*?\\]\\]>",
      // CDATA section
      link: /^!?\[(label)\]\(\s*(href)(?:\s+(title))?\s*\)/,
      reflink: /^!?\[(label)\]\[(ref)\]/,
      nolink: /^!?\[(ref)\](?:\[\])?/,
      reflinkSearch: "reflink|nolink(?!\\()",
      emStrong: {
        lDelim: /^(?:\*+(?:([punct_])|[^\s*]))|^_+(?:([punct*])|([^\s_]))/,
        //        (1) and (2) can only be a Right Delimiter. (3) and (4) can only be Left.  (5) and (6) can be either Left or Right.
        //          () Skip orphan inside strong                                      () Consume to delim     (1) #***                (2) a***#, a***                             (3) #***a, ***a                 (4) ***#              (5) #***#                 (6) a***a
        rDelimAst: /^(?:[^_*\\]|\\.)*?\_\_(?:[^_*\\]|\\.)*?\*(?:[^_*\\]|\\.)*?(?=\_\_)|(?:[^*\\]|\\.)+(?=[^*])|[punct_](\*+)(?=[\s]|$)|(?:[^punct*_\s\\]|\\.)(\*+)(?=[punct_\s]|$)|[punct_\s](\*+)(?=[^punct*_\s])|[\s](\*+)(?=[punct_])|[punct_](\*+)(?=[punct_])|(?:[^punct*_\s\\]|\\.)(\*+)(?=[^punct*_\s])/,
        rDelimUnd: /^(?:[^_*\\]|\\.)*?\*\*(?:[^_*\\]|\\.)*?\_(?:[^_*\\]|\\.)*?(?=\*\*)|(?:[^_\\]|\\.)+(?=[^_])|[punct*](\_+)(?=[\s]|$)|(?:[^punct*_\s\\]|\\.)(\_+)(?=[punct*\s]|$)|[punct*\s](\_+)(?=[^punct*_\s])|[\s](\_+)(?=[punct*])|[punct*](\_+)(?=[punct*])/
        // ^- Not allowed for _
      },
      code: /^(`+)([^`]|[^`][\s\S]*?[^`])\1(?!`)/,
      br: /^( {2,}|\\)\n(?!\s*$)/,
      del: noopTest,
      text: /^(`+|[^`])(?:(?= {2,}\n)|[\s\S]*?(?:(?=[\\<!\[`*_]|\b_|$)|[^ ](?= {2,}\n)))/,
      punctuation: /^([\spunctuation])/
    };
    inline._punctuation = "!\"#$%&'()+\\-.,/:;<=>?@\\[\\]`^{|}~";
    inline.punctuation = edit(inline.punctuation).replace(/punctuation/g, inline._punctuation).getRegex();
    inline.blockSkip = /\[[^\]]*?\]\([^\)]*?\)|`[^`]*?`|<[^>]*?>/g;
    inline.escapedEmSt = /(?:^|[^\\])(?:\\\\)*\\[*_]/g;
    inline._comment = edit(block._comment).replace("(?:-->|$)", "-->").getRegex();
    inline.emStrong.lDelim = edit(inline.emStrong.lDelim).replace(/punct/g, inline._punctuation).getRegex();
    inline.emStrong.rDelimAst = edit(inline.emStrong.rDelimAst, "g").replace(/punct/g, inline._punctuation).getRegex();
    inline.emStrong.rDelimUnd = edit(inline.emStrong.rDelimUnd, "g").replace(/punct/g, inline._punctuation).getRegex();
    inline._escapes = /\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/g;
    inline._scheme = /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/;
    inline._email = /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/;
    inline.autolink = edit(inline.autolink).replace("scheme", inline._scheme).replace("email", inline._email).getRegex();
    inline._attribute = /\s+[a-zA-Z:_][\w.:-]*(?:\s*=\s*"[^"]*"|\s*=\s*'[^']*'|\s*=\s*[^\s"'=<>`]+)?/;
    inline.tag = edit(inline.tag).replace("comment", inline._comment).replace("attribute", inline._attribute).getRegex();
    inline._label = /(?:\[(?:\\.|[^\[\]\\])*\]|\\.|`[^`]*`|[^\[\]\\`])*?/;
    inline._href = /<(?:\\.|[^\n<>\\])+>|[^\s\x00-\x1f]*/;
    inline._title = /"(?:\\"?|[^"\\])*"|'(?:\\'?|[^'\\])*'|\((?:\\\)?|[^)\\])*\)/;
    inline.link = edit(inline.link).replace("label", inline._label).replace("href", inline._href).replace("title", inline._title).getRegex();
    inline.reflink = edit(inline.reflink).replace("label", inline._label).replace("ref", block._label).getRegex();
    inline.nolink = edit(inline.nolink).replace("ref", block._label).getRegex();
    inline.reflinkSearch = edit(inline.reflinkSearch, "g").replace("reflink", inline.reflink).replace("nolink", inline.nolink).getRegex();
    inline.normal = _extends({}, inline);
    inline.pedantic = _extends({}, inline.normal, {
      strong: {
        start: /^__|\*\*/,
        middle: /^__(?=\S)([\s\S]*?\S)__(?!_)|^\*\*(?=\S)([\s\S]*?\S)\*\*(?!\*)/,
        endAst: /\*\*(?!\*)/g,
        endUnd: /__(?!_)/g
      },
      em: {
        start: /^_|\*/,
        middle: /^()\*(?=\S)([\s\S]*?\S)\*(?!\*)|^_(?=\S)([\s\S]*?\S)_(?!_)/,
        endAst: /\*(?!\*)/g,
        endUnd: /_(?!_)/g
      },
      link: edit(/^!?\[(label)\]\((.*?)\)/).replace("label", inline._label).getRegex(),
      reflink: edit(/^!?\[(label)\]\s*\[([^\]]*)\]/).replace("label", inline._label).getRegex()
    });
    inline.gfm = _extends({}, inline.normal, {
      escape: edit(inline.escape).replace("])", "~|])").getRegex(),
      _extended_email: /[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/,
      url: /^((?:ftp|https?):\/\/|www\.)(?:[a-zA-Z0-9\-]+\.?)+[^\s<]*|^email/,
      _backpedal: /(?:[^?!.,:;*_'"~()&]+|\([^)]*\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_'"~)]+(?!$))+/,
      del: /^(~~?)(?=[^\s~])([\s\S]*?[^\s~])\1(?=[^~]|$)/,
      text: /^([`~]+|[^`~])(?:(?= {2,}\n)|(?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)|[\s\S]*?(?:(?=[\\<!\[`*~_]|\b_|https?:\/\/|ftp:\/\/|www\.|$)|[^ ](?= {2,}\n)|[^a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-](?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)))/
    });
    inline.gfm.url = edit(inline.gfm.url, "i").replace("email", inline.gfm._extended_email).getRegex();
    inline.breaks = _extends({}, inline.gfm, {
      br: edit(inline.br).replace("{2,}", "*").getRegex(),
      text: edit(inline.gfm.text).replace("\\b_", "\\b_| {2,}\\n").replace(/\{2,\}/g, "*").getRegex()
    });
    function smartypants(text) {
      return text.replace(/---/g, "\u2014").replace(/--/g, "\u2013").replace(/(^|[-\u2014/(\[{"\s])'/g, "$1\u2018").replace(/'/g, "\u2019").replace(/(^|[-\u2014/(\[{\u2018\s])"/g, "$1\u201C").replace(/"/g, "\u201D").replace(/\.{3}/g, "\u2026");
    }
    function mangle(text) {
      var out = "", i, ch;
      var l = text.length;
      for (i = 0; i < l; i++) {
        ch = text.charCodeAt(i);
        if (Math.random() > 0.5) {
          ch = "x" + ch.toString(16);
        }
        out += "&#" + ch + ";";
      }
      return out;
    }
    var Lexer = /* @__PURE__ */ function() {
      function Lexer2(options2) {
        this.tokens = [];
        this.tokens.links = /* @__PURE__ */ Object.create(null);
        this.options = options2 || exports2.defaults;
        this.options.tokenizer = this.options.tokenizer || new Tokenizer();
        this.tokenizer = this.options.tokenizer;
        this.tokenizer.options = this.options;
        this.tokenizer.lexer = this;
        this.inlineQueue = [];
        this.state = {
          inLink: false,
          inRawBlock: false,
          top: true
        };
        var rules = {
          block: block.normal,
          inline: inline.normal
        };
        if (this.options.pedantic) {
          rules.block = block.pedantic;
          rules.inline = inline.pedantic;
        } else if (this.options.gfm) {
          rules.block = block.gfm;
          if (this.options.breaks) {
            rules.inline = inline.breaks;
          } else {
            rules.inline = inline.gfm;
          }
        }
        this.tokenizer.rules = rules;
      }
      Lexer2.lex = function lex(src, options2) {
        var lexer3 = new Lexer2(options2);
        return lexer3.lex(src);
      };
      Lexer2.lexInline = function lexInline(src, options2) {
        var lexer3 = new Lexer2(options2);
        return lexer3.inlineTokens(src);
      };
      var _proto = Lexer2.prototype;
      _proto.lex = function lex(src) {
        src = src.replace(/\r\n|\r/g, "\n");
        this.blockTokens(src, this.tokens);
        var next;
        while (next = this.inlineQueue.shift()) {
          this.inlineTokens(next.src, next.tokens);
        }
        return this.tokens;
      };
      _proto.blockTokens = function blockTokens(src, tokens) {
        var _this = this;
        if (tokens === void 0) {
          tokens = [];
        }
        if (this.options.pedantic) {
          src = src.replace(/\t/g, "    ").replace(/^ +$/gm, "");
        } else {
          src = src.replace(/^( *)(\t+)/gm, function(_, leading, tabs) {
            return leading + "    ".repeat(tabs.length);
          });
        }
        var token, lastToken, cutSrc, lastParagraphClipped;
        while (src) {
          if (this.options.extensions && this.options.extensions.block && this.options.extensions.block.some(function(extTokenizer) {
            if (token = extTokenizer.call({
              lexer: _this
            }, src, tokens)) {
              src = src.substring(token.raw.length);
              tokens.push(token);
              return true;
            }
            return false;
          })) {
            continue;
          }
          if (token = this.tokenizer.space(src)) {
            src = src.substring(token.raw.length);
            if (token.raw.length === 1 && tokens.length > 0) {
              tokens[tokens.length - 1].raw += "\n";
            } else {
              tokens.push(token);
            }
            continue;
          }
          if (token = this.tokenizer.code(src)) {
            src = src.substring(token.raw.length);
            lastToken = tokens[tokens.length - 1];
            if (lastToken && (lastToken.type === "paragraph" || lastToken.type === "text")) {
              lastToken.raw += "\n" + token.raw;
              lastToken.text += "\n" + token.text;
              this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;
            } else {
              tokens.push(token);
            }
            continue;
          }
          if (token = this.tokenizer.fences(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          if (token = this.tokenizer.heading(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          if (token = this.tokenizer.hr(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          if (token = this.tokenizer.blockquote(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          if (token = this.tokenizer.list(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          if (token = this.tokenizer.html(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          if (token = this.tokenizer.def(src)) {
            src = src.substring(token.raw.length);
            lastToken = tokens[tokens.length - 1];
            if (lastToken && (lastToken.type === "paragraph" || lastToken.type === "text")) {
              lastToken.raw += "\n" + token.raw;
              lastToken.text += "\n" + token.raw;
              this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;
            } else if (!this.tokens.links[token.tag]) {
              this.tokens.links[token.tag] = {
                href: token.href,
                title: token.title
              };
            }
            continue;
          }
          if (token = this.tokenizer.table(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          if (token = this.tokenizer.lheading(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          cutSrc = src;
          if (this.options.extensions && this.options.extensions.startBlock) {
            (function() {
              var startIndex = Infinity;
              var tempSrc = src.slice(1);
              var tempStart = void 0;
              _this.options.extensions.startBlock.forEach(function(getStartIndex) {
                tempStart = getStartIndex.call({
                  lexer: this
                }, tempSrc);
                if (typeof tempStart === "number" && tempStart >= 0) {
                  startIndex = Math.min(startIndex, tempStart);
                }
              });
              if (startIndex < Infinity && startIndex >= 0) {
                cutSrc = src.substring(0, startIndex + 1);
              }
            })();
          }
          if (this.state.top && (token = this.tokenizer.paragraph(cutSrc))) {
            lastToken = tokens[tokens.length - 1];
            if (lastParagraphClipped && lastToken.type === "paragraph") {
              lastToken.raw += "\n" + token.raw;
              lastToken.text += "\n" + token.text;
              this.inlineQueue.pop();
              this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;
            } else {
              tokens.push(token);
            }
            lastParagraphClipped = cutSrc.length !== src.length;
            src = src.substring(token.raw.length);
            continue;
          }
          if (token = this.tokenizer.text(src)) {
            src = src.substring(token.raw.length);
            lastToken = tokens[tokens.length - 1];
            if (lastToken && lastToken.type === "text") {
              lastToken.raw += "\n" + token.raw;
              lastToken.text += "\n" + token.text;
              this.inlineQueue.pop();
              this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;
            } else {
              tokens.push(token);
            }
            continue;
          }
          if (src) {
            var errMsg = "Infinite loop on byte: " + src.charCodeAt(0);
            if (this.options.silent) {
              console.error(errMsg);
              break;
            } else {
              throw new Error(errMsg);
            }
          }
        }
        this.state.top = true;
        return tokens;
      };
      _proto.inline = function inline2(src, tokens) {
        if (tokens === void 0) {
          tokens = [];
        }
        this.inlineQueue.push({
          src,
          tokens
        });
        return tokens;
      };
      _proto.inlineTokens = function inlineTokens(src, tokens) {
        var _this2 = this;
        if (tokens === void 0) {
          tokens = [];
        }
        var token, lastToken, cutSrc;
        var maskedSrc = src;
        var match2;
        var keepPrevChar, prevChar;
        if (this.tokens.links) {
          var links = Object.keys(this.tokens.links);
          if (links.length > 0) {
            while ((match2 = this.tokenizer.rules.inline.reflinkSearch.exec(maskedSrc)) != null) {
              if (links.includes(match2[0].slice(match2[0].lastIndexOf("[") + 1, -1))) {
                maskedSrc = maskedSrc.slice(0, match2.index) + "[" + repeatString("a", match2[0].length - 2) + "]" + maskedSrc.slice(this.tokenizer.rules.inline.reflinkSearch.lastIndex);
              }
            }
          }
        }
        while ((match2 = this.tokenizer.rules.inline.blockSkip.exec(maskedSrc)) != null) {
          maskedSrc = maskedSrc.slice(0, match2.index) + "[" + repeatString("a", match2[0].length - 2) + "]" + maskedSrc.slice(this.tokenizer.rules.inline.blockSkip.lastIndex);
        }
        while ((match2 = this.tokenizer.rules.inline.escapedEmSt.exec(maskedSrc)) != null) {
          maskedSrc = maskedSrc.slice(0, match2.index + match2[0].length - 2) + "++" + maskedSrc.slice(this.tokenizer.rules.inline.escapedEmSt.lastIndex);
          this.tokenizer.rules.inline.escapedEmSt.lastIndex--;
        }
        while (src) {
          if (!keepPrevChar) {
            prevChar = "";
          }
          keepPrevChar = false;
          if (this.options.extensions && this.options.extensions.inline && this.options.extensions.inline.some(function(extTokenizer) {
            if (token = extTokenizer.call({
              lexer: _this2
            }, src, tokens)) {
              src = src.substring(token.raw.length);
              tokens.push(token);
              return true;
            }
            return false;
          })) {
            continue;
          }
          if (token = this.tokenizer.escape(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          if (token = this.tokenizer.tag(src)) {
            src = src.substring(token.raw.length);
            lastToken = tokens[tokens.length - 1];
            if (lastToken && token.type === "text" && lastToken.type === "text") {
              lastToken.raw += token.raw;
              lastToken.text += token.text;
            } else {
              tokens.push(token);
            }
            continue;
          }
          if (token = this.tokenizer.link(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          if (token = this.tokenizer.reflink(src, this.tokens.links)) {
            src = src.substring(token.raw.length);
            lastToken = tokens[tokens.length - 1];
            if (lastToken && token.type === "text" && lastToken.type === "text") {
              lastToken.raw += token.raw;
              lastToken.text += token.text;
            } else {
              tokens.push(token);
            }
            continue;
          }
          if (token = this.tokenizer.emStrong(src, maskedSrc, prevChar)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          if (token = this.tokenizer.codespan(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          if (token = this.tokenizer.br(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          if (token = this.tokenizer.del(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          if (token = this.tokenizer.autolink(src, mangle)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          if (!this.state.inLink && (token = this.tokenizer.url(src, mangle))) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          cutSrc = src;
          if (this.options.extensions && this.options.extensions.startInline) {
            (function() {
              var startIndex = Infinity;
              var tempSrc = src.slice(1);
              var tempStart = void 0;
              _this2.options.extensions.startInline.forEach(function(getStartIndex) {
                tempStart = getStartIndex.call({
                  lexer: this
                }, tempSrc);
                if (typeof tempStart === "number" && tempStart >= 0) {
                  startIndex = Math.min(startIndex, tempStart);
                }
              });
              if (startIndex < Infinity && startIndex >= 0) {
                cutSrc = src.substring(0, startIndex + 1);
              }
            })();
          }
          if (token = this.tokenizer.inlineText(cutSrc, smartypants)) {
            src = src.substring(token.raw.length);
            if (token.raw.slice(-1) !== "_") {
              prevChar = token.raw.slice(-1);
            }
            keepPrevChar = true;
            lastToken = tokens[tokens.length - 1];
            if (lastToken && lastToken.type === "text") {
              lastToken.raw += token.raw;
              lastToken.text += token.text;
            } else {
              tokens.push(token);
            }
            continue;
          }
          if (src) {
            var errMsg = "Infinite loop on byte: " + src.charCodeAt(0);
            if (this.options.silent) {
              console.error(errMsg);
              break;
            } else {
              throw new Error(errMsg);
            }
          }
        }
        return tokens;
      };
      _createClass(Lexer2, null, [{
        key: "rules",
        get: function get2() {
          return {
            block,
            inline
          };
        }
      }]);
      return Lexer2;
    }();
    var Renderer = /* @__PURE__ */ function() {
      function Renderer2(options2) {
        this.options = options2 || exports2.defaults;
      }
      var _proto = Renderer2.prototype;
      _proto.code = function code(_code, infostring, escaped) {
        var lang = (infostring || "").match(/\S*/)[0];
        if (this.options.highlight) {
          var out = this.options.highlight(_code, lang);
          if (out != null && out !== _code) {
            escaped = true;
            _code = out;
          }
        }
        _code = _code.replace(/\n$/, "") + "\n";
        if (!lang) {
          return "<pre><code>" + (escaped ? _code : escape3(_code, true)) + "</code></pre>\n";
        }
        return '<pre><code class="' + this.options.langPrefix + escape3(lang) + '">' + (escaped ? _code : escape3(_code, true)) + "</code></pre>\n";
      };
      _proto.blockquote = function blockquote(quote2) {
        return "<blockquote>\n" + quote2 + "</blockquote>\n";
      };
      _proto.html = function html(_html) {
        return _html;
      };
      _proto.heading = function heading(text, level, raw, slugger) {
        if (this.options.headerIds) {
          var id = this.options.headerPrefix + slugger.slug(raw);
          return "<h" + level + ' id="' + id + '">' + text + "</h" + level + ">\n";
        }
        return "<h" + level + ">" + text + "</h" + level + ">\n";
      };
      _proto.hr = function hr() {
        return this.options.xhtml ? "<hr/>\n" : "<hr>\n";
      };
      _proto.list = function list(body, ordered, start) {
        var type2 = ordered ? "ol" : "ul", startatt = ordered && start !== 1 ? ' start="' + start + '"' : "";
        return "<" + type2 + startatt + ">\n" + body + "</" + type2 + ">\n";
      };
      _proto.listitem = function listitem(text) {
        return "<li>" + text + "</li>\n";
      };
      _proto.checkbox = function checkbox(checked) {
        return "<input " + (checked ? 'checked="" ' : "") + 'disabled="" type="checkbox"' + (this.options.xhtml ? " /" : "") + "> ";
      };
      _proto.paragraph = function paragraph(text) {
        return "<p>" + text + "</p>\n";
      };
      _proto.table = function table(header, body) {
        if (body) body = "<tbody>" + body + "</tbody>";
        return "<table>\n<thead>\n" + header + "</thead>\n" + body + "</table>\n";
      };
      _proto.tablerow = function tablerow(content) {
        return "<tr>\n" + content + "</tr>\n";
      };
      _proto.tablecell = function tablecell(content, flags2) {
        var type2 = flags2.header ? "th" : "td";
        var tag = flags2.align ? "<" + type2 + ' align="' + flags2.align + '">' : "<" + type2 + ">";
        return tag + content + ("</" + type2 + ">\n");
      };
      _proto.strong = function strong(text) {
        return "<strong>" + text + "</strong>";
      };
      _proto.em = function em(text) {
        return "<em>" + text + "</em>";
      };
      _proto.codespan = function codespan(text) {
        return "<code>" + text + "</code>";
      };
      _proto.br = function br() {
        return this.options.xhtml ? "<br/>" : "<br>";
      };
      _proto.del = function del(text) {
        return "<del>" + text + "</del>";
      };
      _proto.link = function link(href, title2, text) {
        href = cleanUrl(this.options.sanitize, this.options.baseUrl, href);
        if (href === null) {
          return text;
        }
        var out = '<a href="' + href + '"';
        if (title2) {
          out += ' title="' + title2 + '"';
        }
        out += ">" + text + "</a>";
        return out;
      };
      _proto.image = function image(href, title2, text) {
        href = cleanUrl(this.options.sanitize, this.options.baseUrl, href);
        if (href === null) {
          return text;
        }
        var out = '<img src="' + href + '" alt="' + text + '"';
        if (title2) {
          out += ' title="' + title2 + '"';
        }
        out += this.options.xhtml ? "/>" : ">";
        return out;
      };
      _proto.text = function text(_text) {
        return _text;
      };
      return Renderer2;
    }();
    var TextRenderer = /* @__PURE__ */ function() {
      function TextRenderer2() {
      }
      var _proto = TextRenderer2.prototype;
      _proto.strong = function strong(text) {
        return text;
      };
      _proto.em = function em(text) {
        return text;
      };
      _proto.codespan = function codespan(text) {
        return text;
      };
      _proto.del = function del(text) {
        return text;
      };
      _proto.html = function html(text) {
        return text;
      };
      _proto.text = function text(_text) {
        return _text;
      };
      _proto.link = function link(href, title2, text) {
        return "" + text;
      };
      _proto.image = function image(href, title2, text) {
        return "" + text;
      };
      _proto.br = function br() {
        return "";
      };
      return TextRenderer2;
    }();
    var Slugger = /* @__PURE__ */ function() {
      function Slugger2() {
        this.seen = {};
      }
      var _proto = Slugger2.prototype;
      _proto.serialize = function serialize(value) {
        return value.toLowerCase().trim().replace(/<[!\/a-z].*?>/ig, "").replace(/[\u2000-\u206F\u2E00-\u2E7F\\'!"#$%&()*+,./:;<=>?@[\]^`{|}~]/g, "").replace(/\s/g, "-");
      };
      _proto.getNextSafeSlug = function getNextSafeSlug(originalSlug, isDryRun) {
        var slug = originalSlug;
        var occurenceAccumulator = 0;
        if (this.seen.hasOwnProperty(slug)) {
          occurenceAccumulator = this.seen[originalSlug];
          do {
            occurenceAccumulator++;
            slug = originalSlug + "-" + occurenceAccumulator;
          } while (this.seen.hasOwnProperty(slug));
        }
        if (!isDryRun) {
          this.seen[originalSlug] = occurenceAccumulator;
          this.seen[slug] = 0;
        }
        return slug;
      };
      _proto.slug = function slug(value, options2) {
        if (options2 === void 0) {
          options2 = {};
        }
        var slug2 = this.serialize(value);
        return this.getNextSafeSlug(slug2, options2.dryrun);
      };
      return Slugger2;
    }();
    var Parser = /* @__PURE__ */ function() {
      function Parser2(options2) {
        this.options = options2 || exports2.defaults;
        this.options.renderer = this.options.renderer || new Renderer();
        this.renderer = this.options.renderer;
        this.renderer.options = this.options;
        this.textRenderer = new TextRenderer();
        this.slugger = new Slugger();
      }
      Parser2.parse = function parse7(tokens, options2) {
        var parser2 = new Parser2(options2);
        return parser2.parse(tokens);
      };
      Parser2.parseInline = function parseInline2(tokens, options2) {
        var parser2 = new Parser2(options2);
        return parser2.parseInline(tokens);
      };
      var _proto = Parser2.prototype;
      _proto.parse = function parse7(tokens, top) {
        if (top === void 0) {
          top = true;
        }
        var out = "", i, j, k, l2, l3, row, cell, header, body, token, ordered, start, loose, itemBody, item, checked, task, checkbox, ret;
        var l = tokens.length;
        for (i = 0; i < l; i++) {
          token = tokens[i];
          if (this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[token.type]) {
            ret = this.options.extensions.renderers[token.type].call({
              parser: this
            }, token);
            if (ret !== false || !["space", "hr", "heading", "code", "table", "blockquote", "list", "html", "paragraph", "text"].includes(token.type)) {
              out += ret || "";
              continue;
            }
          }
          switch (token.type) {
            case "space": {
              continue;
            }
            case "hr": {
              out += this.renderer.hr();
              continue;
            }
            case "heading": {
              out += this.renderer.heading(this.parseInline(token.tokens), token.depth, unescape2(this.parseInline(token.tokens, this.textRenderer)), this.slugger);
              continue;
            }
            case "code": {
              out += this.renderer.code(token.text, token.lang, token.escaped);
              continue;
            }
            case "table": {
              header = "";
              cell = "";
              l2 = token.header.length;
              for (j = 0; j < l2; j++) {
                cell += this.renderer.tablecell(this.parseInline(token.header[j].tokens), {
                  header: true,
                  align: token.align[j]
                });
              }
              header += this.renderer.tablerow(cell);
              body = "";
              l2 = token.rows.length;
              for (j = 0; j < l2; j++) {
                row = token.rows[j];
                cell = "";
                l3 = row.length;
                for (k = 0; k < l3; k++) {
                  cell += this.renderer.tablecell(this.parseInline(row[k].tokens), {
                    header: false,
                    align: token.align[k]
                  });
                }
                body += this.renderer.tablerow(cell);
              }
              out += this.renderer.table(header, body);
              continue;
            }
            case "blockquote": {
              body = this.parse(token.tokens);
              out += this.renderer.blockquote(body);
              continue;
            }
            case "list": {
              ordered = token.ordered;
              start = token.start;
              loose = token.loose;
              l2 = token.items.length;
              body = "";
              for (j = 0; j < l2; j++) {
                item = token.items[j];
                checked = item.checked;
                task = item.task;
                itemBody = "";
                if (item.task) {
                  checkbox = this.renderer.checkbox(checked);
                  if (loose) {
                    if (item.tokens.length > 0 && item.tokens[0].type === "paragraph") {
                      item.tokens[0].text = checkbox + " " + item.tokens[0].text;
                      if (item.tokens[0].tokens && item.tokens[0].tokens.length > 0 && item.tokens[0].tokens[0].type === "text") {
                        item.tokens[0].tokens[0].text = checkbox + " " + item.tokens[0].tokens[0].text;
                      }
                    } else {
                      item.tokens.unshift({
                        type: "text",
                        text: checkbox
                      });
                    }
                  } else {
                    itemBody += checkbox;
                  }
                }
                itemBody += this.parse(item.tokens, loose);
                body += this.renderer.listitem(itemBody, task, checked);
              }
              out += this.renderer.list(body, ordered, start);
              continue;
            }
            case "html": {
              out += this.renderer.html(token.text);
              continue;
            }
            case "paragraph": {
              out += this.renderer.paragraph(this.parseInline(token.tokens));
              continue;
            }
            case "text": {
              body = token.tokens ? this.parseInline(token.tokens) : token.text;
              while (i + 1 < l && tokens[i + 1].type === "text") {
                token = tokens[++i];
                body += "\n" + (token.tokens ? this.parseInline(token.tokens) : token.text);
              }
              out += top ? this.renderer.paragraph(body) : body;
              continue;
            }
            default: {
              var errMsg = 'Token with "' + token.type + '" type was not found.';
              if (this.options.silent) {
                console.error(errMsg);
                return;
              } else {
                throw new Error(errMsg);
              }
            }
          }
        }
        return out;
      };
      _proto.parseInline = function parseInline2(tokens, renderer) {
        renderer = renderer || this.renderer;
        var out = "", i, token, ret;
        var l = tokens.length;
        for (i = 0; i < l; i++) {
          token = tokens[i];
          if (this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[token.type]) {
            ret = this.options.extensions.renderers[token.type].call({
              parser: this
            }, token);
            if (ret !== false || !["escape", "html", "link", "image", "strong", "em", "codespan", "br", "del", "text"].includes(token.type)) {
              out += ret || "";
              continue;
            }
          }
          switch (token.type) {
            case "escape": {
              out += renderer.text(token.text);
              break;
            }
            case "html": {
              out += renderer.html(token.text);
              break;
            }
            case "link": {
              out += renderer.link(token.href, token.title, this.parseInline(token.tokens, renderer));
              break;
            }
            case "image": {
              out += renderer.image(token.href, token.title, token.text);
              break;
            }
            case "strong": {
              out += renderer.strong(this.parseInline(token.tokens, renderer));
              break;
            }
            case "em": {
              out += renderer.em(this.parseInline(token.tokens, renderer));
              break;
            }
            case "codespan": {
              out += renderer.codespan(token.text);
              break;
            }
            case "br": {
              out += renderer.br();
              break;
            }
            case "del": {
              out += renderer.del(this.parseInline(token.tokens, renderer));
              break;
            }
            case "text": {
              out += renderer.text(token.text);
              break;
            }
            default: {
              var errMsg = 'Token with "' + token.type + '" type was not found.';
              if (this.options.silent) {
                console.error(errMsg);
                return;
              } else {
                throw new Error(errMsg);
              }
            }
          }
        }
        return out;
      };
      return Parser2;
    }();
    var Hooks = /* @__PURE__ */ function() {
      function Hooks2(options2) {
        this.options = options2 || exports2.defaults;
      }
      var _proto = Hooks2.prototype;
      _proto.preprocess = function preprocess(markdown) {
        return markdown;
      };
      _proto.postprocess = function postprocess(html) {
        return html;
      };
      return Hooks2;
    }();
    Hooks.passThroughHooks = /* @__PURE__ */ new Set(["preprocess", "postprocess"]);
    function onError(silent, async, callback) {
      return function(e) {
        e.message += "\nPlease report this to https://github.com/markedjs/marked.";
        if (silent) {
          var msg = "<p>An error occurred:</p><pre>" + escape3(e.message + "", true) + "</pre>";
          if (async) {
            return Promise.resolve(msg);
          }
          if (callback) {
            callback(null, msg);
            return;
          }
          return msg;
        }
        if (async) {
          return Promise.reject(e);
        }
        if (callback) {
          callback(e);
          return;
        }
        throw e;
      };
    }
    function parseMarkdown(lexer3, parser2) {
      return function(src, opt, callback) {
        if (typeof opt === "function") {
          callback = opt;
          opt = null;
        }
        var origOpt = _extends({}, opt);
        opt = _extends({}, marked.defaults, origOpt);
        var throwError2 = onError(opt.silent, opt.async, callback);
        if (typeof src === "undefined" || src === null) {
          return throwError2(new Error("marked(): input parameter is undefined or null"));
        }
        if (typeof src !== "string") {
          return throwError2(new Error("marked(): input parameter is of type " + Object.prototype.toString.call(src) + ", string expected"));
        }
        checkSanitizeDeprecation(opt);
        if (opt.hooks) {
          opt.hooks.options = opt;
        }
        if (callback) {
          var highlight = opt.highlight;
          var tokens;
          try {
            if (opt.hooks) {
              src = opt.hooks.preprocess(src);
            }
            tokens = lexer3(src, opt);
          } catch (e) {
            return throwError2(e);
          }
          var done = function done2(err) {
            var out;
            if (!err) {
              try {
                if (opt.walkTokens) {
                  marked.walkTokens(tokens, opt.walkTokens);
                }
                out = parser2(tokens, opt);
                if (opt.hooks) {
                  out = opt.hooks.postprocess(out);
                }
              } catch (e) {
                err = e;
              }
            }
            opt.highlight = highlight;
            return err ? throwError2(err) : callback(null, out);
          };
          if (!highlight || highlight.length < 3) {
            return done();
          }
          delete opt.highlight;
          if (!tokens.length) return done();
          var pending = 0;
          marked.walkTokens(tokens, function(token) {
            if (token.type === "code") {
              pending++;
              setTimeout(function() {
                highlight(token.text, token.lang, function(err, code) {
                  if (err) {
                    return done(err);
                  }
                  if (code != null && code !== token.text) {
                    token.text = code;
                    token.escaped = true;
                  }
                  pending--;
                  if (pending === 0) {
                    done();
                  }
                });
              }, 0);
            }
          });
          if (pending === 0) {
            done();
          }
          return;
        }
        if (opt.async) {
          return Promise.resolve(opt.hooks ? opt.hooks.preprocess(src) : src).then(function(src2) {
            return lexer3(src2, opt);
          }).then(function(tokens2) {
            return opt.walkTokens ? Promise.all(marked.walkTokens(tokens2, opt.walkTokens)).then(function() {
              return tokens2;
            }) : tokens2;
          }).then(function(tokens2) {
            return parser2(tokens2, opt);
          }).then(function(html2) {
            return opt.hooks ? opt.hooks.postprocess(html2) : html2;
          })["catch"](throwError2);
        }
        try {
          if (opt.hooks) {
            src = opt.hooks.preprocess(src);
          }
          var _tokens = lexer3(src, opt);
          if (opt.walkTokens) {
            marked.walkTokens(_tokens, opt.walkTokens);
          }
          var html = parser2(_tokens, opt);
          if (opt.hooks) {
            html = opt.hooks.postprocess(html);
          }
          return html;
        } catch (e) {
          return throwError2(e);
        }
      };
    }
    function marked(src, opt, callback) {
      return parseMarkdown(Lexer.lex, Parser.parse)(src, opt, callback);
    }
    marked.options = marked.setOptions = function(opt) {
      marked.defaults = _extends({}, marked.defaults, opt);
      changeDefaults(marked.defaults);
      return marked;
    };
    marked.getDefaults = getDefaults;
    marked.defaults = exports2.defaults;
    marked.use = function() {
      var extensions = marked.defaults.extensions || {
        renderers: {},
        childTokens: {}
      };
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      args.forEach(function(pack) {
        var opts = _extends({}, pack);
        opts.async = marked.defaults.async || opts.async || false;
        if (pack.extensions) {
          pack.extensions.forEach(function(ext) {
            if (!ext.name) {
              throw new Error("extension name required");
            }
            if (ext.renderer) {
              var prevRenderer = extensions.renderers[ext.name];
              if (prevRenderer) {
                extensions.renderers[ext.name] = function() {
                  for (var _len2 = arguments.length, args2 = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
                    args2[_key2] = arguments[_key2];
                  }
                  var ret = ext.renderer.apply(this, args2);
                  if (ret === false) {
                    ret = prevRenderer.apply(this, args2);
                  }
                  return ret;
                };
              } else {
                extensions.renderers[ext.name] = ext.renderer;
              }
            }
            if (ext.tokenizer) {
              if (!ext.level || ext.level !== "block" && ext.level !== "inline") {
                throw new Error("extension level must be 'block' or 'inline'");
              }
              if (extensions[ext.level]) {
                extensions[ext.level].unshift(ext.tokenizer);
              } else {
                extensions[ext.level] = [ext.tokenizer];
              }
              if (ext.start) {
                if (ext.level === "block") {
                  if (extensions.startBlock) {
                    extensions.startBlock.push(ext.start);
                  } else {
                    extensions.startBlock = [ext.start];
                  }
                } else if (ext.level === "inline") {
                  if (extensions.startInline) {
                    extensions.startInline.push(ext.start);
                  } else {
                    extensions.startInline = [ext.start];
                  }
                }
              }
            }
            if (ext.childTokens) {
              extensions.childTokens[ext.name] = ext.childTokens;
            }
          });
          opts.extensions = extensions;
        }
        if (pack.renderer) {
          (function() {
            var renderer = marked.defaults.renderer || new Renderer();
            var _loop = function _loop2(prop2) {
              var prevRenderer = renderer[prop2];
              renderer[prop2] = function() {
                for (var _len3 = arguments.length, args2 = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
                  args2[_key3] = arguments[_key3];
                }
                var ret = pack.renderer[prop2].apply(renderer, args2);
                if (ret === false) {
                  ret = prevRenderer.apply(renderer, args2);
                }
                return ret;
              };
            };
            for (var prop in pack.renderer) {
              _loop(prop);
            }
            opts.renderer = renderer;
          })();
        }
        if (pack.tokenizer) {
          (function() {
            var tokenizer = marked.defaults.tokenizer || new Tokenizer();
            var _loop2 = function _loop22(prop2) {
              var prevTokenizer = tokenizer[prop2];
              tokenizer[prop2] = function() {
                for (var _len4 = arguments.length, args2 = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
                  args2[_key4] = arguments[_key4];
                }
                var ret = pack.tokenizer[prop2].apply(tokenizer, args2);
                if (ret === false) {
                  ret = prevTokenizer.apply(tokenizer, args2);
                }
                return ret;
              };
            };
            for (var prop in pack.tokenizer) {
              _loop2(prop);
            }
            opts.tokenizer = tokenizer;
          })();
        }
        if (pack.hooks) {
          (function() {
            var hooks = marked.defaults.hooks || new Hooks();
            var _loop3 = function _loop32(prop2) {
              var prevHook = hooks[prop2];
              if (Hooks.passThroughHooks.has(prop2)) {
                hooks[prop2] = function(arg) {
                  if (marked.defaults.async) {
                    return Promise.resolve(pack.hooks[prop2].call(hooks, arg)).then(function(ret2) {
                      return prevHook.call(hooks, ret2);
                    });
                  }
                  var ret = pack.hooks[prop2].call(hooks, arg);
                  return prevHook.call(hooks, ret);
                };
              } else {
                hooks[prop2] = function() {
                  for (var _len5 = arguments.length, args2 = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
                    args2[_key5] = arguments[_key5];
                  }
                  var ret = pack.hooks[prop2].apply(hooks, args2);
                  if (ret === false) {
                    ret = prevHook.apply(hooks, args2);
                  }
                  return ret;
                };
              }
            };
            for (var prop in pack.hooks) {
              _loop3(prop);
            }
            opts.hooks = hooks;
          })();
        }
        if (pack.walkTokens) {
          var _walkTokens = marked.defaults.walkTokens;
          opts.walkTokens = function(token) {
            var values = [];
            values.push(pack.walkTokens.call(this, token));
            if (_walkTokens) {
              values = values.concat(_walkTokens.call(this, token));
            }
            return values;
          };
        }
        marked.setOptions(opts);
      });
    };
    marked.walkTokens = function(tokens, callback) {
      var values = [];
      var _loop4 = function _loop42() {
        var token = _step.value;
        values = values.concat(callback.call(marked, token));
        switch (token.type) {
          case "table": {
            for (var _iterator2 = _createForOfIteratorHelperLoose(token.header), _step2; !(_step2 = _iterator2()).done; ) {
              var cell = _step2.value;
              values = values.concat(marked.walkTokens(cell.tokens, callback));
            }
            for (var _iterator3 = _createForOfIteratorHelperLoose(token.rows), _step3; !(_step3 = _iterator3()).done; ) {
              var row = _step3.value;
              for (var _iterator4 = _createForOfIteratorHelperLoose(row), _step4; !(_step4 = _iterator4()).done; ) {
                var _cell = _step4.value;
                values = values.concat(marked.walkTokens(_cell.tokens, callback));
              }
            }
            break;
          }
          case "list": {
            values = values.concat(marked.walkTokens(token.items, callback));
            break;
          }
          default: {
            if (marked.defaults.extensions && marked.defaults.extensions.childTokens && marked.defaults.extensions.childTokens[token.type]) {
              marked.defaults.extensions.childTokens[token.type].forEach(function(childTokens) {
                values = values.concat(marked.walkTokens(token[childTokens], callback));
              });
            } else if (token.tokens) {
              values = values.concat(marked.walkTokens(token.tokens, callback));
            }
          }
        }
      };
      for (var _iterator = _createForOfIteratorHelperLoose(tokens), _step; !(_step = _iterator()).done; ) {
        _loop4();
      }
      return values;
    };
    marked.parseInline = parseMarkdown(Lexer.lexInline, Parser.parseInline);
    marked.Parser = Parser;
    marked.parser = Parser.parse;
    marked.Renderer = Renderer;
    marked.TextRenderer = TextRenderer;
    marked.Lexer = Lexer;
    marked.lexer = Lexer.lex;
    marked.Tokenizer = Tokenizer;
    marked.Slugger = Slugger;
    marked.Hooks = Hooks;
    marked.parse = marked;
    var options = marked.options;
    var setOptions = marked.setOptions;
    var use = marked.use;
    var walkTokens = marked.walkTokens;
    var parseInline = marked.parseInline;
    var parse6 = marked;
    var parser = Parser.parse;
    var lexer2 = Lexer.lex;
    exports2.Hooks = Hooks;
    exports2.Lexer = Lexer;
    exports2.Parser = Parser;
    exports2.Renderer = Renderer;
    exports2.Slugger = Slugger;
    exports2.TextRenderer = TextRenderer;
    exports2.Tokenizer = Tokenizer;
    exports2.getDefaults = getDefaults;
    exports2.lexer = lexer2;
    exports2.marked = marked;
    exports2.options = options;
    exports2.parse = parse6;
    exports2.parseInline = parseInline;
    exports2.parser = parser;
    exports2.setOptions = setOptions;
    exports2.use = use;
    exports2.walkTokens = walkTokens;
  }
});

// node_modules/@readme/postman-to-openapi/src/md-utils.js
var require_md_utils = __commonJS({
  "node_modules/@readme/postman-to-openapi/src/md-utils.js"(exports2, module2) {
    var { marked } = require_marked();
    var supHeaders = ["object", "name", "description", "example", "type", "required"];
    function parseMdTable(md) {
      const parsed = marked.lexer(md);
      const table = parsed.find((el) => el.type === "table");
      if (table == null) {
        return {};
      }
      const { header: rawHeader, rows } = table;
      const cells = rows.map((row) => row.map((e) => e.text));
      const header = rawHeader.map((e) => e.text);
      if (!header.includes("object") || !header.includes("name")) {
        return {};
      }
      const headers = header.map((h) => supHeaders.includes(h) ? h : false);
      const tableObj = cells.reduce((accTable, cell) => {
        const cellObj = cell.reduce((accCell, field, index) => {
          if (headers[index]) {
            accCell[headers[index]] = field;
          }
          return accCell;
        }, {});
        accTable[cellObj.name] = cellObj;
        return accTable;
      }, {});
      return tableObj;
    }
    module2.exports = { parseMdTable };
  }
});

// node_modules/mustache/mustache.js
var require_mustache = __commonJS({
  "node_modules/mustache/mustache.js"(exports2, module2) {
    (function(global2, factory) {
      typeof exports2 === "object" && typeof module2 !== "undefined" ? module2.exports = factory() : typeof define === "function" && define.amd ? define(factory) : (global2 = global2 || self, global2.Mustache = factory());
    })(exports2, function() {
      "use strict";
      var objectToString = Object.prototype.toString;
      var isArray = Array.isArray || function isArrayPolyfill(object) {
        return objectToString.call(object) === "[object Array]";
      };
      function isFunction(object) {
        return typeof object === "function";
      }
      function typeStr(obj) {
        return isArray(obj) ? "array" : typeof obj;
      }
      function escapeRegExp(string) {
        return string.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&");
      }
      function hasProperty(obj, propName) {
        return obj != null && typeof obj === "object" && propName in obj;
      }
      function primitiveHasOwnProperty(primitive2, propName) {
        return primitive2 != null && typeof primitive2 !== "object" && primitive2.hasOwnProperty && primitive2.hasOwnProperty(propName);
      }
      var regExpTest = RegExp.prototype.test;
      function testRegExp(re, string) {
        return regExpTest.call(re, string);
      }
      var nonSpaceRe = /\S/;
      function isWhitespace2(string) {
        return !testRegExp(nonSpaceRe, string);
      }
      var entityMap = {
        "&": "&amp;",
        "<": "&lt;",
        ">": "&gt;",
        '"': "&quot;",
        "'": "&#39;",
        "/": "&#x2F;",
        "`": "&#x60;",
        "=": "&#x3D;"
      };
      function escapeHtml(string) {
        return String(string).replace(/[&<>"'`=\/]/g, function fromEntityMap(s) {
          return entityMap[s];
        });
      }
      var whiteRe = /\s*/;
      var spaceRe = /\s+/;
      var equalsRe = /\s*=/;
      var curlyRe = /\s*\}/;
      var tagRe = /#|\^|\/|>|\{|&|=|!/;
      function parseTemplate(template, tags) {
        if (!template)
          return [];
        var lineHasNonSpace = false;
        var sections = [];
        var tokens = [];
        var spaces = [];
        var hasTag = false;
        var nonSpace = false;
        var indentation = "";
        var tagIndex = 0;
        function stripSpace() {
          if (hasTag && !nonSpace) {
            while (spaces.length)
              delete tokens[spaces.pop()];
          } else {
            spaces = [];
          }
          hasTag = false;
          nonSpace = false;
        }
        var openingTagRe, closingTagRe, closingCurlyRe;
        function compileTags(tagsToCompile) {
          if (typeof tagsToCompile === "string")
            tagsToCompile = tagsToCompile.split(spaceRe, 2);
          if (!isArray(tagsToCompile) || tagsToCompile.length !== 2)
            throw new Error("Invalid tags: " + tagsToCompile);
          openingTagRe = new RegExp(escapeRegExp(tagsToCompile[0]) + "\\s*");
          closingTagRe = new RegExp("\\s*" + escapeRegExp(tagsToCompile[1]));
          closingCurlyRe = new RegExp("\\s*" + escapeRegExp("}" + tagsToCompile[1]));
        }
        compileTags(tags || mustache.tags);
        var scanner = new Scanner(template);
        var start, type2, value, chr, token, openSection;
        while (!scanner.eos()) {
          start = scanner.pos;
          value = scanner.scanUntil(openingTagRe);
          if (value) {
            for (var i = 0, valueLength = value.length; i < valueLength; ++i) {
              chr = value.charAt(i);
              if (isWhitespace2(chr)) {
                spaces.push(tokens.length);
                indentation += chr;
              } else {
                nonSpace = true;
                lineHasNonSpace = true;
                indentation += " ";
              }
              tokens.push(["text", chr, start, start + 1]);
              start += 1;
              if (chr === "\n") {
                stripSpace();
                indentation = "";
                tagIndex = 0;
                lineHasNonSpace = false;
              }
            }
          }
          if (!scanner.scan(openingTagRe))
            break;
          hasTag = true;
          type2 = scanner.scan(tagRe) || "name";
          scanner.scan(whiteRe);
          if (type2 === "=") {
            value = scanner.scanUntil(equalsRe);
            scanner.scan(equalsRe);
            scanner.scanUntil(closingTagRe);
          } else if (type2 === "{") {
            value = scanner.scanUntil(closingCurlyRe);
            scanner.scan(curlyRe);
            scanner.scanUntil(closingTagRe);
            type2 = "&";
          } else {
            value = scanner.scanUntil(closingTagRe);
          }
          if (!scanner.scan(closingTagRe))
            throw new Error("Unclosed tag at " + scanner.pos);
          if (type2 == ">") {
            token = [type2, value, start, scanner.pos, indentation, tagIndex, lineHasNonSpace];
          } else {
            token = [type2, value, start, scanner.pos];
          }
          tagIndex++;
          tokens.push(token);
          if (type2 === "#" || type2 === "^") {
            sections.push(token);
          } else if (type2 === "/") {
            openSection = sections.pop();
            if (!openSection)
              throw new Error('Unopened section "' + value + '" at ' + start);
            if (openSection[1] !== value)
              throw new Error('Unclosed section "' + openSection[1] + '" at ' + start);
          } else if (type2 === "name" || type2 === "{" || type2 === "&") {
            nonSpace = true;
          } else if (type2 === "=") {
            compileTags(value);
          }
        }
        stripSpace();
        openSection = sections.pop();
        if (openSection)
          throw new Error('Unclosed section "' + openSection[1] + '" at ' + scanner.pos);
        return nestTokens(squashTokens(tokens));
      }
      function squashTokens(tokens) {
        var squashedTokens = [];
        var token, lastToken;
        for (var i = 0, numTokens = tokens.length; i < numTokens; ++i) {
          token = tokens[i];
          if (token) {
            if (token[0] === "text" && lastToken && lastToken[0] === "text") {
              lastToken[1] += token[1];
              lastToken[3] = token[3];
            } else {
              squashedTokens.push(token);
              lastToken = token;
            }
          }
        }
        return squashedTokens;
      }
      function nestTokens(tokens) {
        var nestedTokens = [];
        var collector = nestedTokens;
        var sections = [];
        var token, section;
        for (var i = 0, numTokens = tokens.length; i < numTokens; ++i) {
          token = tokens[i];
          switch (token[0]) {
            case "#":
            case "^":
              collector.push(token);
              sections.push(token);
              collector = token[4] = [];
              break;
            case "/":
              section = sections.pop();
              section[5] = token[2];
              collector = sections.length > 0 ? sections[sections.length - 1][4] : nestedTokens;
              break;
            default:
              collector.push(token);
          }
        }
        return nestedTokens;
      }
      function Scanner(string) {
        this.string = string;
        this.tail = string;
        this.pos = 0;
      }
      Scanner.prototype.eos = function eos() {
        return this.tail === "";
      };
      Scanner.prototype.scan = function scan(re) {
        var match2 = this.tail.match(re);
        if (!match2 || match2.index !== 0)
          return "";
        var string = match2[0];
        this.tail = this.tail.substring(string.length);
        this.pos += string.length;
        return string;
      };
      Scanner.prototype.scanUntil = function scanUntil(re) {
        var index = this.tail.search(re), match2;
        switch (index) {
          case -1:
            match2 = this.tail;
            this.tail = "";
            break;
          case 0:
            match2 = "";
            break;
          default:
            match2 = this.tail.substring(0, index);
            this.tail = this.tail.substring(index);
        }
        this.pos += match2.length;
        return match2;
      };
      function Context(view, parentContext) {
        this.view = view;
        this.cache = { ".": this.view };
        this.parent = parentContext;
      }
      Context.prototype.push = function push(view) {
        return new Context(view, this);
      };
      Context.prototype.lookup = function lookup(name) {
        var cache = this.cache;
        var value;
        if (cache.hasOwnProperty(name)) {
          value = cache[name];
        } else {
          var context = this, intermediateValue, names, index, lookupHit = false;
          while (context) {
            if (name.indexOf(".") > 0) {
              intermediateValue = context.view;
              names = name.split(".");
              index = 0;
              while (intermediateValue != null && index < names.length) {
                if (index === names.length - 1)
                  lookupHit = hasProperty(intermediateValue, names[index]) || primitiveHasOwnProperty(intermediateValue, names[index]);
                intermediateValue = intermediateValue[names[index++]];
              }
            } else {
              intermediateValue = context.view[name];
              lookupHit = hasProperty(context.view, name);
            }
            if (lookupHit) {
              value = intermediateValue;
              break;
            }
            context = context.parent;
          }
          cache[name] = value;
        }
        if (isFunction(value))
          value = value.call(this.view);
        return value;
      };
      function Writer() {
        this.templateCache = {
          _cache: {},
          set: function set3(key, value) {
            this._cache[key] = value;
          },
          get: function get2(key) {
            return this._cache[key];
          },
          clear: function clear() {
            this._cache = {};
          }
        };
      }
      Writer.prototype.clearCache = function clearCache() {
        if (typeof this.templateCache !== "undefined") {
          this.templateCache.clear();
        }
      };
      Writer.prototype.parse = function parse6(template, tags) {
        var cache = this.templateCache;
        var cacheKey = template + ":" + (tags || mustache.tags).join(":");
        var isCacheEnabled = typeof cache !== "undefined";
        var tokens = isCacheEnabled ? cache.get(cacheKey) : void 0;
        if (tokens == void 0) {
          tokens = parseTemplate(template, tags);
          isCacheEnabled && cache.set(cacheKey, tokens);
        }
        return tokens;
      };
      Writer.prototype.render = function render(template, view, partials, config) {
        var tags = this.getConfigTags(config);
        var tokens = this.parse(template, tags);
        var context = view instanceof Context ? view : new Context(view, void 0);
        return this.renderTokens(tokens, context, partials, template, config);
      };
      Writer.prototype.renderTokens = function renderTokens(tokens, context, partials, originalTemplate, config) {
        var buffer = "";
        var token, symbol, value;
        for (var i = 0, numTokens = tokens.length; i < numTokens; ++i) {
          value = void 0;
          token = tokens[i];
          symbol = token[0];
          if (symbol === "#") value = this.renderSection(token, context, partials, originalTemplate, config);
          else if (symbol === "^") value = this.renderInverted(token, context, partials, originalTemplate, config);
          else if (symbol === ">") value = this.renderPartial(token, context, partials, config);
          else if (symbol === "&") value = this.unescapedValue(token, context);
          else if (symbol === "name") value = this.escapedValue(token, context, config);
          else if (symbol === "text") value = this.rawValue(token);
          if (value !== void 0)
            buffer += value;
        }
        return buffer;
      };
      Writer.prototype.renderSection = function renderSection(token, context, partials, originalTemplate, config) {
        var self2 = this;
        var buffer = "";
        var value = context.lookup(token[1]);
        function subRender(template) {
          return self2.render(template, context, partials, config);
        }
        if (!value) return;
        if (isArray(value)) {
          for (var j = 0, valueLength = value.length; j < valueLength; ++j) {
            buffer += this.renderTokens(token[4], context.push(value[j]), partials, originalTemplate, config);
          }
        } else if (typeof value === "object" || typeof value === "string" || typeof value === "number") {
          buffer += this.renderTokens(token[4], context.push(value), partials, originalTemplate, config);
        } else if (isFunction(value)) {
          if (typeof originalTemplate !== "string")
            throw new Error("Cannot use higher-order sections without the original template");
          value = value.call(context.view, originalTemplate.slice(token[3], token[5]), subRender);
          if (value != null)
            buffer += value;
        } else {
          buffer += this.renderTokens(token[4], context, partials, originalTemplate, config);
        }
        return buffer;
      };
      Writer.prototype.renderInverted = function renderInverted(token, context, partials, originalTemplate, config) {
        var value = context.lookup(token[1]);
        if (!value || isArray(value) && value.length === 0)
          return this.renderTokens(token[4], context, partials, originalTemplate, config);
      };
      Writer.prototype.indentPartial = function indentPartial(partial, indentation, lineHasNonSpace) {
        var filteredIndentation = indentation.replace(/[^ \t]/g, "");
        var partialByNl = partial.split("\n");
        for (var i = 0; i < partialByNl.length; i++) {
          if (partialByNl[i].length && (i > 0 || !lineHasNonSpace)) {
            partialByNl[i] = filteredIndentation + partialByNl[i];
          }
        }
        return partialByNl.join("\n");
      };
      Writer.prototype.renderPartial = function renderPartial(token, context, partials, config) {
        if (!partials) return;
        var tags = this.getConfigTags(config);
        var value = isFunction(partials) ? partials(token[1]) : partials[token[1]];
        if (value != null) {
          var lineHasNonSpace = token[6];
          var tagIndex = token[5];
          var indentation = token[4];
          var indentedValue = value;
          if (tagIndex == 0 && indentation) {
            indentedValue = this.indentPartial(value, indentation, lineHasNonSpace);
          }
          var tokens = this.parse(indentedValue, tags);
          return this.renderTokens(tokens, context, partials, indentedValue, config);
        }
      };
      Writer.prototype.unescapedValue = function unescapedValue(token, context) {
        var value = context.lookup(token[1]);
        if (value != null)
          return value;
      };
      Writer.prototype.escapedValue = function escapedValue(token, context, config) {
        var escape3 = this.getConfigEscape(config) || mustache.escape;
        var value = context.lookup(token[1]);
        if (value != null)
          return typeof value === "number" && escape3 === mustache.escape ? String(value) : escape3(value);
      };
      Writer.prototype.rawValue = function rawValue(token) {
        return token[1];
      };
      Writer.prototype.getConfigTags = function getConfigTags(config) {
        if (isArray(config)) {
          return config;
        } else if (config && typeof config === "object") {
          return config.tags;
        } else {
          return void 0;
        }
      };
      Writer.prototype.getConfigEscape = function getConfigEscape(config) {
        if (config && typeof config === "object" && !isArray(config)) {
          return config.escape;
        } else {
          return void 0;
        }
      };
      var mustache = {
        name: "mustache.js",
        version: "4.2.0",
        tags: ["{{", "}}"],
        clearCache: void 0,
        escape: void 0,
        parse: void 0,
        render: void 0,
        Scanner: void 0,
        Context: void 0,
        Writer: void 0,
        /**
         * Allows a user to override the default caching strategy, by providing an
         * object with set, get and clear methods. This can also be used to disable
         * the cache by setting it to the literal `undefined`.
         */
        set templateCache(cache) {
          defaultWriter.templateCache = cache;
        },
        /**
         * Gets the default or overridden caching object from the default writer.
         */
        get templateCache() {
          return defaultWriter.templateCache;
        }
      };
      var defaultWriter = new Writer();
      mustache.clearCache = function clearCache() {
        return defaultWriter.clearCache();
      };
      mustache.parse = function parse6(template, tags) {
        return defaultWriter.parse(template, tags);
      };
      mustache.render = function render(template, view, partials, config) {
        if (typeof template !== "string") {
          throw new TypeError('Invalid template! Template should be a "string" but "' + typeStr(template) + '" was given as the first argument for mustache#render(template, view, partials)');
        }
        return defaultWriter.render(template, view, partials, config);
      };
      mustache.escape = escapeHtml;
      mustache.Scanner = Scanner;
      mustache.Context = Context;
      mustache.Writer = Writer;
      return mustache;
    });
  }
});

// node_modules/@readme/postman-to-openapi/src/var-replacer.js
var require_var_replacer = __commonJS({
  "node_modules/@readme/postman-to-openapi/src/var-replacer.js"(exports2, module2) {
    var Mustache = require_mustache();
    Mustache.Writer.prototype.escapedValue = function escapedValue(token, context) {
      const value = context.lookup(token[1]) || `{{${token[1]}}}`;
      return String(value);
    };
    function replacePostmanVariables(collectionString, additionalVars = {}) {
      const postmanJson = JSON.parse(collectionString);
      const { variable = [] } = postmanJson;
      const formatVars = variable.reduce((obj, { key, value }) => {
        obj[key] = value;
        return obj;
      }, {});
      const context = { ...formatVars, ...additionalVars };
      return Mustache.render(collectionString, context);
    }
    module2.exports = replacePostmanVariables;
  }
});

// node_modules/@readme/postman-to-openapi/src/index.js
var require_src4 = __commonJS({
  "node_modules/@readme/postman-to-openapi/src/index.js"(exports2, module2) {
    var {
      promises: { writeFile, readFile }
    } = require("fs");
    var { getStatusCodeMessage } = require_src3();
    var { dump: dump2 } = require_js_yaml();
    var jsonc = (init_main(), __toCommonJS(main_exports));
    var camelCase = require_lodash();
    var { parseMdTable } = require_md_utils();
    var replacePostmanVariables = require_var_replacer();
    async function postmanToOpenAPI2(input, output, {
      info = {},
      defaultTag = "default",
      pathDepth = 0,
      auth: optsAuth,
      servers,
      externalDocs = {},
      folders = {},
      responseHeaders = true,
      replaceVars = false,
      additionalVars = {},
      outputFormat = "yaml",
      disabledParams = {
        includeQuery: false,
        includeHeader: false
      },
      operationId = "off"
    } = {}) {
      let collectionFile = await resolveInput(input);
      if (replaceVars) {
        collectionFile = replacePostmanVariables(collectionFile, additionalVars);
      }
      const _postmanJson = JSON.parse(collectionFile);
      const postmanJson = _postmanJson.collection || _postmanJson;
      const { item: items, variable = [] } = postmanJson;
      const paths = {};
      const domains = /* @__PURE__ */ new Set();
      const tags = {};
      const securitySchemes = {};
      for (let [i, element] of items.entries()) {
        while (element != null && element.item != null) {
          const { item, description: tagDesc } = element;
          const tag = calculateFolderTag(element, folders);
          const tagged = item.map((e) => ({ ...e, tag }));
          tags[tag] = tagDesc;
          items.splice(i, 1, ...tagged);
          element = tagged.length > 0 ? tagged.shift() : items[i];
        }
        if (element != null) {
          const {
            request: { url, method, body, description: rawDesc, header = [], auth },
            name,
            tag = defaultTag,
            event: events,
            response
          } = element;
          const { path, query, protocol, host, port, valid, pathVars } = scrapeURL(url);
          if (valid) {
            const summary = name.replace(/ \[([^\[\]]*)\]/gi, "");
            domains.add(calculateDomains(protocol, host, port));
            const joinedPath = calculatePath(path, pathDepth);
            if (!paths[joinedPath]) paths[joinedPath] = {};
            const { description, paramsMeta } = descriptionParse(rawDesc);
            paths[joinedPath][method.toLowerCase()] = {
              tags: [tag],
              summary,
              ...calculateOperationId(operationId, name, summary),
              ...description ? { description } : {},
              ...parseBody(body, method),
              ...parseOperationAuth(auth, securitySchemes, optsAuth),
              ...parseParameters(query, header, joinedPath, paramsMeta, pathVars, disabledParams),
              ...parseResponse(response, events, responseHeaders)
            };
          }
        }
      }
      const openApi = {
        openapi: "3.0.0",
        info: compileInfo(postmanJson, info),
        ...parseExternalDocs(variable, externalDocs),
        ...parseServers(domains, servers),
        ...parseAuth(postmanJson, optsAuth, securitySchemes),
        ...parseTags(tags),
        paths
      };
      const openApiDoc = outputFormat === "json" ? JSON.stringify(openApi, null, 4) : dump2(openApi, { skipInvalid: true });
      if (output != null) {
        await writeFile(output, openApiDoc, "utf8");
      }
      return openApiDoc;
    }
    function calculateFolderTag({ tag, name }, { separator = " > ", concat = true }) {
      return tag && concat ? `${tag}${separator}${name}` : name;
    }
    function compileInfo(postmanJson, optsInfo) {
      const {
        info: { name, description: desc },
        variable = []
      } = postmanJson;
      const ver = getVarValue(variable, "version", "1.0.0");
      const { title: title2 = name, description = desc, version = ver, termsOfService, license, contact, xLogo } = optsInfo;
      return {
        title: title2,
        description,
        version,
        ...parseXLogo(variable, xLogo),
        ...termsOfService ? { termsOfService } : {},
        ...parseContact(variable, contact),
        ...parseLicense(variable, license)
      };
    }
    function parseXLogo(variables, xLogo = {}) {
      const urlVar = getVarValue(variables, "x-logo.urlVar");
      const backgroundColorVar = getVarValue(variables, "x-logo.backgroundColorVar");
      const altTextVar = getVarValue(variables, "x-logo.altTextVar");
      const hrefVar = getVarValue(variables, "x-logo.hrefVar");
      const { url = urlVar, backgroundColor = backgroundColorVar, altText = altTextVar, href = hrefVar } = xLogo;
      return url != null ? { "x-logo": { url, backgroundColor, altText, href } } : {};
    }
    function parseLicense(variables, optsLicense = {}) {
      const nameVar = getVarValue(variables, "license.name");
      const urlVar = getVarValue(variables, "license.url");
      const { name = nameVar, url = urlVar } = optsLicense;
      return name != null ? { license: { name, ...url ? { url } : {} } } : {};
    }
    function parseContact(variables, optsContact = {}) {
      const nameVar = getVarValue(variables, "contact.name");
      const urlVar = getVarValue(variables, "contact.url");
      const emailVar = getVarValue(variables, "contact.email");
      const { name = nameVar, url = urlVar, email = emailVar } = optsContact;
      return [name, url, email].some((e) => e != null) ? {
        contact: {
          ...name ? { name } : {},
          ...url ? { url } : {},
          ...email ? { email } : {}
        }
      } : {};
    }
    function parseExternalDocs(variables, optsExternalDocs) {
      const descriptionVar = getVarValue(variables, "externalDocs.description");
      const urlVar = getVarValue(variables, "externalDocs.url");
      const { description = descriptionVar, url = urlVar } = optsExternalDocs;
      return url != null ? { externalDocs: { url, ...description ? { description } : {} } } : {};
    }
    function parseBody(body = {}, method) {
      if (["GET", "DELETE"].includes(method)) {
        return {};
      }
      const { mode, raw, options = { raw } } = body;
      let content = {};
      switch (mode) {
        case "raw": {
          const {
            raw: { language }
          } = options;
          let example = "";
          if (language === "json") {
            if (raw) {
              const errors = [];
              example = jsonc.parse(raw, errors);
              if (errors.length > 0) {
                example = raw;
              }
            }
            content = {
              "application/json": {
                schema: {
                  type: "object",
                  example
                }
              }
            };
          } else if (language === "text") {
            content = {
              "text/plain": {
                schema: {
                  type: "string",
                  example: raw
                }
              }
            };
          } else {
            content = {
              "*/*": {
                schema: {
                  type: "string",
                  // To protect from object types we always stringify this
                  example: JSON.stringify(raw)
                }
              }
            };
          }
          break;
        }
        case "file":
          content = {
            "text/plain": {}
          };
          break;
        case "formdata": {
          content = {
            "multipart/form-data": parseFormData(body.formdata)
          };
          break;
        }
        case "urlencoded":
          content = {
            "application/x-www-form-urlencoded": parseFormData(body.urlencoded)
          };
          break;
      }
      return { requestBody: { content } };
    }
    function parseFormData(data) {
      const objectSchema = {
        schema: {
          type: "object"
        }
      };
      return data.reduce((obj, { key, type: type2, description, value }) => {
        const { schema: schema2 } = obj;
        if (isRequired(description)) {
          (schema2.required = schema2.required || []).push(key);
        }
        (schema2.properties = schema2.properties || {})[key] = {
          type: inferType(value),
          ...description ? { description: description.replace(/ ?\[required\] ?/gi, "") } : {},
          ...value ? { example: value } : {},
          ...type2 === "file" ? { format: "binary" } : {}
        };
        return obj;
      }, objectSchema);
    }
    var defaultParamInserter = (parameterMap, param) => {
      if (!parameterMap.has(param.name)) {
        parameterMap.set(param.name, param);
      }
      return parameterMap;
    };
    function parseParameters(query, header, paths, paramsMeta = {}, pathVars, { includeQuery = false, includeHeader = false }, paramInserter = defaultParamInserter) {
      const parameters = [...header.reduce(mapParameters("header", includeHeader, paramInserter), /* @__PURE__ */ new Map()).values()];
      parameters.push(...query.reduce(mapParameters("query", includeQuery, paramInserter), /* @__PURE__ */ new Map()).values());
      parameters.push(...extractPathParameters(paths, paramsMeta, pathVars));
      return parameters.length ? { parameters } : {};
    }
    function mapParameters(type2, includeDisabled, paramInserter) {
      return (parameterMap, { key, description, value, disabled }) => {
        if (!includeDisabled && disabled === true) return parameterMap;
        const required = /\[required\]/gi.test(description);
        paramInserter(parameterMap, {
          name: key,
          in: type2,
          schema: { type: inferType(value) },
          ...required ? { required } : {},
          ...description ? { description: description.replace(/ ?\[required\] ?/gi, "") } : {},
          ...value ? { example: value } : {}
        });
        return parameterMap;
      };
    }
    function extractPathParameters(path, paramsMeta, pathVars) {
      const matched = path.match(/{\s*[\w-]+\s*}/g) || [];
      return matched.map((match2) => {
        const name = match2.slice(1, -1);
        const { type: varType = "string", description: desc, value } = pathVars[name] || {};
        const { type: type2 = varType, description = desc, example = value } = paramsMeta[name] || {};
        return {
          name,
          in: "path",
          schema: { type: type2 },
          required: true,
          ...description ? { description } : {},
          ...example ? { example } : {}
        };
      });
    }
    function getVarValue(variables, name, def = void 0) {
      const variable = variables.find(({ key }) => key === name);
      return variable ? variable.value : def;
    }
    function inferType(value) {
      if (/^\d+$/.test(value)) return "integer";
      if (/^[+-]?([0-9]*[.])?[0-9]+$/.test(value)) return "number";
      if (/^(true|false)$/.test(value)) return "boolean";
      return "string";
    }
    function parseAuth({ auth }, optAuth, securitySchemes) {
      if (optAuth != null) {
        return parseOptsAuth(optAuth);
      }
      return parsePostmanAuth(auth, securitySchemes);
    }
    function parsePostmanAuth(postmanAuth = {}, securitySchemes) {
      const { type: type2 } = postmanAuth;
      if (type2 != null) {
        securitySchemes[`${type2}Auth`] = {
          type: "http",
          scheme: type2
        };
        return {
          components: { securitySchemes },
          security: [
            {
              [`${type2}Auth`]: []
            }
          ]
        };
      }
      return Object.keys(securitySchemes).length === 0 ? {} : { components: { securitySchemes } };
    }
    function parseOperationAuth(auth, securitySchemes, optsAuth) {
      if (auth == null || optsAuth != null) {
        return {};
      }
      const { type: type2 } = auth;
      securitySchemes[`${type2}Auth`] = {
        type: "http",
        scheme: type2
      };
      return {
        security: [{ [`${type2}Auth`]: [] }]
      };
    }
    function parseOptsAuth(optAuth) {
      const securitySchemes = {};
      const security = [];
      for (const [secName, secDefinition] of Object.entries(optAuth)) {
        const { type: type2, scheme, ...rest } = secDefinition;
        if (type2 === "http" && ["bearer", "basic"].includes(scheme)) {
          securitySchemes[secName] = {
            type: "http",
            scheme,
            ...rest
          };
          security.push({ [secName]: [] });
        }
      }
      return Object.keys(securitySchemes).length === 0 ? {} : {
        components: { securitySchemes },
        security
      };
    }
    function calculatePath(paths, pathDepth) {
      paths = paths.slice(pathDepth);
      return `/${paths.map((path) => {
        path = path.replace(/([{}])\1+/g, "$1");
        path = path.replace(/^:(.*)/g, "{$1}");
        return path;
      }).join("/")}`;
    }
    function calculateDomains(protocol, hosts, port) {
      return `${protocol}://${hosts.join(".")}${port ? `:${port}` : ""}`;
    }
    function scrapeURL(url) {
      if (url === void 0 || url === "" || url.raw === "") {
        return { valid: false };
      }
      const rawUrl = typeof url === "string" || url instanceof String ? url : url.raw;
      const fixedUrl = rawUrl.startsWith("{{") ? `http://${rawUrl}` : rawUrl;
      const objUrl = new URL(fixedUrl);
      return {
        raw: rawUrl,
        path: decodeURIComponent(objUrl.pathname).slice(1).split("/"),
        query: compoundQueryParams(objUrl.searchParams, url.query),
        protocol: objUrl.protocol.slice(0, -1),
        host: decodeURIComponent(objUrl.hostname).split("."),
        port: objUrl.port,
        valid: true,
        pathVars: url.variable == null ? {} : url.variable.reduce((obj, { key, value, description }) => {
          obj[key] = { value, description, type: inferType(value) };
          return obj;
        }, {})
      };
    }
    function compoundQueryParams(searchParams, queryCollection = []) {
      return queryCollection;
    }
    function parseServers(domains, serversOpts) {
      let servers;
      if (serversOpts != null) {
        servers = serversOpts.map(({ url, description }) => ({ url, description }));
      } else {
        servers = Array.from(domains).map((domain) => ({ url: domain }));
      }
      return servers.length > 0 ? { servers } : {};
    }
    function parseTags(tagsObj) {
      const tags = Object.entries(tagsObj).map(([name, description]) => ({ name, description }));
      return tags.length > 0 ? { tags } : {};
    }
    function descriptionParse(description) {
      if (description == null) return { description };
      const splitDesc = description.split(/# postman-to-openapi/gi);
      if (splitDesc.length === 1) return { description };
      return {
        description: splitDesc[0].trim(),
        paramsMeta: parseMdTable(splitDesc[1])
      };
    }
    function parseResponse(responses, events, responseHeaders) {
      if (responses != null && Array.isArray(responses) && responses.length > 0) {
        return parseResponseFromExamples(responses, responseHeaders);
      }
      return { responses: parseResponseFromEvents(events) };
    }
    function parseResponseFromEvents(events = []) {
      let status = 200;
      const test = events.filter((event) => event.listen === "test");
      if (test.length > 0) {
        const script = test[0].script.exec.join();
        const result = script.match(/\.response\.code\)\.to\.eql\((\d{3})\)|\.to\.have\.status\((\d{3})\)/);
        status = result && result[1] != null ? result[1] : result && result[2] != null ? result[2] : status;
      }
      return {
        [status]: {
          description: "Successful response",
          content: {
            "application/json": {}
          }
        }
      };
    }
    function parseResponseFromExamples(responses, responseHeaders) {
      const statusCodeMap = responses.reduce(
        (statusMap, { name, code, status: description, header, body, _postman_previewlanguage: language }) => {
          if (code === void 0) {
            code = "default";
          }
          if (!description) {
            try {
              description = getStatusCodeMessage({ code });
            } catch (err) {
              description = code;
            }
          }
          if (code in statusMap) {
            if (!(language in statusMap[code].bodies)) {
              statusMap[code].bodies[language] = [];
            }
            statusMap[code].bodies[language].push({ name, body });
          } else {
            statusMap[code] = {
              description,
              header,
              bodies: { [language]: [{ name, body }] }
            };
          }
          return statusMap;
        },
        {}
      );
      const parsedResponses = Object.entries(statusCodeMap).reduce((parsed, [status, { description, header, bodies }]) => {
        parsed[status] = {
          description,
          ...parseResponseHeaders(header, responseHeaders),
          ...parseContent(bodies)
        };
        return parsed;
      }, {});
      return { responses: parsedResponses };
    }
    function parseContent(bodiesByLanguage) {
      const content = Object.entries(bodiesByLanguage).reduce((contentObj, [language, bodies]) => {
        if (language === "json") {
          contentObj["application/json"] = {
            schema: { type: "object" },
            ...parseExamples(bodies, "json")
          };
        } else {
          contentObj["text/plain"] = {
            schema: { type: "string" },
            ...parseExamples(bodies, "text")
          };
        }
        return contentObj;
      }, {});
      return { content };
    }
    function parseExamples(bodies, language) {
      if (Array.isArray(bodies) && bodies.length > 1) {
        return {
          examples: bodies.reduce((ex, { name: summary, body: body2 }, i) => {
            ex[`example-${i}`] = {
              summary,
              value: safeSampleParse(body2, summary, language)
            };
            return ex;
          }, {})
        };
      }
      const { body, name } = bodies[0];
      return {
        example: safeSampleParse(body, name, language)
      };
    }
    function safeSampleParse(body, name, language) {
      if (language === "json") {
        const errors = [];
        const parsedBody = jsonc.parse(body == null || body.trim().length === 0 ? "{}" : body, errors);
        if (errors.length > 0) {
          throw new Error(`Error parsing response example "${name}"`);
        }
        return parsedBody;
      }
      return body;
    }
    function parseResponseHeaders(headerArray, responseHeaders) {
      if (!responseHeaders) {
        return {};
      }
      headerArray = headerArray || [];
      const headers = headerArray.reduce((acc, { key, value }) => {
        acc[key] = {
          schema: {
            type: inferType(value),
            example: value
          }
        };
        return acc;
      }, {});
      return Object.keys(headers).length > 0 ? { headers } : {};
    }
    async function resolveInput(input) {
      if (input.trim().startsWith("{")) {
        return input;
      }
      return readFile(input, "utf8");
    }
    function isRequired(text) {
      return /\[required\]/gi.test(text);
    }
    function calculateOperationId(mode, name, summary) {
      let operationId;
      switch (mode) {
        case "off":
          break;
        case "auto":
          operationId = camelCase(summary);
          break;
        case "brackets": {
          const matches = name.match(/\[([^\[\]]*)\]/);
          operationId = matches ? matches[1] : void 0;
          break;
        }
        default:
          break;
      }
      return operationId ? { operationId } : {};
    }
    module2.exports = postmanToOpenAPI2;
  }
});

// node_modules/http2-client/lib/utils.js
var require_utils4 = __commonJS({
  "node_modules/http2-client/lib/utils.js"(exports2, module2) {
    var DebounceTimers = class {
      constructor(cb, defaultDelay) {
        this.cb = cb;
        this.delay = defaultDelay;
        this.timers = {};
        this.pausers = {};
      }
      setDelay(delay) {
        if (delay >= 0)
          this.delay = delay;
      }
      pause(key) {
        this.pausers[key] = this.pausers[key] || 0;
        this.pausers[key]++;
      }
      unpause(key) {
        var count = this.pausers[key] || 0;
        if (count > 0)
          count--;
        this.pausers[key] = count;
      }
      unpauseAndTime(key) {
        this.unpause(key);
        this.time(key);
      }
      time(key) {
        var self2 = this;
        var timers = this.timers;
        var timer = this.timers[key];
        if (this.pausers[key] > 0)
          return;
        if (timer)
          clearTimeout(timer);
        timers[key] = setTimeout(function onTimer() {
          self2.cb(key);
          delete timers[key];
        }, self2.delay);
      }
    };
    var ERR_INVALID_ARG_TYPE = class extends TypeError {
      constructor(name, expected, actual) {
        const type2 = name.includes(".") ? "property" : "argument";
        let msg = `The "${name}" ${type2} ${determiner} ${expected}`;
      }
    };
    function assertIsObject(value, name, types3 = "Object") {
      if (value !== void 0 && (value === null || typeof value !== "object" || Array.isArray(value))) {
        const err = new ERR_INVALID_ARG_TYPE(name, types3, value);
        Error.captureStackTrace(err, assertIsObject);
        throw err;
      }
    }
    module2.exports = {
      ERR_INVALID_ARG_TYPE,
      assertIsObject,
      DebounceTimers
    };
  }
});

// node_modules/http2-client/lib/request-options.js
var require_request_options = __commonJS({
  "node_modules/http2-client/lib/request-options.js"(exports2, module2) {
    var { assertIsObject } = require_utils4();
    function initializeOptions(options) {
      assertIsObject(options, "options");
      options = Object.assign({}, options);
      options.allowHalfOpen = true;
      options.rejectUnauthorized = false;
      assertIsObject(options.settings, "options.settings");
      options.settings = Object.assign({}, options.settings);
      options.Http1IncomingMessage = options.Http1IncomingMessage || this.http.IncomingMessage;
      options.Http1ServerResponse = options.Http1ServerResponse || this.http.ServerResponse;
      options.Http2ServerRequest = options.Http2ServerRequest || (this.http2 || {}).Http2ServerRequest;
      options.Http2ServerResponse = options.Http2ServerResponse || (this.http2 || {}).Http2ServerResponse;
      return options;
    }
    function initializeTLSOptions(options, servername) {
      options = initializeOptions.call(this, options);
      var ALPNProtocols = options.ALPNProtocols = [];
      if (this.http2Support)
        ALPNProtocols.push("h2");
      if (options.allowHTTP1 == true || !this.http2Support)
        ALPNProtocols.push("http/1.1");
      if (servername !== void 0 && options.servername === void 0)
        options.servername = servername;
      return options;
    }
    module2.exports = {
      initializeTLSOptions
    };
  }
});

// node_modules/http2-client/lib/request.js
var require_request = __commonJS({
  "node_modules/http2-client/lib/request.js"(exports2, module2) {
    var { URL: URL2 } = require("url");
    var { EventEmitter } = require("events");
    var _extend = require("util")._extend;
    var { DebounceTimers, assertIsObject, ERR_INVALID_ARG_TYPE } = require_utils4();
    var { initializeTLSOptions } = require_request_options();
    var http4 = require("http");
    var https = require("https");
    var { Stream: Stream2 } = require("stream");
    function addFunctions(container, obj) {
      const proto = obj.prototype;
      Object.keys(proto).forEach((name) => {
        if (container.indexOf(name) != -1)
          return;
        if (name.indexOf("_") != 0 && typeof proto[name] == "function") {
          container.push(name);
        }
      });
    }
    var STUBBED_METHODS_NAME = [];
    addFunctions(STUBBED_METHODS_NAME, http4.ClientRequest);
    addFunctions(STUBBED_METHODS_NAME, http4.OutgoingMessage);
    addFunctions(STUBBED_METHODS_NAME, EventEmitter);
    addFunctions(STUBBED_METHODS_NAME, Stream2);
    var PROPERTIES_TO_PROXY = [
      "httpVersionMajor",
      "httpVersionMinor",
      "httpVersion"
    ];
    var HEADERS_TO_REMOVE = ["host", "connection"];
    var $stubs = Symbol("stubs");
    function ClientRequest() {
      this.http2Mimic = true;
      this[$stubs] = [];
      for (var i = 0; i < STUBBED_METHODS_NAME.length; i++) {
        let name = STUBBED_METHODS_NAME[i];
        if (!ClientRequest.prototype[name]) {
          this[name] = function method() {
            return this.genericStubber(name, arguments);
          }.bind(this);
        }
      }
      var requestOptions, cb, url, args;
      const isInternal = arguments[0] instanceof RequestInternalEnforce;
      var isInternalMethod, isInternalProtocol;
      if (isInternal) {
        const enforceOptions = arguments[0];
        if (enforceOptions.method)
          isInternalMethod = enforceOptions.method;
        if (enforceOptions.protocol)
          isInternalProtocol = enforceOptions.protocol;
      }
      if (isInternal) {
        args = arguments[0].args;
      } else {
        args = arguments;
      }
      if (args[2] != void 0) {
        url = args[0];
        requestOptions = args[1];
        cb = args[2];
      } else if (args[1] == void 0) {
        requestOptions = args[0];
      } else {
        requestOptions = args[0];
        cb = args[1];
      }
      cb = cb || function dummy() {
      };
      if (typeof requestOptions === "string") {
        requestOptions = urlToOptions(new URL2(requestOptions));
        if (!requestOptions.hostname) {
          throw new Error("Unable to determine the domain name");
        }
      } else {
        if (url) {
          requestOptions = _extend(urlToOptions(new URL2(url)), requestOptions);
        } else {
          requestOptions = _extend({}, requestOptions);
        }
      }
      if (isInternalProtocol != isInternalProtocol) {
        requestOptions.protocol = isInternalProtocol;
      }
      if (requestOptions.protocol == "https:" && !requestOptions.port && requestOptions.port != 0)
        requestOptions.port = 443;
      if (!requestOptions.port && requestOptions.port != 0)
        requestOptions.port = 80;
      if (isInternalMethod) {
        requestOptions.method = isInternalMethod;
      } else if (!requestOptions.method)
        requestOptions.method = "GET";
      requestOptions.method = requestOptions.method.toUpperCase();
      const requestManager = requestOptions.requestManager || this.getGlobalManager(requestOptions);
      requestManager.handleClientRequest(this, requestOptions, cb);
    }
    ClientRequest.prototype = {
      getGlobalManager(options) {
        if (options.agent)
          return options.agent.protocol == "https:" ? HttpsRequest.globalManager : HttpRequest.globalManager;
        else
          return HttpRequestManager.globalManager;
      },
      genericStubber(method, args) {
        if (this[$stubs]) {
          this[$stubs].push([method, args]);
          return true;
        } else
          return this[method](...arguments);
      },
      on(eventName, cb) {
        if (eventName == "response") {
          if (!cb.http2Safe) {
            eventName = "http1.response";
            arguments[0] = eventName;
          }
        }
        if (this._on) {
          this._on(...arguments);
        } else
          this.genericStubber("on", arguments);
      },
      once(eventName, cb) {
        if (eventName == "response") {
          if (!cb.http2Safe) {
            eventName = "http1.response";
          }
        }
        if (this._once) {
          this._once(...arguments);
        } else
          this.genericStubber("once", arguments);
      },
      emitError(error) {
        if (this[$stubs]) {
          this[$stubs].forEach(([method, args]) => {
            if ((method === "on" || method === "once") && args[0] === "error") {
              args[1](error);
            }
          });
        } else
          return this.emit("error", error);
      },
      take(stream) {
        for (var i = 0; i < STUBBED_METHODS_NAME.length; i++) {
          let name = STUBBED_METHODS_NAME[i];
          if (stream[name]) {
            this[name] = stream[name].bind(stream);
          }
        }
        this._on = stream.on.bind(stream);
        this._once = stream.once.bind(stream);
        this.proxyProps(stream);
        for (let i2 = 0; i2 < this[$stubs].length; i2++) {
          var stub = this[$stubs][i2];
          stream[stub[0]](...stub[1]);
        }
        this[$stubs] = null;
      },
      proxyProps(http2Stream) {
        function getter() {
          return http2Stream[this];
        }
        function setter(value) {
          http2Stream[this] = value;
        }
        const notToProxy = ["on", "_on", "_once", "once", "http2Mimic"].concat(STUBBED_METHODS_NAME);
        const keys = Object.keys(this);
        const keysToProxy = [].concat(PROPERTIES_TO_PROXY);
        keys.forEach(function whichProxyKeys(key) {
          if (notToProxy.indexOf(key) == -1 && keysToProxy.indexOf(key) == -1) {
            keysToProxy.push(key);
          }
        });
        const properties = Object.getOwnPropertyDescriptors(http2Stream);
        for (var i = 0; i < keysToProxy.length; i++) {
          let name = keysToProxy[i];
          const propConfig = properties[name];
          let shouldCopyValue;
          if (!propConfig)
            shouldCopyValue = true;
          if (propConfig && (propConfig.writable || propConfig))
            shouldCopyValue = true;
          if (shouldCopyValue)
            http2Stream[name] = this[name];
          Object.defineProperty(this, name, {
            get: getter.bind(name),
            set: setter.bind(name)
          });
        }
      }
    };
    var HttpRequestManager = class _HttpRequestManager extends EventEmitter {
      constructor(options) {
        super();
        this.httpsAgent = https.globalAgent;
        this.httpAgent = http4.globalAgent;
        this.init(options);
      }
      log() {
      }
      init(options) {
        options = options || {};
        this.http2Clients = {};
        this.cachedHTTP1Result = {};
        this.setModules();
        this.http2Debouncer = new DebounceTimers(function stopConnection(key) {
          this.log("stopping ", key);
          var foundConnection = this.http2Clients[key];
          if (foundConnection) {
            this.removeHttp2Client(key, foundConnection);
          }
        }.bind(this), 1e3);
        this.keepH1IdentificationCacheFor = options.keepH1IdentificationCacheFor || 3e4;
        this.http2Debouncer.setDelay(options.keepH2ConnectionFor);
        if (options.useHttp) {
          this.enforceProtocol = "http:";
        } else if (options.useHttps) {
          this.enforceProtocol = "https:";
        }
      }
      setModules() {
        this["http"] = require("http");
        this["https"] = require("https");
        this["tls"] = require("tls");
        this["net"] = require("net");
        this.http2Support = false;
        try {
          this["http2"] = require("http2");
          this.http2Support = true;
        } catch (err) {
        }
      }
      handleClientRequest(clientRequest, requestOptions, cb) {
        const requestManager = this;
        const clientKey = requestManager.getClientKey(requestOptions);
        if (requestManager.hasCachedConnection(clientKey)) {
          const socket = requestManager.getHttp2Client(clientKey);
          const connectionOptions = {
            createConnection() {
              return socket;
            }
          };
          process.nextTick(function onMakeRequest() {
            requestManager.makeRequest(clientRequest, clientKey, requestOptions, cb, connectionOptions);
          }.bind(requestManager));
        } else
          requestManager.holdConnectionToIdentification(clientKey, requestOptions, function onIdentification(error, connectionOptions) {
            if (error) {
              clientRequest.emitError(error);
              return;
            }
            requestManager.makeRequest(clientRequest, clientKey, requestOptions, cb, connectionOptions);
          }.bind(requestManager));
      }
      getClientKey(url) {
        return `${url.protocol || this.enforceProtocol}${url.servername || url.host || url.hostname}:${url.port}`;
      }
      getHttp2Client(clientKey) {
        return this.http2Clients[clientKey];
      }
      setHttp2Client(clientKey, client) {
        const httpManager = this;
        const prevClient = httpManager.http2Clients[clientKey];
        if (prevClient)
          httpManager.removeHttp2Client(clientKey, prevClient);
        httpManager.http2Clients[clientKey] = client;
        function closeClient() {
          httpManager.removeHttp2Client(clientKey, client);
        }
        client.on("close", closeClient);
        client.on("goaway", closeClient);
        client.on("error", closeClient);
        client.on("frameError", closeClient);
        client.on("timeout", closeClient);
      }
      removeHttp2Client(clientKey, client) {
        try {
          delete this.http2Clients[clientKey];
          if (!client.closed) {
            client.close();
          }
        } catch (err) {
        }
        client.removeAllListeners("close");
        client.removeAllListeners("error");
        client.removeAllListeners("frameError");
        client.removeAllListeners("timeout");
      }
      request(url, options, cb) {
        var args = new RequestInternalEnforce(arguments);
        if (this.enforceProtocol) {
          args.protocol = this.enforceProtocol;
        }
        return new ClientRequest(args);
      }
      get() {
        var args = new RequestInternalEnforce(arguments);
        args.method = "GET";
        var request2 = this.request(args);
        request2.end();
        return request2;
      }
      hasCachedConnection(clientKey) {
        const http2Client = this.getHttp2Client(clientKey);
        if (http2Client) {
          return true;
        }
        return this.cachedHTTP1Result[clientKey] + this.keepH1IdentificationCacheFor < Date.now();
      }
      makeRequest(inStream, clientKey, requestOptions, cb, connectionOptions) {
        const http2Client = this.getHttp2Client(clientKey);
        if (http2Client) {
          return this.makeHttp2Request(clientKey, inStream, http2Client, Object.assign(connectionOptions || {}, requestOptions), cb);
        }
        if (!requestOptions.agent) {
          if (requestOptions.protocol == "https:")
            requestOptions.agent = this.httpsAgent;
          else
            requestOptions.agent = this.httpAgent;
        }
        return this.makeHttpRequest(clientKey, inStream, requestOptions, cb, connectionOptions);
      }
      holdConnectionToIdentification(clientKey, requestOptions, cb) {
        const topic = `identify-${clientKey}`;
        if (this._events[topic])
          this.once(topic, cb);
        else {
          this.once(topic, function letKnowThereIsAnEvent() {
          });
          const socket = this.identifyConnection(requestOptions, function onIdentify(error, type2) {
            if (error) {
              return cb(error);
            }
            var options = {
              createConnection() {
                return socket;
              }
            };
            if (type2 == "h2" && this.http2Support) {
              var http2Client = this.http2.connect(requestOptions, options);
              this.setHttp2Client(clientKey, http2Client);
            } else {
              this.cachedHTTP1Result[clientKey] = Date.now();
            }
            cb(null, options);
            this.emit(topic, options);
          }.bind(this));
        }
      }
      makeHttpRequest(clientKey, inStream, options, cb, connectionOptions) {
        if (options instanceof URL2)
          options = urlToOptions(options);
        const h1op = _extend({}, options);
        if (connectionOptions)
          h1op.createConnection = connectionOptions.createConnection;
        const requestModule = h1op.protocol == "https:" ? this.https : this.http;
        const req = requestModule.request(h1op, cb);
        inStream.take(req);
        inStream._on("response", function onHttp1Response(v) {
          this.emit("http1.response", v);
        });
      }
      makeHttp2Request(clientKey, inStream, http2Client, requestOptions, cb) {
        var http2Debouncer = this.http2Debouncer;
        http2Debouncer.pause(clientKey);
        var headers = _extend({}, requestOptions.headers || {});
        if (requestOptions.method)
          headers[":method"] = requestOptions.method;
        if (requestOptions.path)
          headers[":path"] = requestOptions.path;
        Object.keys(headers).forEach((key) => {
          if (HEADERS_TO_REMOVE.indexOf((key + "").toLowerCase()) != -1) {
            delete headers[key];
          }
        });
        requestOptions.headers = headers;
        var req = http2Client.request(
          headers
        );
        inStream.emit("socket", requestOptions.createConnection());
        let maxContentLength;
        let currentContent = 0;
        req.on("data", function onData(data) {
          currentContent += data.length;
          if (currentContent >= maxContentLength)
            http2Debouncer.unpauseAndTime(clientKey);
        });
        inStream.take(req);
        function onResponse(headers2) {
          maxContentLength = parseInt(headers2["content-length"]);
          if (maxContentLength < 0)
            this.http2Debouncer.unpauseAndTime(clientKey);
          _HttpRequestManager.httpCompatibleResponse(req, requestOptions, headers2);
          inStream.emit("http1.response", req);
          if (cb)
            cb(req);
        }
        onResponse.http2Safe = true;
        req.once("response", onResponse.bind(this));
      }
      static httpCompatibleResponse(res, requestOptions, headers) {
        res.httpVersion = "2.0";
        res.rawHeaders = headers;
        res.headers = headers;
        res.statusCode = headers[":status"];
        delete headers[":status"];
      }
      identifyConnection(requestOptions, cb) {
        var socket = this.connect(requestOptions, { allowHTTP1: true }, function onConnect() {
          socket.removeListener("error", cb);
          if (socket.alpnProtocol == "h2") {
            cb(null, "h2");
          } else {
            socket.end();
            cb(null, "h1");
          }
        });
        socket.on("error", cb);
        return socket;
      }
      connect(authority, options, listener) {
        if (typeof options === "function") {
          listener = options;
          options = void 0;
        }
        assertIsObject(options, "options");
        options = Object.assign({}, options);
        if (typeof authority === "string")
          authority = new URL2(authority);
        assertIsObject(authority, "authority", ["string", "Object", "URL"]);
        var protocol = authority.protocol || options.protocol || (this.enforceProtocol != "detect" ? this.enforceProtocol : null) || "http:";
        var port = "" + (authority.port !== "" ? authority.port : authority.protocol === "http:" ? 80 : 443);
        var host = authority.hostname || authority.host || "localhost";
        var socket;
        if (typeof options.createConnection === "function") {
          socket = options.createConnection(authority, options);
        } else {
          switch (protocol) {
            case "http:":
              socket = this.net.connect(port, host, listener);
              break;
            case "https:":
              socket = this.tls.connect(port, host, initializeTLSOptions.call(this, options, host), listener);
              break;
            default:
              throw new Error("Not supprted" + protocol);
          }
        }
        return socket;
      }
    };
    function urlToOptions(url) {
      var options = {
        protocol: url.protocol,
        hostname: url.hostname,
        hash: url.hash,
        search: url.search,
        pathname: url.pathname,
        path: `${url.pathname}${url.search}`,
        href: url.href
      };
      if (url.port !== "") {
        options.port = Number(url.port);
      }
      if (url.username || url.password) {
        options.auth = `${url.username}:${url.password}`;
      }
      return options;
    }
    var RequestInternalEnforce = class _RequestInternalEnforce {
      constructor(args) {
        if (args[0] instanceof _RequestInternalEnforce) {
          return args[0];
        }
        this.args = args;
        this.method = null;
        this.protocol = null;
      }
    };
    var HttpsRequest = class extends HttpRequestManager {
      constructor() {
        super(...arguments);
        this.Agent = https.Agent;
        this.globalAgent = https.globalAgent;
        this.enforceProtocol = "https:";
      }
    };
    var httpsRequestSinglton = new HttpsRequest();
    HttpsRequest.globalManager = httpsRequestSinglton;
    HttpsRequest.Manager = HttpsRequest;
    var HttpRequest = class extends HttpRequestManager {
      constructor() {
        super(...arguments);
        this.Agent = http4.Agent;
        this.globalAgent = http4.globalAgent;
        this.enforceProtocol = "http:";
      }
    };
    var httpRequestSinglton = new HttpRequest();
    HttpRequest.globalManager = httpRequestSinglton;
    HttpRequest.Manager = HttpRequest;
    var singeltonHttpManager = new HttpRequestManager();
    singeltonHttpManager.enforceProtocol = "detect";
    HttpRequestManager.globalManager = singeltonHttpManager;
    module2.exports = {
      HttpRequest,
      HttpsRequest,
      HTTP2OutgoingMessage: ClientRequest,
      ClientRequest,
      HttpRequestManager
    };
  }
});

// node_modules/http2-client/lib/http.js
var require_http2 = __commonJS({
  "node_modules/http2-client/lib/http.js"(exports2, module2) {
    var {
      HttpRequest,
      ClientRequest
    } = require_request();
    var globalManager = HttpRequest.globalManager;
    var request2 = globalManager.request.bind(globalManager);
    var get2 = globalManager.get.bind(globalManager);
    var http4 = Object.assign({}, require("http"));
    module2.exports = Object.assign(http4, {
      ClientRequest,
      globalManager,
      request: request2,
      get: get2
    });
  }
});

// node_modules/http2-client/lib/https.js
var require_https = __commonJS({
  "node_modules/http2-client/lib/https.js"(exports2, module2) {
    var {
      HttpsRequest,
      ClientRequest
    } = require_request();
    var globalManager = HttpsRequest.globalManager;
    var request2 = globalManager.request.bind(globalManager);
    var get2 = globalManager.get.bind(globalManager);
    var https = Object.assign({}, require("https"));
    module2.exports = Object.assign(https, {
      ClientRequest,
      globalManager,
      request: request2,
      get: get2
    });
  }
});

// node_modules/http2-client/lib/index.js
var require_lib17 = __commonJS({
  "node_modules/http2-client/lib/index.js"(exports2, module2) {
    var {
      HttpRequestManager,
      HTTP2OutgoingMessage,
      ClientRequest
    } = require_request();
    var http4 = require_http2();
    var https = require_https();
    var autoDetectManager = new HttpRequestManager();
    HttpRequestManager.globalManager = autoDetectManager;
    var request2 = autoDetectManager.request.bind(autoDetectManager);
    var get2 = autoDetectManager.get.bind(autoDetectManager);
    module2.exports = {
      HTTP2OutgoingMessage,
      ClientRequest,
      globalManager: HttpRequestManager.globalManager,
      request: request2,
      get: get2,
      http: http4,
      https
    };
  }
});

// node_modules/node-fetch-h2/lib/index.mjs
var lib_exports = {};
__export(lib_exports, {
  FetchError: () => FetchError,
  Headers: () => Headers,
  Request: () => Request,
  Response: () => Response,
  default: () => lib_default
});
function FetchError(message, type2, systemError) {
  Error.call(this, message);
  this.message = message;
  this.type = type2;
  if (systemError) {
    this.code = this.errno = systemError.code;
  }
  Error.captureStackTrace(this, this.constructor);
}
function Body(body) {
  var _this = this;
  var _ref = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, _ref$size = _ref.size;
  let size = _ref$size === void 0 ? 0 : _ref$size;
  var _ref$timeout = _ref.timeout;
  let timeout = _ref$timeout === void 0 ? 0 : _ref$timeout;
  if (body == null) {
    body = null;
  } else if (isURLSearchParams(body)) {
    body = Buffer.from(body.toString());
  } else if (body instanceof Blob) {
    body = body[BUFFER];
  } else if (Buffer.isBuffer(body)) ;
  else if (Object.prototype.toString.call(body) === "[object ArrayBuffer]") {
    body = Buffer.from(body);
  } else if (ArrayBuffer.isView(body)) {
    body = Buffer.from(body.buffer, body.byteOffset, body.byteLength);
  } else if (body instanceof import_stream.default) ;
  else {
    body = Buffer.from(String(body));
  }
  this[INTERNALS] = {
    body,
    disturbed: false,
    error: null
  };
  this.size = size;
  this.timeout = timeout;
  if (body instanceof import_stream.default) {
    body.on("error", function(err) {
      const error = err.name === "AbortError" ? err : new FetchError(`Invalid response body while trying to fetch ${_this.url}: ${err.message}`, "system", err);
      _this[INTERNALS].error = error;
    });
  }
}
function consumeBody() {
  var _this4 = this;
  if (this[INTERNALS].disturbed) {
    return Body.Promise.reject(new TypeError(`body used already for: ${this.url}`));
  }
  this[INTERNALS].disturbed = true;
  if (this[INTERNALS].error) {
    return Body.Promise.reject(this[INTERNALS].error);
  }
  if (this.body === null) {
    return Body.Promise.resolve(Buffer.alloc(0));
  }
  if (Buffer.isBuffer(this.body)) {
    return Body.Promise.resolve(this.body);
  }
  if (!(this.body instanceof import_stream.default)) {
    return Body.Promise.resolve(Buffer.alloc(0));
  }
  let accum = [];
  let accumBytes = 0;
  let abort = false;
  return new Body.Promise(function(resolve, reject) {
    let resTimeout;
    if (_this4.timeout) {
      resTimeout = setTimeout(function() {
        abort = true;
        reject(new FetchError(`Response timeout while trying to fetch ${_this4.url} (over ${_this4.timeout}ms)`, "body-timeout"));
      }, _this4.timeout);
    }
    _this4.body.on("error", function(err) {
      if (err.name === "AbortError") {
        abort = true;
        reject(err);
      } else {
        reject(new FetchError(`Invalid response body while trying to fetch ${_this4.url}: ${err.message}`, "system", err));
      }
    });
    _this4.body.on("data", function(chunk) {
      if (abort || chunk === null) {
        return;
      }
      if (_this4.size && accumBytes + chunk.length > _this4.size) {
        abort = true;
        reject(new FetchError(`content size at ${_this4.url} over limit: ${_this4.size}`, "max-size"));
        return;
      }
      accumBytes += chunk.length;
      accum.push(chunk);
    });
    _this4.body.on("end", function() {
      if (abort) {
        return;
      }
      clearTimeout(resTimeout);
      try {
        resolve(Buffer.concat(accum));
      } catch (err) {
        reject(new FetchError(`Could not create Buffer from response body for ${_this4.url}: ${err.message}`, "system", err));
      }
    });
  });
}
function convertBody(buffer, headers) {
  if (typeof convert !== "function") {
    throw new Error("The package `encoding` must be installed to use the textConverted() function");
  }
  const ct = headers.get("content-type");
  let charset = "utf-8";
  let res, str2;
  if (ct) {
    res = /charset=([^;]*)/i.exec(ct);
  }
  str2 = buffer.slice(0, 1024).toString();
  if (!res && str2) {
    res = /<meta.+?charset=(['"])(.+?)\1/i.exec(str2);
  }
  if (!res && str2) {
    res = /<meta[\s]+?http-equiv=(['"])content-type\1[\s]+?content=(['"])(.+?)\2/i.exec(str2);
    if (res) {
      res = /charset=(.*)/i.exec(res.pop());
    }
  }
  if (!res && str2) {
    res = /<\?xml.+?encoding=(['"])(.+?)\1/i.exec(str2);
  }
  if (res) {
    charset = res.pop();
    if (charset === "gb2312" || charset === "gbk") {
      charset = "gb18030";
    }
  }
  return convert(buffer, "UTF-8", charset).toString();
}
function isURLSearchParams(obj) {
  if (typeof obj !== "object" || typeof obj.append !== "function" || typeof obj.delete !== "function" || typeof obj.get !== "function" || typeof obj.getAll !== "function" || typeof obj.has !== "function" || typeof obj.set !== "function") {
    return false;
  }
  return obj.constructor.name === "URLSearchParams" || Object.prototype.toString.call(obj) === "[object URLSearchParams]" || typeof obj.sort === "function";
}
function clone(instance) {
  let p1, p2;
  let body = instance.body;
  if (instance.bodyUsed) {
    throw new Error("cannot clone body after it is used");
  }
  if (body instanceof import_stream.default && typeof body.getBoundary !== "function") {
    p1 = new PassThrough();
    p2 = new PassThrough();
    body.pipe(p1);
    body.pipe(p2);
    instance[INTERNALS].body = p1;
    body = p2;
  }
  return body;
}
function extractContentType(body) {
  if (body === null) {
    return null;
  } else if (typeof body === "string") {
    return "text/plain;charset=UTF-8";
  } else if (isURLSearchParams(body)) {
    return "application/x-www-form-urlencoded;charset=UTF-8";
  } else if (body instanceof Blob) {
    return body.type || null;
  } else if (Buffer.isBuffer(body)) {
    return null;
  } else if (Object.prototype.toString.call(body) === "[object ArrayBuffer]") {
    return null;
  } else if (ArrayBuffer.isView(body)) {
    return null;
  } else if (typeof body.getBoundary === "function") {
    return `multipart/form-data;boundary=${body.getBoundary()}`;
  } else if (body instanceof import_stream.default) {
    return null;
  } else {
    return "text/plain;charset=UTF-8";
  }
}
function getTotalBytes(instance) {
  const body = instance.body;
  if (body === null) {
    return 0;
  } else if (Buffer.isBuffer(body)) {
    return body.length;
  } else if (body && typeof body.getLengthSync === "function") {
    if (body._lengthRetrievers && body._lengthRetrievers.length == 0 || // 1.x
    body.hasKnownLength && body.hasKnownLength()) {
      return body.getLengthSync();
    }
    return null;
  } else {
    return null;
  }
}
function writeToStream(dest, instance) {
  const body = instance.body;
  if (body === null) {
    dest.end();
  } else if (Buffer.isBuffer(body)) {
    dest.write(body);
    dest.end();
  } else {
    body.pipe(dest);
  }
}
function validateName(name) {
  name = `${name}`;
  if (invalidTokenRegex.test(name)) {
    throw new TypeError(`${name} is not a legal HTTP header name`);
  }
}
function validateValue(value) {
  value = `${value}`;
  if (invalidHeaderCharRegex.test(value)) {
    throw new TypeError(`${value} is not a legal HTTP header value`);
  }
}
function find(map2, name) {
  name = name.toLowerCase();
  for (const key in map2) {
    if (key.toLowerCase() === name) {
      return key;
    }
  }
  return void 0;
}
function getHeaders(headers) {
  let kind = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "key+value";
  const keys = Object.keys(headers[MAP]).sort();
  return keys.map(kind === "key" ? function(k) {
    return k.toLowerCase();
  } : kind === "value" ? function(k) {
    return headers[MAP][k].join(", ");
  } : function(k) {
    return [k.toLowerCase(), headers[MAP][k].join(", ")];
  });
}
function createHeadersIterator(target, kind) {
  const iterator = Object.create(HeadersIteratorPrototype);
  iterator[INTERNAL] = {
    target,
    kind,
    index: 0
  };
  return iterator;
}
function exportNodeCompatibleHeaders(headers) {
  const obj = Object.assign({ __proto__: null }, headers[MAP]);
  const hostHeaderKey = find(headers[MAP], "Host");
  if (hostHeaderKey !== void 0) {
    obj[hostHeaderKey] = obj[hostHeaderKey][0];
  }
  return obj;
}
function createHeadersLenient(obj) {
  const headers = new Headers();
  for (const name of Object.keys(obj)) {
    if (invalidTokenRegex.test(name)) {
      continue;
    }
    if (Array.isArray(obj[name])) {
      for (const val of obj[name]) {
        if (invalidHeaderCharRegex.test(val)) {
          continue;
        }
        if (headers[MAP][name] === void 0) {
          headers[MAP][name] = [val];
        } else {
          headers[MAP][name].push(val);
        }
      }
    } else if (!invalidHeaderCharRegex.test(obj[name])) {
      headers[MAP][name] = [obj[name]];
    }
  }
  return headers;
}
function isRequest(input) {
  return typeof input === "object" && typeof input[INTERNALS$2] === "object";
}
function isAbortSignal(signal) {
  const proto = signal && typeof signal === "object" && Object.getPrototypeOf(signal);
  return !!(proto && proto.constructor.name === "AbortSignal");
}
function getNodeRequestOptions(request2) {
  const parsedURL = request2[INTERNALS$2].parsedURL;
  const headers = new Headers(request2[INTERNALS$2].headers);
  if (!headers.has("Accept")) {
    headers.set("Accept", "*/*");
  }
  if (!parsedURL.protocol || !parsedURL.hostname) {
    throw new TypeError("Only absolute URLs are supported");
  }
  if (!/^https?:$/.test(parsedURL.protocol)) {
    throw new TypeError("Only HTTP(S) protocols are supported");
  }
  if (request2.signal && request2.body instanceof import_stream.default.Readable && !streamDestructionSupported) {
    throw new Error("Cancellation of streamed requests with AbortSignal is not supported in node < 8");
  }
  let contentLengthValue = null;
  if (request2.body == null && /^(POST|PUT)$/i.test(request2.method)) {
    contentLengthValue = "0";
  }
  if (request2.body != null) {
    const totalBytes = getTotalBytes(request2);
    if (typeof totalBytes === "number") {
      contentLengthValue = String(totalBytes);
    }
  }
  if (contentLengthValue) {
    headers.set("Content-Length", contentLengthValue);
  }
  if (!headers.has("User-Agent")) {
    headers.set("User-Agent", "node-fetch/1.0 (+https://github.com/bitinn/node-fetch)");
  }
  if (request2.compress && !headers.has("Accept-Encoding")) {
    headers.set("Accept-Encoding", "gzip,deflate");
  }
  if (!headers.has("Connection") && !request2.agent) {
    headers.set("Connection", "close");
  }
  return Object.assign({}, parsedURL, {
    method: request2.method,
    headers: exportNodeCompatibleHeaders(headers),
    agent: request2.agent
  });
}
function AbortError(message) {
  Error.call(this, message);
  this.type = "aborted";
  this.message = message;
  Error.captureStackTrace(this, this.constructor);
}
function fetch3(url, opts) {
  if (!fetch3.Promise) {
    throw new Error("native promise missing, set fetch.Promise to your favorite alternative");
  }
  Body.Promise = fetch3.Promise;
  return new fetch3.Promise(function(resolve, reject) {
    const request2 = new Request(url, opts);
    const options = getNodeRequestOptions(request2);
    const send = import_http2_client.default.request;
    const signal = request2.signal;
    let response = null;
    const abort = function abort2() {
      let error = new AbortError("The user aborted a request.");
      reject(error);
      if (request2.body && request2.body instanceof import_stream.default.Readable) {
        request2.body.destroy(error);
      }
      if (!response || !response.body) return;
      response.body.emit("error", error);
    };
    if (signal && signal.aborted) {
      abort();
      return;
    }
    const abortAndFinalize = function abortAndFinalize2() {
      abort();
      finalize();
    };
    const req = send(options);
    let reqTimeout;
    if (signal) {
      signal.addEventListener("abort", abortAndFinalize);
    }
    function finalize() {
      req.abort();
      if (signal) signal.removeEventListener("abort", abortAndFinalize);
      clearTimeout(reqTimeout);
    }
    if (request2.timeout) {
      req.once("socket", function(socket) {
        reqTimeout = setTimeout(function() {
          reject(new FetchError(`network timeout at: ${request2.url}`, "request-timeout"));
          finalize();
        }, request2.timeout);
      });
    }
    req.on("error", function(err) {
      reject(new FetchError(`request to ${request2.url} failed, reason: ${err.message}`, "system", err));
      finalize();
    });
    req.on("response", function(res) {
      clearTimeout(reqTimeout);
      const headers = createHeadersLenient(res.headers);
      if (fetch3.isRedirect(res.statusCode)) {
        const location2 = headers.get("Location");
        const locationURL = location2 === null ? null : resolve_url(request2.url, location2);
        switch (request2.redirect) {
          case "error":
            reject(new FetchError(`redirect mode is set to error: ${request2.url}`, "no-redirect"));
            finalize();
            return;
          case "manual":
            if (locationURL !== null) {
              try {
                headers.set("Location", locationURL);
              } catch (err) {
                reject(err);
              }
            }
            break;
          case "follow":
            if (locationURL === null) {
              break;
            }
            if (request2.counter >= request2.follow) {
              reject(new FetchError(`maximum redirect reached at: ${request2.url}`, "max-redirect"));
              finalize();
              return;
            }
            const requestOpts = {
              headers: new Headers(request2.headers),
              follow: request2.follow,
              counter: request2.counter + 1,
              agent: request2.agent,
              compress: request2.compress,
              method: request2.method,
              body: request2.body,
              signal: request2.signal
            };
            if (res.statusCode !== 303 && request2.body && getTotalBytes(request2) === null) {
              reject(new FetchError("Cannot follow redirect with body being a readable stream", "unsupported-redirect"));
              finalize();
              return;
            }
            if (res.statusCode === 303 || (res.statusCode === 301 || res.statusCode === 302) && request2.method === "POST") {
              requestOpts.method = "GET";
              requestOpts.body = void 0;
              requestOpts.headers.delete("content-length");
            }
            resolve(fetch3(new Request(locationURL, requestOpts)));
            finalize();
            return;
        }
      }
      res.once("end", function() {
        if (signal) signal.removeEventListener("abort", abortAndFinalize);
      });
      let body = res.pipe(new PassThrough$1());
      const response_options = {
        url: request2.url,
        status: res.statusCode,
        statusText: res.statusMessage,
        headers,
        size: request2.size,
        timeout: request2.timeout
      };
      const codings = headers.get("Content-Encoding");
      if (!request2.compress || request2.method === "HEAD" || codings === null || res.statusCode === 204 || res.statusCode === 304) {
        response = new Response(body, response_options);
        resolve(response);
        return;
      }
      const zlibOptions = {
        flush: import_zlib.default.Z_SYNC_FLUSH,
        finishFlush: import_zlib.default.Z_SYNC_FLUSH
      };
      if (codings == "gzip" || codings == "x-gzip") {
        body = body.pipe(import_zlib.default.createGunzip(zlibOptions));
        response = new Response(body, response_options);
        resolve(response);
        return;
      }
      if (codings == "deflate" || codings == "x-deflate") {
        const raw = res.pipe(new PassThrough$1());
        raw.once("data", function(chunk) {
          if ((chunk[0] & 15) === 8) {
            body = body.pipe(import_zlib.default.createInflate());
          } else {
            body = body.pipe(import_zlib.default.createInflateRaw());
          }
          response = new Response(body, response_options);
          resolve(response);
        });
        return;
      }
      response = new Response(body, response_options);
      resolve(response);
    });
    writeToStream(req, request2);
  });
}
var import_stream, import_http, import_url2, import_http2_client, import_zlib, BUFFER, TYPE, Blob, convert, INTERNALS, PassThrough, invalidTokenRegex, invalidHeaderCharRegex, MAP, Headers, INTERNAL, HeadersIteratorPrototype, INTERNALS$1, STATUS_CODES, Response, INTERNALS$2, parse_url, format_url, streamDestructionSupported, Request, PassThrough$1, resolve_url, lib_default;
var init_lib = __esm({
  "node_modules/node-fetch-h2/lib/index.mjs"() {
    import_stream = __toESM(require("stream"), 1);
    import_http = __toESM(require("http"), 1);
    import_url2 = __toESM(require("url"), 1);
    import_http2_client = __toESM(require_lib17(), 1);
    import_zlib = __toESM(require("zlib"), 1);
    BUFFER = Symbol("buffer");
    TYPE = Symbol("type");
    Blob = class _Blob {
      constructor() {
        this[TYPE] = "";
        const blobParts = arguments[0];
        const options = arguments[1];
        const buffers = [];
        if (blobParts) {
          const a = blobParts;
          const length = Number(a.length);
          for (let i = 0; i < length; i++) {
            const element = a[i];
            let buffer;
            if (element instanceof Buffer) {
              buffer = element;
            } else if (ArrayBuffer.isView(element)) {
              buffer = Buffer.from(element.buffer, element.byteOffset, element.byteLength);
            } else if (element instanceof ArrayBuffer) {
              buffer = Buffer.from(element);
            } else if (element instanceof _Blob) {
              buffer = element[BUFFER];
            } else {
              buffer = Buffer.from(typeof element === "string" ? element : String(element));
            }
            buffers.push(buffer);
          }
        }
        this[BUFFER] = Buffer.concat(buffers);
        let type2 = options && options.type !== void 0 && String(options.type).toLowerCase();
        if (type2 && !/[^\u0020-\u007E]/.test(type2)) {
          this[TYPE] = type2;
        }
      }
      get size() {
        return this[BUFFER].length;
      }
      get type() {
        return this[TYPE];
      }
      slice() {
        const size = this.size;
        const start = arguments[0];
        const end = arguments[1];
        let relativeStart, relativeEnd;
        if (start === void 0) {
          relativeStart = 0;
        } else if (start < 0) {
          relativeStart = Math.max(size + start, 0);
        } else {
          relativeStart = Math.min(start, size);
        }
        if (end === void 0) {
          relativeEnd = size;
        } else if (end < 0) {
          relativeEnd = Math.max(size + end, 0);
        } else {
          relativeEnd = Math.min(end, size);
        }
        const span = Math.max(relativeEnd - relativeStart, 0);
        const buffer = this[BUFFER];
        const slicedBuffer = buffer.slice(relativeStart, relativeStart + span);
        const blob = new _Blob([], { type: arguments[2] });
        blob[BUFFER] = slicedBuffer;
        return blob;
      }
    };
    Object.defineProperties(Blob.prototype, {
      size: { enumerable: true },
      type: { enumerable: true },
      slice: { enumerable: true }
    });
    Object.defineProperty(Blob.prototype, Symbol.toStringTag, {
      value: "Blob",
      writable: false,
      enumerable: false,
      configurable: true
    });
    FetchError.prototype = Object.create(Error.prototype);
    FetchError.prototype.constructor = FetchError;
    FetchError.prototype.name = "FetchError";
    try {
      convert = require("encoding").convert;
    } catch (e) {
    }
    INTERNALS = Symbol("Body internals");
    PassThrough = import_stream.default.PassThrough;
    Body.prototype = {
      get body() {
        return this[INTERNALS].body;
      },
      get bodyUsed() {
        return this[INTERNALS].disturbed;
      },
      /**
       * Decode response as ArrayBuffer
       *
       * @return  Promise
       */
      arrayBuffer() {
        return consumeBody.call(this).then(function(buf) {
          return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
        });
      },
      /**
       * Return raw response as Blob
       *
       * @return Promise
       */
      blob() {
        let ct = this.headers && this.headers.get("content-type") || "";
        return consumeBody.call(this).then(function(buf) {
          return Object.assign(
            // Prevent copying
            new Blob([], {
              type: ct.toLowerCase()
            }),
            {
              [BUFFER]: buf
            }
          );
        });
      },
      /**
       * Decode response as json
       *
       * @return  Promise
       */
      json() {
        var _this2 = this;
        return consumeBody.call(this).then(function(buffer) {
          try {
            return JSON.parse(buffer.toString());
          } catch (err) {
            return Body.Promise.reject(new FetchError(`invalid json response body at ${_this2.url} reason: ${err.message}`, "invalid-json"));
          }
        });
      },
      /**
       * Decode response as text
       *
       * @return  Promise
       */
      text() {
        return consumeBody.call(this).then(function(buffer) {
          return buffer.toString();
        });
      },
      /**
       * Decode response as buffer (non-spec api)
       *
       * @return  Promise
       */
      buffer() {
        return consumeBody.call(this);
      },
      /**
       * Decode response as text, while automatically detecting the encoding and
       * trying to decode to UTF-8 (non-spec api)
       *
       * @return  Promise
       */
      textConverted() {
        var _this3 = this;
        return consumeBody.call(this).then(function(buffer) {
          return convertBody(buffer, _this3.headers);
        });
      }
    };
    Object.defineProperties(Body.prototype, {
      body: { enumerable: true },
      bodyUsed: { enumerable: true },
      arrayBuffer: { enumerable: true },
      blob: { enumerable: true },
      json: { enumerable: true },
      text: { enumerable: true }
    });
    Body.mixIn = function(proto) {
      for (const name of Object.getOwnPropertyNames(Body.prototype)) {
        if (!(name in proto)) {
          const desc = Object.getOwnPropertyDescriptor(Body.prototype, name);
          Object.defineProperty(proto, name, desc);
        }
      }
    };
    Body.Promise = global.Promise;
    invalidTokenRegex = /[^\^_`a-zA-Z\-0-9!#$%&'*+.|~]/;
    invalidHeaderCharRegex = /[^\t\x20-\x7e\x80-\xff]/;
    MAP = Symbol("map");
    Headers = class _Headers {
      /**
       * Headers class
       *
       * @param   Object  headers  Response headers
       * @return  Void
       */
      constructor() {
        let init = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : void 0;
        this[MAP] = /* @__PURE__ */ Object.create(null);
        if (init instanceof _Headers) {
          const rawHeaders = init.raw();
          const headerNames = Object.keys(rawHeaders);
          for (const headerName of headerNames) {
            for (const value of rawHeaders[headerName]) {
              this.append(headerName, value);
            }
          }
          return;
        }
        if (init == null) ;
        else if (typeof init === "object") {
          const method = init[Symbol.iterator];
          if (method != null) {
            if (typeof method !== "function") {
              throw new TypeError("Header pairs must be iterable");
            }
            const pairs2 = [];
            for (const pair of init) {
              if (typeof pair !== "object" || typeof pair[Symbol.iterator] !== "function") {
                throw new TypeError("Each header pair must be iterable");
              }
              pairs2.push(Array.from(pair));
            }
            for (const pair of pairs2) {
              if (pair.length !== 2) {
                throw new TypeError("Each header pair must be a name/value tuple");
              }
              this.append(pair[0], pair[1]);
            }
          } else {
            for (const key of Object.keys(init)) {
              const value = init[key];
              this.append(key, value);
            }
          }
        } else {
          throw new TypeError("Provided initializer must be an object");
        }
      }
      /**
       * Return combined header value given name
       *
       * @param   String  name  Header name
       * @return  Mixed
       */
      get(name) {
        name = `${name}`;
        validateName(name);
        const key = find(this[MAP], name);
        if (key === void 0) {
          return null;
        }
        return this[MAP][key].join(", ");
      }
      /**
       * Iterate over all headers
       *
       * @param   Function  callback  Executed for each item with parameters (value, name, thisArg)
       * @param   Boolean   thisArg   `this` context for callback function
       * @return  Void
       */
      forEach(callback) {
        let thisArg = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : void 0;
        let pairs2 = getHeaders(this);
        let i = 0;
        while (i < pairs2.length) {
          var _pairs$i = pairs2[i];
          const name = _pairs$i[0], value = _pairs$i[1];
          callback.call(thisArg, value, name, this);
          pairs2 = getHeaders(this);
          i++;
        }
      }
      /**
       * Overwrite header values given name
       *
       * @param   String  name   Header name
       * @param   String  value  Header value
       * @return  Void
       */
      set(name, value) {
        name = `${name}`;
        value = `${value}`;
        validateName(name);
        validateValue(value);
        const key = find(this[MAP], name);
        this[MAP][key !== void 0 ? key : name] = [value];
      }
      /**
       * Append a value onto existing header
       *
       * @param   String  name   Header name
       * @param   String  value  Header value
       * @return  Void
       */
      append(name, value) {
        name = `${name}`;
        value = `${value}`;
        validateName(name);
        validateValue(value);
        const key = find(this[MAP], name);
        if (key !== void 0) {
          this[MAP][key].push(value);
        } else {
          this[MAP][name] = [value];
        }
      }
      /**
       * Check for header name existence
       *
       * @param   String   name  Header name
       * @return  Boolean
       */
      has(name) {
        name = `${name}`;
        validateName(name);
        return find(this[MAP], name) !== void 0;
      }
      /**
       * Delete all header values given name
       *
       * @param   String  name  Header name
       * @return  Void
       */
      delete(name) {
        name = `${name}`;
        validateName(name);
        const key = find(this[MAP], name);
        if (key !== void 0) {
          delete this[MAP][key];
        }
      }
      /**
       * Return raw headers (non-spec api)
       *
       * @return  Object
       */
      raw() {
        return this[MAP];
      }
      /**
       * Get an iterator on keys.
       *
       * @return  Iterator
       */
      keys() {
        return createHeadersIterator(this, "key");
      }
      /**
       * Get an iterator on values.
       *
       * @return  Iterator
       */
      values() {
        return createHeadersIterator(this, "value");
      }
      /**
       * Get an iterator on entries.
       *
       * This is the default iterator of the Headers object.
       *
       * @return  Iterator
       */
      [Symbol.iterator]() {
        return createHeadersIterator(this, "key+value");
      }
    };
    Headers.prototype.entries = Headers.prototype[Symbol.iterator];
    Object.defineProperty(Headers.prototype, Symbol.toStringTag, {
      value: "Headers",
      writable: false,
      enumerable: false,
      configurable: true
    });
    Object.defineProperties(Headers.prototype, {
      get: { enumerable: true },
      forEach: { enumerable: true },
      set: { enumerable: true },
      append: { enumerable: true },
      has: { enumerable: true },
      delete: { enumerable: true },
      keys: { enumerable: true },
      values: { enumerable: true },
      entries: { enumerable: true }
    });
    INTERNAL = Symbol("internal");
    HeadersIteratorPrototype = Object.setPrototypeOf({
      next() {
        if (!this || Object.getPrototypeOf(this) !== HeadersIteratorPrototype) {
          throw new TypeError("Value of `this` is not a HeadersIterator");
        }
        var _INTERNAL = this[INTERNAL];
        const target = _INTERNAL.target, kind = _INTERNAL.kind, index = _INTERNAL.index;
        const values = getHeaders(target, kind);
        const len = values.length;
        if (index >= len) {
          return {
            value: void 0,
            done: true
          };
        }
        this[INTERNAL].index = index + 1;
        return {
          value: values[index],
          done: false
        };
      }
    }, Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]())));
    Object.defineProperty(HeadersIteratorPrototype, Symbol.toStringTag, {
      value: "HeadersIterator",
      writable: false,
      enumerable: false,
      configurable: true
    });
    INTERNALS$1 = Symbol("Response internals");
    STATUS_CODES = import_http.default.STATUS_CODES;
    Response = class _Response {
      constructor() {
        let body = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
        let opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        Body.call(this, body, opts);
        const status = opts.status || 200;
        const headers = new Headers(opts.headers);
        if (body != null && !headers.has("Content-Type")) {
          const contentType = extractContentType(body);
          if (contentType) {
            headers.append("Content-Type", contentType);
          }
        }
        this[INTERNALS$1] = {
          url: opts.url,
          status,
          statusText: opts.statusText || STATUS_CODES[status],
          headers
        };
      }
      get url() {
        return this[INTERNALS$1].url;
      }
      get status() {
        return this[INTERNALS$1].status;
      }
      /**
       * Convenience property representing if the request ended normally
       */
      get ok() {
        return this[INTERNALS$1].status >= 200 && this[INTERNALS$1].status < 300;
      }
      get statusText() {
        return this[INTERNALS$1].statusText;
      }
      get headers() {
        return this[INTERNALS$1].headers;
      }
      /**
       * Clone this response
       *
       * @return  Response
       */
      clone() {
        return new _Response(clone(this), {
          url: this.url,
          status: this.status,
          statusText: this.statusText,
          headers: this.headers,
          ok: this.ok
        });
      }
    };
    Body.mixIn(Response.prototype);
    Object.defineProperties(Response.prototype, {
      url: { enumerable: true },
      status: { enumerable: true },
      ok: { enumerable: true },
      statusText: { enumerable: true },
      headers: { enumerable: true },
      clone: { enumerable: true }
    });
    Object.defineProperty(Response.prototype, Symbol.toStringTag, {
      value: "Response",
      writable: false,
      enumerable: false,
      configurable: true
    });
    INTERNALS$2 = Symbol("Request internals");
    parse_url = import_url2.default.parse;
    format_url = import_url2.default.format;
    streamDestructionSupported = "destroy" in import_stream.default.Readable.prototype;
    Request = class _Request {
      constructor(input) {
        let init = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        let parsedURL;
        if (!isRequest(input)) {
          if (input && input.href) {
            parsedURL = parse_url(input.href);
          } else {
            parsedURL = parse_url(`${input}`);
          }
          input = {};
        } else {
          parsedURL = parse_url(input.url);
        }
        let method = init.method || input.method || "GET";
        method = method.toUpperCase();
        if ((init.body != null || isRequest(input) && input.body !== null) && (method === "GET" || method === "HEAD")) {
          throw new TypeError("Request with GET/HEAD method cannot have body");
        }
        let inputBody = init.body != null ? init.body : isRequest(input) && input.body !== null ? clone(input) : null;
        Body.call(this, inputBody, {
          timeout: init.timeout || input.timeout || 0,
          size: init.size || input.size || 0
        });
        const headers = new Headers(init.headers || input.headers || {});
        if (inputBody != null && !headers.has("Content-Type")) {
          const contentType = extractContentType(inputBody);
          if (contentType) {
            headers.append("Content-Type", contentType);
          }
        }
        let signal = isRequest(input) ? input.signal : null;
        if ("signal" in init) signal = init.signal;
        if (signal != null && !isAbortSignal(signal)) {
          throw new TypeError("Expected signal to be an instanceof AbortSignal");
        }
        this[INTERNALS$2] = {
          method,
          redirect: init.redirect || input.redirect || "follow",
          headers,
          parsedURL,
          signal
        };
        this.follow = init.follow !== void 0 ? init.follow : input.follow !== void 0 ? input.follow : 20;
        this.compress = init.compress !== void 0 ? init.compress : input.compress !== void 0 ? input.compress : true;
        this.counter = init.counter || input.counter || 0;
        this.agent = init.agent || input.agent;
      }
      get method() {
        return this[INTERNALS$2].method;
      }
      get url() {
        return format_url(this[INTERNALS$2].parsedURL);
      }
      get headers() {
        return this[INTERNALS$2].headers;
      }
      get redirect() {
        return this[INTERNALS$2].redirect;
      }
      get signal() {
        return this[INTERNALS$2].signal;
      }
      /**
       * Clone this request
       *
       * @return  Request
       */
      clone() {
        return new _Request(this);
      }
    };
    Body.mixIn(Request.prototype);
    Object.defineProperty(Request.prototype, Symbol.toStringTag, {
      value: "Request",
      writable: false,
      enumerable: false,
      configurable: true
    });
    Object.defineProperties(Request.prototype, {
      method: { enumerable: true },
      url: { enumerable: true },
      headers: { enumerable: true },
      redirect: { enumerable: true },
      clone: { enumerable: true },
      signal: { enumerable: true }
    });
    AbortError.prototype = Object.create(Error.prototype);
    AbortError.prototype.constructor = AbortError;
    AbortError.prototype.name = "AbortError";
    PassThrough$1 = import_stream.default.PassThrough;
    resolve_url = import_url2.default.resolve;
    fetch3.isRedirect = function(code) {
      return code === 301 || code === 302 || code === 303 || code === 307 || code === 308;
    };
    fetch3.Promise = global.Promise;
    lib_default = fetch3;
  }
});

// node_modules/swagger2openapi/node_modules/yaml/dist/PlainValue-ec8e588e.js
var require_PlainValue_ec8e588e = __commonJS({
  "node_modules/swagger2openapi/node_modules/yaml/dist/PlainValue-ec8e588e.js"(exports2) {
    "use strict";
    var Char = {
      ANCHOR: "&",
      COMMENT: "#",
      TAG: "!",
      DIRECTIVES_END: "-",
      DOCUMENT_END: "."
    };
    var Type2 = {
      ALIAS: "ALIAS",
      BLANK_LINE: "BLANK_LINE",
      BLOCK_FOLDED: "BLOCK_FOLDED",
      BLOCK_LITERAL: "BLOCK_LITERAL",
      COMMENT: "COMMENT",
      DIRECTIVE: "DIRECTIVE",
      DOCUMENT: "DOCUMENT",
      FLOW_MAP: "FLOW_MAP",
      FLOW_SEQ: "FLOW_SEQ",
      MAP: "MAP",
      MAP_KEY: "MAP_KEY",
      MAP_VALUE: "MAP_VALUE",
      PLAIN: "PLAIN",
      QUOTE_DOUBLE: "QUOTE_DOUBLE",
      QUOTE_SINGLE: "QUOTE_SINGLE",
      SEQ: "SEQ",
      SEQ_ITEM: "SEQ_ITEM"
    };
    var defaultTagPrefix = "tag:yaml.org,2002:";
    var defaultTags = {
      MAP: "tag:yaml.org,2002:map",
      SEQ: "tag:yaml.org,2002:seq",
      STR: "tag:yaml.org,2002:str"
    };
    function findLineStarts(src) {
      const ls = [0];
      let offset = src.indexOf("\n");
      while (offset !== -1) {
        offset += 1;
        ls.push(offset);
        offset = src.indexOf("\n", offset);
      }
      return ls;
    }
    function getSrcInfo(cst) {
      let lineStarts, src;
      if (typeof cst === "string") {
        lineStarts = findLineStarts(cst);
        src = cst;
      } else {
        if (Array.isArray(cst)) cst = cst[0];
        if (cst && cst.context) {
          if (!cst.lineStarts) cst.lineStarts = findLineStarts(cst.context.src);
          lineStarts = cst.lineStarts;
          src = cst.context.src;
        }
      }
      return {
        lineStarts,
        src
      };
    }
    function getLinePos(offset, cst) {
      if (typeof offset !== "number" || offset < 0) return null;
      const {
        lineStarts,
        src
      } = getSrcInfo(cst);
      if (!lineStarts || !src || offset > src.length) return null;
      for (let i = 0; i < lineStarts.length; ++i) {
        const start = lineStarts[i];
        if (offset < start) {
          return {
            line: i,
            col: offset - lineStarts[i - 1] + 1
          };
        }
        if (offset === start) return {
          line: i + 1,
          col: 1
        };
      }
      const line = lineStarts.length;
      return {
        line,
        col: offset - lineStarts[line - 1] + 1
      };
    }
    function getLine2(line, cst) {
      const {
        lineStarts,
        src
      } = getSrcInfo(cst);
      if (!lineStarts || !(line >= 1) || line > lineStarts.length) return null;
      const start = lineStarts[line - 1];
      let end = lineStarts[line];
      while (end && end > start && src[end - 1] === "\n") --end;
      return src.slice(start, end);
    }
    function getPrettyContext({
      start,
      end
    }, cst, maxWidth = 80) {
      let src = getLine2(start.line, cst);
      if (!src) return null;
      let {
        col
      } = start;
      if (src.length > maxWidth) {
        if (col <= maxWidth - 10) {
          src = src.substr(0, maxWidth - 1) + "\u2026";
        } else {
          const halfWidth = Math.round(maxWidth / 2);
          if (src.length > col + halfWidth) src = src.substr(0, col + halfWidth - 1) + "\u2026";
          col -= src.length - maxWidth;
          src = "\u2026" + src.substr(1 - maxWidth);
        }
      }
      let errLen = 1;
      let errEnd = "";
      if (end) {
        if (end.line === start.line && col + (end.col - start.col) <= maxWidth + 1) {
          errLen = end.col - start.col;
        } else {
          errLen = Math.min(src.length + 1, maxWidth) - col;
          errEnd = "\u2026";
        }
      }
      const offset = col > 1 ? " ".repeat(col - 1) : "";
      const err = "^".repeat(errLen);
      return `${src}
${offset}${err}${errEnd}`;
    }
    var Range = class _Range {
      static copy(orig) {
        return new _Range(orig.start, orig.end);
      }
      constructor(start, end) {
        this.start = start;
        this.end = end || start;
      }
      isEmpty() {
        return typeof this.start !== "number" || !this.end || this.end <= this.start;
      }
      /**
       * Set `origStart` and `origEnd` to point to the original source range for
       * this node, which may differ due to dropped CR characters.
       *
       * @param {number[]} cr - Positions of dropped CR characters
       * @param {number} offset - Starting index of `cr` from the last call
       * @returns {number} - The next offset, matching the one found for `origStart`
       */
      setOrigRange(cr, offset) {
        const {
          start,
          end
        } = this;
        if (cr.length === 0 || end <= cr[0]) {
          this.origStart = start;
          this.origEnd = end;
          return offset;
        }
        let i = offset;
        while (i < cr.length) {
          if (cr[i] > start) break;
          else ++i;
        }
        this.origStart = start + i;
        const nextOffset = i;
        while (i < cr.length) {
          if (cr[i] >= end) break;
          else ++i;
        }
        this.origEnd = end + i;
        return nextOffset;
      }
    };
    var Node = class _Node {
      static addStringTerminator(src, offset, str2) {
        if (str2[str2.length - 1] === "\n") return str2;
        const next = _Node.endOfWhiteSpace(src, offset);
        return next >= src.length || src[next] === "\n" ? str2 + "\n" : str2;
      }
      // ^(---|...)
      static atDocumentBoundary(src, offset, sep) {
        const ch0 = src[offset];
        if (!ch0) return true;
        const prev = src[offset - 1];
        if (prev && prev !== "\n") return false;
        if (sep) {
          if (ch0 !== sep) return false;
        } else {
          if (ch0 !== Char.DIRECTIVES_END && ch0 !== Char.DOCUMENT_END) return false;
        }
        const ch1 = src[offset + 1];
        const ch2 = src[offset + 2];
        if (ch1 !== ch0 || ch2 !== ch0) return false;
        const ch3 = src[offset + 3];
        return !ch3 || ch3 === "\n" || ch3 === "	" || ch3 === " ";
      }
      static endOfIdentifier(src, offset) {
        let ch = src[offset];
        const isVerbatim = ch === "<";
        const notOk = isVerbatim ? ["\n", "	", " ", ">"] : ["\n", "	", " ", "[", "]", "{", "}", ","];
        while (ch && notOk.indexOf(ch) === -1) ch = src[offset += 1];
        if (isVerbatim && ch === ">") offset += 1;
        return offset;
      }
      static endOfIndent(src, offset) {
        let ch = src[offset];
        while (ch === " ") ch = src[offset += 1];
        return offset;
      }
      static endOfLine(src, offset) {
        let ch = src[offset];
        while (ch && ch !== "\n") ch = src[offset += 1];
        return offset;
      }
      static endOfWhiteSpace(src, offset) {
        let ch = src[offset];
        while (ch === "	" || ch === " ") ch = src[offset += 1];
        return offset;
      }
      static startOfLine(src, offset) {
        let ch = src[offset - 1];
        if (ch === "\n") return offset;
        while (ch && ch !== "\n") ch = src[offset -= 1];
        return offset + 1;
      }
      /**
       * End of indentation, or null if the line's indent level is not more
       * than `indent`
       *
       * @param {string} src
       * @param {number} indent
       * @param {number} lineStart
       * @returns {?number}
       */
      static endOfBlockIndent(src, indent, lineStart) {
        const inEnd = _Node.endOfIndent(src, lineStart);
        if (inEnd > lineStart + indent) {
          return inEnd;
        } else {
          const wsEnd = _Node.endOfWhiteSpace(src, inEnd);
          const ch = src[wsEnd];
          if (!ch || ch === "\n") return wsEnd;
        }
        return null;
      }
      static atBlank(src, offset, endAsBlank) {
        const ch = src[offset];
        return ch === "\n" || ch === "	" || ch === " " || endAsBlank && !ch;
      }
      static nextNodeIsIndented(ch, indentDiff, indicatorAsIndent) {
        if (!ch || indentDiff < 0) return false;
        if (indentDiff > 0) return true;
        return indicatorAsIndent && ch === "-";
      }
      // should be at line or string end, or at next non-whitespace char
      static normalizeOffset(src, offset) {
        const ch = src[offset];
        return !ch ? offset : ch !== "\n" && src[offset - 1] === "\n" ? offset - 1 : _Node.endOfWhiteSpace(src, offset);
      }
      // fold single newline into space, multiple newlines to N - 1 newlines
      // presumes src[offset] === '\n'
      static foldNewline(src, offset, indent) {
        let inCount = 0;
        let error = false;
        let fold = "";
        let ch = src[offset + 1];
        while (ch === " " || ch === "	" || ch === "\n") {
          switch (ch) {
            case "\n":
              inCount = 0;
              offset += 1;
              fold += "\n";
              break;
            case "	":
              if (inCount <= indent) error = true;
              offset = _Node.endOfWhiteSpace(src, offset + 2) - 1;
              break;
            case " ":
              inCount += 1;
              offset += 1;
              break;
          }
          ch = src[offset + 1];
        }
        if (!fold) fold = " ";
        if (ch && inCount <= indent) error = true;
        return {
          fold,
          offset,
          error
        };
      }
      constructor(type2, props, context) {
        Object.defineProperty(this, "context", {
          value: context || null,
          writable: true
        });
        this.error = null;
        this.range = null;
        this.valueRange = null;
        this.props = props || [];
        this.type = type2;
        this.value = null;
      }
      getPropValue(idx, key, skipKey) {
        if (!this.context) return null;
        const {
          src
        } = this.context;
        const prop = this.props[idx];
        return prop && src[prop.start] === key ? src.slice(prop.start + (skipKey ? 1 : 0), prop.end) : null;
      }
      get anchor() {
        for (let i = 0; i < this.props.length; ++i) {
          const anchor = this.getPropValue(i, Char.ANCHOR, true);
          if (anchor != null) return anchor;
        }
        return null;
      }
      get comment() {
        const comments = [];
        for (let i = 0; i < this.props.length; ++i) {
          const comment = this.getPropValue(i, Char.COMMENT, true);
          if (comment != null) comments.push(comment);
        }
        return comments.length > 0 ? comments.join("\n") : null;
      }
      commentHasRequiredWhitespace(start) {
        const {
          src
        } = this.context;
        if (this.header && start === this.header.end) return false;
        if (!this.valueRange) return false;
        const {
          end
        } = this.valueRange;
        return start !== end || _Node.atBlank(src, end - 1);
      }
      get hasComment() {
        if (this.context) {
          const {
            src
          } = this.context;
          for (let i = 0; i < this.props.length; ++i) {
            if (src[this.props[i].start] === Char.COMMENT) return true;
          }
        }
        return false;
      }
      get hasProps() {
        if (this.context) {
          const {
            src
          } = this.context;
          for (let i = 0; i < this.props.length; ++i) {
            if (src[this.props[i].start] !== Char.COMMENT) return true;
          }
        }
        return false;
      }
      get includesTrailingLines() {
        return false;
      }
      get jsonLike() {
        const jsonLikeTypes = [Type2.FLOW_MAP, Type2.FLOW_SEQ, Type2.QUOTE_DOUBLE, Type2.QUOTE_SINGLE];
        return jsonLikeTypes.indexOf(this.type) !== -1;
      }
      get rangeAsLinePos() {
        if (!this.range || !this.context) return void 0;
        const start = getLinePos(this.range.start, this.context.root);
        if (!start) return void 0;
        const end = getLinePos(this.range.end, this.context.root);
        return {
          start,
          end
        };
      }
      get rawValue() {
        if (!this.valueRange || !this.context) return null;
        const {
          start,
          end
        } = this.valueRange;
        return this.context.src.slice(start, end);
      }
      get tag() {
        for (let i = 0; i < this.props.length; ++i) {
          const tag = this.getPropValue(i, Char.TAG, false);
          if (tag != null) {
            if (tag[1] === "<") {
              return {
                verbatim: tag.slice(2, -1)
              };
            } else {
              const [_, handle, suffix] = tag.match(/^(.*!)([^!]*)$/);
              return {
                handle,
                suffix
              };
            }
          }
        }
        return null;
      }
      get valueRangeContainsNewline() {
        if (!this.valueRange || !this.context) return false;
        const {
          start,
          end
        } = this.valueRange;
        const {
          src
        } = this.context;
        for (let i = start; i < end; ++i) {
          if (src[i] === "\n") return true;
        }
        return false;
      }
      parseComment(start) {
        const {
          src
        } = this.context;
        if (src[start] === Char.COMMENT) {
          const end = _Node.endOfLine(src, start + 1);
          const commentRange = new Range(start, end);
          this.props.push(commentRange);
          return end;
        }
        return start;
      }
      /**
       * Populates the `origStart` and `origEnd` values of all ranges for this
       * node. Extended by child classes to handle descendant nodes.
       *
       * @param {number[]} cr - Positions of dropped CR characters
       * @param {number} offset - Starting index of `cr` from the last call
       * @returns {number} - The next offset, matching the one found for `origStart`
       */
      setOrigRanges(cr, offset) {
        if (this.range) offset = this.range.setOrigRange(cr, offset);
        if (this.valueRange) this.valueRange.setOrigRange(cr, offset);
        this.props.forEach((prop) => prop.setOrigRange(cr, offset));
        return offset;
      }
      toString() {
        const {
          context: {
            src
          },
          range,
          value
        } = this;
        if (value != null) return value;
        const str2 = src.slice(range.start, range.end);
        return _Node.addStringTerminator(src, range.end, str2);
      }
    };
    var YAMLError = class extends Error {
      constructor(name, source, message) {
        if (!message || !(source instanceof Node)) throw new Error(`Invalid arguments for new ${name}`);
        super();
        this.name = name;
        this.message = message;
        this.source = source;
      }
      makePretty() {
        if (!this.source) return;
        this.nodeType = this.source.type;
        const cst = this.source.context && this.source.context.root;
        if (typeof this.offset === "number") {
          this.range = new Range(this.offset, this.offset + 1);
          const start = cst && getLinePos(this.offset, cst);
          if (start) {
            const end = {
              line: start.line,
              col: start.col + 1
            };
            this.linePos = {
              start,
              end
            };
          }
          delete this.offset;
        } else {
          this.range = this.source.range;
          this.linePos = this.source.rangeAsLinePos;
        }
        if (this.linePos) {
          const {
            line,
            col
          } = this.linePos.start;
          this.message += ` at line ${line}, column ${col}`;
          const ctx = cst && getPrettyContext(this.linePos, cst);
          if (ctx) this.message += `:

${ctx}
`;
        }
        delete this.source;
      }
    };
    var YAMLReferenceError = class extends YAMLError {
      constructor(source, message) {
        super("YAMLReferenceError", source, message);
      }
    };
    var YAMLSemanticError = class extends YAMLError {
      constructor(source, message) {
        super("YAMLSemanticError", source, message);
      }
    };
    var YAMLSyntaxError = class extends YAMLError {
      constructor(source, message) {
        super("YAMLSyntaxError", source, message);
      }
    };
    var YAMLWarning = class extends YAMLError {
      constructor(source, message) {
        super("YAMLWarning", source, message);
      }
    };
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    var PlainValue = class _PlainValue extends Node {
      static endOfLine(src, start, inFlow) {
        let ch = src[start];
        let offset = start;
        while (ch && ch !== "\n") {
          if (inFlow && (ch === "[" || ch === "]" || ch === "{" || ch === "}" || ch === ",")) break;
          const next = src[offset + 1];
          if (ch === ":" && (!next || next === "\n" || next === "	" || next === " " || inFlow && next === ",")) break;
          if ((ch === " " || ch === "	") && next === "#") break;
          offset += 1;
          ch = next;
        }
        return offset;
      }
      get strValue() {
        if (!this.valueRange || !this.context) return null;
        let {
          start,
          end
        } = this.valueRange;
        const {
          src
        } = this.context;
        let ch = src[end - 1];
        while (start < end && (ch === "\n" || ch === "	" || ch === " ")) ch = src[--end - 1];
        let str2 = "";
        for (let i = start; i < end; ++i) {
          const ch2 = src[i];
          if (ch2 === "\n") {
            const {
              fold,
              offset
            } = Node.foldNewline(src, i, -1);
            str2 += fold;
            i = offset;
          } else if (ch2 === " " || ch2 === "	") {
            const wsStart = i;
            let next = src[i + 1];
            while (i < end && (next === " " || next === "	")) {
              i += 1;
              next = src[i + 1];
            }
            if (next !== "\n") str2 += i > wsStart ? src.slice(wsStart, i + 1) : ch2;
          } else {
            str2 += ch2;
          }
        }
        const ch0 = src[start];
        switch (ch0) {
          case "	": {
            const msg = "Plain value cannot start with a tab character";
            const errors = [new YAMLSemanticError(this, msg)];
            return {
              errors,
              str: str2
            };
          }
          case "@":
          case "`": {
            const msg = `Plain value cannot start with reserved character ${ch0}`;
            const errors = [new YAMLSemanticError(this, msg)];
            return {
              errors,
              str: str2
            };
          }
          default:
            return str2;
        }
      }
      parseBlockValue(start) {
        const {
          indent,
          inFlow,
          src
        } = this.context;
        let offset = start;
        let valueEnd = start;
        for (let ch = src[offset]; ch === "\n"; ch = src[offset]) {
          if (Node.atDocumentBoundary(src, offset + 1)) break;
          const end = Node.endOfBlockIndent(src, indent, offset + 1);
          if (end === null || src[end] === "#") break;
          if (src[end] === "\n") {
            offset = end;
          } else {
            valueEnd = _PlainValue.endOfLine(src, end, inFlow);
            offset = valueEnd;
          }
        }
        if (this.valueRange.isEmpty()) this.valueRange.start = start;
        this.valueRange.end = valueEnd;
        return valueEnd;
      }
      /**
       * Parses a plain value from the source
       *
       * Accepted forms are:
       * ```
       * #comment
       *
       * first line
       *
       * first line #comment
       *
       * first line
       * block
       * lines
       *
       * #comment
       * block
       * lines
       * ```
       * where block lines are empty or have an indent level greater than `indent`.
       *
       * @param {ParseContext} context
       * @param {number} start - Index of first character
       * @returns {number} - Index of the character after this scalar, may be `\n`
       */
      parse(context, start) {
        this.context = context;
        const {
          inFlow,
          src
        } = context;
        let offset = start;
        const ch = src[offset];
        if (ch && ch !== "#" && ch !== "\n") {
          offset = _PlainValue.endOfLine(src, start, inFlow);
        }
        this.valueRange = new Range(start, offset);
        offset = Node.endOfWhiteSpace(src, offset);
        offset = this.parseComment(offset);
        if (!this.hasComment || this.valueRange.isEmpty()) {
          offset = this.parseBlockValue(offset);
        }
        return offset;
      }
    };
    exports2.Char = Char;
    exports2.Node = Node;
    exports2.PlainValue = PlainValue;
    exports2.Range = Range;
    exports2.Type = Type2;
    exports2.YAMLError = YAMLError;
    exports2.YAMLReferenceError = YAMLReferenceError;
    exports2.YAMLSemanticError = YAMLSemanticError;
    exports2.YAMLSyntaxError = YAMLSyntaxError;
    exports2.YAMLWarning = YAMLWarning;
    exports2._defineProperty = _defineProperty;
    exports2.defaultTagPrefix = defaultTagPrefix;
    exports2.defaultTags = defaultTags;
  }
});

// node_modules/swagger2openapi/node_modules/yaml/dist/parse-cst.js
var require_parse_cst = __commonJS({
  "node_modules/swagger2openapi/node_modules/yaml/dist/parse-cst.js"(exports2) {
    "use strict";
    var PlainValue = require_PlainValue_ec8e588e();
    var BlankLine = class extends PlainValue.Node {
      constructor() {
        super(PlainValue.Type.BLANK_LINE);
      }
      /* istanbul ignore next */
      get includesTrailingLines() {
        return true;
      }
      /**
       * Parses a blank line from the source
       *
       * @param {ParseContext} context
       * @param {number} start - Index of first \n character
       * @returns {number} - Index of the character after this
       */
      parse(context, start) {
        this.context = context;
        this.range = new PlainValue.Range(start, start + 1);
        return start + 1;
      }
    };
    var CollectionItem = class extends PlainValue.Node {
      constructor(type2, props) {
        super(type2, props);
        this.node = null;
      }
      get includesTrailingLines() {
        return !!this.node && this.node.includesTrailingLines;
      }
      /**
       * @param {ParseContext} context
       * @param {number} start - Index of first character
       * @returns {number} - Index of the character after this
       */
      parse(context, start) {
        this.context = context;
        const {
          parseNode,
          src
        } = context;
        let {
          atLineStart,
          lineStart
        } = context;
        if (!atLineStart && this.type === PlainValue.Type.SEQ_ITEM) this.error = new PlainValue.YAMLSemanticError(this, "Sequence items must not have preceding content on the same line");
        const indent = atLineStart ? start - lineStart : context.indent;
        let offset = PlainValue.Node.endOfWhiteSpace(src, start + 1);
        let ch = src[offset];
        const inlineComment = ch === "#";
        const comments = [];
        let blankLine = null;
        while (ch === "\n" || ch === "#") {
          if (ch === "#") {
            const end2 = PlainValue.Node.endOfLine(src, offset + 1);
            comments.push(new PlainValue.Range(offset, end2));
            offset = end2;
          } else {
            atLineStart = true;
            lineStart = offset + 1;
            const wsEnd = PlainValue.Node.endOfWhiteSpace(src, lineStart);
            if (src[wsEnd] === "\n" && comments.length === 0) {
              blankLine = new BlankLine();
              lineStart = blankLine.parse({
                src
              }, lineStart);
            }
            offset = PlainValue.Node.endOfIndent(src, lineStart);
          }
          ch = src[offset];
        }
        if (PlainValue.Node.nextNodeIsIndented(ch, offset - (lineStart + indent), this.type !== PlainValue.Type.SEQ_ITEM)) {
          this.node = parseNode({
            atLineStart,
            inCollection: false,
            indent,
            lineStart,
            parent: this
          }, offset);
        } else if (ch && lineStart > start + 1) {
          offset = lineStart - 1;
        }
        if (this.node) {
          if (blankLine) {
            const items = context.parent.items || context.parent.contents;
            if (items) items.push(blankLine);
          }
          if (comments.length) Array.prototype.push.apply(this.props, comments);
          offset = this.node.range.end;
        } else {
          if (inlineComment) {
            const c2 = comments[0];
            this.props.push(c2);
            offset = c2.end;
          } else {
            offset = PlainValue.Node.endOfLine(src, start + 1);
          }
        }
        const end = this.node ? this.node.valueRange.end : offset;
        this.valueRange = new PlainValue.Range(start, end);
        return offset;
      }
      setOrigRanges(cr, offset) {
        offset = super.setOrigRanges(cr, offset);
        return this.node ? this.node.setOrigRanges(cr, offset) : offset;
      }
      toString() {
        const {
          context: {
            src
          },
          node: node2,
          range,
          value
        } = this;
        if (value != null) return value;
        const str2 = node2 ? src.slice(range.start, node2.range.start) + String(node2) : src.slice(range.start, range.end);
        return PlainValue.Node.addStringTerminator(src, range.end, str2);
      }
    };
    var Comment = class extends PlainValue.Node {
      constructor() {
        super(PlainValue.Type.COMMENT);
      }
      /**
       * Parses a comment line from the source
       *
       * @param {ParseContext} context
       * @param {number} start - Index of first character
       * @returns {number} - Index of the character after this scalar
       */
      parse(context, start) {
        this.context = context;
        const offset = this.parseComment(start);
        this.range = new PlainValue.Range(start, offset);
        return offset;
      }
    };
    function grabCollectionEndComments(node2) {
      let cnode = node2;
      while (cnode instanceof CollectionItem) cnode = cnode.node;
      if (!(cnode instanceof Collection)) return null;
      const len = cnode.items.length;
      let ci = -1;
      for (let i = len - 1; i >= 0; --i) {
        const n = cnode.items[i];
        if (n.type === PlainValue.Type.COMMENT) {
          const {
            indent,
            lineStart
          } = n.context;
          if (indent > 0 && n.range.start >= lineStart + indent) break;
          ci = i;
        } else if (n.type === PlainValue.Type.BLANK_LINE) ci = i;
        else break;
      }
      if (ci === -1) return null;
      const ca = cnode.items.splice(ci, len - ci);
      const prevEnd = ca[0].range.start;
      while (true) {
        cnode.range.end = prevEnd;
        if (cnode.valueRange && cnode.valueRange.end > prevEnd) cnode.valueRange.end = prevEnd;
        if (cnode === node2) break;
        cnode = cnode.context.parent;
      }
      return ca;
    }
    var Collection = class _Collection extends PlainValue.Node {
      static nextContentHasIndent(src, offset, indent) {
        const lineStart = PlainValue.Node.endOfLine(src, offset) + 1;
        offset = PlainValue.Node.endOfWhiteSpace(src, lineStart);
        const ch = src[offset];
        if (!ch) return false;
        if (offset >= lineStart + indent) return true;
        if (ch !== "#" && ch !== "\n") return false;
        return _Collection.nextContentHasIndent(src, offset, indent);
      }
      constructor(firstItem) {
        super(firstItem.type === PlainValue.Type.SEQ_ITEM ? PlainValue.Type.SEQ : PlainValue.Type.MAP);
        for (let i = firstItem.props.length - 1; i >= 0; --i) {
          if (firstItem.props[i].start < firstItem.context.lineStart) {
            this.props = firstItem.props.slice(0, i + 1);
            firstItem.props = firstItem.props.slice(i + 1);
            const itemRange = firstItem.props[0] || firstItem.valueRange;
            firstItem.range.start = itemRange.start;
            break;
          }
        }
        this.items = [firstItem];
        const ec = grabCollectionEndComments(firstItem);
        if (ec) Array.prototype.push.apply(this.items, ec);
      }
      get includesTrailingLines() {
        return this.items.length > 0;
      }
      /**
       * @param {ParseContext} context
       * @param {number} start - Index of first character
       * @returns {number} - Index of the character after this
       */
      parse(context, start) {
        this.context = context;
        const {
          parseNode,
          src
        } = context;
        let lineStart = PlainValue.Node.startOfLine(src, start);
        const firstItem = this.items[0];
        firstItem.context.parent = this;
        this.valueRange = PlainValue.Range.copy(firstItem.valueRange);
        const indent = firstItem.range.start - firstItem.context.lineStart;
        let offset = start;
        offset = PlainValue.Node.normalizeOffset(src, offset);
        let ch = src[offset];
        let atLineStart = PlainValue.Node.endOfWhiteSpace(src, lineStart) === offset;
        let prevIncludesTrailingLines = false;
        while (ch) {
          while (ch === "\n" || ch === "#") {
            if (atLineStart && ch === "\n" && !prevIncludesTrailingLines) {
              const blankLine = new BlankLine();
              offset = blankLine.parse({
                src
              }, offset);
              this.valueRange.end = offset;
              if (offset >= src.length) {
                ch = null;
                break;
              }
              this.items.push(blankLine);
              offset -= 1;
            } else if (ch === "#") {
              if (offset < lineStart + indent && !_Collection.nextContentHasIndent(src, offset, indent)) {
                return offset;
              }
              const comment = new Comment();
              offset = comment.parse({
                indent,
                lineStart,
                src
              }, offset);
              this.items.push(comment);
              this.valueRange.end = offset;
              if (offset >= src.length) {
                ch = null;
                break;
              }
            }
            lineStart = offset + 1;
            offset = PlainValue.Node.endOfIndent(src, lineStart);
            if (PlainValue.Node.atBlank(src, offset)) {
              const wsEnd = PlainValue.Node.endOfWhiteSpace(src, offset);
              const next = src[wsEnd];
              if (!next || next === "\n" || next === "#") {
                offset = wsEnd;
              }
            }
            ch = src[offset];
            atLineStart = true;
          }
          if (!ch) {
            break;
          }
          if (offset !== lineStart + indent && (atLineStart || ch !== ":")) {
            if (offset < lineStart + indent) {
              if (lineStart > start) offset = lineStart;
              break;
            } else if (!this.error) {
              const msg = "All collection items must start at the same column";
              this.error = new PlainValue.YAMLSyntaxError(this, msg);
            }
          }
          if (firstItem.type === PlainValue.Type.SEQ_ITEM) {
            if (ch !== "-") {
              if (lineStart > start) offset = lineStart;
              break;
            }
          } else if (ch === "-" && !this.error) {
            const next = src[offset + 1];
            if (!next || next === "\n" || next === "	" || next === " ") {
              const msg = "A collection cannot be both a mapping and a sequence";
              this.error = new PlainValue.YAMLSyntaxError(this, msg);
            }
          }
          const node2 = parseNode({
            atLineStart,
            inCollection: true,
            indent,
            lineStart,
            parent: this
          }, offset);
          if (!node2) return offset;
          this.items.push(node2);
          this.valueRange.end = node2.valueRange.end;
          offset = PlainValue.Node.normalizeOffset(src, node2.range.end);
          ch = src[offset];
          atLineStart = false;
          prevIncludesTrailingLines = node2.includesTrailingLines;
          if (ch) {
            let ls = offset - 1;
            let prev = src[ls];
            while (prev === " " || prev === "	") prev = src[--ls];
            if (prev === "\n") {
              lineStart = ls + 1;
              atLineStart = true;
            }
          }
          const ec = grabCollectionEndComments(node2);
          if (ec) Array.prototype.push.apply(this.items, ec);
        }
        return offset;
      }
      setOrigRanges(cr, offset) {
        offset = super.setOrigRanges(cr, offset);
        this.items.forEach((node2) => {
          offset = node2.setOrigRanges(cr, offset);
        });
        return offset;
      }
      toString() {
        const {
          context: {
            src
          },
          items,
          range,
          value
        } = this;
        if (value != null) return value;
        let str2 = src.slice(range.start, items[0].range.start) + String(items[0]);
        for (let i = 1; i < items.length; ++i) {
          const item = items[i];
          const {
            atLineStart,
            indent
          } = item.context;
          if (atLineStart) for (let i2 = 0; i2 < indent; ++i2) str2 += " ";
          str2 += String(item);
        }
        return PlainValue.Node.addStringTerminator(src, range.end, str2);
      }
    };
    var Directive = class extends PlainValue.Node {
      constructor() {
        super(PlainValue.Type.DIRECTIVE);
        this.name = null;
      }
      get parameters() {
        const raw = this.rawValue;
        return raw ? raw.trim().split(/[ \t]+/) : [];
      }
      parseName(start) {
        const {
          src
        } = this.context;
        let offset = start;
        let ch = src[offset];
        while (ch && ch !== "\n" && ch !== "	" && ch !== " ") ch = src[offset += 1];
        this.name = src.slice(start, offset);
        return offset;
      }
      parseParameters(start) {
        const {
          src
        } = this.context;
        let offset = start;
        let ch = src[offset];
        while (ch && ch !== "\n" && ch !== "#") ch = src[offset += 1];
        this.valueRange = new PlainValue.Range(start, offset);
        return offset;
      }
      parse(context, start) {
        this.context = context;
        let offset = this.parseName(start + 1);
        offset = this.parseParameters(offset);
        offset = this.parseComment(offset);
        this.range = new PlainValue.Range(start, offset);
        return offset;
      }
    };
    var Document = class _Document extends PlainValue.Node {
      static startCommentOrEndBlankLine(src, start) {
        const offset = PlainValue.Node.endOfWhiteSpace(src, start);
        const ch = src[offset];
        return ch === "#" || ch === "\n" ? offset : start;
      }
      constructor() {
        super(PlainValue.Type.DOCUMENT);
        this.directives = null;
        this.contents = null;
        this.directivesEndMarker = null;
        this.documentEndMarker = null;
      }
      parseDirectives(start) {
        const {
          src
        } = this.context;
        this.directives = [];
        let atLineStart = true;
        let hasDirectives = false;
        let offset = start;
        while (!PlainValue.Node.atDocumentBoundary(src, offset, PlainValue.Char.DIRECTIVES_END)) {
          offset = _Document.startCommentOrEndBlankLine(src, offset);
          switch (src[offset]) {
            case "\n":
              if (atLineStart) {
                const blankLine = new BlankLine();
                offset = blankLine.parse({
                  src
                }, offset);
                if (offset < src.length) {
                  this.directives.push(blankLine);
                }
              } else {
                offset += 1;
                atLineStart = true;
              }
              break;
            case "#":
              {
                const comment = new Comment();
                offset = comment.parse({
                  src
                }, offset);
                this.directives.push(comment);
                atLineStart = false;
              }
              break;
            case "%":
              {
                const directive = new Directive();
                offset = directive.parse({
                  parent: this,
                  src
                }, offset);
                this.directives.push(directive);
                hasDirectives = true;
                atLineStart = false;
              }
              break;
            default:
              if (hasDirectives) {
                this.error = new PlainValue.YAMLSemanticError(this, "Missing directives-end indicator line");
              } else if (this.directives.length > 0) {
                this.contents = this.directives;
                this.directives = [];
              }
              return offset;
          }
        }
        if (src[offset]) {
          this.directivesEndMarker = new PlainValue.Range(offset, offset + 3);
          return offset + 3;
        }
        if (hasDirectives) {
          this.error = new PlainValue.YAMLSemanticError(this, "Missing directives-end indicator line");
        } else if (this.directives.length > 0) {
          this.contents = this.directives;
          this.directives = [];
        }
        return offset;
      }
      parseContents(start) {
        const {
          parseNode,
          src
        } = this.context;
        if (!this.contents) this.contents = [];
        let lineStart = start;
        while (src[lineStart - 1] === "-") lineStart -= 1;
        let offset = PlainValue.Node.endOfWhiteSpace(src, start);
        let atLineStart = lineStart === start;
        this.valueRange = new PlainValue.Range(offset);
        while (!PlainValue.Node.atDocumentBoundary(src, offset, PlainValue.Char.DOCUMENT_END)) {
          switch (src[offset]) {
            case "\n":
              if (atLineStart) {
                const blankLine = new BlankLine();
                offset = blankLine.parse({
                  src
                }, offset);
                if (offset < src.length) {
                  this.contents.push(blankLine);
                }
              } else {
                offset += 1;
                atLineStart = true;
              }
              lineStart = offset;
              break;
            case "#":
              {
                const comment = new Comment();
                offset = comment.parse({
                  src
                }, offset);
                this.contents.push(comment);
                atLineStart = false;
              }
              break;
            default: {
              const iEnd = PlainValue.Node.endOfIndent(src, offset);
              const context = {
                atLineStart,
                indent: -1,
                inFlow: false,
                inCollection: false,
                lineStart,
                parent: this
              };
              const node2 = parseNode(context, iEnd);
              if (!node2) return this.valueRange.end = iEnd;
              this.contents.push(node2);
              offset = node2.range.end;
              atLineStart = false;
              const ec = grabCollectionEndComments(node2);
              if (ec) Array.prototype.push.apply(this.contents, ec);
            }
          }
          offset = _Document.startCommentOrEndBlankLine(src, offset);
        }
        this.valueRange.end = offset;
        if (src[offset]) {
          this.documentEndMarker = new PlainValue.Range(offset, offset + 3);
          offset += 3;
          if (src[offset]) {
            offset = PlainValue.Node.endOfWhiteSpace(src, offset);
            if (src[offset] === "#") {
              const comment = new Comment();
              offset = comment.parse({
                src
              }, offset);
              this.contents.push(comment);
            }
            switch (src[offset]) {
              case "\n":
                offset += 1;
                break;
              case void 0:
                break;
              default:
                this.error = new PlainValue.YAMLSyntaxError(this, "Document end marker line cannot have a non-comment suffix");
            }
          }
        }
        return offset;
      }
      /**
       * @param {ParseContext} context
       * @param {number} start - Index of first character
       * @returns {number} - Index of the character after this
       */
      parse(context, start) {
        context.root = this;
        this.context = context;
        const {
          src
        } = context;
        let offset = src.charCodeAt(start) === 65279 ? start + 1 : start;
        offset = this.parseDirectives(offset);
        offset = this.parseContents(offset);
        return offset;
      }
      setOrigRanges(cr, offset) {
        offset = super.setOrigRanges(cr, offset);
        this.directives.forEach((node2) => {
          offset = node2.setOrigRanges(cr, offset);
        });
        if (this.directivesEndMarker) offset = this.directivesEndMarker.setOrigRange(cr, offset);
        this.contents.forEach((node2) => {
          offset = node2.setOrigRanges(cr, offset);
        });
        if (this.documentEndMarker) offset = this.documentEndMarker.setOrigRange(cr, offset);
        return offset;
      }
      toString() {
        const {
          contents,
          directives,
          value
        } = this;
        if (value != null) return value;
        let str2 = directives.join("");
        if (contents.length > 0) {
          if (directives.length > 0 || contents[0].type === PlainValue.Type.COMMENT) str2 += "---\n";
          str2 += contents.join("");
        }
        if (str2[str2.length - 1] !== "\n") str2 += "\n";
        return str2;
      }
    };
    var Alias = class extends PlainValue.Node {
      /**
       * Parses an *alias from the source
       *
       * @param {ParseContext} context
       * @param {number} start - Index of first character
       * @returns {number} - Index of the character after this scalar
       */
      parse(context, start) {
        this.context = context;
        const {
          src
        } = context;
        let offset = PlainValue.Node.endOfIdentifier(src, start + 1);
        this.valueRange = new PlainValue.Range(start + 1, offset);
        offset = PlainValue.Node.endOfWhiteSpace(src, offset);
        offset = this.parseComment(offset);
        return offset;
      }
    };
    var Chomp = {
      CLIP: "CLIP",
      KEEP: "KEEP",
      STRIP: "STRIP"
    };
    var BlockValue = class extends PlainValue.Node {
      constructor(type2, props) {
        super(type2, props);
        this.blockIndent = null;
        this.chomping = Chomp.CLIP;
        this.header = null;
      }
      get includesTrailingLines() {
        return this.chomping === Chomp.KEEP;
      }
      get strValue() {
        if (!this.valueRange || !this.context) return null;
        let {
          start,
          end
        } = this.valueRange;
        const {
          indent,
          src
        } = this.context;
        if (this.valueRange.isEmpty()) return "";
        let lastNewLine = null;
        let ch = src[end - 1];
        while (ch === "\n" || ch === "	" || ch === " ") {
          end -= 1;
          if (end <= start) {
            if (this.chomping === Chomp.KEEP) break;
            else return "";
          }
          if (ch === "\n") lastNewLine = end;
          ch = src[end - 1];
        }
        let keepStart = end + 1;
        if (lastNewLine) {
          if (this.chomping === Chomp.KEEP) {
            keepStart = lastNewLine;
            end = this.valueRange.end;
          } else {
            end = lastNewLine;
          }
        }
        const bi = indent + this.blockIndent;
        const folded = this.type === PlainValue.Type.BLOCK_FOLDED;
        let atStart = true;
        let str2 = "";
        let sep = "";
        let prevMoreIndented = false;
        for (let i = start; i < end; ++i) {
          for (let j = 0; j < bi; ++j) {
            if (src[i] !== " ") break;
            i += 1;
          }
          const ch2 = src[i];
          if (ch2 === "\n") {
            if (sep === "\n") str2 += "\n";
            else sep = "\n";
          } else {
            const lineEnd = PlainValue.Node.endOfLine(src, i);
            const line = src.slice(i, lineEnd);
            i = lineEnd;
            if (folded && (ch2 === " " || ch2 === "	") && i < keepStart) {
              if (sep === " ") sep = "\n";
              else if (!prevMoreIndented && !atStart && sep === "\n") sep = "\n\n";
              str2 += sep + line;
              sep = lineEnd < end && src[lineEnd] || "";
              prevMoreIndented = true;
            } else {
              str2 += sep + line;
              sep = folded && i < keepStart ? " " : "\n";
              prevMoreIndented = false;
            }
            if (atStart && line !== "") atStart = false;
          }
        }
        return this.chomping === Chomp.STRIP ? str2 : str2 + "\n";
      }
      parseBlockHeader(start) {
        const {
          src
        } = this.context;
        let offset = start + 1;
        let bi = "";
        while (true) {
          const ch = src[offset];
          switch (ch) {
            case "-":
              this.chomping = Chomp.STRIP;
              break;
            case "+":
              this.chomping = Chomp.KEEP;
              break;
            case "0":
            case "1":
            case "2":
            case "3":
            case "4":
            case "5":
            case "6":
            case "7":
            case "8":
            case "9":
              bi += ch;
              break;
            default:
              this.blockIndent = Number(bi) || null;
              this.header = new PlainValue.Range(start, offset);
              return offset;
          }
          offset += 1;
        }
      }
      parseBlockValue(start) {
        const {
          indent,
          src
        } = this.context;
        const explicit = !!this.blockIndent;
        let offset = start;
        let valueEnd = start;
        let minBlockIndent = 1;
        for (let ch = src[offset]; ch === "\n"; ch = src[offset]) {
          offset += 1;
          if (PlainValue.Node.atDocumentBoundary(src, offset)) break;
          const end = PlainValue.Node.endOfBlockIndent(src, indent, offset);
          if (end === null) break;
          const ch2 = src[end];
          const lineIndent = end - (offset + indent);
          if (!this.blockIndent) {
            if (src[end] !== "\n") {
              if (lineIndent < minBlockIndent) {
                const msg = "Block scalars with more-indented leading empty lines must use an explicit indentation indicator";
                this.error = new PlainValue.YAMLSemanticError(this, msg);
              }
              this.blockIndent = lineIndent;
            } else if (lineIndent > minBlockIndent) {
              minBlockIndent = lineIndent;
            }
          } else if (ch2 && ch2 !== "\n" && lineIndent < this.blockIndent) {
            if (src[end] === "#") break;
            if (!this.error) {
              const src2 = explicit ? "explicit indentation indicator" : "first line";
              const msg = `Block scalars must not be less indented than their ${src2}`;
              this.error = new PlainValue.YAMLSemanticError(this, msg);
            }
          }
          if (src[end] === "\n") {
            offset = end;
          } else {
            offset = valueEnd = PlainValue.Node.endOfLine(src, end);
          }
        }
        if (this.chomping !== Chomp.KEEP) {
          offset = src[valueEnd] ? valueEnd + 1 : valueEnd;
        }
        this.valueRange = new PlainValue.Range(start + 1, offset);
        return offset;
      }
      /**
       * Parses a block value from the source
       *
       * Accepted forms are:
       * ```
       * BS
       * block
       * lines
       *
       * BS #comment
       * block
       * lines
       * ```
       * where the block style BS matches the regexp `[|>][-+1-9]*` and block lines
       * are empty or have an indent level greater than `indent`.
       *
       * @param {ParseContext} context
       * @param {number} start - Index of first character
       * @returns {number} - Index of the character after this block
       */
      parse(context, start) {
        this.context = context;
        const {
          src
        } = context;
        let offset = this.parseBlockHeader(start);
        offset = PlainValue.Node.endOfWhiteSpace(src, offset);
        offset = this.parseComment(offset);
        offset = this.parseBlockValue(offset);
        return offset;
      }
      setOrigRanges(cr, offset) {
        offset = super.setOrigRanges(cr, offset);
        return this.header ? this.header.setOrigRange(cr, offset) : offset;
      }
    };
    var FlowCollection = class extends PlainValue.Node {
      constructor(type2, props) {
        super(type2, props);
        this.items = null;
      }
      prevNodeIsJsonLike(idx = this.items.length) {
        const node2 = this.items[idx - 1];
        return !!node2 && (node2.jsonLike || node2.type === PlainValue.Type.COMMENT && this.prevNodeIsJsonLike(idx - 1));
      }
      /**
       * @param {ParseContext} context
       * @param {number} start - Index of first character
       * @returns {number} - Index of the character after this
       */
      parse(context, start) {
        this.context = context;
        const {
          parseNode,
          src
        } = context;
        let {
          indent,
          lineStart
        } = context;
        let char = src[start];
        this.items = [{
          char,
          offset: start
        }];
        let offset = PlainValue.Node.endOfWhiteSpace(src, start + 1);
        char = src[offset];
        while (char && char !== "]" && char !== "}") {
          switch (char) {
            case "\n":
              {
                lineStart = offset + 1;
                const wsEnd = PlainValue.Node.endOfWhiteSpace(src, lineStart);
                if (src[wsEnd] === "\n") {
                  const blankLine = new BlankLine();
                  lineStart = blankLine.parse({
                    src
                  }, lineStart);
                  this.items.push(blankLine);
                }
                offset = PlainValue.Node.endOfIndent(src, lineStart);
                if (offset <= lineStart + indent) {
                  char = src[offset];
                  if (offset < lineStart + indent || char !== "]" && char !== "}") {
                    const msg = "Insufficient indentation in flow collection";
                    this.error = new PlainValue.YAMLSemanticError(this, msg);
                  }
                }
              }
              break;
            case ",":
              {
                this.items.push({
                  char,
                  offset
                });
                offset += 1;
              }
              break;
            case "#":
              {
                const comment = new Comment();
                offset = comment.parse({
                  src
                }, offset);
                this.items.push(comment);
              }
              break;
            case "?":
            case ":": {
              const next = src[offset + 1];
              if (next === "\n" || next === "	" || next === " " || next === "," || // in-flow : after JSON-like key does not need to be followed by whitespace
              char === ":" && this.prevNodeIsJsonLike()) {
                this.items.push({
                  char,
                  offset
                });
                offset += 1;
                break;
              }
            }
            default: {
              const node2 = parseNode({
                atLineStart: false,
                inCollection: false,
                inFlow: true,
                indent: -1,
                lineStart,
                parent: this
              }, offset);
              if (!node2) {
                this.valueRange = new PlainValue.Range(start, offset);
                return offset;
              }
              this.items.push(node2);
              offset = PlainValue.Node.normalizeOffset(src, node2.range.end);
            }
          }
          offset = PlainValue.Node.endOfWhiteSpace(src, offset);
          char = src[offset];
        }
        this.valueRange = new PlainValue.Range(start, offset + 1);
        if (char) {
          this.items.push({
            char,
            offset
          });
          offset = PlainValue.Node.endOfWhiteSpace(src, offset + 1);
          offset = this.parseComment(offset);
        }
        return offset;
      }
      setOrigRanges(cr, offset) {
        offset = super.setOrigRanges(cr, offset);
        this.items.forEach((node2) => {
          if (node2 instanceof PlainValue.Node) {
            offset = node2.setOrigRanges(cr, offset);
          } else if (cr.length === 0) {
            node2.origOffset = node2.offset;
          } else {
            let i = offset;
            while (i < cr.length) {
              if (cr[i] > node2.offset) break;
              else ++i;
            }
            node2.origOffset = node2.offset + i;
            offset = i;
          }
        });
        return offset;
      }
      toString() {
        const {
          context: {
            src
          },
          items,
          range,
          value
        } = this;
        if (value != null) return value;
        const nodes = items.filter((item) => item instanceof PlainValue.Node);
        let str2 = "";
        let prevEnd = range.start;
        nodes.forEach((node2) => {
          const prefix = src.slice(prevEnd, node2.range.start);
          prevEnd = node2.range.end;
          str2 += prefix + String(node2);
          if (str2[str2.length - 1] === "\n" && src[prevEnd - 1] !== "\n" && src[prevEnd] === "\n") {
            prevEnd += 1;
          }
        });
        str2 += src.slice(prevEnd, range.end);
        return PlainValue.Node.addStringTerminator(src, range.end, str2);
      }
    };
    var QuoteDouble = class _QuoteDouble extends PlainValue.Node {
      static endOfQuote(src, offset) {
        let ch = src[offset];
        while (ch && ch !== '"') {
          offset += ch === "\\" ? 2 : 1;
          ch = src[offset];
        }
        return offset + 1;
      }
      /**
       * @returns {string | { str: string, errors: YAMLSyntaxError[] }}
       */
      get strValue() {
        if (!this.valueRange || !this.context) return null;
        const errors = [];
        const {
          start,
          end
        } = this.valueRange;
        const {
          indent,
          src
        } = this.context;
        if (src[end - 1] !== '"') errors.push(new PlainValue.YAMLSyntaxError(this, 'Missing closing "quote'));
        let str2 = "";
        for (let i = start + 1; i < end - 1; ++i) {
          const ch = src[i];
          if (ch === "\n") {
            if (PlainValue.Node.atDocumentBoundary(src, i + 1)) errors.push(new PlainValue.YAMLSemanticError(this, "Document boundary indicators are not allowed within string values"));
            const {
              fold,
              offset,
              error
            } = PlainValue.Node.foldNewline(src, i, indent);
            str2 += fold;
            i = offset;
            if (error) errors.push(new PlainValue.YAMLSemanticError(this, "Multi-line double-quoted string needs to be sufficiently indented"));
          } else if (ch === "\\") {
            i += 1;
            switch (src[i]) {
              case "0":
                str2 += "\0";
                break;
              case "a":
                str2 += "\x07";
                break;
              case "b":
                str2 += "\b";
                break;
              case "e":
                str2 += "\x1B";
                break;
              case "f":
                str2 += "\f";
                break;
              case "n":
                str2 += "\n";
                break;
              case "r":
                str2 += "\r";
                break;
              case "t":
                str2 += "	";
                break;
              case "v":
                str2 += "\v";
                break;
              case "N":
                str2 += "\x85";
                break;
              case "_":
                str2 += "\xA0";
                break;
              case "L":
                str2 += "\u2028";
                break;
              case "P":
                str2 += "\u2029";
                break;
              case " ":
                str2 += " ";
                break;
              case '"':
                str2 += '"';
                break;
              case "/":
                str2 += "/";
                break;
              case "\\":
                str2 += "\\";
                break;
              case "	":
                str2 += "	";
                break;
              case "x":
                str2 += this.parseCharCode(i + 1, 2, errors);
                i += 2;
                break;
              case "u":
                str2 += this.parseCharCode(i + 1, 4, errors);
                i += 4;
                break;
              case "U":
                str2 += this.parseCharCode(i + 1, 8, errors);
                i += 8;
                break;
              case "\n":
                while (src[i + 1] === " " || src[i + 1] === "	") i += 1;
                break;
              default:
                errors.push(new PlainValue.YAMLSyntaxError(this, `Invalid escape sequence ${src.substr(i - 1, 2)}`));
                str2 += "\\" + src[i];
            }
          } else if (ch === " " || ch === "	") {
            const wsStart = i;
            let next = src[i + 1];
            while (next === " " || next === "	") {
              i += 1;
              next = src[i + 1];
            }
            if (next !== "\n") str2 += i > wsStart ? src.slice(wsStart, i + 1) : ch;
          } else {
            str2 += ch;
          }
        }
        return errors.length > 0 ? {
          errors,
          str: str2
        } : str2;
      }
      parseCharCode(offset, length, errors) {
        const {
          src
        } = this.context;
        const cc = src.substr(offset, length);
        const ok = cc.length === length && /^[0-9a-fA-F]+$/.test(cc);
        const code = ok ? parseInt(cc, 16) : NaN;
        if (isNaN(code)) {
          errors.push(new PlainValue.YAMLSyntaxError(this, `Invalid escape sequence ${src.substr(offset - 2, length + 2)}`));
          return src.substr(offset - 2, length + 2);
        }
        return String.fromCodePoint(code);
      }
      /**
       * Parses a "double quoted" value from the source
       *
       * @param {ParseContext} context
       * @param {number} start - Index of first character
       * @returns {number} - Index of the character after this scalar
       */
      parse(context, start) {
        this.context = context;
        const {
          src
        } = context;
        let offset = _QuoteDouble.endOfQuote(src, start + 1);
        this.valueRange = new PlainValue.Range(start, offset);
        offset = PlainValue.Node.endOfWhiteSpace(src, offset);
        offset = this.parseComment(offset);
        return offset;
      }
    };
    var QuoteSingle = class _QuoteSingle extends PlainValue.Node {
      static endOfQuote(src, offset) {
        let ch = src[offset];
        while (ch) {
          if (ch === "'") {
            if (src[offset + 1] !== "'") break;
            ch = src[offset += 2];
          } else {
            ch = src[offset += 1];
          }
        }
        return offset + 1;
      }
      /**
       * @returns {string | { str: string, errors: YAMLSyntaxError[] }}
       */
      get strValue() {
        if (!this.valueRange || !this.context) return null;
        const errors = [];
        const {
          start,
          end
        } = this.valueRange;
        const {
          indent,
          src
        } = this.context;
        if (src[end - 1] !== "'") errors.push(new PlainValue.YAMLSyntaxError(this, "Missing closing 'quote"));
        let str2 = "";
        for (let i = start + 1; i < end - 1; ++i) {
          const ch = src[i];
          if (ch === "\n") {
            if (PlainValue.Node.atDocumentBoundary(src, i + 1)) errors.push(new PlainValue.YAMLSemanticError(this, "Document boundary indicators are not allowed within string values"));
            const {
              fold,
              offset,
              error
            } = PlainValue.Node.foldNewline(src, i, indent);
            str2 += fold;
            i = offset;
            if (error) errors.push(new PlainValue.YAMLSemanticError(this, "Multi-line single-quoted string needs to be sufficiently indented"));
          } else if (ch === "'") {
            str2 += ch;
            i += 1;
            if (src[i] !== "'") errors.push(new PlainValue.YAMLSyntaxError(this, "Unescaped single quote? This should not happen."));
          } else if (ch === " " || ch === "	") {
            const wsStart = i;
            let next = src[i + 1];
            while (next === " " || next === "	") {
              i += 1;
              next = src[i + 1];
            }
            if (next !== "\n") str2 += i > wsStart ? src.slice(wsStart, i + 1) : ch;
          } else {
            str2 += ch;
          }
        }
        return errors.length > 0 ? {
          errors,
          str: str2
        } : str2;
      }
      /**
       * Parses a 'single quoted' value from the source
       *
       * @param {ParseContext} context
       * @param {number} start - Index of first character
       * @returns {number} - Index of the character after this scalar
       */
      parse(context, start) {
        this.context = context;
        const {
          src
        } = context;
        let offset = _QuoteSingle.endOfQuote(src, start + 1);
        this.valueRange = new PlainValue.Range(start, offset);
        offset = PlainValue.Node.endOfWhiteSpace(src, offset);
        offset = this.parseComment(offset);
        return offset;
      }
    };
    function createNewNode(type2, props) {
      switch (type2) {
        case PlainValue.Type.ALIAS:
          return new Alias(type2, props);
        case PlainValue.Type.BLOCK_FOLDED:
        case PlainValue.Type.BLOCK_LITERAL:
          return new BlockValue(type2, props);
        case PlainValue.Type.FLOW_MAP:
        case PlainValue.Type.FLOW_SEQ:
          return new FlowCollection(type2, props);
        case PlainValue.Type.MAP_KEY:
        case PlainValue.Type.MAP_VALUE:
        case PlainValue.Type.SEQ_ITEM:
          return new CollectionItem(type2, props);
        case PlainValue.Type.COMMENT:
        case PlainValue.Type.PLAIN:
          return new PlainValue.PlainValue(type2, props);
        case PlainValue.Type.QUOTE_DOUBLE:
          return new QuoteDouble(type2, props);
        case PlainValue.Type.QUOTE_SINGLE:
          return new QuoteSingle(type2, props);
        default:
          return null;
      }
    }
    var ParseContext = class _ParseContext {
      static parseType(src, offset, inFlow) {
        switch (src[offset]) {
          case "*":
            return PlainValue.Type.ALIAS;
          case ">":
            return PlainValue.Type.BLOCK_FOLDED;
          case "|":
            return PlainValue.Type.BLOCK_LITERAL;
          case "{":
            return PlainValue.Type.FLOW_MAP;
          case "[":
            return PlainValue.Type.FLOW_SEQ;
          case "?":
            return !inFlow && PlainValue.Node.atBlank(src, offset + 1, true) ? PlainValue.Type.MAP_KEY : PlainValue.Type.PLAIN;
          case ":":
            return !inFlow && PlainValue.Node.atBlank(src, offset + 1, true) ? PlainValue.Type.MAP_VALUE : PlainValue.Type.PLAIN;
          case "-":
            return !inFlow && PlainValue.Node.atBlank(src, offset + 1, true) ? PlainValue.Type.SEQ_ITEM : PlainValue.Type.PLAIN;
          case '"':
            return PlainValue.Type.QUOTE_DOUBLE;
          case "'":
            return PlainValue.Type.QUOTE_SINGLE;
          default:
            return PlainValue.Type.PLAIN;
        }
      }
      constructor(orig = {}, {
        atLineStart,
        inCollection,
        inFlow,
        indent,
        lineStart,
        parent
      } = {}) {
        PlainValue._defineProperty(this, "parseNode", (overlay, start) => {
          if (PlainValue.Node.atDocumentBoundary(this.src, start)) return null;
          const context = new _ParseContext(this, overlay);
          const {
            props,
            type: type2,
            valueStart
          } = context.parseProps(start);
          const node2 = createNewNode(type2, props);
          let offset = node2.parse(context, valueStart);
          node2.range = new PlainValue.Range(start, offset);
          if (offset <= start) {
            node2.error = new Error(`Node#parse consumed no characters`);
            node2.error.parseEnd = offset;
            node2.error.source = node2;
            node2.range.end = start + 1;
          }
          if (context.nodeStartsCollection(node2)) {
            if (!node2.error && !context.atLineStart && context.parent.type === PlainValue.Type.DOCUMENT) {
              node2.error = new PlainValue.YAMLSyntaxError(node2, "Block collection must not have preceding content here (e.g. directives-end indicator)");
            }
            const collection = new Collection(node2);
            offset = collection.parse(new _ParseContext(context), offset);
            collection.range = new PlainValue.Range(start, offset);
            return collection;
          }
          return node2;
        });
        this.atLineStart = atLineStart != null ? atLineStart : orig.atLineStart || false;
        this.inCollection = inCollection != null ? inCollection : orig.inCollection || false;
        this.inFlow = inFlow != null ? inFlow : orig.inFlow || false;
        this.indent = indent != null ? indent : orig.indent;
        this.lineStart = lineStart != null ? lineStart : orig.lineStart;
        this.parent = parent != null ? parent : orig.parent || {};
        this.root = orig.root;
        this.src = orig.src;
      }
      nodeStartsCollection(node2) {
        const {
          inCollection,
          inFlow,
          src
        } = this;
        if (inCollection || inFlow) return false;
        if (node2 instanceof CollectionItem) return true;
        let offset = node2.range.end;
        if (src[offset] === "\n" || src[offset - 1] === "\n") return false;
        offset = PlainValue.Node.endOfWhiteSpace(src, offset);
        return src[offset] === ":";
      }
      // Anchor and tag are before type, which determines the node implementation
      // class; hence this intermediate step.
      parseProps(offset) {
        const {
          inFlow,
          parent,
          src
        } = this;
        const props = [];
        let lineHasProps = false;
        offset = this.atLineStart ? PlainValue.Node.endOfIndent(src, offset) : PlainValue.Node.endOfWhiteSpace(src, offset);
        let ch = src[offset];
        while (ch === PlainValue.Char.ANCHOR || ch === PlainValue.Char.COMMENT || ch === PlainValue.Char.TAG || ch === "\n") {
          if (ch === "\n") {
            let inEnd = offset;
            let lineStart;
            do {
              lineStart = inEnd + 1;
              inEnd = PlainValue.Node.endOfIndent(src, lineStart);
            } while (src[inEnd] === "\n");
            const indentDiff = inEnd - (lineStart + this.indent);
            const noIndicatorAsIndent = parent.type === PlainValue.Type.SEQ_ITEM && parent.context.atLineStart;
            if (src[inEnd] !== "#" && !PlainValue.Node.nextNodeIsIndented(src[inEnd], indentDiff, !noIndicatorAsIndent)) break;
            this.atLineStart = true;
            this.lineStart = lineStart;
            lineHasProps = false;
            offset = inEnd;
          } else if (ch === PlainValue.Char.COMMENT) {
            const end = PlainValue.Node.endOfLine(src, offset + 1);
            props.push(new PlainValue.Range(offset, end));
            offset = end;
          } else {
            let end = PlainValue.Node.endOfIdentifier(src, offset + 1);
            if (ch === PlainValue.Char.TAG && src[end] === "," && /^[a-zA-Z0-9-]+\.[a-zA-Z0-9-]+,\d\d\d\d(-\d\d){0,2}\/\S/.test(src.slice(offset + 1, end + 13))) {
              end = PlainValue.Node.endOfIdentifier(src, end + 5);
            }
            props.push(new PlainValue.Range(offset, end));
            lineHasProps = true;
            offset = PlainValue.Node.endOfWhiteSpace(src, end);
          }
          ch = src[offset];
        }
        if (lineHasProps && ch === ":" && PlainValue.Node.atBlank(src, offset + 1, true)) offset -= 1;
        const type2 = _ParseContext.parseType(src, offset, inFlow);
        return {
          props,
          type: type2,
          valueStart: offset
        };
      }
      /**
       * Parses a node from the source
       * @param {ParseContext} overlay
       * @param {number} start - Index of first non-whitespace character for the node
       * @returns {?Node} - null if at a document boundary
       */
    };
    function parse6(src) {
      const cr = [];
      if (src.indexOf("\r") !== -1) {
        src = src.replace(/\r\n?/g, (match2, offset2) => {
          if (match2.length > 1) cr.push(offset2);
          return "\n";
        });
      }
      const documents = [];
      let offset = 0;
      do {
        const doc = new Document();
        const context = new ParseContext({
          src
        });
        offset = doc.parse(context, offset);
        documents.push(doc);
      } while (offset < src.length);
      documents.setOrigRanges = () => {
        if (cr.length === 0) return false;
        for (let i = 1; i < cr.length; ++i) cr[i] -= i;
        let crOffset = 0;
        for (let i = 0; i < documents.length; ++i) {
          crOffset = documents[i].setOrigRanges(cr, crOffset);
        }
        cr.splice(0, cr.length);
        return true;
      };
      documents.toString = () => documents.join("...\n");
      return documents;
    }
    exports2.parse = parse6;
  }
});

// node_modules/swagger2openapi/node_modules/yaml/dist/resolveSeq-d03cb037.js
var require_resolveSeq_d03cb037 = __commonJS({
  "node_modules/swagger2openapi/node_modules/yaml/dist/resolveSeq-d03cb037.js"(exports2) {
    "use strict";
    var PlainValue = require_PlainValue_ec8e588e();
    function addCommentBefore(str2, indent, comment) {
      if (!comment) return str2;
      const cc = comment.replace(/[\s\S]^/gm, `$&${indent}#`);
      return `#${cc}
${indent}${str2}`;
    }
    function addComment(str2, indent, comment) {
      return !comment ? str2 : comment.indexOf("\n") === -1 ? `${str2} #${comment}` : `${str2}
` + comment.replace(/^/gm, `${indent || ""}#`);
    }
    var Node = class {
    };
    function toJSON3(value, arg, ctx) {
      if (Array.isArray(value)) return value.map((v, i) => toJSON3(v, String(i), ctx));
      if (value && typeof value.toJSON === "function") {
        const anchor = ctx && ctx.anchors && ctx.anchors.get(value);
        if (anchor) ctx.onCreate = (res2) => {
          anchor.res = res2;
          delete ctx.onCreate;
        };
        const res = value.toJSON(arg, ctx);
        if (anchor && ctx.onCreate) ctx.onCreate(res);
        return res;
      }
      if ((!ctx || !ctx.keep) && typeof value === "bigint") return Number(value);
      return value;
    }
    var Scalar = class extends Node {
      constructor(value) {
        super();
        this.value = value;
      }
      toJSON(arg, ctx) {
        return ctx && ctx.keep ? this.value : toJSON3(this.value, arg, ctx);
      }
      toString() {
        return String(this.value);
      }
    };
    function collectionFromPath(schema2, path, value) {
      let v = value;
      for (let i = path.length - 1; i >= 0; --i) {
        const k = path[i];
        if (Number.isInteger(k) && k >= 0) {
          const a = [];
          a[k] = v;
          v = a;
        } else {
          const o = {};
          Object.defineProperty(o, k, {
            value: v,
            writable: true,
            enumerable: true,
            configurable: true
          });
          v = o;
        }
      }
      return schema2.createNode(v, false);
    }
    var isEmptyPath = (path) => path == null || typeof path === "object" && path[Symbol.iterator]().next().done;
    var Collection = class _Collection extends Node {
      constructor(schema2) {
        super();
        PlainValue._defineProperty(this, "items", []);
        this.schema = schema2;
      }
      addIn(path, value) {
        if (isEmptyPath(path)) this.add(value);
        else {
          const [key, ...rest] = path;
          const node2 = this.get(key, true);
          if (node2 instanceof _Collection) node2.addIn(rest, value);
          else if (node2 === void 0 && this.schema) this.set(key, collectionFromPath(this.schema, rest, value));
          else throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
        }
      }
      deleteIn([key, ...rest]) {
        if (rest.length === 0) return this.delete(key);
        const node2 = this.get(key, true);
        if (node2 instanceof _Collection) return node2.deleteIn(rest);
        else throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
      }
      getIn([key, ...rest], keepScalar) {
        const node2 = this.get(key, true);
        if (rest.length === 0) return !keepScalar && node2 instanceof Scalar ? node2.value : node2;
        else return node2 instanceof _Collection ? node2.getIn(rest, keepScalar) : void 0;
      }
      hasAllNullValues() {
        return this.items.every((node2) => {
          if (!node2 || node2.type !== "PAIR") return false;
          const n = node2.value;
          return n == null || n instanceof Scalar && n.value == null && !n.commentBefore && !n.comment && !n.tag;
        });
      }
      hasIn([key, ...rest]) {
        if (rest.length === 0) return this.has(key);
        const node2 = this.get(key, true);
        return node2 instanceof _Collection ? node2.hasIn(rest) : false;
      }
      setIn([key, ...rest], value) {
        if (rest.length === 0) {
          this.set(key, value);
        } else {
          const node2 = this.get(key, true);
          if (node2 instanceof _Collection) node2.setIn(rest, value);
          else if (node2 === void 0 && this.schema) this.set(key, collectionFromPath(this.schema, rest, value));
          else throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
        }
      }
      // overridden in implementations
      /* istanbul ignore next */
      toJSON() {
        return null;
      }
      toString(ctx, {
        blockItem,
        flowChars,
        isMap,
        itemIndent
      }, onComment, onChompKeep) {
        const {
          indent,
          indentStep,
          stringify: stringify3
        } = ctx;
        const inFlow = this.type === PlainValue.Type.FLOW_MAP || this.type === PlainValue.Type.FLOW_SEQ || ctx.inFlow;
        if (inFlow) itemIndent += indentStep;
        const allNullValues = isMap && this.hasAllNullValues();
        ctx = Object.assign({}, ctx, {
          allNullValues,
          indent: itemIndent,
          inFlow,
          type: null
        });
        let chompKeep = false;
        let hasItemWithNewLine = false;
        const nodes = this.items.reduce((nodes2, item, i) => {
          let comment;
          if (item) {
            if (!chompKeep && item.spaceBefore) nodes2.push({
              type: "comment",
              str: ""
            });
            if (item.commentBefore) item.commentBefore.match(/^.*$/gm).forEach((line) => {
              nodes2.push({
                type: "comment",
                str: `#${line}`
              });
            });
            if (item.comment) comment = item.comment;
            if (inFlow && (!chompKeep && item.spaceBefore || item.commentBefore || item.comment || item.key && (item.key.commentBefore || item.key.comment) || item.value && (item.value.commentBefore || item.value.comment))) hasItemWithNewLine = true;
          }
          chompKeep = false;
          let str3 = stringify3(item, ctx, () => comment = null, () => chompKeep = true);
          if (inFlow && !hasItemWithNewLine && str3.includes("\n")) hasItemWithNewLine = true;
          if (inFlow && i < this.items.length - 1) str3 += ",";
          str3 = addComment(str3, itemIndent, comment);
          if (chompKeep && (comment || inFlow)) chompKeep = false;
          nodes2.push({
            type: "item",
            str: str3
          });
          return nodes2;
        }, []);
        let str2;
        if (nodes.length === 0) {
          str2 = flowChars.start + flowChars.end;
        } else if (inFlow) {
          const {
            start,
            end
          } = flowChars;
          const strings = nodes.map((n) => n.str);
          if (hasItemWithNewLine || strings.reduce((sum, str3) => sum + str3.length + 2, 2) > _Collection.maxFlowStringSingleLineLength) {
            str2 = start;
            for (const s of strings) {
              str2 += s ? `
${indentStep}${indent}${s}` : "\n";
            }
            str2 += `
${indent}${end}`;
          } else {
            str2 = `${start} ${strings.join(" ")} ${end}`;
          }
        } else {
          const strings = nodes.map(blockItem);
          str2 = strings.shift();
          for (const s of strings) str2 += s ? `
${indent}${s}` : "\n";
        }
        if (this.comment) {
          str2 += "\n" + this.comment.replace(/^/gm, `${indent}#`);
          if (onComment) onComment();
        } else if (chompKeep && onChompKeep) onChompKeep();
        return str2;
      }
    };
    PlainValue._defineProperty(Collection, "maxFlowStringSingleLineLength", 60);
    function asItemIndex(key) {
      let idx = key instanceof Scalar ? key.value : key;
      if (idx && typeof idx === "string") idx = Number(idx);
      return Number.isInteger(idx) && idx >= 0 ? idx : null;
    }
    var YAMLSeq = class extends Collection {
      add(value) {
        this.items.push(value);
      }
      delete(key) {
        const idx = asItemIndex(key);
        if (typeof idx !== "number") return false;
        const del = this.items.splice(idx, 1);
        return del.length > 0;
      }
      get(key, keepScalar) {
        const idx = asItemIndex(key);
        if (typeof idx !== "number") return void 0;
        const it = this.items[idx];
        return !keepScalar && it instanceof Scalar ? it.value : it;
      }
      has(key) {
        const idx = asItemIndex(key);
        return typeof idx === "number" && idx < this.items.length;
      }
      set(key, value) {
        const idx = asItemIndex(key);
        if (typeof idx !== "number") throw new Error(`Expected a valid index, not ${key}.`);
        this.items[idx] = value;
      }
      toJSON(_, ctx) {
        const seq2 = [];
        if (ctx && ctx.onCreate) ctx.onCreate(seq2);
        let i = 0;
        for (const item of this.items) seq2.push(toJSON3(item, String(i++), ctx));
        return seq2;
      }
      toString(ctx, onComment, onChompKeep) {
        if (!ctx) return JSON.stringify(this);
        return super.toString(ctx, {
          blockItem: (n) => n.type === "comment" ? n.str : `- ${n.str}`,
          flowChars: {
            start: "[",
            end: "]"
          },
          isMap: false,
          itemIndent: (ctx.indent || "") + "  "
        }, onComment, onChompKeep);
      }
    };
    var stringifyKey = (key, jsKey, ctx) => {
      if (jsKey === null) return "";
      if (typeof jsKey !== "object") return String(jsKey);
      if (key instanceof Node && ctx && ctx.doc) return key.toString({
        anchors: /* @__PURE__ */ Object.create(null),
        doc: ctx.doc,
        indent: "",
        indentStep: ctx.indentStep,
        inFlow: true,
        inStringifyKey: true,
        stringify: ctx.stringify
      });
      return JSON.stringify(jsKey);
    };
    var Pair = class _Pair extends Node {
      constructor(key, value = null) {
        super();
        this.key = key;
        this.value = value;
        this.type = _Pair.Type.PAIR;
      }
      get commentBefore() {
        return this.key instanceof Node ? this.key.commentBefore : void 0;
      }
      set commentBefore(cb) {
        if (this.key == null) this.key = new Scalar(null);
        if (this.key instanceof Node) this.key.commentBefore = cb;
        else {
          const msg = "Pair.commentBefore is an alias for Pair.key.commentBefore. To set it, the key must be a Node.";
          throw new Error(msg);
        }
      }
      addToJSMap(ctx, map2) {
        const key = toJSON3(this.key, "", ctx);
        if (map2 instanceof Map) {
          const value = toJSON3(this.value, key, ctx);
          map2.set(key, value);
        } else if (map2 instanceof Set) {
          map2.add(key);
        } else {
          const stringKey = stringifyKey(this.key, key, ctx);
          const value = toJSON3(this.value, stringKey, ctx);
          if (stringKey in map2) Object.defineProperty(map2, stringKey, {
            value,
            writable: true,
            enumerable: true,
            configurable: true
          });
          else map2[stringKey] = value;
        }
        return map2;
      }
      toJSON(_, ctx) {
        const pair = ctx && ctx.mapAsMap ? /* @__PURE__ */ new Map() : {};
        return this.addToJSMap(ctx, pair);
      }
      toString(ctx, onComment, onChompKeep) {
        if (!ctx || !ctx.doc) return JSON.stringify(this);
        const {
          indent: indentSize,
          indentSeq,
          simpleKeys
        } = ctx.doc.options;
        let {
          key,
          value
        } = this;
        let keyComment = key instanceof Node && key.comment;
        if (simpleKeys) {
          if (keyComment) {
            throw new Error("With simple keys, key nodes cannot have comments");
          }
          if (key instanceof Collection) {
            const msg = "With simple keys, collection cannot be used as a key value";
            throw new Error(msg);
          }
        }
        let explicitKey = !simpleKeys && (!key || keyComment || (key instanceof Node ? key instanceof Collection || key.type === PlainValue.Type.BLOCK_FOLDED || key.type === PlainValue.Type.BLOCK_LITERAL : typeof key === "object"));
        const {
          doc,
          indent,
          indentStep,
          stringify: stringify3
        } = ctx;
        ctx = Object.assign({}, ctx, {
          implicitKey: !explicitKey,
          indent: indent + indentStep
        });
        let chompKeep = false;
        let str2 = stringify3(key, ctx, () => keyComment = null, () => chompKeep = true);
        str2 = addComment(str2, ctx.indent, keyComment);
        if (!explicitKey && str2.length > 1024) {
          if (simpleKeys) throw new Error("With simple keys, single line scalar must not span more than 1024 characters");
          explicitKey = true;
        }
        if (ctx.allNullValues && !simpleKeys) {
          if (this.comment) {
            str2 = addComment(str2, ctx.indent, this.comment);
            if (onComment) onComment();
          } else if (chompKeep && !keyComment && onChompKeep) onChompKeep();
          return ctx.inFlow && !explicitKey ? str2 : `? ${str2}`;
        }
        str2 = explicitKey ? `? ${str2}
${indent}:` : `${str2}:`;
        if (this.comment) {
          str2 = addComment(str2, ctx.indent, this.comment);
          if (onComment) onComment();
        }
        let vcb = "";
        let valueComment = null;
        if (value instanceof Node) {
          if (value.spaceBefore) vcb = "\n";
          if (value.commentBefore) {
            const cs = value.commentBefore.replace(/^/gm, `${ctx.indent}#`);
            vcb += `
${cs}`;
          }
          valueComment = value.comment;
        } else if (value && typeof value === "object") {
          value = doc.schema.createNode(value, true);
        }
        ctx.implicitKey = false;
        if (!explicitKey && !this.comment && value instanceof Scalar) ctx.indentAtStart = str2.length + 1;
        chompKeep = false;
        if (!indentSeq && indentSize >= 2 && !ctx.inFlow && !explicitKey && value instanceof YAMLSeq && value.type !== PlainValue.Type.FLOW_SEQ && !value.tag && !doc.anchors.getName(value)) {
          ctx.indent = ctx.indent.substr(2);
        }
        const valueStr = stringify3(value, ctx, () => valueComment = null, () => chompKeep = true);
        let ws = " ";
        if (vcb || this.comment) {
          ws = `${vcb}
${ctx.indent}`;
        } else if (!explicitKey && value instanceof Collection) {
          const flow = valueStr[0] === "[" || valueStr[0] === "{";
          if (!flow || valueStr.includes("\n")) ws = `
${ctx.indent}`;
        } else if (valueStr[0] === "\n") ws = "";
        if (chompKeep && !valueComment && onChompKeep) onChompKeep();
        return addComment(str2 + ws + valueStr, ctx.indent, valueComment);
      }
    };
    PlainValue._defineProperty(Pair, "Type", {
      PAIR: "PAIR",
      MERGE_PAIR: "MERGE_PAIR"
    });
    var getAliasCount = (node2, anchors) => {
      if (node2 instanceof Alias) {
        const anchor = anchors.get(node2.source);
        return anchor.count * anchor.aliasCount;
      } else if (node2 instanceof Collection) {
        let count = 0;
        for (const item of node2.items) {
          const c2 = getAliasCount(item, anchors);
          if (c2 > count) count = c2;
        }
        return count;
      } else if (node2 instanceof Pair) {
        const kc = getAliasCount(node2.key, anchors);
        const vc = getAliasCount(node2.value, anchors);
        return Math.max(kc, vc);
      }
      return 1;
    };
    var Alias = class _Alias extends Node {
      static stringify({
        range,
        source
      }, {
        anchors,
        doc,
        implicitKey,
        inStringifyKey
      }) {
        let anchor = Object.keys(anchors).find((a) => anchors[a] === source);
        if (!anchor && inStringifyKey) anchor = doc.anchors.getName(source) || doc.anchors.newName();
        if (anchor) return `*${anchor}${implicitKey ? " " : ""}`;
        const msg = doc.anchors.getName(source) ? "Alias node must be after source node" : "Source node not found for alias node";
        throw new Error(`${msg} [${range}]`);
      }
      constructor(source) {
        super();
        this.source = source;
        this.type = PlainValue.Type.ALIAS;
      }
      set tag(t) {
        throw new Error("Alias nodes cannot have tags");
      }
      toJSON(arg, ctx) {
        if (!ctx) return toJSON3(this.source, arg, ctx);
        const {
          anchors,
          maxAliasCount
        } = ctx;
        const anchor = anchors.get(this.source);
        if (!anchor || anchor.res === void 0) {
          const msg = "This should not happen: Alias anchor was not resolved?";
          if (this.cstNode) throw new PlainValue.YAMLReferenceError(this.cstNode, msg);
          else throw new ReferenceError(msg);
        }
        if (maxAliasCount >= 0) {
          anchor.count += 1;
          if (anchor.aliasCount === 0) anchor.aliasCount = getAliasCount(this.source, anchors);
          if (anchor.count * anchor.aliasCount > maxAliasCount) {
            const msg = "Excessive alias count indicates a resource exhaustion attack";
            if (this.cstNode) throw new PlainValue.YAMLReferenceError(this.cstNode, msg);
            else throw new ReferenceError(msg);
          }
        }
        return anchor.res;
      }
      // Only called when stringifying an alias mapping key while constructing
      // Object output.
      toString(ctx) {
        return _Alias.stringify(this, ctx);
      }
    };
    PlainValue._defineProperty(Alias, "default", true);
    function findPair(items, key) {
      const k = key instanceof Scalar ? key.value : key;
      for (const it of items) {
        if (it instanceof Pair) {
          if (it.key === key || it.key === k) return it;
          if (it.key && it.key.value === k) return it;
        }
      }
      return void 0;
    }
    var YAMLMap = class extends Collection {
      add(pair, overwrite) {
        if (!pair) pair = new Pair(pair);
        else if (!(pair instanceof Pair)) pair = new Pair(pair.key || pair, pair.value);
        const prev = findPair(this.items, pair.key);
        const sortEntries = this.schema && this.schema.sortMapEntries;
        if (prev) {
          if (overwrite) prev.value = pair.value;
          else throw new Error(`Key ${pair.key} already set`);
        } else if (sortEntries) {
          const i = this.items.findIndex((item) => sortEntries(pair, item) < 0);
          if (i === -1) this.items.push(pair);
          else this.items.splice(i, 0, pair);
        } else {
          this.items.push(pair);
        }
      }
      delete(key) {
        const it = findPair(this.items, key);
        if (!it) return false;
        const del = this.items.splice(this.items.indexOf(it), 1);
        return del.length > 0;
      }
      get(key, keepScalar) {
        const it = findPair(this.items, key);
        const node2 = it && it.value;
        return !keepScalar && node2 instanceof Scalar ? node2.value : node2;
      }
      has(key) {
        return !!findPair(this.items, key);
      }
      set(key, value) {
        this.add(new Pair(key, value), true);
      }
      /**
       * @param {*} arg ignored
       * @param {*} ctx Conversion context, originally set in Document#toJSON()
       * @param {Class} Type If set, forces the returned collection type
       * @returns {*} Instance of Type, Map, or Object
       */
      toJSON(_, ctx, Type2) {
        const map2 = Type2 ? new Type2() : ctx && ctx.mapAsMap ? /* @__PURE__ */ new Map() : {};
        if (ctx && ctx.onCreate) ctx.onCreate(map2);
        for (const item of this.items) item.addToJSMap(ctx, map2);
        return map2;
      }
      toString(ctx, onComment, onChompKeep) {
        if (!ctx) return JSON.stringify(this);
        for (const item of this.items) {
          if (!(item instanceof Pair)) throw new Error(`Map items must all be pairs; found ${JSON.stringify(item)} instead`);
        }
        return super.toString(ctx, {
          blockItem: (n) => n.str,
          flowChars: {
            start: "{",
            end: "}"
          },
          isMap: true,
          itemIndent: ctx.indent || ""
        }, onComment, onChompKeep);
      }
    };
    var MERGE_KEY = "<<";
    var Merge = class extends Pair {
      constructor(pair) {
        if (pair instanceof Pair) {
          let seq2 = pair.value;
          if (!(seq2 instanceof YAMLSeq)) {
            seq2 = new YAMLSeq();
            seq2.items.push(pair.value);
            seq2.range = pair.value.range;
          }
          super(pair.key, seq2);
          this.range = pair.range;
        } else {
          super(new Scalar(MERGE_KEY), new YAMLSeq());
        }
        this.type = Pair.Type.MERGE_PAIR;
      }
      // If the value associated with a merge key is a single mapping node, each of
      // its key/value pairs is inserted into the current mapping, unless the key
      // already exists in it. If the value associated with the merge key is a
      // sequence, then this sequence is expected to contain mapping nodes and each
      // of these nodes is merged in turn according to its order in the sequence.
      // Keys in mapping nodes earlier in the sequence override keys specified in
      // later mapping nodes. -- http://yaml.org/type/merge.html
      addToJSMap(ctx, map2) {
        for (const {
          source
        } of this.value.items) {
          if (!(source instanceof YAMLMap)) throw new Error("Merge sources must be maps");
          const srcMap = source.toJSON(null, ctx, Map);
          for (const [key, value] of srcMap) {
            if (map2 instanceof Map) {
              if (!map2.has(key)) map2.set(key, value);
            } else if (map2 instanceof Set) {
              map2.add(key);
            } else if (!Object.prototype.hasOwnProperty.call(map2, key)) {
              Object.defineProperty(map2, key, {
                value,
                writable: true,
                enumerable: true,
                configurable: true
              });
            }
          }
        }
        return map2;
      }
      toString(ctx, onComment) {
        const seq2 = this.value;
        if (seq2.items.length > 1) return super.toString(ctx, onComment);
        this.value = seq2.items[0];
        const str2 = super.toString(ctx, onComment);
        this.value = seq2;
        return str2;
      }
    };
    var binaryOptions = {
      defaultType: PlainValue.Type.BLOCK_LITERAL,
      lineWidth: 76
    };
    var boolOptions = {
      trueStr: "true",
      falseStr: "false"
    };
    var intOptions = {
      asBigInt: false
    };
    var nullOptions = {
      nullStr: "null"
    };
    var strOptions = {
      defaultType: PlainValue.Type.PLAIN,
      doubleQuoted: {
        jsonEncoding: false,
        minMultiLineLength: 40
      },
      fold: {
        lineWidth: 80,
        minContentWidth: 20
      }
    };
    function resolveScalar(str2, tags, scalarFallback) {
      for (const {
        format: format6,
        test,
        resolve
      } of tags) {
        if (test) {
          const match2 = str2.match(test);
          if (match2) {
            let res = resolve.apply(null, match2);
            if (!(res instanceof Scalar)) res = new Scalar(res);
            if (format6) res.format = format6;
            return res;
          }
        }
      }
      if (scalarFallback) str2 = scalarFallback(str2);
      return new Scalar(str2);
    }
    var FOLD_FLOW = "flow";
    var FOLD_BLOCK = "block";
    var FOLD_QUOTED = "quoted";
    var consumeMoreIndentedLines = (text, i) => {
      let ch = text[i + 1];
      while (ch === " " || ch === "	") {
        do {
          ch = text[i += 1];
        } while (ch && ch !== "\n");
        ch = text[i + 1];
      }
      return i;
    };
    function foldFlowLines(text, indent, mode, {
      indentAtStart,
      lineWidth = 80,
      minContentWidth = 20,
      onFold,
      onOverflow
    }) {
      if (!lineWidth || lineWidth < 0) return text;
      const endStep = Math.max(1 + minContentWidth, 1 + lineWidth - indent.length);
      if (text.length <= endStep) return text;
      const folds = [];
      const escapedFolds = {};
      let end = lineWidth - indent.length;
      if (typeof indentAtStart === "number") {
        if (indentAtStart > lineWidth - Math.max(2, minContentWidth)) folds.push(0);
        else end = lineWidth - indentAtStart;
      }
      let split = void 0;
      let prev = void 0;
      let overflow = false;
      let i = -1;
      let escStart = -1;
      let escEnd = -1;
      if (mode === FOLD_BLOCK) {
        i = consumeMoreIndentedLines(text, i);
        if (i !== -1) end = i + endStep;
      }
      for (let ch; ch = text[i += 1]; ) {
        if (mode === FOLD_QUOTED && ch === "\\") {
          escStart = i;
          switch (text[i + 1]) {
            case "x":
              i += 3;
              break;
            case "u":
              i += 5;
              break;
            case "U":
              i += 9;
              break;
            default:
              i += 1;
          }
          escEnd = i;
        }
        if (ch === "\n") {
          if (mode === FOLD_BLOCK) i = consumeMoreIndentedLines(text, i);
          end = i + endStep;
          split = void 0;
        } else {
          if (ch === " " && prev && prev !== " " && prev !== "\n" && prev !== "	") {
            const next = text[i + 1];
            if (next && next !== " " && next !== "\n" && next !== "	") split = i;
          }
          if (i >= end) {
            if (split) {
              folds.push(split);
              end = split + endStep;
              split = void 0;
            } else if (mode === FOLD_QUOTED) {
              while (prev === " " || prev === "	") {
                prev = ch;
                ch = text[i += 1];
                overflow = true;
              }
              const j = i > escEnd + 1 ? i - 2 : escStart - 1;
              if (escapedFolds[j]) return text;
              folds.push(j);
              escapedFolds[j] = true;
              end = j + endStep;
              split = void 0;
            } else {
              overflow = true;
            }
          }
        }
        prev = ch;
      }
      if (overflow && onOverflow) onOverflow();
      if (folds.length === 0) return text;
      if (onFold) onFold();
      let res = text.slice(0, folds[0]);
      for (let i2 = 0; i2 < folds.length; ++i2) {
        const fold = folds[i2];
        const end2 = folds[i2 + 1] || text.length;
        if (fold === 0) res = `
${indent}${text.slice(0, end2)}`;
        else {
          if (mode === FOLD_QUOTED && escapedFolds[fold]) res += `${text[fold]}\\`;
          res += `
${indent}${text.slice(fold + 1, end2)}`;
        }
      }
      return res;
    }
    var getFoldOptions = ({
      indentAtStart
    }) => indentAtStart ? Object.assign({
      indentAtStart
    }, strOptions.fold) : strOptions.fold;
    var containsDocumentMarker = (str2) => /^(%|---|\.\.\.)/m.test(str2);
    function lineLengthOverLimit(str2, lineWidth, indentLength) {
      if (!lineWidth || lineWidth < 0) return false;
      const limit = lineWidth - indentLength;
      const strLen = str2.length;
      if (strLen <= limit) return false;
      for (let i = 0, start = 0; i < strLen; ++i) {
        if (str2[i] === "\n") {
          if (i - start > limit) return true;
          start = i + 1;
          if (strLen - start <= limit) return false;
        }
      }
      return true;
    }
    function doubleQuotedString(value, ctx) {
      const {
        implicitKey
      } = ctx;
      const {
        jsonEncoding,
        minMultiLineLength
      } = strOptions.doubleQuoted;
      const json3 = JSON.stringify(value);
      if (jsonEncoding) return json3;
      const indent = ctx.indent || (containsDocumentMarker(value) ? "  " : "");
      let str2 = "";
      let start = 0;
      for (let i = 0, ch = json3[i]; ch; ch = json3[++i]) {
        if (ch === " " && json3[i + 1] === "\\" && json3[i + 2] === "n") {
          str2 += json3.slice(start, i) + "\\ ";
          i += 1;
          start = i;
          ch = "\\";
        }
        if (ch === "\\") switch (json3[i + 1]) {
          case "u":
            {
              str2 += json3.slice(start, i);
              const code = json3.substr(i + 2, 4);
              switch (code) {
                case "0000":
                  str2 += "\\0";
                  break;
                case "0007":
                  str2 += "\\a";
                  break;
                case "000b":
                  str2 += "\\v";
                  break;
                case "001b":
                  str2 += "\\e";
                  break;
                case "0085":
                  str2 += "\\N";
                  break;
                case "00a0":
                  str2 += "\\_";
                  break;
                case "2028":
                  str2 += "\\L";
                  break;
                case "2029":
                  str2 += "\\P";
                  break;
                default:
                  if (code.substr(0, 2) === "00") str2 += "\\x" + code.substr(2);
                  else str2 += json3.substr(i, 6);
              }
              i += 5;
              start = i + 1;
            }
            break;
          case "n":
            if (implicitKey || json3[i + 2] === '"' || json3.length < minMultiLineLength) {
              i += 1;
            } else {
              str2 += json3.slice(start, i) + "\n\n";
              while (json3[i + 2] === "\\" && json3[i + 3] === "n" && json3[i + 4] !== '"') {
                str2 += "\n";
                i += 2;
              }
              str2 += indent;
              if (json3[i + 2] === " ") str2 += "\\";
              i += 1;
              start = i + 1;
            }
            break;
          default:
            i += 1;
        }
      }
      str2 = start ? str2 + json3.slice(start) : json3;
      return implicitKey ? str2 : foldFlowLines(str2, indent, FOLD_QUOTED, getFoldOptions(ctx));
    }
    function singleQuotedString(value, ctx) {
      if (ctx.implicitKey) {
        if (/\n/.test(value)) return doubleQuotedString(value, ctx);
      } else {
        if (/[ \t]\n|\n[ \t]/.test(value)) return doubleQuotedString(value, ctx);
      }
      const indent = ctx.indent || (containsDocumentMarker(value) ? "  " : "");
      const res = "'" + value.replace(/'/g, "''").replace(/\n+/g, `$&
${indent}`) + "'";
      return ctx.implicitKey ? res : foldFlowLines(res, indent, FOLD_FLOW, getFoldOptions(ctx));
    }
    function blockString({
      comment,
      type: type2,
      value
    }, ctx, onComment, onChompKeep) {
      if (/\n[\t ]+$/.test(value) || /^\s*$/.test(value)) {
        return doubleQuotedString(value, ctx);
      }
      const indent = ctx.indent || (ctx.forceBlockIndent || containsDocumentMarker(value) ? "  " : "");
      const indentSize = indent ? "2" : "1";
      const literal = type2 === PlainValue.Type.BLOCK_FOLDED ? false : type2 === PlainValue.Type.BLOCK_LITERAL ? true : !lineLengthOverLimit(value, strOptions.fold.lineWidth, indent.length);
      let header = literal ? "|" : ">";
      if (!value) return header + "\n";
      let wsStart = "";
      let wsEnd = "";
      value = value.replace(/[\n\t ]*$/, (ws) => {
        const n = ws.indexOf("\n");
        if (n === -1) {
          header += "-";
        } else if (value === ws || n !== ws.length - 1) {
          header += "+";
          if (onChompKeep) onChompKeep();
        }
        wsEnd = ws.replace(/\n$/, "");
        return "";
      }).replace(/^[\n ]*/, (ws) => {
        if (ws.indexOf(" ") !== -1) header += indentSize;
        const m = ws.match(/ +$/);
        if (m) {
          wsStart = ws.slice(0, -m[0].length);
          return m[0];
        } else {
          wsStart = ws;
          return "";
        }
      });
      if (wsEnd) wsEnd = wsEnd.replace(/\n+(?!\n|$)/g, `$&${indent}`);
      if (wsStart) wsStart = wsStart.replace(/\n+/g, `$&${indent}`);
      if (comment) {
        header += " #" + comment.replace(/ ?[\r\n]+/g, " ");
        if (onComment) onComment();
      }
      if (!value) return `${header}${indentSize}
${indent}${wsEnd}`;
      if (literal) {
        value = value.replace(/\n+/g, `$&${indent}`);
        return `${header}
${indent}${wsStart}${value}${wsEnd}`;
      }
      value = value.replace(/\n+/g, "\n$&").replace(/(?:^|\n)([\t ].*)(?:([\n\t ]*)\n(?![\n\t ]))?/g, "$1$2").replace(/\n+/g, `$&${indent}`);
      const body = foldFlowLines(`${wsStart}${value}${wsEnd}`, indent, FOLD_BLOCK, strOptions.fold);
      return `${header}
${indent}${body}`;
    }
    function plainString(item, ctx, onComment, onChompKeep) {
      const {
        comment,
        type: type2,
        value
      } = item;
      const {
        actualString,
        implicitKey,
        indent,
        inFlow
      } = ctx;
      if (implicitKey && /[\n[\]{},]/.test(value) || inFlow && /[[\]{},]/.test(value)) {
        return doubleQuotedString(value, ctx);
      }
      if (!value || /^[\n\t ,[\]{}#&*!|>'"%@`]|^[?-]$|^[?-][ \t]|[\n:][ \t]|[ \t]\n|[\n\t ]#|[\n\t :]$/.test(value)) {
        return implicitKey || inFlow || value.indexOf("\n") === -1 ? value.indexOf('"') !== -1 && value.indexOf("'") === -1 ? singleQuotedString(value, ctx) : doubleQuotedString(value, ctx) : blockString(item, ctx, onComment, onChompKeep);
      }
      if (!implicitKey && !inFlow && type2 !== PlainValue.Type.PLAIN && value.indexOf("\n") !== -1) {
        return blockString(item, ctx, onComment, onChompKeep);
      }
      if (indent === "" && containsDocumentMarker(value)) {
        ctx.forceBlockIndent = true;
        return blockString(item, ctx, onComment, onChompKeep);
      }
      const str2 = value.replace(/\n+/g, `$&
${indent}`);
      if (actualString) {
        const {
          tags
        } = ctx.doc.schema;
        const resolved = resolveScalar(str2, tags, tags.scalarFallback).value;
        if (typeof resolved !== "string") return doubleQuotedString(value, ctx);
      }
      const body = implicitKey ? str2 : foldFlowLines(str2, indent, FOLD_FLOW, getFoldOptions(ctx));
      if (comment && !inFlow && (body.indexOf("\n") !== -1 || comment.indexOf("\n") !== -1)) {
        if (onComment) onComment();
        return addCommentBefore(body, indent, comment);
      }
      return body;
    }
    function stringifyString(item, ctx, onComment, onChompKeep) {
      const {
        defaultType
      } = strOptions;
      const {
        implicitKey,
        inFlow
      } = ctx;
      let {
        type: type2,
        value
      } = item;
      if (typeof value !== "string") {
        value = String(value);
        item = Object.assign({}, item, {
          value
        });
      }
      const _stringify = (_type) => {
        switch (_type) {
          case PlainValue.Type.BLOCK_FOLDED:
          case PlainValue.Type.BLOCK_LITERAL:
            return blockString(item, ctx, onComment, onChompKeep);
          case PlainValue.Type.QUOTE_DOUBLE:
            return doubleQuotedString(value, ctx);
          case PlainValue.Type.QUOTE_SINGLE:
            return singleQuotedString(value, ctx);
          case PlainValue.Type.PLAIN:
            return plainString(item, ctx, onComment, onChompKeep);
          default:
            return null;
        }
      };
      if (type2 !== PlainValue.Type.QUOTE_DOUBLE && /[\x00-\x08\x0b-\x1f\x7f-\x9f]/.test(value)) {
        type2 = PlainValue.Type.QUOTE_DOUBLE;
      } else if ((implicitKey || inFlow) && (type2 === PlainValue.Type.BLOCK_FOLDED || type2 === PlainValue.Type.BLOCK_LITERAL)) {
        type2 = PlainValue.Type.QUOTE_DOUBLE;
      }
      let res = _stringify(type2);
      if (res === null) {
        res = _stringify(defaultType);
        if (res === null) throw new Error(`Unsupported default string type ${defaultType}`);
      }
      return res;
    }
    function stringifyNumber({
      format: format6,
      minFractionDigits,
      tag,
      value
    }) {
      if (typeof value === "bigint") return String(value);
      if (!isFinite(value)) return isNaN(value) ? ".nan" : value < 0 ? "-.inf" : ".inf";
      let n = JSON.stringify(value);
      if (!format6 && minFractionDigits && (!tag || tag === "tag:yaml.org,2002:float") && /^\d/.test(n)) {
        let i = n.indexOf(".");
        if (i < 0) {
          i = n.length;
          n += ".";
        }
        let d = minFractionDigits - (n.length - i - 1);
        while (d-- > 0) n += "0";
      }
      return n;
    }
    function checkFlowCollectionEnd(errors, cst) {
      let char, name;
      switch (cst.type) {
        case PlainValue.Type.FLOW_MAP:
          char = "}";
          name = "flow map";
          break;
        case PlainValue.Type.FLOW_SEQ:
          char = "]";
          name = "flow sequence";
          break;
        default:
          errors.push(new PlainValue.YAMLSemanticError(cst, "Not a flow collection!?"));
          return;
      }
      let lastItem;
      for (let i = cst.items.length - 1; i >= 0; --i) {
        const item = cst.items[i];
        if (!item || item.type !== PlainValue.Type.COMMENT) {
          lastItem = item;
          break;
        }
      }
      if (lastItem && lastItem.char !== char) {
        const msg = `Expected ${name} to end with ${char}`;
        let err;
        if (typeof lastItem.offset === "number") {
          err = new PlainValue.YAMLSemanticError(cst, msg);
          err.offset = lastItem.offset + 1;
        } else {
          err = new PlainValue.YAMLSemanticError(lastItem, msg);
          if (lastItem.range && lastItem.range.end) err.offset = lastItem.range.end - lastItem.range.start;
        }
        errors.push(err);
      }
    }
    function checkFlowCommentSpace(errors, comment) {
      const prev = comment.context.src[comment.range.start - 1];
      if (prev !== "\n" && prev !== "	" && prev !== " ") {
        const msg = "Comments must be separated from other tokens by white space characters";
        errors.push(new PlainValue.YAMLSemanticError(comment, msg));
      }
    }
    function getLongKeyError(source, key) {
      const sk = String(key);
      const k = sk.substr(0, 8) + "..." + sk.substr(-8);
      return new PlainValue.YAMLSemanticError(source, `The "${k}" key is too long`);
    }
    function resolveComments(collection, comments) {
      for (const {
        afterKey,
        before,
        comment
      } of comments) {
        let item = collection.items[before];
        if (!item) {
          if (comment !== void 0) {
            if (collection.comment) collection.comment += "\n" + comment;
            else collection.comment = comment;
          }
        } else {
          if (afterKey && item.value) item = item.value;
          if (comment === void 0) {
            if (afterKey || !item.commentBefore) item.spaceBefore = true;
          } else {
            if (item.commentBefore) item.commentBefore += "\n" + comment;
            else item.commentBefore = comment;
          }
        }
      }
    }
    function resolveString(doc, node2) {
      const res = node2.strValue;
      if (!res) return "";
      if (typeof res === "string") return res;
      res.errors.forEach((error) => {
        if (!error.source) error.source = node2;
        doc.errors.push(error);
      });
      return res.str;
    }
    function resolveTagHandle(doc, node2) {
      const {
        handle,
        suffix
      } = node2.tag;
      let prefix = doc.tagPrefixes.find((p) => p.handle === handle);
      if (!prefix) {
        const dtp = doc.getDefaults().tagPrefixes;
        if (dtp) prefix = dtp.find((p) => p.handle === handle);
        if (!prefix) throw new PlainValue.YAMLSemanticError(node2, `The ${handle} tag handle is non-default and was not declared.`);
      }
      if (!suffix) throw new PlainValue.YAMLSemanticError(node2, `The ${handle} tag has no suffix.`);
      if (handle === "!" && (doc.version || doc.options.version) === "1.0") {
        if (suffix[0] === "^") {
          doc.warnings.push(new PlainValue.YAMLWarning(node2, "YAML 1.0 ^ tag expansion is not supported"));
          return suffix;
        }
        if (/[:/]/.test(suffix)) {
          const vocab = suffix.match(/^([a-z0-9-]+)\/(.*)/i);
          return vocab ? `tag:${vocab[1]}.yaml.org,2002:${vocab[2]}` : `tag:${suffix}`;
        }
      }
      return prefix.prefix + decodeURIComponent(suffix);
    }
    function resolveTagName(doc, node2) {
      const {
        tag,
        type: type2
      } = node2;
      let nonSpecific = false;
      if (tag) {
        const {
          handle,
          suffix,
          verbatim
        } = tag;
        if (verbatim) {
          if (verbatim !== "!" && verbatim !== "!!") return verbatim;
          const msg = `Verbatim tags aren't resolved, so ${verbatim} is invalid.`;
          doc.errors.push(new PlainValue.YAMLSemanticError(node2, msg));
        } else if (handle === "!" && !suffix) {
          nonSpecific = true;
        } else {
          try {
            return resolveTagHandle(doc, node2);
          } catch (error) {
            doc.errors.push(error);
          }
        }
      }
      switch (type2) {
        case PlainValue.Type.BLOCK_FOLDED:
        case PlainValue.Type.BLOCK_LITERAL:
        case PlainValue.Type.QUOTE_DOUBLE:
        case PlainValue.Type.QUOTE_SINGLE:
          return PlainValue.defaultTags.STR;
        case PlainValue.Type.FLOW_MAP:
        case PlainValue.Type.MAP:
          return PlainValue.defaultTags.MAP;
        case PlainValue.Type.FLOW_SEQ:
        case PlainValue.Type.SEQ:
          return PlainValue.defaultTags.SEQ;
        case PlainValue.Type.PLAIN:
          return nonSpecific ? PlainValue.defaultTags.STR : null;
        default:
          return null;
      }
    }
    function resolveByTagName(doc, node2, tagName) {
      const {
        tags
      } = doc.schema;
      const matchWithTest = [];
      for (const tag of tags) {
        if (tag.tag === tagName) {
          if (tag.test) matchWithTest.push(tag);
          else {
            const res = tag.resolve(doc, node2);
            return res instanceof Collection ? res : new Scalar(res);
          }
        }
      }
      const str2 = resolveString(doc, node2);
      if (typeof str2 === "string" && matchWithTest.length > 0) return resolveScalar(str2, matchWithTest, tags.scalarFallback);
      return null;
    }
    function getFallbackTagName({
      type: type2
    }) {
      switch (type2) {
        case PlainValue.Type.FLOW_MAP:
        case PlainValue.Type.MAP:
          return PlainValue.defaultTags.MAP;
        case PlainValue.Type.FLOW_SEQ:
        case PlainValue.Type.SEQ:
          return PlainValue.defaultTags.SEQ;
        default:
          return PlainValue.defaultTags.STR;
      }
    }
    function resolveTag(doc, node2, tagName) {
      try {
        const res = resolveByTagName(doc, node2, tagName);
        if (res) {
          if (tagName && node2.tag) res.tag = tagName;
          return res;
        }
      } catch (error) {
        if (!error.source) error.source = node2;
        doc.errors.push(error);
        return null;
      }
      try {
        const fallback = getFallbackTagName(node2);
        if (!fallback) throw new Error(`The tag ${tagName} is unavailable`);
        const msg = `The tag ${tagName} is unavailable, falling back to ${fallback}`;
        doc.warnings.push(new PlainValue.YAMLWarning(node2, msg));
        const res = resolveByTagName(doc, node2, fallback);
        res.tag = tagName;
        return res;
      } catch (error) {
        const refError = new PlainValue.YAMLReferenceError(node2, error.message);
        refError.stack = error.stack;
        doc.errors.push(refError);
        return null;
      }
    }
    var isCollectionItem = (node2) => {
      if (!node2) return false;
      const {
        type: type2
      } = node2;
      return type2 === PlainValue.Type.MAP_KEY || type2 === PlainValue.Type.MAP_VALUE || type2 === PlainValue.Type.SEQ_ITEM;
    };
    function resolveNodeProps(errors, node2) {
      const comments = {
        before: [],
        after: []
      };
      let hasAnchor = false;
      let hasTag = false;
      const props = isCollectionItem(node2.context.parent) ? node2.context.parent.props.concat(node2.props) : node2.props;
      for (const {
        start,
        end
      } of props) {
        switch (node2.context.src[start]) {
          case PlainValue.Char.COMMENT: {
            if (!node2.commentHasRequiredWhitespace(start)) {
              const msg = "Comments must be separated from other tokens by white space characters";
              errors.push(new PlainValue.YAMLSemanticError(node2, msg));
            }
            const {
              header,
              valueRange
            } = node2;
            const cc = valueRange && (start > valueRange.start || header && start > header.start) ? comments.after : comments.before;
            cc.push(node2.context.src.slice(start + 1, end));
            break;
          }
          case PlainValue.Char.ANCHOR:
            if (hasAnchor) {
              const msg = "A node can have at most one anchor";
              errors.push(new PlainValue.YAMLSemanticError(node2, msg));
            }
            hasAnchor = true;
            break;
          case PlainValue.Char.TAG:
            if (hasTag) {
              const msg = "A node can have at most one tag";
              errors.push(new PlainValue.YAMLSemanticError(node2, msg));
            }
            hasTag = true;
            break;
        }
      }
      return {
        comments,
        hasAnchor,
        hasTag
      };
    }
    function resolveNodeValue(doc, node2) {
      const {
        anchors,
        errors,
        schema: schema2
      } = doc;
      if (node2.type === PlainValue.Type.ALIAS) {
        const name = node2.rawValue;
        const src = anchors.getNode(name);
        if (!src) {
          const msg = `Aliased anchor not found: ${name}`;
          errors.push(new PlainValue.YAMLReferenceError(node2, msg));
          return null;
        }
        const res = new Alias(src);
        anchors._cstAliases.push(res);
        return res;
      }
      const tagName = resolveTagName(doc, node2);
      if (tagName) return resolveTag(doc, node2, tagName);
      if (node2.type !== PlainValue.Type.PLAIN) {
        const msg = `Failed to resolve ${node2.type} node here`;
        errors.push(new PlainValue.YAMLSyntaxError(node2, msg));
        return null;
      }
      try {
        const str2 = resolveString(doc, node2);
        return resolveScalar(str2, schema2.tags, schema2.tags.scalarFallback);
      } catch (error) {
        if (!error.source) error.source = node2;
        errors.push(error);
        return null;
      }
    }
    function resolveNode(doc, node2) {
      if (!node2) return null;
      if (node2.error) doc.errors.push(node2.error);
      const {
        comments,
        hasAnchor,
        hasTag
      } = resolveNodeProps(doc.errors, node2);
      if (hasAnchor) {
        const {
          anchors
        } = doc;
        const name = node2.anchor;
        const prev = anchors.getNode(name);
        if (prev) anchors.map[anchors.newName(name)] = prev;
        anchors.map[name] = node2;
      }
      if (node2.type === PlainValue.Type.ALIAS && (hasAnchor || hasTag)) {
        const msg = "An alias node must not specify any properties";
        doc.errors.push(new PlainValue.YAMLSemanticError(node2, msg));
      }
      const res = resolveNodeValue(doc, node2);
      if (res) {
        res.range = [node2.range.start, node2.range.end];
        if (doc.options.keepCstNodes) res.cstNode = node2;
        if (doc.options.keepNodeTypes) res.type = node2.type;
        const cb = comments.before.join("\n");
        if (cb) {
          res.commentBefore = res.commentBefore ? `${res.commentBefore}
${cb}` : cb;
        }
        const ca = comments.after.join("\n");
        if (ca) res.comment = res.comment ? `${res.comment}
${ca}` : ca;
      }
      return node2.resolved = res;
    }
    function resolveMap(doc, cst) {
      if (cst.type !== PlainValue.Type.MAP && cst.type !== PlainValue.Type.FLOW_MAP) {
        const msg = `A ${cst.type} node cannot be resolved as a mapping`;
        doc.errors.push(new PlainValue.YAMLSyntaxError(cst, msg));
        return null;
      }
      const {
        comments,
        items
      } = cst.type === PlainValue.Type.FLOW_MAP ? resolveFlowMapItems(doc, cst) : resolveBlockMapItems(doc, cst);
      const map2 = new YAMLMap();
      map2.items = items;
      resolveComments(map2, comments);
      let hasCollectionKey = false;
      for (let i = 0; i < items.length; ++i) {
        const {
          key: iKey
        } = items[i];
        if (iKey instanceof Collection) hasCollectionKey = true;
        if (doc.schema.merge && iKey && iKey.value === MERGE_KEY) {
          items[i] = new Merge(items[i]);
          const sources = items[i].value.items;
          let error = null;
          sources.some((node2) => {
            if (node2 instanceof Alias) {
              const {
                type: type2
              } = node2.source;
              if (type2 === PlainValue.Type.MAP || type2 === PlainValue.Type.FLOW_MAP) return false;
              return error = "Merge nodes aliases can only point to maps";
            }
            return error = "Merge nodes can only have Alias nodes as values";
          });
          if (error) doc.errors.push(new PlainValue.YAMLSemanticError(cst, error));
        } else {
          for (let j = i + 1; j < items.length; ++j) {
            const {
              key: jKey
            } = items[j];
            if (iKey === jKey || iKey && jKey && Object.prototype.hasOwnProperty.call(iKey, "value") && iKey.value === jKey.value) {
              const msg = `Map keys must be unique; "${iKey}" is repeated`;
              doc.errors.push(new PlainValue.YAMLSemanticError(cst, msg));
              break;
            }
          }
        }
      }
      if (hasCollectionKey && !doc.options.mapAsMap) {
        const warn = "Keys with collection values will be stringified as YAML due to JS Object restrictions. Use mapAsMap: true to avoid this.";
        doc.warnings.push(new PlainValue.YAMLWarning(cst, warn));
      }
      cst.resolved = map2;
      return map2;
    }
    var valueHasPairComment = ({
      context: {
        lineStart,
        node: node2,
        src
      },
      props
    }) => {
      if (props.length === 0) return false;
      const {
        start
      } = props[0];
      if (node2 && start > node2.valueRange.start) return false;
      if (src[start] !== PlainValue.Char.COMMENT) return false;
      for (let i = lineStart; i < start; ++i) if (src[i] === "\n") return false;
      return true;
    };
    function resolvePairComment(item, pair) {
      if (!valueHasPairComment(item)) return;
      const comment = item.getPropValue(0, PlainValue.Char.COMMENT, true);
      let found = false;
      const cb = pair.value.commentBefore;
      if (cb && cb.startsWith(comment)) {
        pair.value.commentBefore = cb.substr(comment.length + 1);
        found = true;
      } else {
        const cc = pair.value.comment;
        if (!item.node && cc && cc.startsWith(comment)) {
          pair.value.comment = cc.substr(comment.length + 1);
          found = true;
        }
      }
      if (found) pair.comment = comment;
    }
    function resolveBlockMapItems(doc, cst) {
      const comments = [];
      const items = [];
      let key = void 0;
      let keyStart = null;
      for (let i = 0; i < cst.items.length; ++i) {
        const item = cst.items[i];
        switch (item.type) {
          case PlainValue.Type.BLANK_LINE:
            comments.push({
              afterKey: !!key,
              before: items.length
            });
            break;
          case PlainValue.Type.COMMENT:
            comments.push({
              afterKey: !!key,
              before: items.length,
              comment: item.comment
            });
            break;
          case PlainValue.Type.MAP_KEY:
            if (key !== void 0) items.push(new Pair(key));
            if (item.error) doc.errors.push(item.error);
            key = resolveNode(doc, item.node);
            keyStart = null;
            break;
          case PlainValue.Type.MAP_VALUE:
            {
              if (key === void 0) key = null;
              if (item.error) doc.errors.push(item.error);
              if (!item.context.atLineStart && item.node && item.node.type === PlainValue.Type.MAP && !item.node.context.atLineStart) {
                const msg = "Nested mappings are not allowed in compact mappings";
                doc.errors.push(new PlainValue.YAMLSemanticError(item.node, msg));
              }
              let valueNode = item.node;
              if (!valueNode && item.props.length > 0) {
                valueNode = new PlainValue.PlainValue(PlainValue.Type.PLAIN, []);
                valueNode.context = {
                  parent: item,
                  src: item.context.src
                };
                const pos = item.range.start + 1;
                valueNode.range = {
                  start: pos,
                  end: pos
                };
                valueNode.valueRange = {
                  start: pos,
                  end: pos
                };
                if (typeof item.range.origStart === "number") {
                  const origPos = item.range.origStart + 1;
                  valueNode.range.origStart = valueNode.range.origEnd = origPos;
                  valueNode.valueRange.origStart = valueNode.valueRange.origEnd = origPos;
                }
              }
              const pair = new Pair(key, resolveNode(doc, valueNode));
              resolvePairComment(item, pair);
              items.push(pair);
              if (key && typeof keyStart === "number") {
                if (item.range.start > keyStart + 1024) doc.errors.push(getLongKeyError(cst, key));
              }
              key = void 0;
              keyStart = null;
            }
            break;
          default:
            if (key !== void 0) items.push(new Pair(key));
            key = resolveNode(doc, item);
            keyStart = item.range.start;
            if (item.error) doc.errors.push(item.error);
            next: for (let j = i + 1; ; ++j) {
              const nextItem = cst.items[j];
              switch (nextItem && nextItem.type) {
                case PlainValue.Type.BLANK_LINE:
                case PlainValue.Type.COMMENT:
                  continue next;
                case PlainValue.Type.MAP_VALUE:
                  break next;
                default: {
                  const msg = "Implicit map keys need to be followed by map values";
                  doc.errors.push(new PlainValue.YAMLSemanticError(item, msg));
                  break next;
                }
              }
            }
            if (item.valueRangeContainsNewline) {
              const msg = "Implicit map keys need to be on a single line";
              doc.errors.push(new PlainValue.YAMLSemanticError(item, msg));
            }
        }
      }
      if (key !== void 0) items.push(new Pair(key));
      return {
        comments,
        items
      };
    }
    function resolveFlowMapItems(doc, cst) {
      const comments = [];
      const items = [];
      let key = void 0;
      let explicitKey = false;
      let next = "{";
      for (let i = 0; i < cst.items.length; ++i) {
        const item = cst.items[i];
        if (typeof item.char === "string") {
          const {
            char,
            offset
          } = item;
          if (char === "?" && key === void 0 && !explicitKey) {
            explicitKey = true;
            next = ":";
            continue;
          }
          if (char === ":") {
            if (key === void 0) key = null;
            if (next === ":") {
              next = ",";
              continue;
            }
          } else {
            if (explicitKey) {
              if (key === void 0 && char !== ",") key = null;
              explicitKey = false;
            }
            if (key !== void 0) {
              items.push(new Pair(key));
              key = void 0;
              if (char === ",") {
                next = ":";
                continue;
              }
            }
          }
          if (char === "}") {
            if (i === cst.items.length - 1) continue;
          } else if (char === next) {
            next = ":";
            continue;
          }
          const msg = `Flow map contains an unexpected ${char}`;
          const err = new PlainValue.YAMLSyntaxError(cst, msg);
          err.offset = offset;
          doc.errors.push(err);
        } else if (item.type === PlainValue.Type.BLANK_LINE) {
          comments.push({
            afterKey: !!key,
            before: items.length
          });
        } else if (item.type === PlainValue.Type.COMMENT) {
          checkFlowCommentSpace(doc.errors, item);
          comments.push({
            afterKey: !!key,
            before: items.length,
            comment: item.comment
          });
        } else if (key === void 0) {
          if (next === ",") doc.errors.push(new PlainValue.YAMLSemanticError(item, "Separator , missing in flow map"));
          key = resolveNode(doc, item);
        } else {
          if (next !== ",") doc.errors.push(new PlainValue.YAMLSemanticError(item, "Indicator : missing in flow map entry"));
          items.push(new Pair(key, resolveNode(doc, item)));
          key = void 0;
          explicitKey = false;
        }
      }
      checkFlowCollectionEnd(doc.errors, cst);
      if (key !== void 0) items.push(new Pair(key));
      return {
        comments,
        items
      };
    }
    function resolveSeq(doc, cst) {
      if (cst.type !== PlainValue.Type.SEQ && cst.type !== PlainValue.Type.FLOW_SEQ) {
        const msg = `A ${cst.type} node cannot be resolved as a sequence`;
        doc.errors.push(new PlainValue.YAMLSyntaxError(cst, msg));
        return null;
      }
      const {
        comments,
        items
      } = cst.type === PlainValue.Type.FLOW_SEQ ? resolveFlowSeqItems(doc, cst) : resolveBlockSeqItems(doc, cst);
      const seq2 = new YAMLSeq();
      seq2.items = items;
      resolveComments(seq2, comments);
      if (!doc.options.mapAsMap && items.some((it) => it instanceof Pair && it.key instanceof Collection)) {
        const warn = "Keys with collection values will be stringified as YAML due to JS Object restrictions. Use mapAsMap: true to avoid this.";
        doc.warnings.push(new PlainValue.YAMLWarning(cst, warn));
      }
      cst.resolved = seq2;
      return seq2;
    }
    function resolveBlockSeqItems(doc, cst) {
      const comments = [];
      const items = [];
      for (let i = 0; i < cst.items.length; ++i) {
        const item = cst.items[i];
        switch (item.type) {
          case PlainValue.Type.BLANK_LINE:
            comments.push({
              before: items.length
            });
            break;
          case PlainValue.Type.COMMENT:
            comments.push({
              comment: item.comment,
              before: items.length
            });
            break;
          case PlainValue.Type.SEQ_ITEM:
            if (item.error) doc.errors.push(item.error);
            items.push(resolveNode(doc, item.node));
            if (item.hasProps) {
              const msg = "Sequence items cannot have tags or anchors before the - indicator";
              doc.errors.push(new PlainValue.YAMLSemanticError(item, msg));
            }
            break;
          default:
            if (item.error) doc.errors.push(item.error);
            doc.errors.push(new PlainValue.YAMLSyntaxError(item, `Unexpected ${item.type} node in sequence`));
        }
      }
      return {
        comments,
        items
      };
    }
    function resolveFlowSeqItems(doc, cst) {
      const comments = [];
      const items = [];
      let explicitKey = false;
      let key = void 0;
      let keyStart = null;
      let next = "[";
      let prevItem = null;
      for (let i = 0; i < cst.items.length; ++i) {
        const item = cst.items[i];
        if (typeof item.char === "string") {
          const {
            char,
            offset
          } = item;
          if (char !== ":" && (explicitKey || key !== void 0)) {
            if (explicitKey && key === void 0) key = next ? items.pop() : null;
            items.push(new Pair(key));
            explicitKey = false;
            key = void 0;
            keyStart = null;
          }
          if (char === next) {
            next = null;
          } else if (!next && char === "?") {
            explicitKey = true;
          } else if (next !== "[" && char === ":" && key === void 0) {
            if (next === ",") {
              key = items.pop();
              if (key instanceof Pair) {
                const msg = "Chaining flow sequence pairs is invalid";
                const err = new PlainValue.YAMLSemanticError(cst, msg);
                err.offset = offset;
                doc.errors.push(err);
              }
              if (!explicitKey && typeof keyStart === "number") {
                const keyEnd = item.range ? item.range.start : item.offset;
                if (keyEnd > keyStart + 1024) doc.errors.push(getLongKeyError(cst, key));
                const {
                  src
                } = prevItem.context;
                for (let i2 = keyStart; i2 < keyEnd; ++i2) if (src[i2] === "\n") {
                  const msg = "Implicit keys of flow sequence pairs need to be on a single line";
                  doc.errors.push(new PlainValue.YAMLSemanticError(prevItem, msg));
                  break;
                }
              }
            } else {
              key = null;
            }
            keyStart = null;
            explicitKey = false;
            next = null;
          } else if (next === "[" || char !== "]" || i < cst.items.length - 1) {
            const msg = `Flow sequence contains an unexpected ${char}`;
            const err = new PlainValue.YAMLSyntaxError(cst, msg);
            err.offset = offset;
            doc.errors.push(err);
          }
        } else if (item.type === PlainValue.Type.BLANK_LINE) {
          comments.push({
            before: items.length
          });
        } else if (item.type === PlainValue.Type.COMMENT) {
          checkFlowCommentSpace(doc.errors, item);
          comments.push({
            comment: item.comment,
            before: items.length
          });
        } else {
          if (next) {
            const msg = `Expected a ${next} in flow sequence`;
            doc.errors.push(new PlainValue.YAMLSemanticError(item, msg));
          }
          const value = resolveNode(doc, item);
          if (key === void 0) {
            items.push(value);
            prevItem = item;
          } else {
            items.push(new Pair(key, value));
            key = void 0;
          }
          keyStart = item.range.start;
          next = ",";
        }
      }
      checkFlowCollectionEnd(doc.errors, cst);
      if (key !== void 0) items.push(new Pair(key));
      return {
        comments,
        items
      };
    }
    exports2.Alias = Alias;
    exports2.Collection = Collection;
    exports2.Merge = Merge;
    exports2.Node = Node;
    exports2.Pair = Pair;
    exports2.Scalar = Scalar;
    exports2.YAMLMap = YAMLMap;
    exports2.YAMLSeq = YAMLSeq;
    exports2.addComment = addComment;
    exports2.binaryOptions = binaryOptions;
    exports2.boolOptions = boolOptions;
    exports2.findPair = findPair;
    exports2.intOptions = intOptions;
    exports2.isEmptyPath = isEmptyPath;
    exports2.nullOptions = nullOptions;
    exports2.resolveMap = resolveMap;
    exports2.resolveNode = resolveNode;
    exports2.resolveSeq = resolveSeq;
    exports2.resolveString = resolveString;
    exports2.strOptions = strOptions;
    exports2.stringifyNumber = stringifyNumber;
    exports2.stringifyString = stringifyString;
    exports2.toJSON = toJSON3;
  }
});

// node_modules/swagger2openapi/node_modules/yaml/dist/warnings-1000a372.js
var require_warnings_1000a372 = __commonJS({
  "node_modules/swagger2openapi/node_modules/yaml/dist/warnings-1000a372.js"(exports2) {
    "use strict";
    var PlainValue = require_PlainValue_ec8e588e();
    var resolveSeq = require_resolveSeq_d03cb037();
    var binary2 = {
      identify: (value) => value instanceof Uint8Array,
      // Buffer inherits from Uint8Array
      default: false,
      tag: "tag:yaml.org,2002:binary",
      /**
       * Returns a Buffer in node and an Uint8Array in browsers
       *
       * To use the resulting buffer as an image, you'll want to do something like:
       *
       *   const blob = new Blob([buffer], { type: 'image/jpeg' })
       *   document.querySelector('#photo').src = URL.createObjectURL(blob)
       */
      resolve: (doc, node2) => {
        const src = resolveSeq.resolveString(doc, node2);
        if (typeof Buffer === "function") {
          return Buffer.from(src, "base64");
        } else if (typeof atob === "function") {
          const str2 = atob(src.replace(/[\n\r]/g, ""));
          const buffer = new Uint8Array(str2.length);
          for (let i = 0; i < str2.length; ++i) buffer[i] = str2.charCodeAt(i);
          return buffer;
        } else {
          const msg = "This environment does not support reading binary tags; either Buffer or atob is required";
          doc.errors.push(new PlainValue.YAMLReferenceError(node2, msg));
          return null;
        }
      },
      options: resolveSeq.binaryOptions,
      stringify: ({
        comment,
        type: type2,
        value
      }, ctx, onComment, onChompKeep) => {
        let src;
        if (typeof Buffer === "function") {
          src = value instanceof Buffer ? value.toString("base64") : Buffer.from(value.buffer).toString("base64");
        } else if (typeof btoa === "function") {
          let s = "";
          for (let i = 0; i < value.length; ++i) s += String.fromCharCode(value[i]);
          src = btoa(s);
        } else {
          throw new Error("This environment does not support writing binary tags; either Buffer or btoa is required");
        }
        if (!type2) type2 = resolveSeq.binaryOptions.defaultType;
        if (type2 === PlainValue.Type.QUOTE_DOUBLE) {
          value = src;
        } else {
          const {
            lineWidth
          } = resolveSeq.binaryOptions;
          const n = Math.ceil(src.length / lineWidth);
          const lines = new Array(n);
          for (let i = 0, o = 0; i < n; ++i, o += lineWidth) {
            lines[i] = src.substr(o, lineWidth);
          }
          value = lines.join(type2 === PlainValue.Type.BLOCK_LITERAL ? "\n" : " ");
        }
        return resolveSeq.stringifyString({
          comment,
          type: type2,
          value
        }, ctx, onComment, onChompKeep);
      }
    };
    function parsePairs(doc, cst) {
      const seq2 = resolveSeq.resolveSeq(doc, cst);
      for (let i = 0; i < seq2.items.length; ++i) {
        let item = seq2.items[i];
        if (item instanceof resolveSeq.Pair) continue;
        else if (item instanceof resolveSeq.YAMLMap) {
          if (item.items.length > 1) {
            const msg = "Each pair must have its own sequence indicator";
            throw new PlainValue.YAMLSemanticError(cst, msg);
          }
          const pair = item.items[0] || new resolveSeq.Pair();
          if (item.commentBefore) pair.commentBefore = pair.commentBefore ? `${item.commentBefore}
${pair.commentBefore}` : item.commentBefore;
          if (item.comment) pair.comment = pair.comment ? `${item.comment}
${pair.comment}` : item.comment;
          item = pair;
        }
        seq2.items[i] = item instanceof resolveSeq.Pair ? item : new resolveSeq.Pair(item);
      }
      return seq2;
    }
    function createPairs(schema2, iterable, ctx) {
      const pairs3 = new resolveSeq.YAMLSeq(schema2);
      pairs3.tag = "tag:yaml.org,2002:pairs";
      for (const it of iterable) {
        let key, value;
        if (Array.isArray(it)) {
          if (it.length === 2) {
            key = it[0];
            value = it[1];
          } else throw new TypeError(`Expected [key, value] tuple: ${it}`);
        } else if (it && it instanceof Object) {
          const keys = Object.keys(it);
          if (keys.length === 1) {
            key = keys[0];
            value = it[key];
          } else throw new TypeError(`Expected { key: value } tuple: ${it}`);
        } else {
          key = it;
        }
        const pair = schema2.createPair(key, value, ctx);
        pairs3.items.push(pair);
      }
      return pairs3;
    }
    var pairs2 = {
      default: false,
      tag: "tag:yaml.org,2002:pairs",
      resolve: parsePairs,
      createNode: createPairs
    };
    var YAMLOMap = class _YAMLOMap extends resolveSeq.YAMLSeq {
      constructor() {
        super();
        PlainValue._defineProperty(this, "add", resolveSeq.YAMLMap.prototype.add.bind(this));
        PlainValue._defineProperty(this, "delete", resolveSeq.YAMLMap.prototype.delete.bind(this));
        PlainValue._defineProperty(this, "get", resolveSeq.YAMLMap.prototype.get.bind(this));
        PlainValue._defineProperty(this, "has", resolveSeq.YAMLMap.prototype.has.bind(this));
        PlainValue._defineProperty(this, "set", resolveSeq.YAMLMap.prototype.set.bind(this));
        this.tag = _YAMLOMap.tag;
      }
      toJSON(_, ctx) {
        const map2 = /* @__PURE__ */ new Map();
        if (ctx && ctx.onCreate) ctx.onCreate(map2);
        for (const pair of this.items) {
          let key, value;
          if (pair instanceof resolveSeq.Pair) {
            key = resolveSeq.toJSON(pair.key, "", ctx);
            value = resolveSeq.toJSON(pair.value, key, ctx);
          } else {
            key = resolveSeq.toJSON(pair, "", ctx);
          }
          if (map2.has(key)) throw new Error("Ordered maps must not include duplicate keys");
          map2.set(key, value);
        }
        return map2;
      }
    };
    PlainValue._defineProperty(YAMLOMap, "tag", "tag:yaml.org,2002:omap");
    function parseOMap(doc, cst) {
      const pairs3 = parsePairs(doc, cst);
      const seenKeys = [];
      for (const {
        key
      } of pairs3.items) {
        if (key instanceof resolveSeq.Scalar) {
          if (seenKeys.includes(key.value)) {
            const msg = "Ordered maps must not include duplicate keys";
            throw new PlainValue.YAMLSemanticError(cst, msg);
          } else {
            seenKeys.push(key.value);
          }
        }
      }
      return Object.assign(new YAMLOMap(), pairs3);
    }
    function createOMap(schema2, iterable, ctx) {
      const pairs3 = createPairs(schema2, iterable, ctx);
      const omap3 = new YAMLOMap();
      omap3.items = pairs3.items;
      return omap3;
    }
    var omap2 = {
      identify: (value) => value instanceof Map,
      nodeClass: YAMLOMap,
      default: false,
      tag: "tag:yaml.org,2002:omap",
      resolve: parseOMap,
      createNode: createOMap
    };
    var YAMLSet = class _YAMLSet extends resolveSeq.YAMLMap {
      constructor() {
        super();
        this.tag = _YAMLSet.tag;
      }
      add(key) {
        const pair = key instanceof resolveSeq.Pair ? key : new resolveSeq.Pair(key);
        const prev = resolveSeq.findPair(this.items, pair.key);
        if (!prev) this.items.push(pair);
      }
      get(key, keepPair) {
        const pair = resolveSeq.findPair(this.items, key);
        return !keepPair && pair instanceof resolveSeq.Pair ? pair.key instanceof resolveSeq.Scalar ? pair.key.value : pair.key : pair;
      }
      set(key, value) {
        if (typeof value !== "boolean") throw new Error(`Expected boolean value for set(key, value) in a YAML set, not ${typeof value}`);
        const prev = resolveSeq.findPair(this.items, key);
        if (prev && !value) {
          this.items.splice(this.items.indexOf(prev), 1);
        } else if (!prev && value) {
          this.items.push(new resolveSeq.Pair(key));
        }
      }
      toJSON(_, ctx) {
        return super.toJSON(_, ctx, Set);
      }
      toString(ctx, onComment, onChompKeep) {
        if (!ctx) return JSON.stringify(this);
        if (this.hasAllNullValues()) return super.toString(ctx, onComment, onChompKeep);
        else throw new Error("Set items must all have null values");
      }
    };
    PlainValue._defineProperty(YAMLSet, "tag", "tag:yaml.org,2002:set");
    function parseSet(doc, cst) {
      const map2 = resolveSeq.resolveMap(doc, cst);
      if (!map2.hasAllNullValues()) throw new PlainValue.YAMLSemanticError(cst, "Set items must all have null values");
      return Object.assign(new YAMLSet(), map2);
    }
    function createSet(schema2, iterable, ctx) {
      const set4 = new YAMLSet();
      for (const value of iterable) set4.items.push(schema2.createPair(value, null, ctx));
      return set4;
    }
    var set3 = {
      identify: (value) => value instanceof Set,
      nodeClass: YAMLSet,
      default: false,
      tag: "tag:yaml.org,2002:set",
      resolve: parseSet,
      createNode: createSet
    };
    var parseSexagesimal = (sign, parts) => {
      const n = parts.split(":").reduce((n2, p) => n2 * 60 + Number(p), 0);
      return sign === "-" ? -n : n;
    };
    var stringifySexagesimal = ({
      value
    }) => {
      if (isNaN(value) || !isFinite(value)) return resolveSeq.stringifyNumber(value);
      let sign = "";
      if (value < 0) {
        sign = "-";
        value = Math.abs(value);
      }
      const parts = [value % 60];
      if (value < 60) {
        parts.unshift(0);
      } else {
        value = Math.round((value - parts[0]) / 60);
        parts.unshift(value % 60);
        if (value >= 60) {
          value = Math.round((value - parts[0]) / 60);
          parts.unshift(value);
        }
      }
      return sign + parts.map((n) => n < 10 ? "0" + String(n) : String(n)).join(":").replace(/000000\d*$/, "");
    };
    var intTime = {
      identify: (value) => typeof value === "number",
      default: true,
      tag: "tag:yaml.org,2002:int",
      format: "TIME",
      test: /^([-+]?)([0-9][0-9_]*(?::[0-5]?[0-9])+)$/,
      resolve: (str2, sign, parts) => parseSexagesimal(sign, parts.replace(/_/g, "")),
      stringify: stringifySexagesimal
    };
    var floatTime = {
      identify: (value) => typeof value === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      format: "TIME",
      test: /^([-+]?)([0-9][0-9_]*(?::[0-5]?[0-9])+\.[0-9_]*)$/,
      resolve: (str2, sign, parts) => parseSexagesimal(sign, parts.replace(/_/g, "")),
      stringify: stringifySexagesimal
    };
    var timestamp2 = {
      identify: (value) => value instanceof Date,
      default: true,
      tag: "tag:yaml.org,2002:timestamp",
      // If the time zone is omitted, the timestamp is assumed to be specified in UTC. The time part
      // may be omitted altogether, resulting in a date format. In such a case, the time part is
      // assumed to be 00:00:00Z (start of day, UTC).
      test: RegExp("^(?:([0-9]{4})-([0-9]{1,2})-([0-9]{1,2})(?:(?:t|T|[ \\t]+)([0-9]{1,2}):([0-9]{1,2}):([0-9]{1,2}(\\.[0-9]+)?)(?:[ \\t]*(Z|[-+][012]?[0-9](?::[0-9]{2})?))?)?)$"),
      resolve: (str2, year, month, day, hour, minute, second, millisec, tz) => {
        if (millisec) millisec = (millisec + "00").substr(1, 3);
        let date = Date.UTC(year, month - 1, day, hour || 0, minute || 0, second || 0, millisec || 0);
        if (tz && tz !== "Z") {
          let d = parseSexagesimal(tz[0], tz.slice(1));
          if (Math.abs(d) < 30) d *= 60;
          date -= 6e4 * d;
        }
        return new Date(date);
      },
      stringify: ({
        value
      }) => value.toISOString().replace(/((T00:00)?:00)?\.000Z$/, "")
    };
    function shouldWarn(deprecation) {
      const env = typeof process !== "undefined" && process.env || {};
      if (deprecation) {
        if (typeof YAML_SILENCE_DEPRECATION_WARNINGS !== "undefined") return !YAML_SILENCE_DEPRECATION_WARNINGS;
        return !env.YAML_SILENCE_DEPRECATION_WARNINGS;
      }
      if (typeof YAML_SILENCE_WARNINGS !== "undefined") return !YAML_SILENCE_WARNINGS;
      return !env.YAML_SILENCE_WARNINGS;
    }
    function warn(warning, type2) {
      if (shouldWarn(false)) {
        const emit = typeof process !== "undefined" && process.emitWarning;
        if (emit) emit(warning, type2);
        else {
          console.warn(type2 ? `${type2}: ${warning}` : warning);
        }
      }
    }
    function warnFileDeprecation(filename) {
      if (shouldWarn(true)) {
        const path = filename.replace(/.*yaml[/\\]/i, "").replace(/\.js$/, "").replace(/\\/g, "/");
        warn(`The endpoint 'yaml/${path}' will be removed in a future release.`, "DeprecationWarning");
      }
    }
    var warned = {};
    function warnOptionDeprecation(name, alternative) {
      if (!warned[name] && shouldWarn(true)) {
        warned[name] = true;
        let msg = `The option '${name}' will be removed in a future release`;
        msg += alternative ? `, use '${alternative}' instead.` : ".";
        warn(msg, "DeprecationWarning");
      }
    }
    exports2.binary = binary2;
    exports2.floatTime = floatTime;
    exports2.intTime = intTime;
    exports2.omap = omap2;
    exports2.pairs = pairs2;
    exports2.set = set3;
    exports2.timestamp = timestamp2;
    exports2.warn = warn;
    exports2.warnFileDeprecation = warnFileDeprecation;
    exports2.warnOptionDeprecation = warnOptionDeprecation;
  }
});

// node_modules/swagger2openapi/node_modules/yaml/dist/Schema-88e323a7.js
var require_Schema_88e323a7 = __commonJS({
  "node_modules/swagger2openapi/node_modules/yaml/dist/Schema-88e323a7.js"(exports2) {
    "use strict";
    var PlainValue = require_PlainValue_ec8e588e();
    var resolveSeq = require_resolveSeq_d03cb037();
    var warnings = require_warnings_1000a372();
    function createMap(schema2, obj, ctx) {
      const map3 = new resolveSeq.YAMLMap(schema2);
      if (obj instanceof Map) {
        for (const [key, value] of obj) map3.items.push(schema2.createPair(key, value, ctx));
      } else if (obj && typeof obj === "object") {
        for (const key of Object.keys(obj)) map3.items.push(schema2.createPair(key, obj[key], ctx));
      }
      if (typeof schema2.sortMapEntries === "function") {
        map3.items.sort(schema2.sortMapEntries);
      }
      return map3;
    }
    var map2 = {
      createNode: createMap,
      default: true,
      nodeClass: resolveSeq.YAMLMap,
      tag: "tag:yaml.org,2002:map",
      resolve: resolveSeq.resolveMap
    };
    function createSeq(schema2, obj, ctx) {
      const seq3 = new resolveSeq.YAMLSeq(schema2);
      if (obj && obj[Symbol.iterator]) {
        for (const it of obj) {
          const v = schema2.createNode(it, ctx.wrapScalars, null, ctx);
          seq3.items.push(v);
        }
      }
      return seq3;
    }
    var seq2 = {
      createNode: createSeq,
      default: true,
      nodeClass: resolveSeq.YAMLSeq,
      tag: "tag:yaml.org,2002:seq",
      resolve: resolveSeq.resolveSeq
    };
    var string = {
      identify: (value) => typeof value === "string",
      default: true,
      tag: "tag:yaml.org,2002:str",
      resolve: resolveSeq.resolveString,
      stringify(item, ctx, onComment, onChompKeep) {
        ctx = Object.assign({
          actualString: true
        }, ctx);
        return resolveSeq.stringifyString(item, ctx, onComment, onChompKeep);
      },
      options: resolveSeq.strOptions
    };
    var failsafe2 = [map2, seq2, string];
    var intIdentify$2 = (value) => typeof value === "bigint" || Number.isInteger(value);
    var intResolve$1 = (src, part, radix) => resolveSeq.intOptions.asBigInt ? BigInt(src) : parseInt(part, radix);
    function intStringify$1(node2, radix, prefix) {
      const {
        value
      } = node2;
      if (intIdentify$2(value) && value >= 0) return prefix + value.toString(radix);
      return resolveSeq.stringifyNumber(node2);
    }
    var nullObj = {
      identify: (value) => value == null,
      createNode: (schema2, value, ctx) => ctx.wrapScalars ? new resolveSeq.Scalar(null) : null,
      default: true,
      tag: "tag:yaml.org,2002:null",
      test: /^(?:~|[Nn]ull|NULL)?$/,
      resolve: () => null,
      options: resolveSeq.nullOptions,
      stringify: () => resolveSeq.nullOptions.nullStr
    };
    var boolObj = {
      identify: (value) => typeof value === "boolean",
      default: true,
      tag: "tag:yaml.org,2002:bool",
      test: /^(?:[Tt]rue|TRUE|[Ff]alse|FALSE)$/,
      resolve: (str2) => str2[0] === "t" || str2[0] === "T",
      options: resolveSeq.boolOptions,
      stringify: ({
        value
      }) => value ? resolveSeq.boolOptions.trueStr : resolveSeq.boolOptions.falseStr
    };
    var octObj = {
      identify: (value) => intIdentify$2(value) && value >= 0,
      default: true,
      tag: "tag:yaml.org,2002:int",
      format: "OCT",
      test: /^0o([0-7]+)$/,
      resolve: (str2, oct) => intResolve$1(str2, oct, 8),
      options: resolveSeq.intOptions,
      stringify: (node2) => intStringify$1(node2, 8, "0o")
    };
    var intObj = {
      identify: intIdentify$2,
      default: true,
      tag: "tag:yaml.org,2002:int",
      test: /^[-+]?[0-9]+$/,
      resolve: (str2) => intResolve$1(str2, str2, 10),
      options: resolveSeq.intOptions,
      stringify: resolveSeq.stringifyNumber
    };
    var hexObj = {
      identify: (value) => intIdentify$2(value) && value >= 0,
      default: true,
      tag: "tag:yaml.org,2002:int",
      format: "HEX",
      test: /^0x([0-9a-fA-F]+)$/,
      resolve: (str2, hex) => intResolve$1(str2, hex, 16),
      options: resolveSeq.intOptions,
      stringify: (node2) => intStringify$1(node2, 16, "0x")
    };
    var nanObj = {
      identify: (value) => typeof value === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      test: /^(?:[-+]?\.inf|(\.nan))$/i,
      resolve: (str2, nan) => nan ? NaN : str2[0] === "-" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY,
      stringify: resolveSeq.stringifyNumber
    };
    var expObj = {
      identify: (value) => typeof value === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      format: "EXP",
      test: /^[-+]?(?:\.[0-9]+|[0-9]+(?:\.[0-9]*)?)[eE][-+]?[0-9]+$/,
      resolve: (str2) => parseFloat(str2),
      stringify: ({
        value
      }) => Number(value).toExponential()
    };
    var floatObj = {
      identify: (value) => typeof value === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      test: /^[-+]?(?:\.([0-9]+)|[0-9]+\.([0-9]*))$/,
      resolve(str2, frac1, frac2) {
        const frac = frac1 || frac2;
        const node2 = new resolveSeq.Scalar(parseFloat(str2));
        if (frac && frac[frac.length - 1] === "0") node2.minFractionDigits = frac.length;
        return node2;
      },
      stringify: resolveSeq.stringifyNumber
    };
    var core2 = failsafe2.concat([nullObj, boolObj, octObj, intObj, hexObj, nanObj, expObj, floatObj]);
    var intIdentify$1 = (value) => typeof value === "bigint" || Number.isInteger(value);
    var stringifyJSON = ({
      value
    }) => JSON.stringify(value);
    var json3 = [map2, seq2, {
      identify: (value) => typeof value === "string",
      default: true,
      tag: "tag:yaml.org,2002:str",
      resolve: resolveSeq.resolveString,
      stringify: stringifyJSON
    }, {
      identify: (value) => value == null,
      createNode: (schema2, value, ctx) => ctx.wrapScalars ? new resolveSeq.Scalar(null) : null,
      default: true,
      tag: "tag:yaml.org,2002:null",
      test: /^null$/,
      resolve: () => null,
      stringify: stringifyJSON
    }, {
      identify: (value) => typeof value === "boolean",
      default: true,
      tag: "tag:yaml.org,2002:bool",
      test: /^true|false$/,
      resolve: (str2) => str2 === "true",
      stringify: stringifyJSON
    }, {
      identify: intIdentify$1,
      default: true,
      tag: "tag:yaml.org,2002:int",
      test: /^-?(?:0|[1-9][0-9]*)$/,
      resolve: (str2) => resolveSeq.intOptions.asBigInt ? BigInt(str2) : parseInt(str2, 10),
      stringify: ({
        value
      }) => intIdentify$1(value) ? value.toString() : JSON.stringify(value)
    }, {
      identify: (value) => typeof value === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      test: /^-?(?:0|[1-9][0-9]*)(?:\.[0-9]*)?(?:[eE][-+]?[0-9]+)?$/,
      resolve: (str2) => parseFloat(str2),
      stringify: stringifyJSON
    }];
    json3.scalarFallback = (str2) => {
      throw new SyntaxError(`Unresolved plain scalar ${JSON.stringify(str2)}`);
    };
    var boolStringify = ({
      value
    }) => value ? resolveSeq.boolOptions.trueStr : resolveSeq.boolOptions.falseStr;
    var intIdentify = (value) => typeof value === "bigint" || Number.isInteger(value);
    function intResolve(sign, src, radix) {
      let str2 = src.replace(/_/g, "");
      if (resolveSeq.intOptions.asBigInt) {
        switch (radix) {
          case 2:
            str2 = `0b${str2}`;
            break;
          case 8:
            str2 = `0o${str2}`;
            break;
          case 16:
            str2 = `0x${str2}`;
            break;
        }
        const n2 = BigInt(str2);
        return sign === "-" ? BigInt(-1) * n2 : n2;
      }
      const n = parseInt(str2, radix);
      return sign === "-" ? -1 * n : n;
    }
    function intStringify(node2, radix, prefix) {
      const {
        value
      } = node2;
      if (intIdentify(value)) {
        const str2 = value.toString(radix);
        return value < 0 ? "-" + prefix + str2.substr(1) : prefix + str2;
      }
      return resolveSeq.stringifyNumber(node2);
    }
    var yaml11 = failsafe2.concat([{
      identify: (value) => value == null,
      createNode: (schema2, value, ctx) => ctx.wrapScalars ? new resolveSeq.Scalar(null) : null,
      default: true,
      tag: "tag:yaml.org,2002:null",
      test: /^(?:~|[Nn]ull|NULL)?$/,
      resolve: () => null,
      options: resolveSeq.nullOptions,
      stringify: () => resolveSeq.nullOptions.nullStr
    }, {
      identify: (value) => typeof value === "boolean",
      default: true,
      tag: "tag:yaml.org,2002:bool",
      test: /^(?:Y|y|[Yy]es|YES|[Tt]rue|TRUE|[Oo]n|ON)$/,
      resolve: () => true,
      options: resolveSeq.boolOptions,
      stringify: boolStringify
    }, {
      identify: (value) => typeof value === "boolean",
      default: true,
      tag: "tag:yaml.org,2002:bool",
      test: /^(?:N|n|[Nn]o|NO|[Ff]alse|FALSE|[Oo]ff|OFF)$/i,
      resolve: () => false,
      options: resolveSeq.boolOptions,
      stringify: boolStringify
    }, {
      identify: intIdentify,
      default: true,
      tag: "tag:yaml.org,2002:int",
      format: "BIN",
      test: /^([-+]?)0b([0-1_]+)$/,
      resolve: (str2, sign, bin) => intResolve(sign, bin, 2),
      stringify: (node2) => intStringify(node2, 2, "0b")
    }, {
      identify: intIdentify,
      default: true,
      tag: "tag:yaml.org,2002:int",
      format: "OCT",
      test: /^([-+]?)0([0-7_]+)$/,
      resolve: (str2, sign, oct) => intResolve(sign, oct, 8),
      stringify: (node2) => intStringify(node2, 8, "0")
    }, {
      identify: intIdentify,
      default: true,
      tag: "tag:yaml.org,2002:int",
      test: /^([-+]?)([0-9][0-9_]*)$/,
      resolve: (str2, sign, abs) => intResolve(sign, abs, 10),
      stringify: resolveSeq.stringifyNumber
    }, {
      identify: intIdentify,
      default: true,
      tag: "tag:yaml.org,2002:int",
      format: "HEX",
      test: /^([-+]?)0x([0-9a-fA-F_]+)$/,
      resolve: (str2, sign, hex) => intResolve(sign, hex, 16),
      stringify: (node2) => intStringify(node2, 16, "0x")
    }, {
      identify: (value) => typeof value === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      test: /^(?:[-+]?\.inf|(\.nan))$/i,
      resolve: (str2, nan) => nan ? NaN : str2[0] === "-" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY,
      stringify: resolveSeq.stringifyNumber
    }, {
      identify: (value) => typeof value === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      format: "EXP",
      test: /^[-+]?([0-9][0-9_]*)?(\.[0-9_]*)?[eE][-+]?[0-9]+$/,
      resolve: (str2) => parseFloat(str2.replace(/_/g, "")),
      stringify: ({
        value
      }) => Number(value).toExponential()
    }, {
      identify: (value) => typeof value === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      test: /^[-+]?(?:[0-9][0-9_]*)?\.([0-9_]*)$/,
      resolve(str2, frac) {
        const node2 = new resolveSeq.Scalar(parseFloat(str2.replace(/_/g, "")));
        if (frac) {
          const f = frac.replace(/_/g, "");
          if (f[f.length - 1] === "0") node2.minFractionDigits = f.length;
        }
        return node2;
      },
      stringify: resolveSeq.stringifyNumber
    }], warnings.binary, warnings.omap, warnings.pairs, warnings.set, warnings.intTime, warnings.floatTime, warnings.timestamp);
    var schemas = {
      core: core2,
      failsafe: failsafe2,
      json: json3,
      yaml11
    };
    var tags = {
      binary: warnings.binary,
      bool: boolObj,
      float: floatObj,
      floatExp: expObj,
      floatNaN: nanObj,
      floatTime: warnings.floatTime,
      int: intObj,
      intHex: hexObj,
      intOct: octObj,
      intTime: warnings.intTime,
      map: map2,
      null: nullObj,
      omap: warnings.omap,
      pairs: warnings.pairs,
      seq: seq2,
      set: warnings.set,
      timestamp: warnings.timestamp
    };
    function findTagObject(value, tagName, tags2) {
      if (tagName) {
        const match2 = tags2.filter((t) => t.tag === tagName);
        const tagObj = match2.find((t) => !t.format) || match2[0];
        if (!tagObj) throw new Error(`Tag ${tagName} not found`);
        return tagObj;
      }
      return tags2.find((t) => (t.identify && t.identify(value) || t.class && value instanceof t.class) && !t.format);
    }
    function createNode(value, tagName, ctx) {
      if (value instanceof resolveSeq.Node) return value;
      const {
        defaultPrefix,
        onTagObj,
        prevObjects,
        schema: schema2,
        wrapScalars
      } = ctx;
      if (tagName && tagName.startsWith("!!")) tagName = defaultPrefix + tagName.slice(2);
      let tagObj = findTagObject(value, tagName, schema2.tags);
      if (!tagObj) {
        if (typeof value.toJSON === "function") value = value.toJSON();
        if (!value || typeof value !== "object") return wrapScalars ? new resolveSeq.Scalar(value) : value;
        tagObj = value instanceof Map ? map2 : value[Symbol.iterator] ? seq2 : map2;
      }
      if (onTagObj) {
        onTagObj(tagObj);
        delete ctx.onTagObj;
      }
      const obj = {
        value: void 0,
        node: void 0
      };
      if (value && typeof value === "object" && prevObjects) {
        const prev = prevObjects.get(value);
        if (prev) {
          const alias = new resolveSeq.Alias(prev);
          ctx.aliasNodes.push(alias);
          return alias;
        }
        obj.value = value;
        prevObjects.set(value, obj);
      }
      obj.node = tagObj.createNode ? tagObj.createNode(ctx.schema, value, ctx) : wrapScalars ? new resolveSeq.Scalar(value) : value;
      if (tagName && obj.node instanceof resolveSeq.Node) obj.node.tag = tagName;
      return obj.node;
    }
    function getSchemaTags(schemas2, knownTags, customTags, schemaId) {
      let tags2 = schemas2[schemaId.replace(/\W/g, "")];
      if (!tags2) {
        const keys = Object.keys(schemas2).map((key) => JSON.stringify(key)).join(", ");
        throw new Error(`Unknown schema "${schemaId}"; use one of ${keys}`);
      }
      if (Array.isArray(customTags)) {
        for (const tag of customTags) tags2 = tags2.concat(tag);
      } else if (typeof customTags === "function") {
        tags2 = customTags(tags2.slice());
      }
      for (let i = 0; i < tags2.length; ++i) {
        const tag = tags2[i];
        if (typeof tag === "string") {
          const tagObj = knownTags[tag];
          if (!tagObj) {
            const keys = Object.keys(knownTags).map((key) => JSON.stringify(key)).join(", ");
            throw new Error(`Unknown custom tag "${tag}"; use one of ${keys}`);
          }
          tags2[i] = tagObj;
        }
      }
      return tags2;
    }
    var sortMapEntriesByKey = (a, b) => a.key < b.key ? -1 : a.key > b.key ? 1 : 0;
    var Schema2 = class _Schema {
      // TODO: remove in v2
      // TODO: remove in v2
      constructor({
        customTags,
        merge: merge2,
        schema: schema2,
        sortMapEntries,
        tags: deprecatedCustomTags
      }) {
        this.merge = !!merge2;
        this.name = schema2;
        this.sortMapEntries = sortMapEntries === true ? sortMapEntriesByKey : sortMapEntries || null;
        if (!customTags && deprecatedCustomTags) warnings.warnOptionDeprecation("tags", "customTags");
        this.tags = getSchemaTags(schemas, tags, customTags || deprecatedCustomTags, schema2);
      }
      createNode(value, wrapScalars, tagName, ctx) {
        const baseCtx = {
          defaultPrefix: _Schema.defaultPrefix,
          schema: this,
          wrapScalars
        };
        const createCtx = ctx ? Object.assign(ctx, baseCtx) : baseCtx;
        return createNode(value, tagName, createCtx);
      }
      createPair(key, value, ctx) {
        if (!ctx) ctx = {
          wrapScalars: true
        };
        const k = this.createNode(key, ctx.wrapScalars, null, ctx);
        const v = this.createNode(value, ctx.wrapScalars, null, ctx);
        return new resolveSeq.Pair(k, v);
      }
    };
    PlainValue._defineProperty(Schema2, "defaultPrefix", PlainValue.defaultTagPrefix);
    PlainValue._defineProperty(Schema2, "defaultTags", PlainValue.defaultTags);
    exports2.Schema = Schema2;
  }
});

// node_modules/swagger2openapi/node_modules/yaml/dist/Document-9b4560a1.js
var require_Document_9b4560a1 = __commonJS({
  "node_modules/swagger2openapi/node_modules/yaml/dist/Document-9b4560a1.js"(exports2) {
    "use strict";
    var PlainValue = require_PlainValue_ec8e588e();
    var resolveSeq = require_resolveSeq_d03cb037();
    var Schema2 = require_Schema_88e323a7();
    var defaultOptions = {
      anchorPrefix: "a",
      customTags: null,
      indent: 2,
      indentSeq: true,
      keepCstNodes: false,
      keepNodeTypes: true,
      keepBlobsInJSON: true,
      mapAsMap: false,
      maxAliasCount: 100,
      prettyErrors: false,
      // TODO Set true in v2
      simpleKeys: false,
      version: "1.2"
    };
    var scalarOptions = {
      get binary() {
        return resolveSeq.binaryOptions;
      },
      set binary(opt) {
        Object.assign(resolveSeq.binaryOptions, opt);
      },
      get bool() {
        return resolveSeq.boolOptions;
      },
      set bool(opt) {
        Object.assign(resolveSeq.boolOptions, opt);
      },
      get int() {
        return resolveSeq.intOptions;
      },
      set int(opt) {
        Object.assign(resolveSeq.intOptions, opt);
      },
      get null() {
        return resolveSeq.nullOptions;
      },
      set null(opt) {
        Object.assign(resolveSeq.nullOptions, opt);
      },
      get str() {
        return resolveSeq.strOptions;
      },
      set str(opt) {
        Object.assign(resolveSeq.strOptions, opt);
      }
    };
    var documentOptions = {
      "1.0": {
        schema: "yaml-1.1",
        merge: true,
        tagPrefixes: [{
          handle: "!",
          prefix: PlainValue.defaultTagPrefix
        }, {
          handle: "!!",
          prefix: "tag:private.yaml.org,2002:"
        }]
      },
      1.1: {
        schema: "yaml-1.1",
        merge: true,
        tagPrefixes: [{
          handle: "!",
          prefix: "!"
        }, {
          handle: "!!",
          prefix: PlainValue.defaultTagPrefix
        }]
      },
      1.2: {
        schema: "core",
        merge: false,
        tagPrefixes: [{
          handle: "!",
          prefix: "!"
        }, {
          handle: "!!",
          prefix: PlainValue.defaultTagPrefix
        }]
      }
    };
    function stringifyTag(doc, tag) {
      if ((doc.version || doc.options.version) === "1.0") {
        const priv = tag.match(/^tag:private\.yaml\.org,2002:([^:/]+)$/);
        if (priv) return "!" + priv[1];
        const vocab = tag.match(/^tag:([a-zA-Z0-9-]+)\.yaml\.org,2002:(.*)/);
        return vocab ? `!${vocab[1]}/${vocab[2]}` : `!${tag.replace(/^tag:/, "")}`;
      }
      let p = doc.tagPrefixes.find((p2) => tag.indexOf(p2.prefix) === 0);
      if (!p) {
        const dtp = doc.getDefaults().tagPrefixes;
        p = dtp && dtp.find((p2) => tag.indexOf(p2.prefix) === 0);
      }
      if (!p) return tag[0] === "!" ? tag : `!<${tag}>`;
      const suffix = tag.substr(p.prefix.length).replace(/[!,[\]{}]/g, (ch) => ({
        "!": "%21",
        ",": "%2C",
        "[": "%5B",
        "]": "%5D",
        "{": "%7B",
        "}": "%7D"
      })[ch]);
      return p.handle + suffix;
    }
    function getTagObject(tags, item) {
      if (item instanceof resolveSeq.Alias) return resolveSeq.Alias;
      if (item.tag) {
        const match2 = tags.filter((t) => t.tag === item.tag);
        if (match2.length > 0) return match2.find((t) => t.format === item.format) || match2[0];
      }
      let tagObj, obj;
      if (item instanceof resolveSeq.Scalar) {
        obj = item.value;
        const match2 = tags.filter((t) => t.identify && t.identify(obj) || t.class && obj instanceof t.class);
        tagObj = match2.find((t) => t.format === item.format) || match2.find((t) => !t.format);
      } else {
        obj = item;
        tagObj = tags.find((t) => t.nodeClass && obj instanceof t.nodeClass);
      }
      if (!tagObj) {
        const name = obj && obj.constructor ? obj.constructor.name : typeof obj;
        throw new Error(`Tag not resolved for ${name} value`);
      }
      return tagObj;
    }
    function stringifyProps(node2, tagObj, {
      anchors,
      doc
    }) {
      const props = [];
      const anchor = doc.anchors.getName(node2);
      if (anchor) {
        anchors[anchor] = node2;
        props.push(`&${anchor}`);
      }
      if (node2.tag) {
        props.push(stringifyTag(doc, node2.tag));
      } else if (!tagObj.default) {
        props.push(stringifyTag(doc, tagObj.tag));
      }
      return props.join(" ");
    }
    function stringify3(item, ctx, onComment, onChompKeep) {
      const {
        anchors,
        schema: schema2
      } = ctx.doc;
      let tagObj;
      if (!(item instanceof resolveSeq.Node)) {
        const createCtx = {
          aliasNodes: [],
          onTagObj: (o) => tagObj = o,
          prevObjects: /* @__PURE__ */ new Map()
        };
        item = schema2.createNode(item, true, null, createCtx);
        for (const alias of createCtx.aliasNodes) {
          alias.source = alias.source.node;
          let name = anchors.getName(alias.source);
          if (!name) {
            name = anchors.newName();
            anchors.map[name] = alias.source;
          }
        }
      }
      if (item instanceof resolveSeq.Pair) return item.toString(ctx, onComment, onChompKeep);
      if (!tagObj) tagObj = getTagObject(schema2.tags, item);
      const props = stringifyProps(item, tagObj, ctx);
      if (props.length > 0) ctx.indentAtStart = (ctx.indentAtStart || 0) + props.length + 1;
      const str2 = typeof tagObj.stringify === "function" ? tagObj.stringify(item, ctx, onComment, onChompKeep) : item instanceof resolveSeq.Scalar ? resolveSeq.stringifyString(item, ctx, onComment, onChompKeep) : item.toString(ctx, onComment, onChompKeep);
      if (!props) return str2;
      return item instanceof resolveSeq.Scalar || str2[0] === "{" || str2[0] === "[" ? `${props} ${str2}` : `${props}
${ctx.indent}${str2}`;
    }
    var Anchors = class _Anchors {
      static validAnchorNode(node2) {
        return node2 instanceof resolveSeq.Scalar || node2 instanceof resolveSeq.YAMLSeq || node2 instanceof resolveSeq.YAMLMap;
      }
      constructor(prefix) {
        PlainValue._defineProperty(this, "map", /* @__PURE__ */ Object.create(null));
        this.prefix = prefix;
      }
      createAlias(node2, name) {
        this.setAnchor(node2, name);
        return new resolveSeq.Alias(node2);
      }
      createMergePair(...sources) {
        const merge2 = new resolveSeq.Merge();
        merge2.value.items = sources.map((s) => {
          if (s instanceof resolveSeq.Alias) {
            if (s.source instanceof resolveSeq.YAMLMap) return s;
          } else if (s instanceof resolveSeq.YAMLMap) {
            return this.createAlias(s);
          }
          throw new Error("Merge sources must be Map nodes or their Aliases");
        });
        return merge2;
      }
      getName(node2) {
        const {
          map: map2
        } = this;
        return Object.keys(map2).find((a) => map2[a] === node2);
      }
      getNames() {
        return Object.keys(this.map);
      }
      getNode(name) {
        return this.map[name];
      }
      newName(prefix) {
        if (!prefix) prefix = this.prefix;
        const names = Object.keys(this.map);
        for (let i = 1; true; ++i) {
          const name = `${prefix}${i}`;
          if (!names.includes(name)) return name;
        }
      }
      // During parsing, map & aliases contain CST nodes
      resolveNodes() {
        const {
          map: map2,
          _cstAliases
        } = this;
        Object.keys(map2).forEach((a) => {
          map2[a] = map2[a].resolved;
        });
        _cstAliases.forEach((a) => {
          a.source = a.source.resolved;
        });
        delete this._cstAliases;
      }
      setAnchor(node2, name) {
        if (node2 != null && !_Anchors.validAnchorNode(node2)) {
          throw new Error("Anchors may only be set for Scalar, Seq and Map nodes");
        }
        if (name && /[\x00-\x19\s,[\]{}]/.test(name)) {
          throw new Error("Anchor names must not contain whitespace or control characters");
        }
        const {
          map: map2
        } = this;
        const prev = node2 && Object.keys(map2).find((a) => map2[a] === node2);
        if (prev) {
          if (!name) {
            return prev;
          } else if (prev !== name) {
            delete map2[prev];
            map2[name] = node2;
          }
        } else {
          if (!name) {
            if (!node2) return null;
            name = this.newName();
          }
          map2[name] = node2;
        }
        return name;
      }
    };
    var visit3 = (node2, tags) => {
      if (node2 && typeof node2 === "object") {
        const {
          tag
        } = node2;
        if (node2 instanceof resolveSeq.Collection) {
          if (tag) tags[tag] = true;
          node2.items.forEach((n) => visit3(n, tags));
        } else if (node2 instanceof resolveSeq.Pair) {
          visit3(node2.key, tags);
          visit3(node2.value, tags);
        } else if (node2 instanceof resolveSeq.Scalar) {
          if (tag) tags[tag] = true;
        }
      }
      return tags;
    };
    var listTagNames = (node2) => Object.keys(visit3(node2, {}));
    function parseContents(doc, contents) {
      const comments = {
        before: [],
        after: []
      };
      let body = void 0;
      let spaceBefore = false;
      for (const node2 of contents) {
        if (node2.valueRange) {
          if (body !== void 0) {
            const msg = "Document contains trailing content not separated by a ... or --- line";
            doc.errors.push(new PlainValue.YAMLSyntaxError(node2, msg));
            break;
          }
          const res = resolveSeq.resolveNode(doc, node2);
          if (spaceBefore) {
            res.spaceBefore = true;
            spaceBefore = false;
          }
          body = res;
        } else if (node2.comment !== null) {
          const cc = body === void 0 ? comments.before : comments.after;
          cc.push(node2.comment);
        } else if (node2.type === PlainValue.Type.BLANK_LINE) {
          spaceBefore = true;
          if (body === void 0 && comments.before.length > 0 && !doc.commentBefore) {
            doc.commentBefore = comments.before.join("\n");
            comments.before = [];
          }
        }
      }
      doc.contents = body || null;
      if (!body) {
        doc.comment = comments.before.concat(comments.after).join("\n") || null;
      } else {
        const cb = comments.before.join("\n");
        if (cb) {
          const cbNode = body instanceof resolveSeq.Collection && body.items[0] ? body.items[0] : body;
          cbNode.commentBefore = cbNode.commentBefore ? `${cb}
${cbNode.commentBefore}` : cb;
        }
        doc.comment = comments.after.join("\n") || null;
      }
    }
    function resolveTagDirective({
      tagPrefixes
    }, directive) {
      const [handle, prefix] = directive.parameters;
      if (!handle || !prefix) {
        const msg = "Insufficient parameters given for %TAG directive";
        throw new PlainValue.YAMLSemanticError(directive, msg);
      }
      if (tagPrefixes.some((p) => p.handle === handle)) {
        const msg = "The %TAG directive must only be given at most once per handle in the same document.";
        throw new PlainValue.YAMLSemanticError(directive, msg);
      }
      return {
        handle,
        prefix
      };
    }
    function resolveYamlDirective(doc, directive) {
      let [version] = directive.parameters;
      if (directive.name === "YAML:1.0") version = "1.0";
      if (!version) {
        const msg = "Insufficient parameters given for %YAML directive";
        throw new PlainValue.YAMLSemanticError(directive, msg);
      }
      if (!documentOptions[version]) {
        const v0 = doc.version || doc.options.version;
        const msg = `Document will be parsed as YAML ${v0} rather than YAML ${version}`;
        doc.warnings.push(new PlainValue.YAMLWarning(directive, msg));
      }
      return version;
    }
    function parseDirectives(doc, directives, prevDoc) {
      const directiveComments = [];
      let hasDirectives = false;
      for (const directive of directives) {
        const {
          comment,
          name
        } = directive;
        switch (name) {
          case "TAG":
            try {
              doc.tagPrefixes.push(resolveTagDirective(doc, directive));
            } catch (error) {
              doc.errors.push(error);
            }
            hasDirectives = true;
            break;
          case "YAML":
          case "YAML:1.0":
            if (doc.version) {
              const msg = "The %YAML directive must only be given at most once per document.";
              doc.errors.push(new PlainValue.YAMLSemanticError(directive, msg));
            }
            try {
              doc.version = resolveYamlDirective(doc, directive);
            } catch (error) {
              doc.errors.push(error);
            }
            hasDirectives = true;
            break;
          default:
            if (name) {
              const msg = `YAML only supports %TAG and %YAML directives, and not %${name}`;
              doc.warnings.push(new PlainValue.YAMLWarning(directive, msg));
            }
        }
        if (comment) directiveComments.push(comment);
      }
      if (prevDoc && !hasDirectives && "1.1" === (doc.version || prevDoc.version || doc.options.version)) {
        const copyTagPrefix = ({
          handle,
          prefix
        }) => ({
          handle,
          prefix
        });
        doc.tagPrefixes = prevDoc.tagPrefixes.map(copyTagPrefix);
        doc.version = prevDoc.version;
      }
      doc.commentBefore = directiveComments.join("\n") || null;
    }
    function assertCollection(contents) {
      if (contents instanceof resolveSeq.Collection) return true;
      throw new Error("Expected a YAML collection as document contents");
    }
    var Document = class _Document {
      constructor(options) {
        this.anchors = new Anchors(options.anchorPrefix);
        this.commentBefore = null;
        this.comment = null;
        this.contents = null;
        this.directivesEndMarker = null;
        this.errors = [];
        this.options = options;
        this.schema = null;
        this.tagPrefixes = [];
        this.version = null;
        this.warnings = [];
      }
      add(value) {
        assertCollection(this.contents);
        return this.contents.add(value);
      }
      addIn(path, value) {
        assertCollection(this.contents);
        this.contents.addIn(path, value);
      }
      delete(key) {
        assertCollection(this.contents);
        return this.contents.delete(key);
      }
      deleteIn(path) {
        if (resolveSeq.isEmptyPath(path)) {
          if (this.contents == null) return false;
          this.contents = null;
          return true;
        }
        assertCollection(this.contents);
        return this.contents.deleteIn(path);
      }
      getDefaults() {
        return _Document.defaults[this.version] || _Document.defaults[this.options.version] || {};
      }
      get(key, keepScalar) {
        return this.contents instanceof resolveSeq.Collection ? this.contents.get(key, keepScalar) : void 0;
      }
      getIn(path, keepScalar) {
        if (resolveSeq.isEmptyPath(path)) return !keepScalar && this.contents instanceof resolveSeq.Scalar ? this.contents.value : this.contents;
        return this.contents instanceof resolveSeq.Collection ? this.contents.getIn(path, keepScalar) : void 0;
      }
      has(key) {
        return this.contents instanceof resolveSeq.Collection ? this.contents.has(key) : false;
      }
      hasIn(path) {
        if (resolveSeq.isEmptyPath(path)) return this.contents !== void 0;
        return this.contents instanceof resolveSeq.Collection ? this.contents.hasIn(path) : false;
      }
      set(key, value) {
        assertCollection(this.contents);
        this.contents.set(key, value);
      }
      setIn(path, value) {
        if (resolveSeq.isEmptyPath(path)) this.contents = value;
        else {
          assertCollection(this.contents);
          this.contents.setIn(path, value);
        }
      }
      setSchema(id, customTags) {
        if (!id && !customTags && this.schema) return;
        if (typeof id === "number") id = id.toFixed(1);
        if (id === "1.0" || id === "1.1" || id === "1.2") {
          if (this.version) this.version = id;
          else this.options.version = id;
          delete this.options.schema;
        } else if (id && typeof id === "string") {
          this.options.schema = id;
        }
        if (Array.isArray(customTags)) this.options.customTags = customTags;
        const opt = Object.assign({}, this.getDefaults(), this.options);
        this.schema = new Schema2.Schema(opt);
      }
      parse(node2, prevDoc) {
        if (this.options.keepCstNodes) this.cstNode = node2;
        if (this.options.keepNodeTypes) this.type = "DOCUMENT";
        const {
          directives = [],
          contents = [],
          directivesEndMarker,
          error,
          valueRange
        } = node2;
        if (error) {
          if (!error.source) error.source = this;
          this.errors.push(error);
        }
        parseDirectives(this, directives, prevDoc);
        if (directivesEndMarker) this.directivesEndMarker = true;
        this.range = valueRange ? [valueRange.start, valueRange.end] : null;
        this.setSchema();
        this.anchors._cstAliases = [];
        parseContents(this, contents);
        this.anchors.resolveNodes();
        if (this.options.prettyErrors) {
          for (const error2 of this.errors) if (error2 instanceof PlainValue.YAMLError) error2.makePretty();
          for (const warn of this.warnings) if (warn instanceof PlainValue.YAMLError) warn.makePretty();
        }
        return this;
      }
      listNonDefaultTags() {
        return listTagNames(this.contents).filter((t) => t.indexOf(Schema2.Schema.defaultPrefix) !== 0);
      }
      setTagPrefix(handle, prefix) {
        if (handle[0] !== "!" || handle[handle.length - 1] !== "!") throw new Error("Handle must start and end with !");
        if (prefix) {
          const prev = this.tagPrefixes.find((p) => p.handle === handle);
          if (prev) prev.prefix = prefix;
          else this.tagPrefixes.push({
            handle,
            prefix
          });
        } else {
          this.tagPrefixes = this.tagPrefixes.filter((p) => p.handle !== handle);
        }
      }
      toJSON(arg, onAnchor) {
        const {
          keepBlobsInJSON,
          mapAsMap,
          maxAliasCount
        } = this.options;
        const keep = keepBlobsInJSON && (typeof arg !== "string" || !(this.contents instanceof resolveSeq.Scalar));
        const ctx = {
          doc: this,
          indentStep: "  ",
          keep,
          mapAsMap: keep && !!mapAsMap,
          maxAliasCount,
          stringify: stringify3
          // Requiring directly in Pair would create circular dependencies
        };
        const anchorNames = Object.keys(this.anchors.map);
        if (anchorNames.length > 0) ctx.anchors = new Map(anchorNames.map((name) => [this.anchors.map[name], {
          alias: [],
          aliasCount: 0,
          count: 1
        }]));
        const res = resolveSeq.toJSON(this.contents, arg, ctx);
        if (typeof onAnchor === "function" && ctx.anchors) for (const {
          count,
          res: res2
        } of ctx.anchors.values()) onAnchor(res2, count);
        return res;
      }
      toString() {
        if (this.errors.length > 0) throw new Error("Document with errors cannot be stringified");
        const indentSize = this.options.indent;
        if (!Number.isInteger(indentSize) || indentSize <= 0) {
          const s = JSON.stringify(indentSize);
          throw new Error(`"indent" option must be a positive integer, not ${s}`);
        }
        this.setSchema();
        const lines = [];
        let hasDirectives = false;
        if (this.version) {
          let vd = "%YAML 1.2";
          if (this.schema.name === "yaml-1.1") {
            if (this.version === "1.0") vd = "%YAML:1.0";
            else if (this.version === "1.1") vd = "%YAML 1.1";
          }
          lines.push(vd);
          hasDirectives = true;
        }
        const tagNames = this.listNonDefaultTags();
        this.tagPrefixes.forEach(({
          handle,
          prefix
        }) => {
          if (tagNames.some((t) => t.indexOf(prefix) === 0)) {
            lines.push(`%TAG ${handle} ${prefix}`);
            hasDirectives = true;
          }
        });
        if (hasDirectives || this.directivesEndMarker) lines.push("---");
        if (this.commentBefore) {
          if (hasDirectives || !this.directivesEndMarker) lines.unshift("");
          lines.unshift(this.commentBefore.replace(/^/gm, "#"));
        }
        const ctx = {
          anchors: /* @__PURE__ */ Object.create(null),
          doc: this,
          indent: "",
          indentStep: " ".repeat(indentSize),
          stringify: stringify3
          // Requiring directly in nodes would create circular dependencies
        };
        let chompKeep = false;
        let contentComment = null;
        if (this.contents) {
          if (this.contents instanceof resolveSeq.Node) {
            if (this.contents.spaceBefore && (hasDirectives || this.directivesEndMarker)) lines.push("");
            if (this.contents.commentBefore) lines.push(this.contents.commentBefore.replace(/^/gm, "#"));
            ctx.forceBlockIndent = !!this.comment;
            contentComment = this.contents.comment;
          }
          const onChompKeep = contentComment ? null : () => chompKeep = true;
          const body = stringify3(this.contents, ctx, () => contentComment = null, onChompKeep);
          lines.push(resolveSeq.addComment(body, "", contentComment));
        } else if (this.contents !== void 0) {
          lines.push(stringify3(this.contents, ctx));
        }
        if (this.comment) {
          if ((!chompKeep || contentComment) && lines[lines.length - 1] !== "") lines.push("");
          lines.push(this.comment.replace(/^/gm, "#"));
        }
        return lines.join("\n") + "\n";
      }
    };
    PlainValue._defineProperty(Document, "defaults", documentOptions);
    exports2.Document = Document;
    exports2.defaultOptions = defaultOptions;
    exports2.scalarOptions = scalarOptions;
  }
});

// node_modules/swagger2openapi/node_modules/yaml/dist/index.js
var require_dist4 = __commonJS({
  "node_modules/swagger2openapi/node_modules/yaml/dist/index.js"(exports2) {
    "use strict";
    var parseCst = require_parse_cst();
    var Document$1 = require_Document_9b4560a1();
    var Schema2 = require_Schema_88e323a7();
    var PlainValue = require_PlainValue_ec8e588e();
    var warnings = require_warnings_1000a372();
    require_resolveSeq_d03cb037();
    function createNode(value, wrapScalars = true, tag) {
      if (tag === void 0 && typeof wrapScalars === "string") {
        tag = wrapScalars;
        wrapScalars = true;
      }
      const options = Object.assign({}, Document$1.Document.defaults[Document$1.defaultOptions.version], Document$1.defaultOptions);
      const schema2 = new Schema2.Schema(options);
      return schema2.createNode(value, wrapScalars, tag);
    }
    var Document = class extends Document$1.Document {
      constructor(options) {
        super(Object.assign({}, Document$1.defaultOptions, options));
      }
    };
    function parseAllDocuments(src, options) {
      const stream = [];
      let prev;
      for (const cstDoc of parseCst.parse(src)) {
        const doc = new Document(options);
        doc.parse(cstDoc, prev);
        stream.push(doc);
        prev = doc;
      }
      return stream;
    }
    function parseDocument(src, options) {
      const cst = parseCst.parse(src);
      const doc = new Document(options).parse(cst[0]);
      if (cst.length > 1) {
        const errMsg = "Source contains multiple documents; please use YAML.parseAllDocuments()";
        doc.errors.unshift(new PlainValue.YAMLSemanticError(cst[1], errMsg));
      }
      return doc;
    }
    function parse6(src, options) {
      const doc = parseDocument(src, options);
      doc.warnings.forEach((warning) => warnings.warn(warning));
      if (doc.errors.length > 0) throw doc.errors[0];
      return doc.toJSON();
    }
    function stringify3(value, options) {
      const doc = new Document(options);
      doc.contents = value;
      return String(doc);
    }
    var YAML = {
      createNode,
      defaultOptions: Document$1.defaultOptions,
      Document,
      parse: parse6,
      parseAllDocuments,
      parseCST: parseCst.parse,
      parseDocument,
      scalarOptions: Document$1.scalarOptions,
      stringify: stringify3
    };
    exports2.YAML = YAML;
  }
});

// node_modules/swagger2openapi/node_modules/yaml/index.js
var require_yaml2 = __commonJS({
  "node_modules/swagger2openapi/node_modules/yaml/index.js"(exports2, module2) {
    module2.exports = require_dist4().YAML;
  }
});

// node_modules/reftools/lib/jptr.js
var require_jptr = __commonJS({
  "node_modules/reftools/lib/jptr.js"(exports2, module2) {
    "use strict";
    function jpescape(s) {
      return s.replace(/\~/g, "~0").replace(/\//g, "~1");
    }
    function jpunescape(s) {
      return s.replace(/\~1/g, "/").replace(/~0/g, "~");
    }
    function jptr(obj, prop, newValue) {
      if (typeof obj === "undefined") return false;
      if (!prop || typeof prop !== "string" || prop === "#") return typeof newValue !== "undefined" ? newValue : obj;
      if (prop.indexOf("#") >= 0) {
        let parts = prop.split("#");
        let uri = parts[0];
        if (uri) return false;
        prop = parts[1];
        prop = decodeURIComponent(prop.slice(1).split("+").join(" "));
      }
      if (prop.startsWith("/")) prop = prop.slice(1);
      let components = prop.split("/");
      for (let i = 0; i < components.length; i++) {
        components[i] = jpunescape(components[i]);
        let setAndLast = typeof newValue !== "undefined" && i == components.length - 1;
        let index = parseInt(components[i], 10);
        if (!Array.isArray(obj) || isNaN(index) || index.toString() !== components[i]) {
          index = Array.isArray(obj) && components[i] === "-" ? -2 : -1;
        } else {
          components[i] = i > 0 ? components[i - 1] : "";
        }
        if (index != -1 || obj && obj.hasOwnProperty(components[i])) {
          if (index >= 0) {
            if (setAndLast) {
              obj[index] = newValue;
            }
            obj = obj[index];
          } else if (index === -2) {
            if (setAndLast) {
              if (Array.isArray(obj)) {
                obj.push(newValue);
              }
              return newValue;
            } else return void 0;
          } else {
            if (setAndLast) {
              obj[components[i]] = newValue;
            }
            obj = obj[components[i]];
          }
        } else {
          if (typeof newValue !== "undefined" && typeof obj === "object" && !Array.isArray(obj)) {
            obj[components[i]] = setAndLast ? newValue : components[i + 1] === "0" || components[i + 1] === "-" ? [] : {};
            obj = obj[components[i]];
          } else return false;
        }
      }
      return obj;
    }
    module2.exports = {
      jptr,
      jpescape,
      jpunescape
    };
  }
});

// node_modules/reftools/lib/isref.js
var require_isref = __commonJS({
  "node_modules/reftools/lib/isref.js"(exports2, module2) {
    "use strict";
    function isRef2(obj, key) {
      return key === "$ref" && (!!obj && typeof obj[key] === "string");
    }
    module2.exports = {
      isRef: isRef2
    };
  }
});

// node_modules/reftools/lib/clone.js
var require_clone = __commonJS({
  "node_modules/reftools/lib/clone.js"(exports2, module2) {
    "use strict";
    function nop(obj) {
      return obj;
    }
    function clone2(obj) {
      return JSON.parse(JSON.stringify(obj));
    }
    function shallowClone(obj) {
      let result = {};
      for (let p in obj) {
        if (obj.hasOwnProperty(p)) {
          result[p] = obj[p];
        }
      }
      return result;
    }
    function deepClone(obj) {
      let result = Array.isArray(obj) ? [] : {};
      for (let p in obj) {
        if (obj.hasOwnProperty(p) || Array.isArray(obj)) {
          result[p] = typeof obj[p] === "object" ? deepClone(obj[p]) : obj[p];
        }
      }
      return result;
    }
    function fastClone(obj) {
      return Object.assign({}, obj);
    }
    function circularClone(obj, hash) {
      if (!hash) hash = /* @__PURE__ */ new WeakMap();
      if (Object(obj) !== obj || obj instanceof Function) return obj;
      if (hash.has(obj)) return hash.get(obj);
      try {
        var result = new obj.constructor();
      } catch (e) {
        result = Object.create(Object.getPrototypeOf(obj));
      }
      hash.set(obj, result);
      return Object.assign(result, ...Object.keys(obj).map(
        (key) => ({ [key]: circularClone(obj[key], hash) })
      ));
    }
    module2.exports = {
      nop,
      clone: clone2,
      shallowClone,
      deepClone,
      fastClone,
      circularClone
    };
  }
});

// node_modules/reftools/lib/recurse.js
var require_recurse = __commonJS({
  "node_modules/reftools/lib/recurse.js"(exports2, module2) {
    "use strict";
    var jpescape = require_jptr().jpescape;
    function defaultState() {
      return {
        path: "#",
        depth: 0,
        pkey: "",
        parent: {},
        payload: {},
        seen: /* @__PURE__ */ new WeakMap(),
        identity: false,
        identityDetection: false
      };
    }
    function recurse(object, state, callback) {
      if (!state) state = { depth: 0 };
      if (!state.depth) {
        state = Object.assign({}, defaultState(), state);
      }
      if (typeof object !== "object") return;
      let oPath = state.path;
      for (let key in object) {
        state.key = key;
        state.path = state.path + "/" + encodeURIComponent(jpescape(key));
        state.identityPath = state.seen.get(object[key]);
        state.identity = typeof state.identityPath !== "undefined";
        if (object.hasOwnProperty(key)) {
          callback(object, key, state);
        }
        if (typeof object[key] === "object" && !state.identity) {
          if (state.identityDetection && !Array.isArray(object[key]) && object[key] !== null) {
            state.seen.set(object[key], state.path);
          }
          let newState = {};
          newState.parent = object;
          newState.path = state.path;
          newState.depth = state.depth ? state.depth + 1 : 1;
          newState.pkey = key;
          newState.payload = state.payload;
          newState.seen = state.seen;
          newState.identity = false;
          newState.identityDetection = state.identityDetection;
          recurse(object[key], newState, callback);
        }
        state.path = oPath;
      }
    }
    module2.exports = {
      recurse
    };
  }
});

// node_modules/oas-resolver/node_modules/yaml/dist/PlainValue-ec8e588e.js
var require_PlainValue_ec8e588e2 = __commonJS({
  "node_modules/oas-resolver/node_modules/yaml/dist/PlainValue-ec8e588e.js"(exports2) {
    "use strict";
    var Char = {
      ANCHOR: "&",
      COMMENT: "#",
      TAG: "!",
      DIRECTIVES_END: "-",
      DOCUMENT_END: "."
    };
    var Type2 = {
      ALIAS: "ALIAS",
      BLANK_LINE: "BLANK_LINE",
      BLOCK_FOLDED: "BLOCK_FOLDED",
      BLOCK_LITERAL: "BLOCK_LITERAL",
      COMMENT: "COMMENT",
      DIRECTIVE: "DIRECTIVE",
      DOCUMENT: "DOCUMENT",
      FLOW_MAP: "FLOW_MAP",
      FLOW_SEQ: "FLOW_SEQ",
      MAP: "MAP",
      MAP_KEY: "MAP_KEY",
      MAP_VALUE: "MAP_VALUE",
      PLAIN: "PLAIN",
      QUOTE_DOUBLE: "QUOTE_DOUBLE",
      QUOTE_SINGLE: "QUOTE_SINGLE",
      SEQ: "SEQ",
      SEQ_ITEM: "SEQ_ITEM"
    };
    var defaultTagPrefix = "tag:yaml.org,2002:";
    var defaultTags = {
      MAP: "tag:yaml.org,2002:map",
      SEQ: "tag:yaml.org,2002:seq",
      STR: "tag:yaml.org,2002:str"
    };
    function findLineStarts(src) {
      const ls = [0];
      let offset = src.indexOf("\n");
      while (offset !== -1) {
        offset += 1;
        ls.push(offset);
        offset = src.indexOf("\n", offset);
      }
      return ls;
    }
    function getSrcInfo(cst) {
      let lineStarts, src;
      if (typeof cst === "string") {
        lineStarts = findLineStarts(cst);
        src = cst;
      } else {
        if (Array.isArray(cst)) cst = cst[0];
        if (cst && cst.context) {
          if (!cst.lineStarts) cst.lineStarts = findLineStarts(cst.context.src);
          lineStarts = cst.lineStarts;
          src = cst.context.src;
        }
      }
      return {
        lineStarts,
        src
      };
    }
    function getLinePos(offset, cst) {
      if (typeof offset !== "number" || offset < 0) return null;
      const {
        lineStarts,
        src
      } = getSrcInfo(cst);
      if (!lineStarts || !src || offset > src.length) return null;
      for (let i = 0; i < lineStarts.length; ++i) {
        const start = lineStarts[i];
        if (offset < start) {
          return {
            line: i,
            col: offset - lineStarts[i - 1] + 1
          };
        }
        if (offset === start) return {
          line: i + 1,
          col: 1
        };
      }
      const line = lineStarts.length;
      return {
        line,
        col: offset - lineStarts[line - 1] + 1
      };
    }
    function getLine2(line, cst) {
      const {
        lineStarts,
        src
      } = getSrcInfo(cst);
      if (!lineStarts || !(line >= 1) || line > lineStarts.length) return null;
      const start = lineStarts[line - 1];
      let end = lineStarts[line];
      while (end && end > start && src[end - 1] === "\n") --end;
      return src.slice(start, end);
    }
    function getPrettyContext({
      start,
      end
    }, cst, maxWidth = 80) {
      let src = getLine2(start.line, cst);
      if (!src) return null;
      let {
        col
      } = start;
      if (src.length > maxWidth) {
        if (col <= maxWidth - 10) {
          src = src.substr(0, maxWidth - 1) + "\u2026";
        } else {
          const halfWidth = Math.round(maxWidth / 2);
          if (src.length > col + halfWidth) src = src.substr(0, col + halfWidth - 1) + "\u2026";
          col -= src.length - maxWidth;
          src = "\u2026" + src.substr(1 - maxWidth);
        }
      }
      let errLen = 1;
      let errEnd = "";
      if (end) {
        if (end.line === start.line && col + (end.col - start.col) <= maxWidth + 1) {
          errLen = end.col - start.col;
        } else {
          errLen = Math.min(src.length + 1, maxWidth) - col;
          errEnd = "\u2026";
        }
      }
      const offset = col > 1 ? " ".repeat(col - 1) : "";
      const err = "^".repeat(errLen);
      return `${src}
${offset}${err}${errEnd}`;
    }
    var Range = class _Range {
      static copy(orig) {
        return new _Range(orig.start, orig.end);
      }
      constructor(start, end) {
        this.start = start;
        this.end = end || start;
      }
      isEmpty() {
        return typeof this.start !== "number" || !this.end || this.end <= this.start;
      }
      /**
       * Set `origStart` and `origEnd` to point to the original source range for
       * this node, which may differ due to dropped CR characters.
       *
       * @param {number[]} cr - Positions of dropped CR characters
       * @param {number} offset - Starting index of `cr` from the last call
       * @returns {number} - The next offset, matching the one found for `origStart`
       */
      setOrigRange(cr, offset) {
        const {
          start,
          end
        } = this;
        if (cr.length === 0 || end <= cr[0]) {
          this.origStart = start;
          this.origEnd = end;
          return offset;
        }
        let i = offset;
        while (i < cr.length) {
          if (cr[i] > start) break;
          else ++i;
        }
        this.origStart = start + i;
        const nextOffset = i;
        while (i < cr.length) {
          if (cr[i] >= end) break;
          else ++i;
        }
        this.origEnd = end + i;
        return nextOffset;
      }
    };
    var Node = class _Node {
      static addStringTerminator(src, offset, str2) {
        if (str2[str2.length - 1] === "\n") return str2;
        const next = _Node.endOfWhiteSpace(src, offset);
        return next >= src.length || src[next] === "\n" ? str2 + "\n" : str2;
      }
      // ^(---|...)
      static atDocumentBoundary(src, offset, sep) {
        const ch0 = src[offset];
        if (!ch0) return true;
        const prev = src[offset - 1];
        if (prev && prev !== "\n") return false;
        if (sep) {
          if (ch0 !== sep) return false;
        } else {
          if (ch0 !== Char.DIRECTIVES_END && ch0 !== Char.DOCUMENT_END) return false;
        }
        const ch1 = src[offset + 1];
        const ch2 = src[offset + 2];
        if (ch1 !== ch0 || ch2 !== ch0) return false;
        const ch3 = src[offset + 3];
        return !ch3 || ch3 === "\n" || ch3 === "	" || ch3 === " ";
      }
      static endOfIdentifier(src, offset) {
        let ch = src[offset];
        const isVerbatim = ch === "<";
        const notOk = isVerbatim ? ["\n", "	", " ", ">"] : ["\n", "	", " ", "[", "]", "{", "}", ","];
        while (ch && notOk.indexOf(ch) === -1) ch = src[offset += 1];
        if (isVerbatim && ch === ">") offset += 1;
        return offset;
      }
      static endOfIndent(src, offset) {
        let ch = src[offset];
        while (ch === " ") ch = src[offset += 1];
        return offset;
      }
      static endOfLine(src, offset) {
        let ch = src[offset];
        while (ch && ch !== "\n") ch = src[offset += 1];
        return offset;
      }
      static endOfWhiteSpace(src, offset) {
        let ch = src[offset];
        while (ch === "	" || ch === " ") ch = src[offset += 1];
        return offset;
      }
      static startOfLine(src, offset) {
        let ch = src[offset - 1];
        if (ch === "\n") return offset;
        while (ch && ch !== "\n") ch = src[offset -= 1];
        return offset + 1;
      }
      /**
       * End of indentation, or null if the line's indent level is not more
       * than `indent`
       *
       * @param {string} src
       * @param {number} indent
       * @param {number} lineStart
       * @returns {?number}
       */
      static endOfBlockIndent(src, indent, lineStart) {
        const inEnd = _Node.endOfIndent(src, lineStart);
        if (inEnd > lineStart + indent) {
          return inEnd;
        } else {
          const wsEnd = _Node.endOfWhiteSpace(src, inEnd);
          const ch = src[wsEnd];
          if (!ch || ch === "\n") return wsEnd;
        }
        return null;
      }
      static atBlank(src, offset, endAsBlank) {
        const ch = src[offset];
        return ch === "\n" || ch === "	" || ch === " " || endAsBlank && !ch;
      }
      static nextNodeIsIndented(ch, indentDiff, indicatorAsIndent) {
        if (!ch || indentDiff < 0) return false;
        if (indentDiff > 0) return true;
        return indicatorAsIndent && ch === "-";
      }
      // should be at line or string end, or at next non-whitespace char
      static normalizeOffset(src, offset) {
        const ch = src[offset];
        return !ch ? offset : ch !== "\n" && src[offset - 1] === "\n" ? offset - 1 : _Node.endOfWhiteSpace(src, offset);
      }
      // fold single newline into space, multiple newlines to N - 1 newlines
      // presumes src[offset] === '\n'
      static foldNewline(src, offset, indent) {
        let inCount = 0;
        let error = false;
        let fold = "";
        let ch = src[offset + 1];
        while (ch === " " || ch === "	" || ch === "\n") {
          switch (ch) {
            case "\n":
              inCount = 0;
              offset += 1;
              fold += "\n";
              break;
            case "	":
              if (inCount <= indent) error = true;
              offset = _Node.endOfWhiteSpace(src, offset + 2) - 1;
              break;
            case " ":
              inCount += 1;
              offset += 1;
              break;
          }
          ch = src[offset + 1];
        }
        if (!fold) fold = " ";
        if (ch && inCount <= indent) error = true;
        return {
          fold,
          offset,
          error
        };
      }
      constructor(type2, props, context) {
        Object.defineProperty(this, "context", {
          value: context || null,
          writable: true
        });
        this.error = null;
        this.range = null;
        this.valueRange = null;
        this.props = props || [];
        this.type = type2;
        this.value = null;
      }
      getPropValue(idx, key, skipKey) {
        if (!this.context) return null;
        const {
          src
        } = this.context;
        const prop = this.props[idx];
        return prop && src[prop.start] === key ? src.slice(prop.start + (skipKey ? 1 : 0), prop.end) : null;
      }
      get anchor() {
        for (let i = 0; i < this.props.length; ++i) {
          const anchor = this.getPropValue(i, Char.ANCHOR, true);
          if (anchor != null) return anchor;
        }
        return null;
      }
      get comment() {
        const comments = [];
        for (let i = 0; i < this.props.length; ++i) {
          const comment = this.getPropValue(i, Char.COMMENT, true);
          if (comment != null) comments.push(comment);
        }
        return comments.length > 0 ? comments.join("\n") : null;
      }
      commentHasRequiredWhitespace(start) {
        const {
          src
        } = this.context;
        if (this.header && start === this.header.end) return false;
        if (!this.valueRange) return false;
        const {
          end
        } = this.valueRange;
        return start !== end || _Node.atBlank(src, end - 1);
      }
      get hasComment() {
        if (this.context) {
          const {
            src
          } = this.context;
          for (let i = 0; i < this.props.length; ++i) {
            if (src[this.props[i].start] === Char.COMMENT) return true;
          }
        }
        return false;
      }
      get hasProps() {
        if (this.context) {
          const {
            src
          } = this.context;
          for (let i = 0; i < this.props.length; ++i) {
            if (src[this.props[i].start] !== Char.COMMENT) return true;
          }
        }
        return false;
      }
      get includesTrailingLines() {
        return false;
      }
      get jsonLike() {
        const jsonLikeTypes = [Type2.FLOW_MAP, Type2.FLOW_SEQ, Type2.QUOTE_DOUBLE, Type2.QUOTE_SINGLE];
        return jsonLikeTypes.indexOf(this.type) !== -1;
      }
      get rangeAsLinePos() {
        if (!this.range || !this.context) return void 0;
        const start = getLinePos(this.range.start, this.context.root);
        if (!start) return void 0;
        const end = getLinePos(this.range.end, this.context.root);
        return {
          start,
          end
        };
      }
      get rawValue() {
        if (!this.valueRange || !this.context) return null;
        const {
          start,
          end
        } = this.valueRange;
        return this.context.src.slice(start, end);
      }
      get tag() {
        for (let i = 0; i < this.props.length; ++i) {
          const tag = this.getPropValue(i, Char.TAG, false);
          if (tag != null) {
            if (tag[1] === "<") {
              return {
                verbatim: tag.slice(2, -1)
              };
            } else {
              const [_, handle, suffix] = tag.match(/^(.*!)([^!]*)$/);
              return {
                handle,
                suffix
              };
            }
          }
        }
        return null;
      }
      get valueRangeContainsNewline() {
        if (!this.valueRange || !this.context) return false;
        const {
          start,
          end
        } = this.valueRange;
        const {
          src
        } = this.context;
        for (let i = start; i < end; ++i) {
          if (src[i] === "\n") return true;
        }
        return false;
      }
      parseComment(start) {
        const {
          src
        } = this.context;
        if (src[start] === Char.COMMENT) {
          const end = _Node.endOfLine(src, start + 1);
          const commentRange = new Range(start, end);
          this.props.push(commentRange);
          return end;
        }
        return start;
      }
      /**
       * Populates the `origStart` and `origEnd` values of all ranges for this
       * node. Extended by child classes to handle descendant nodes.
       *
       * @param {number[]} cr - Positions of dropped CR characters
       * @param {number} offset - Starting index of `cr` from the last call
       * @returns {number} - The next offset, matching the one found for `origStart`
       */
      setOrigRanges(cr, offset) {
        if (this.range) offset = this.range.setOrigRange(cr, offset);
        if (this.valueRange) this.valueRange.setOrigRange(cr, offset);
        this.props.forEach((prop) => prop.setOrigRange(cr, offset));
        return offset;
      }
      toString() {
        const {
          context: {
            src
          },
          range,
          value
        } = this;
        if (value != null) return value;
        const str2 = src.slice(range.start, range.end);
        return _Node.addStringTerminator(src, range.end, str2);
      }
    };
    var YAMLError = class extends Error {
      constructor(name, source, message) {
        if (!message || !(source instanceof Node)) throw new Error(`Invalid arguments for new ${name}`);
        super();
        this.name = name;
        this.message = message;
        this.source = source;
      }
      makePretty() {
        if (!this.source) return;
        this.nodeType = this.source.type;
        const cst = this.source.context && this.source.context.root;
        if (typeof this.offset === "number") {
          this.range = new Range(this.offset, this.offset + 1);
          const start = cst && getLinePos(this.offset, cst);
          if (start) {
            const end = {
              line: start.line,
              col: start.col + 1
            };
            this.linePos = {
              start,
              end
            };
          }
          delete this.offset;
        } else {
          this.range = this.source.range;
          this.linePos = this.source.rangeAsLinePos;
        }
        if (this.linePos) {
          const {
            line,
            col
          } = this.linePos.start;
          this.message += ` at line ${line}, column ${col}`;
          const ctx = cst && getPrettyContext(this.linePos, cst);
          if (ctx) this.message += `:

${ctx}
`;
        }
        delete this.source;
      }
    };
    var YAMLReferenceError = class extends YAMLError {
      constructor(source, message) {
        super("YAMLReferenceError", source, message);
      }
    };
    var YAMLSemanticError = class extends YAMLError {
      constructor(source, message) {
        super("YAMLSemanticError", source, message);
      }
    };
    var YAMLSyntaxError = class extends YAMLError {
      constructor(source, message) {
        super("YAMLSyntaxError", source, message);
      }
    };
    var YAMLWarning = class extends YAMLError {
      constructor(source, message) {
        super("YAMLWarning", source, message);
      }
    };
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    var PlainValue = class _PlainValue extends Node {
      static endOfLine(src, start, inFlow) {
        let ch = src[start];
        let offset = start;
        while (ch && ch !== "\n") {
          if (inFlow && (ch === "[" || ch === "]" || ch === "{" || ch === "}" || ch === ",")) break;
          const next = src[offset + 1];
          if (ch === ":" && (!next || next === "\n" || next === "	" || next === " " || inFlow && next === ",")) break;
          if ((ch === " " || ch === "	") && next === "#") break;
          offset += 1;
          ch = next;
        }
        return offset;
      }
      get strValue() {
        if (!this.valueRange || !this.context) return null;
        let {
          start,
          end
        } = this.valueRange;
        const {
          src
        } = this.context;
        let ch = src[end - 1];
        while (start < end && (ch === "\n" || ch === "	" || ch === " ")) ch = src[--end - 1];
        let str2 = "";
        for (let i = start; i < end; ++i) {
          const ch2 = src[i];
          if (ch2 === "\n") {
            const {
              fold,
              offset
            } = Node.foldNewline(src, i, -1);
            str2 += fold;
            i = offset;
          } else if (ch2 === " " || ch2 === "	") {
            const wsStart = i;
            let next = src[i + 1];
            while (i < end && (next === " " || next === "	")) {
              i += 1;
              next = src[i + 1];
            }
            if (next !== "\n") str2 += i > wsStart ? src.slice(wsStart, i + 1) : ch2;
          } else {
            str2 += ch2;
          }
        }
        const ch0 = src[start];
        switch (ch0) {
          case "	": {
            const msg = "Plain value cannot start with a tab character";
            const errors = [new YAMLSemanticError(this, msg)];
            return {
              errors,
              str: str2
            };
          }
          case "@":
          case "`": {
            const msg = `Plain value cannot start with reserved character ${ch0}`;
            const errors = [new YAMLSemanticError(this, msg)];
            return {
              errors,
              str: str2
            };
          }
          default:
            return str2;
        }
      }
      parseBlockValue(start) {
        const {
          indent,
          inFlow,
          src
        } = this.context;
        let offset = start;
        let valueEnd = start;
        for (let ch = src[offset]; ch === "\n"; ch = src[offset]) {
          if (Node.atDocumentBoundary(src, offset + 1)) break;
          const end = Node.endOfBlockIndent(src, indent, offset + 1);
          if (end === null || src[end] === "#") break;
          if (src[end] === "\n") {
            offset = end;
          } else {
            valueEnd = _PlainValue.endOfLine(src, end, inFlow);
            offset = valueEnd;
          }
        }
        if (this.valueRange.isEmpty()) this.valueRange.start = start;
        this.valueRange.end = valueEnd;
        return valueEnd;
      }
      /**
       * Parses a plain value from the source
       *
       * Accepted forms are:
       * ```
       * #comment
       *
       * first line
       *
       * first line #comment
       *
       * first line
       * block
       * lines
       *
       * #comment
       * block
       * lines
       * ```
       * where block lines are empty or have an indent level greater than `indent`.
       *
       * @param {ParseContext} context
       * @param {number} start - Index of first character
       * @returns {number} - Index of the character after this scalar, may be `\n`
       */
      parse(context, start) {
        this.context = context;
        const {
          inFlow,
          src
        } = context;
        let offset = start;
        const ch = src[offset];
        if (ch && ch !== "#" && ch !== "\n") {
          offset = _PlainValue.endOfLine(src, start, inFlow);
        }
        this.valueRange = new Range(start, offset);
        offset = Node.endOfWhiteSpace(src, offset);
        offset = this.parseComment(offset);
        if (!this.hasComment || this.valueRange.isEmpty()) {
          offset = this.parseBlockValue(offset);
        }
        return offset;
      }
    };
    exports2.Char = Char;
    exports2.Node = Node;
    exports2.PlainValue = PlainValue;
    exports2.Range = Range;
    exports2.Type = Type2;
    exports2.YAMLError = YAMLError;
    exports2.YAMLReferenceError = YAMLReferenceError;
    exports2.YAMLSemanticError = YAMLSemanticError;
    exports2.YAMLSyntaxError = YAMLSyntaxError;
    exports2.YAMLWarning = YAMLWarning;
    exports2._defineProperty = _defineProperty;
    exports2.defaultTagPrefix = defaultTagPrefix;
    exports2.defaultTags = defaultTags;
  }
});

// node_modules/oas-resolver/node_modules/yaml/dist/parse-cst.js
var require_parse_cst2 = __commonJS({
  "node_modules/oas-resolver/node_modules/yaml/dist/parse-cst.js"(exports2) {
    "use strict";
    var PlainValue = require_PlainValue_ec8e588e2();
    var BlankLine = class extends PlainValue.Node {
      constructor() {
        super(PlainValue.Type.BLANK_LINE);
      }
      /* istanbul ignore next */
      get includesTrailingLines() {
        return true;
      }
      /**
       * Parses a blank line from the source
       *
       * @param {ParseContext} context
       * @param {number} start - Index of first \n character
       * @returns {number} - Index of the character after this
       */
      parse(context, start) {
        this.context = context;
        this.range = new PlainValue.Range(start, start + 1);
        return start + 1;
      }
    };
    var CollectionItem = class extends PlainValue.Node {
      constructor(type2, props) {
        super(type2, props);
        this.node = null;
      }
      get includesTrailingLines() {
        return !!this.node && this.node.includesTrailingLines;
      }
      /**
       * @param {ParseContext} context
       * @param {number} start - Index of first character
       * @returns {number} - Index of the character after this
       */
      parse(context, start) {
        this.context = context;
        const {
          parseNode,
          src
        } = context;
        let {
          atLineStart,
          lineStart
        } = context;
        if (!atLineStart && this.type === PlainValue.Type.SEQ_ITEM) this.error = new PlainValue.YAMLSemanticError(this, "Sequence items must not have preceding content on the same line");
        const indent = atLineStart ? start - lineStart : context.indent;
        let offset = PlainValue.Node.endOfWhiteSpace(src, start + 1);
        let ch = src[offset];
        const inlineComment = ch === "#";
        const comments = [];
        let blankLine = null;
        while (ch === "\n" || ch === "#") {
          if (ch === "#") {
            const end2 = PlainValue.Node.endOfLine(src, offset + 1);
            comments.push(new PlainValue.Range(offset, end2));
            offset = end2;
          } else {
            atLineStart = true;
            lineStart = offset + 1;
            const wsEnd = PlainValue.Node.endOfWhiteSpace(src, lineStart);
            if (src[wsEnd] === "\n" && comments.length === 0) {
              blankLine = new BlankLine();
              lineStart = blankLine.parse({
                src
              }, lineStart);
            }
            offset = PlainValue.Node.endOfIndent(src, lineStart);
          }
          ch = src[offset];
        }
        if (PlainValue.Node.nextNodeIsIndented(ch, offset - (lineStart + indent), this.type !== PlainValue.Type.SEQ_ITEM)) {
          this.node = parseNode({
            atLineStart,
            inCollection: false,
            indent,
            lineStart,
            parent: this
          }, offset);
        } else if (ch && lineStart > start + 1) {
          offset = lineStart - 1;
        }
        if (this.node) {
          if (blankLine) {
            const items = context.parent.items || context.parent.contents;
            if (items) items.push(blankLine);
          }
          if (comments.length) Array.prototype.push.apply(this.props, comments);
          offset = this.node.range.end;
        } else {
          if (inlineComment) {
            const c2 = comments[0];
            this.props.push(c2);
            offset = c2.end;
          } else {
            offset = PlainValue.Node.endOfLine(src, start + 1);
          }
        }
        const end = this.node ? this.node.valueRange.end : offset;
        this.valueRange = new PlainValue.Range(start, end);
        return offset;
      }
      setOrigRanges(cr, offset) {
        offset = super.setOrigRanges(cr, offset);
        return this.node ? this.node.setOrigRanges(cr, offset) : offset;
      }
      toString() {
        const {
          context: {
            src
          },
          node: node2,
          range,
          value
        } = this;
        if (value != null) return value;
        const str2 = node2 ? src.slice(range.start, node2.range.start) + String(node2) : src.slice(range.start, range.end);
        return PlainValue.Node.addStringTerminator(src, range.end, str2);
      }
    };
    var Comment = class extends PlainValue.Node {
      constructor() {
        super(PlainValue.Type.COMMENT);
      }
      /**
       * Parses a comment line from the source
       *
       * @param {ParseContext} context
       * @param {number} start - Index of first character
       * @returns {number} - Index of the character after this scalar
       */
      parse(context, start) {
        this.context = context;
        const offset = this.parseComment(start);
        this.range = new PlainValue.Range(start, offset);
        return offset;
      }
    };
    function grabCollectionEndComments(node2) {
      let cnode = node2;
      while (cnode instanceof CollectionItem) cnode = cnode.node;
      if (!(cnode instanceof Collection)) return null;
      const len = cnode.items.length;
      let ci = -1;
      for (let i = len - 1; i >= 0; --i) {
        const n = cnode.items[i];
        if (n.type === PlainValue.Type.COMMENT) {
          const {
            indent,
            lineStart
          } = n.context;
          if (indent > 0 && n.range.start >= lineStart + indent) break;
          ci = i;
        } else if (n.type === PlainValue.Type.BLANK_LINE) ci = i;
        else break;
      }
      if (ci === -1) return null;
      const ca = cnode.items.splice(ci, len - ci);
      const prevEnd = ca[0].range.start;
      while (true) {
        cnode.range.end = prevEnd;
        if (cnode.valueRange && cnode.valueRange.end > prevEnd) cnode.valueRange.end = prevEnd;
        if (cnode === node2) break;
        cnode = cnode.context.parent;
      }
      return ca;
    }
    var Collection = class _Collection extends PlainValue.Node {
      static nextContentHasIndent(src, offset, indent) {
        const lineStart = PlainValue.Node.endOfLine(src, offset) + 1;
        offset = PlainValue.Node.endOfWhiteSpace(src, lineStart);
        const ch = src[offset];
        if (!ch) return false;
        if (offset >= lineStart + indent) return true;
        if (ch !== "#" && ch !== "\n") return false;
        return _Collection.nextContentHasIndent(src, offset, indent);
      }
      constructor(firstItem) {
        super(firstItem.type === PlainValue.Type.SEQ_ITEM ? PlainValue.Type.SEQ : PlainValue.Type.MAP);
        for (let i = firstItem.props.length - 1; i >= 0; --i) {
          if (firstItem.props[i].start < firstItem.context.lineStart) {
            this.props = firstItem.props.slice(0, i + 1);
            firstItem.props = firstItem.props.slice(i + 1);
            const itemRange = firstItem.props[0] || firstItem.valueRange;
            firstItem.range.start = itemRange.start;
            break;
          }
        }
        this.items = [firstItem];
        const ec = grabCollectionEndComments(firstItem);
        if (ec) Array.prototype.push.apply(this.items, ec);
      }
      get includesTrailingLines() {
        return this.items.length > 0;
      }
      /**
       * @param {ParseContext} context
       * @param {number} start - Index of first character
       * @returns {number} - Index of the character after this
       */
      parse(context, start) {
        this.context = context;
        const {
          parseNode,
          src
        } = context;
        let lineStart = PlainValue.Node.startOfLine(src, start);
        const firstItem = this.items[0];
        firstItem.context.parent = this;
        this.valueRange = PlainValue.Range.copy(firstItem.valueRange);
        const indent = firstItem.range.start - firstItem.context.lineStart;
        let offset = start;
        offset = PlainValue.Node.normalizeOffset(src, offset);
        let ch = src[offset];
        let atLineStart = PlainValue.Node.endOfWhiteSpace(src, lineStart) === offset;
        let prevIncludesTrailingLines = false;
        while (ch) {
          while (ch === "\n" || ch === "#") {
            if (atLineStart && ch === "\n" && !prevIncludesTrailingLines) {
              const blankLine = new BlankLine();
              offset = blankLine.parse({
                src
              }, offset);
              this.valueRange.end = offset;
              if (offset >= src.length) {
                ch = null;
                break;
              }
              this.items.push(blankLine);
              offset -= 1;
            } else if (ch === "#") {
              if (offset < lineStart + indent && !_Collection.nextContentHasIndent(src, offset, indent)) {
                return offset;
              }
              const comment = new Comment();
              offset = comment.parse({
                indent,
                lineStart,
                src
              }, offset);
              this.items.push(comment);
              this.valueRange.end = offset;
              if (offset >= src.length) {
                ch = null;
                break;
              }
            }
            lineStart = offset + 1;
            offset = PlainValue.Node.endOfIndent(src, lineStart);
            if (PlainValue.Node.atBlank(src, offset)) {
              const wsEnd = PlainValue.Node.endOfWhiteSpace(src, offset);
              const next = src[wsEnd];
              if (!next || next === "\n" || next === "#") {
                offset = wsEnd;
              }
            }
            ch = src[offset];
            atLineStart = true;
          }
          if (!ch) {
            break;
          }
          if (offset !== lineStart + indent && (atLineStart || ch !== ":")) {
            if (offset < lineStart + indent) {
              if (lineStart > start) offset = lineStart;
              break;
            } else if (!this.error) {
              const msg = "All collection items must start at the same column";
              this.error = new PlainValue.YAMLSyntaxError(this, msg);
            }
          }
          if (firstItem.type === PlainValue.Type.SEQ_ITEM) {
            if (ch !== "-") {
              if (lineStart > start) offset = lineStart;
              break;
            }
          } else if (ch === "-" && !this.error) {
            const next = src[offset + 1];
            if (!next || next === "\n" || next === "	" || next === " ") {
              const msg = "A collection cannot be both a mapping and a sequence";
              this.error = new PlainValue.YAMLSyntaxError(this, msg);
            }
          }
          const node2 = parseNode({
            atLineStart,
            inCollection: true,
            indent,
            lineStart,
            parent: this
          }, offset);
          if (!node2) return offset;
          this.items.push(node2);
          this.valueRange.end = node2.valueRange.end;
          offset = PlainValue.Node.normalizeOffset(src, node2.range.end);
          ch = src[offset];
          atLineStart = false;
          prevIncludesTrailingLines = node2.includesTrailingLines;
          if (ch) {
            let ls = offset - 1;
            let prev = src[ls];
            while (prev === " " || prev === "	") prev = src[--ls];
            if (prev === "\n") {
              lineStart = ls + 1;
              atLineStart = true;
            }
          }
          const ec = grabCollectionEndComments(node2);
          if (ec) Array.prototype.push.apply(this.items, ec);
        }
        return offset;
      }
      setOrigRanges(cr, offset) {
        offset = super.setOrigRanges(cr, offset);
        this.items.forEach((node2) => {
          offset = node2.setOrigRanges(cr, offset);
        });
        return offset;
      }
      toString() {
        const {
          context: {
            src
          },
          items,
          range,
          value
        } = this;
        if (value != null) return value;
        let str2 = src.slice(range.start, items[0].range.start) + String(items[0]);
        for (let i = 1; i < items.length; ++i) {
          const item = items[i];
          const {
            atLineStart,
            indent
          } = item.context;
          if (atLineStart) for (let i2 = 0; i2 < indent; ++i2) str2 += " ";
          str2 += String(item);
        }
        return PlainValue.Node.addStringTerminator(src, range.end, str2);
      }
    };
    var Directive = class extends PlainValue.Node {
      constructor() {
        super(PlainValue.Type.DIRECTIVE);
        this.name = null;
      }
      get parameters() {
        const raw = this.rawValue;
        return raw ? raw.trim().split(/[ \t]+/) : [];
      }
      parseName(start) {
        const {
          src
        } = this.context;
        let offset = start;
        let ch = src[offset];
        while (ch && ch !== "\n" && ch !== "	" && ch !== " ") ch = src[offset += 1];
        this.name = src.slice(start, offset);
        return offset;
      }
      parseParameters(start) {
        const {
          src
        } = this.context;
        let offset = start;
        let ch = src[offset];
        while (ch && ch !== "\n" && ch !== "#") ch = src[offset += 1];
        this.valueRange = new PlainValue.Range(start, offset);
        return offset;
      }
      parse(context, start) {
        this.context = context;
        let offset = this.parseName(start + 1);
        offset = this.parseParameters(offset);
        offset = this.parseComment(offset);
        this.range = new PlainValue.Range(start, offset);
        return offset;
      }
    };
    var Document = class _Document extends PlainValue.Node {
      static startCommentOrEndBlankLine(src, start) {
        const offset = PlainValue.Node.endOfWhiteSpace(src, start);
        const ch = src[offset];
        return ch === "#" || ch === "\n" ? offset : start;
      }
      constructor() {
        super(PlainValue.Type.DOCUMENT);
        this.directives = null;
        this.contents = null;
        this.directivesEndMarker = null;
        this.documentEndMarker = null;
      }
      parseDirectives(start) {
        const {
          src
        } = this.context;
        this.directives = [];
        let atLineStart = true;
        let hasDirectives = false;
        let offset = start;
        while (!PlainValue.Node.atDocumentBoundary(src, offset, PlainValue.Char.DIRECTIVES_END)) {
          offset = _Document.startCommentOrEndBlankLine(src, offset);
          switch (src[offset]) {
            case "\n":
              if (atLineStart) {
                const blankLine = new BlankLine();
                offset = blankLine.parse({
                  src
                }, offset);
                if (offset < src.length) {
                  this.directives.push(blankLine);
                }
              } else {
                offset += 1;
                atLineStart = true;
              }
              break;
            case "#":
              {
                const comment = new Comment();
                offset = comment.parse({
                  src
                }, offset);
                this.directives.push(comment);
                atLineStart = false;
              }
              break;
            case "%":
              {
                const directive = new Directive();
                offset = directive.parse({
                  parent: this,
                  src
                }, offset);
                this.directives.push(directive);
                hasDirectives = true;
                atLineStart = false;
              }
              break;
            default:
              if (hasDirectives) {
                this.error = new PlainValue.YAMLSemanticError(this, "Missing directives-end indicator line");
              } else if (this.directives.length > 0) {
                this.contents = this.directives;
                this.directives = [];
              }
              return offset;
          }
        }
        if (src[offset]) {
          this.directivesEndMarker = new PlainValue.Range(offset, offset + 3);
          return offset + 3;
        }
        if (hasDirectives) {
          this.error = new PlainValue.YAMLSemanticError(this, "Missing directives-end indicator line");
        } else if (this.directives.length > 0) {
          this.contents = this.directives;
          this.directives = [];
        }
        return offset;
      }
      parseContents(start) {
        const {
          parseNode,
          src
        } = this.context;
        if (!this.contents) this.contents = [];
        let lineStart = start;
        while (src[lineStart - 1] === "-") lineStart -= 1;
        let offset = PlainValue.Node.endOfWhiteSpace(src, start);
        let atLineStart = lineStart === start;
        this.valueRange = new PlainValue.Range(offset);
        while (!PlainValue.Node.atDocumentBoundary(src, offset, PlainValue.Char.DOCUMENT_END)) {
          switch (src[offset]) {
            case "\n":
              if (atLineStart) {
                const blankLine = new BlankLine();
                offset = blankLine.parse({
                  src
                }, offset);
                if (offset < src.length) {
                  this.contents.push(blankLine);
                }
              } else {
                offset += 1;
                atLineStart = true;
              }
              lineStart = offset;
              break;
            case "#":
              {
                const comment = new Comment();
                offset = comment.parse({
                  src
                }, offset);
                this.contents.push(comment);
                atLineStart = false;
              }
              break;
            default: {
              const iEnd = PlainValue.Node.endOfIndent(src, offset);
              const context = {
                atLineStart,
                indent: -1,
                inFlow: false,
                inCollection: false,
                lineStart,
                parent: this
              };
              const node2 = parseNode(context, iEnd);
              if (!node2) return this.valueRange.end = iEnd;
              this.contents.push(node2);
              offset = node2.range.end;
              atLineStart = false;
              const ec = grabCollectionEndComments(node2);
              if (ec) Array.prototype.push.apply(this.contents, ec);
            }
          }
          offset = _Document.startCommentOrEndBlankLine(src, offset);
        }
        this.valueRange.end = offset;
        if (src[offset]) {
          this.documentEndMarker = new PlainValue.Range(offset, offset + 3);
          offset += 3;
          if (src[offset]) {
            offset = PlainValue.Node.endOfWhiteSpace(src, offset);
            if (src[offset] === "#") {
              const comment = new Comment();
              offset = comment.parse({
                src
              }, offset);
              this.contents.push(comment);
            }
            switch (src[offset]) {
              case "\n":
                offset += 1;
                break;
              case void 0:
                break;
              default:
                this.error = new PlainValue.YAMLSyntaxError(this, "Document end marker line cannot have a non-comment suffix");
            }
          }
        }
        return offset;
      }
      /**
       * @param {ParseContext} context
       * @param {number} start - Index of first character
       * @returns {number} - Index of the character after this
       */
      parse(context, start) {
        context.root = this;
        this.context = context;
        const {
          src
        } = context;
        let offset = src.charCodeAt(start) === 65279 ? start + 1 : start;
        offset = this.parseDirectives(offset);
        offset = this.parseContents(offset);
        return offset;
      }
      setOrigRanges(cr, offset) {
        offset = super.setOrigRanges(cr, offset);
        this.directives.forEach((node2) => {
          offset = node2.setOrigRanges(cr, offset);
        });
        if (this.directivesEndMarker) offset = this.directivesEndMarker.setOrigRange(cr, offset);
        this.contents.forEach((node2) => {
          offset = node2.setOrigRanges(cr, offset);
        });
        if (this.documentEndMarker) offset = this.documentEndMarker.setOrigRange(cr, offset);
        return offset;
      }
      toString() {
        const {
          contents,
          directives,
          value
        } = this;
        if (value != null) return value;
        let str2 = directives.join("");
        if (contents.length > 0) {
          if (directives.length > 0 || contents[0].type === PlainValue.Type.COMMENT) str2 += "---\n";
          str2 += contents.join("");
        }
        if (str2[str2.length - 1] !== "\n") str2 += "\n";
        return str2;
      }
    };
    var Alias = class extends PlainValue.Node {
      /**
       * Parses an *alias from the source
       *
       * @param {ParseContext} context
       * @param {number} start - Index of first character
       * @returns {number} - Index of the character after this scalar
       */
      parse(context, start) {
        this.context = context;
        const {
          src
        } = context;
        let offset = PlainValue.Node.endOfIdentifier(src, start + 1);
        this.valueRange = new PlainValue.Range(start + 1, offset);
        offset = PlainValue.Node.endOfWhiteSpace(src, offset);
        offset = this.parseComment(offset);
        return offset;
      }
    };
    var Chomp = {
      CLIP: "CLIP",
      KEEP: "KEEP",
      STRIP: "STRIP"
    };
    var BlockValue = class extends PlainValue.Node {
      constructor(type2, props) {
        super(type2, props);
        this.blockIndent = null;
        this.chomping = Chomp.CLIP;
        this.header = null;
      }
      get includesTrailingLines() {
        return this.chomping === Chomp.KEEP;
      }
      get strValue() {
        if (!this.valueRange || !this.context) return null;
        let {
          start,
          end
        } = this.valueRange;
        const {
          indent,
          src
        } = this.context;
        if (this.valueRange.isEmpty()) return "";
        let lastNewLine = null;
        let ch = src[end - 1];
        while (ch === "\n" || ch === "	" || ch === " ") {
          end -= 1;
          if (end <= start) {
            if (this.chomping === Chomp.KEEP) break;
            else return "";
          }
          if (ch === "\n") lastNewLine = end;
          ch = src[end - 1];
        }
        let keepStart = end + 1;
        if (lastNewLine) {
          if (this.chomping === Chomp.KEEP) {
            keepStart = lastNewLine;
            end = this.valueRange.end;
          } else {
            end = lastNewLine;
          }
        }
        const bi = indent + this.blockIndent;
        const folded = this.type === PlainValue.Type.BLOCK_FOLDED;
        let atStart = true;
        let str2 = "";
        let sep = "";
        let prevMoreIndented = false;
        for (let i = start; i < end; ++i) {
          for (let j = 0; j < bi; ++j) {
            if (src[i] !== " ") break;
            i += 1;
          }
          const ch2 = src[i];
          if (ch2 === "\n") {
            if (sep === "\n") str2 += "\n";
            else sep = "\n";
          } else {
            const lineEnd = PlainValue.Node.endOfLine(src, i);
            const line = src.slice(i, lineEnd);
            i = lineEnd;
            if (folded && (ch2 === " " || ch2 === "	") && i < keepStart) {
              if (sep === " ") sep = "\n";
              else if (!prevMoreIndented && !atStart && sep === "\n") sep = "\n\n";
              str2 += sep + line;
              sep = lineEnd < end && src[lineEnd] || "";
              prevMoreIndented = true;
            } else {
              str2 += sep + line;
              sep = folded && i < keepStart ? " " : "\n";
              prevMoreIndented = false;
            }
            if (atStart && line !== "") atStart = false;
          }
        }
        return this.chomping === Chomp.STRIP ? str2 : str2 + "\n";
      }
      parseBlockHeader(start) {
        const {
          src
        } = this.context;
        let offset = start + 1;
        let bi = "";
        while (true) {
          const ch = src[offset];
          switch (ch) {
            case "-":
              this.chomping = Chomp.STRIP;
              break;
            case "+":
              this.chomping = Chomp.KEEP;
              break;
            case "0":
            case "1":
            case "2":
            case "3":
            case "4":
            case "5":
            case "6":
            case "7":
            case "8":
            case "9":
              bi += ch;
              break;
            default:
              this.blockIndent = Number(bi) || null;
              this.header = new PlainValue.Range(start, offset);
              return offset;
          }
          offset += 1;
        }
      }
      parseBlockValue(start) {
        const {
          indent,
          src
        } = this.context;
        const explicit = !!this.blockIndent;
        let offset = start;
        let valueEnd = start;
        let minBlockIndent = 1;
        for (let ch = src[offset]; ch === "\n"; ch = src[offset]) {
          offset += 1;
          if (PlainValue.Node.atDocumentBoundary(src, offset)) break;
          const end = PlainValue.Node.endOfBlockIndent(src, indent, offset);
          if (end === null) break;
          const ch2 = src[end];
          const lineIndent = end - (offset + indent);
          if (!this.blockIndent) {
            if (src[end] !== "\n") {
              if (lineIndent < minBlockIndent) {
                const msg = "Block scalars with more-indented leading empty lines must use an explicit indentation indicator";
                this.error = new PlainValue.YAMLSemanticError(this, msg);
              }
              this.blockIndent = lineIndent;
            } else if (lineIndent > minBlockIndent) {
              minBlockIndent = lineIndent;
            }
          } else if (ch2 && ch2 !== "\n" && lineIndent < this.blockIndent) {
            if (src[end] === "#") break;
            if (!this.error) {
              const src2 = explicit ? "explicit indentation indicator" : "first line";
              const msg = `Block scalars must not be less indented than their ${src2}`;
              this.error = new PlainValue.YAMLSemanticError(this, msg);
            }
          }
          if (src[end] === "\n") {
            offset = end;
          } else {
            offset = valueEnd = PlainValue.Node.endOfLine(src, end);
          }
        }
        if (this.chomping !== Chomp.KEEP) {
          offset = src[valueEnd] ? valueEnd + 1 : valueEnd;
        }
        this.valueRange = new PlainValue.Range(start + 1, offset);
        return offset;
      }
      /**
       * Parses a block value from the source
       *
       * Accepted forms are:
       * ```
       * BS
       * block
       * lines
       *
       * BS #comment
       * block
       * lines
       * ```
       * where the block style BS matches the regexp `[|>][-+1-9]*` and block lines
       * are empty or have an indent level greater than `indent`.
       *
       * @param {ParseContext} context
       * @param {number} start - Index of first character
       * @returns {number} - Index of the character after this block
       */
      parse(context, start) {
        this.context = context;
        const {
          src
        } = context;
        let offset = this.parseBlockHeader(start);
        offset = PlainValue.Node.endOfWhiteSpace(src, offset);
        offset = this.parseComment(offset);
        offset = this.parseBlockValue(offset);
        return offset;
      }
      setOrigRanges(cr, offset) {
        offset = super.setOrigRanges(cr, offset);
        return this.header ? this.header.setOrigRange(cr, offset) : offset;
      }
    };
    var FlowCollection = class extends PlainValue.Node {
      constructor(type2, props) {
        super(type2, props);
        this.items = null;
      }
      prevNodeIsJsonLike(idx = this.items.length) {
        const node2 = this.items[idx - 1];
        return !!node2 && (node2.jsonLike || node2.type === PlainValue.Type.COMMENT && this.prevNodeIsJsonLike(idx - 1));
      }
      /**
       * @param {ParseContext} context
       * @param {number} start - Index of first character
       * @returns {number} - Index of the character after this
       */
      parse(context, start) {
        this.context = context;
        const {
          parseNode,
          src
        } = context;
        let {
          indent,
          lineStart
        } = context;
        let char = src[start];
        this.items = [{
          char,
          offset: start
        }];
        let offset = PlainValue.Node.endOfWhiteSpace(src, start + 1);
        char = src[offset];
        while (char && char !== "]" && char !== "}") {
          switch (char) {
            case "\n":
              {
                lineStart = offset + 1;
                const wsEnd = PlainValue.Node.endOfWhiteSpace(src, lineStart);
                if (src[wsEnd] === "\n") {
                  const blankLine = new BlankLine();
                  lineStart = blankLine.parse({
                    src
                  }, lineStart);
                  this.items.push(blankLine);
                }
                offset = PlainValue.Node.endOfIndent(src, lineStart);
                if (offset <= lineStart + indent) {
                  char = src[offset];
                  if (offset < lineStart + indent || char !== "]" && char !== "}") {
                    const msg = "Insufficient indentation in flow collection";
                    this.error = new PlainValue.YAMLSemanticError(this, msg);
                  }
                }
              }
              break;
            case ",":
              {
                this.items.push({
                  char,
                  offset
                });
                offset += 1;
              }
              break;
            case "#":
              {
                const comment = new Comment();
                offset = comment.parse({
                  src
                }, offset);
                this.items.push(comment);
              }
              break;
            case "?":
            case ":": {
              const next = src[offset + 1];
              if (next === "\n" || next === "	" || next === " " || next === "," || // in-flow : after JSON-like key does not need to be followed by whitespace
              char === ":" && this.prevNodeIsJsonLike()) {
                this.items.push({
                  char,
                  offset
                });
                offset += 1;
                break;
              }
            }
            default: {
              const node2 = parseNode({
                atLineStart: false,
                inCollection: false,
                inFlow: true,
                indent: -1,
                lineStart,
                parent: this
              }, offset);
              if (!node2) {
                this.valueRange = new PlainValue.Range(start, offset);
                return offset;
              }
              this.items.push(node2);
              offset = PlainValue.Node.normalizeOffset(src, node2.range.end);
            }
          }
          offset = PlainValue.Node.endOfWhiteSpace(src, offset);
          char = src[offset];
        }
        this.valueRange = new PlainValue.Range(start, offset + 1);
        if (char) {
          this.items.push({
            char,
            offset
          });
          offset = PlainValue.Node.endOfWhiteSpace(src, offset + 1);
          offset = this.parseComment(offset);
        }
        return offset;
      }
      setOrigRanges(cr, offset) {
        offset = super.setOrigRanges(cr, offset);
        this.items.forEach((node2) => {
          if (node2 instanceof PlainValue.Node) {
            offset = node2.setOrigRanges(cr, offset);
          } else if (cr.length === 0) {
            node2.origOffset = node2.offset;
          } else {
            let i = offset;
            while (i < cr.length) {
              if (cr[i] > node2.offset) break;
              else ++i;
            }
            node2.origOffset = node2.offset + i;
            offset = i;
          }
        });
        return offset;
      }
      toString() {
        const {
          context: {
            src
          },
          items,
          range,
          value
        } = this;
        if (value != null) return value;
        const nodes = items.filter((item) => item instanceof PlainValue.Node);
        let str2 = "";
        let prevEnd = range.start;
        nodes.forEach((node2) => {
          const prefix = src.slice(prevEnd, node2.range.start);
          prevEnd = node2.range.end;
          str2 += prefix + String(node2);
          if (str2[str2.length - 1] === "\n" && src[prevEnd - 1] !== "\n" && src[prevEnd] === "\n") {
            prevEnd += 1;
          }
        });
        str2 += src.slice(prevEnd, range.end);
        return PlainValue.Node.addStringTerminator(src, range.end, str2);
      }
    };
    var QuoteDouble = class _QuoteDouble extends PlainValue.Node {
      static endOfQuote(src, offset) {
        let ch = src[offset];
        while (ch && ch !== '"') {
          offset += ch === "\\" ? 2 : 1;
          ch = src[offset];
        }
        return offset + 1;
      }
      /**
       * @returns {string | { str: string, errors: YAMLSyntaxError[] }}
       */
      get strValue() {
        if (!this.valueRange || !this.context) return null;
        const errors = [];
        const {
          start,
          end
        } = this.valueRange;
        const {
          indent,
          src
        } = this.context;
        if (src[end - 1] !== '"') errors.push(new PlainValue.YAMLSyntaxError(this, 'Missing closing "quote'));
        let str2 = "";
        for (let i = start + 1; i < end - 1; ++i) {
          const ch = src[i];
          if (ch === "\n") {
            if (PlainValue.Node.atDocumentBoundary(src, i + 1)) errors.push(new PlainValue.YAMLSemanticError(this, "Document boundary indicators are not allowed within string values"));
            const {
              fold,
              offset,
              error
            } = PlainValue.Node.foldNewline(src, i, indent);
            str2 += fold;
            i = offset;
            if (error) errors.push(new PlainValue.YAMLSemanticError(this, "Multi-line double-quoted string needs to be sufficiently indented"));
          } else if (ch === "\\") {
            i += 1;
            switch (src[i]) {
              case "0":
                str2 += "\0";
                break;
              case "a":
                str2 += "\x07";
                break;
              case "b":
                str2 += "\b";
                break;
              case "e":
                str2 += "\x1B";
                break;
              case "f":
                str2 += "\f";
                break;
              case "n":
                str2 += "\n";
                break;
              case "r":
                str2 += "\r";
                break;
              case "t":
                str2 += "	";
                break;
              case "v":
                str2 += "\v";
                break;
              case "N":
                str2 += "\x85";
                break;
              case "_":
                str2 += "\xA0";
                break;
              case "L":
                str2 += "\u2028";
                break;
              case "P":
                str2 += "\u2029";
                break;
              case " ":
                str2 += " ";
                break;
              case '"':
                str2 += '"';
                break;
              case "/":
                str2 += "/";
                break;
              case "\\":
                str2 += "\\";
                break;
              case "	":
                str2 += "	";
                break;
              case "x":
                str2 += this.parseCharCode(i + 1, 2, errors);
                i += 2;
                break;
              case "u":
                str2 += this.parseCharCode(i + 1, 4, errors);
                i += 4;
                break;
              case "U":
                str2 += this.parseCharCode(i + 1, 8, errors);
                i += 8;
                break;
              case "\n":
                while (src[i + 1] === " " || src[i + 1] === "	") i += 1;
                break;
              default:
                errors.push(new PlainValue.YAMLSyntaxError(this, `Invalid escape sequence ${src.substr(i - 1, 2)}`));
                str2 += "\\" + src[i];
            }
          } else if (ch === " " || ch === "	") {
            const wsStart = i;
            let next = src[i + 1];
            while (next === " " || next === "	") {
              i += 1;
              next = src[i + 1];
            }
            if (next !== "\n") str2 += i > wsStart ? src.slice(wsStart, i + 1) : ch;
          } else {
            str2 += ch;
          }
        }
        return errors.length > 0 ? {
          errors,
          str: str2
        } : str2;
      }
      parseCharCode(offset, length, errors) {
        const {
          src
        } = this.context;
        const cc = src.substr(offset, length);
        const ok = cc.length === length && /^[0-9a-fA-F]+$/.test(cc);
        const code = ok ? parseInt(cc, 16) : NaN;
        if (isNaN(code)) {
          errors.push(new PlainValue.YAMLSyntaxError(this, `Invalid escape sequence ${src.substr(offset - 2, length + 2)}`));
          return src.substr(offset - 2, length + 2);
        }
        return String.fromCodePoint(code);
      }
      /**
       * Parses a "double quoted" value from the source
       *
       * @param {ParseContext} context
       * @param {number} start - Index of first character
       * @returns {number} - Index of the character after this scalar
       */
      parse(context, start) {
        this.context = context;
        const {
          src
        } = context;
        let offset = _QuoteDouble.endOfQuote(src, start + 1);
        this.valueRange = new PlainValue.Range(start, offset);
        offset = PlainValue.Node.endOfWhiteSpace(src, offset);
        offset = this.parseComment(offset);
        return offset;
      }
    };
    var QuoteSingle = class _QuoteSingle extends PlainValue.Node {
      static endOfQuote(src, offset) {
        let ch = src[offset];
        while (ch) {
          if (ch === "'") {
            if (src[offset + 1] !== "'") break;
            ch = src[offset += 2];
          } else {
            ch = src[offset += 1];
          }
        }
        return offset + 1;
      }
      /**
       * @returns {string | { str: string, errors: YAMLSyntaxError[] }}
       */
      get strValue() {
        if (!this.valueRange || !this.context) return null;
        const errors = [];
        const {
          start,
          end
        } = this.valueRange;
        const {
          indent,
          src
        } = this.context;
        if (src[end - 1] !== "'") errors.push(new PlainValue.YAMLSyntaxError(this, "Missing closing 'quote"));
        let str2 = "";
        for (let i = start + 1; i < end - 1; ++i) {
          const ch = src[i];
          if (ch === "\n") {
            if (PlainValue.Node.atDocumentBoundary(src, i + 1)) errors.push(new PlainValue.YAMLSemanticError(this, "Document boundary indicators are not allowed within string values"));
            const {
              fold,
              offset,
              error
            } = PlainValue.Node.foldNewline(src, i, indent);
            str2 += fold;
            i = offset;
            if (error) errors.push(new PlainValue.YAMLSemanticError(this, "Multi-line single-quoted string needs to be sufficiently indented"));
          } else if (ch === "'") {
            str2 += ch;
            i += 1;
            if (src[i] !== "'") errors.push(new PlainValue.YAMLSyntaxError(this, "Unescaped single quote? This should not happen."));
          } else if (ch === " " || ch === "	") {
            const wsStart = i;
            let next = src[i + 1];
            while (next === " " || next === "	") {
              i += 1;
              next = src[i + 1];
            }
            if (next !== "\n") str2 += i > wsStart ? src.slice(wsStart, i + 1) : ch;
          } else {
            str2 += ch;
          }
        }
        return errors.length > 0 ? {
          errors,
          str: str2
        } : str2;
      }
      /**
       * Parses a 'single quoted' value from the source
       *
       * @param {ParseContext} context
       * @param {number} start - Index of first character
       * @returns {number} - Index of the character after this scalar
       */
      parse(context, start) {
        this.context = context;
        const {
          src
        } = context;
        let offset = _QuoteSingle.endOfQuote(src, start + 1);
        this.valueRange = new PlainValue.Range(start, offset);
        offset = PlainValue.Node.endOfWhiteSpace(src, offset);
        offset = this.parseComment(offset);
        return offset;
      }
    };
    function createNewNode(type2, props) {
      switch (type2) {
        case PlainValue.Type.ALIAS:
          return new Alias(type2, props);
        case PlainValue.Type.BLOCK_FOLDED:
        case PlainValue.Type.BLOCK_LITERAL:
          return new BlockValue(type2, props);
        case PlainValue.Type.FLOW_MAP:
        case PlainValue.Type.FLOW_SEQ:
          return new FlowCollection(type2, props);
        case PlainValue.Type.MAP_KEY:
        case PlainValue.Type.MAP_VALUE:
        case PlainValue.Type.SEQ_ITEM:
          return new CollectionItem(type2, props);
        case PlainValue.Type.COMMENT:
        case PlainValue.Type.PLAIN:
          return new PlainValue.PlainValue(type2, props);
        case PlainValue.Type.QUOTE_DOUBLE:
          return new QuoteDouble(type2, props);
        case PlainValue.Type.QUOTE_SINGLE:
          return new QuoteSingle(type2, props);
        default:
          return null;
      }
    }
    var ParseContext = class _ParseContext {
      static parseType(src, offset, inFlow) {
        switch (src[offset]) {
          case "*":
            return PlainValue.Type.ALIAS;
          case ">":
            return PlainValue.Type.BLOCK_FOLDED;
          case "|":
            return PlainValue.Type.BLOCK_LITERAL;
          case "{":
            return PlainValue.Type.FLOW_MAP;
          case "[":
            return PlainValue.Type.FLOW_SEQ;
          case "?":
            return !inFlow && PlainValue.Node.atBlank(src, offset + 1, true) ? PlainValue.Type.MAP_KEY : PlainValue.Type.PLAIN;
          case ":":
            return !inFlow && PlainValue.Node.atBlank(src, offset + 1, true) ? PlainValue.Type.MAP_VALUE : PlainValue.Type.PLAIN;
          case "-":
            return !inFlow && PlainValue.Node.atBlank(src, offset + 1, true) ? PlainValue.Type.SEQ_ITEM : PlainValue.Type.PLAIN;
          case '"':
            return PlainValue.Type.QUOTE_DOUBLE;
          case "'":
            return PlainValue.Type.QUOTE_SINGLE;
          default:
            return PlainValue.Type.PLAIN;
        }
      }
      constructor(orig = {}, {
        atLineStart,
        inCollection,
        inFlow,
        indent,
        lineStart,
        parent
      } = {}) {
        PlainValue._defineProperty(this, "parseNode", (overlay, start) => {
          if (PlainValue.Node.atDocumentBoundary(this.src, start)) return null;
          const context = new _ParseContext(this, overlay);
          const {
            props,
            type: type2,
            valueStart
          } = context.parseProps(start);
          const node2 = createNewNode(type2, props);
          let offset = node2.parse(context, valueStart);
          node2.range = new PlainValue.Range(start, offset);
          if (offset <= start) {
            node2.error = new Error(`Node#parse consumed no characters`);
            node2.error.parseEnd = offset;
            node2.error.source = node2;
            node2.range.end = start + 1;
          }
          if (context.nodeStartsCollection(node2)) {
            if (!node2.error && !context.atLineStart && context.parent.type === PlainValue.Type.DOCUMENT) {
              node2.error = new PlainValue.YAMLSyntaxError(node2, "Block collection must not have preceding content here (e.g. directives-end indicator)");
            }
            const collection = new Collection(node2);
            offset = collection.parse(new _ParseContext(context), offset);
            collection.range = new PlainValue.Range(start, offset);
            return collection;
          }
          return node2;
        });
        this.atLineStart = atLineStart != null ? atLineStart : orig.atLineStart || false;
        this.inCollection = inCollection != null ? inCollection : orig.inCollection || false;
        this.inFlow = inFlow != null ? inFlow : orig.inFlow || false;
        this.indent = indent != null ? indent : orig.indent;
        this.lineStart = lineStart != null ? lineStart : orig.lineStart;
        this.parent = parent != null ? parent : orig.parent || {};
        this.root = orig.root;
        this.src = orig.src;
      }
      nodeStartsCollection(node2) {
        const {
          inCollection,
          inFlow,
          src
        } = this;
        if (inCollection || inFlow) return false;
        if (node2 instanceof CollectionItem) return true;
        let offset = node2.range.end;
        if (src[offset] === "\n" || src[offset - 1] === "\n") return false;
        offset = PlainValue.Node.endOfWhiteSpace(src, offset);
        return src[offset] === ":";
      }
      // Anchor and tag are before type, which determines the node implementation
      // class; hence this intermediate step.
      parseProps(offset) {
        const {
          inFlow,
          parent,
          src
        } = this;
        const props = [];
        let lineHasProps = false;
        offset = this.atLineStart ? PlainValue.Node.endOfIndent(src, offset) : PlainValue.Node.endOfWhiteSpace(src, offset);
        let ch = src[offset];
        while (ch === PlainValue.Char.ANCHOR || ch === PlainValue.Char.COMMENT || ch === PlainValue.Char.TAG || ch === "\n") {
          if (ch === "\n") {
            let inEnd = offset;
            let lineStart;
            do {
              lineStart = inEnd + 1;
              inEnd = PlainValue.Node.endOfIndent(src, lineStart);
            } while (src[inEnd] === "\n");
            const indentDiff = inEnd - (lineStart + this.indent);
            const noIndicatorAsIndent = parent.type === PlainValue.Type.SEQ_ITEM && parent.context.atLineStart;
            if (src[inEnd] !== "#" && !PlainValue.Node.nextNodeIsIndented(src[inEnd], indentDiff, !noIndicatorAsIndent)) break;
            this.atLineStart = true;
            this.lineStart = lineStart;
            lineHasProps = false;
            offset = inEnd;
          } else if (ch === PlainValue.Char.COMMENT) {
            const end = PlainValue.Node.endOfLine(src, offset + 1);
            props.push(new PlainValue.Range(offset, end));
            offset = end;
          } else {
            let end = PlainValue.Node.endOfIdentifier(src, offset + 1);
            if (ch === PlainValue.Char.TAG && src[end] === "," && /^[a-zA-Z0-9-]+\.[a-zA-Z0-9-]+,\d\d\d\d(-\d\d){0,2}\/\S/.test(src.slice(offset + 1, end + 13))) {
              end = PlainValue.Node.endOfIdentifier(src, end + 5);
            }
            props.push(new PlainValue.Range(offset, end));
            lineHasProps = true;
            offset = PlainValue.Node.endOfWhiteSpace(src, end);
          }
          ch = src[offset];
        }
        if (lineHasProps && ch === ":" && PlainValue.Node.atBlank(src, offset + 1, true)) offset -= 1;
        const type2 = _ParseContext.parseType(src, offset, inFlow);
        return {
          props,
          type: type2,
          valueStart: offset
        };
      }
      /**
       * Parses a node from the source
       * @param {ParseContext} overlay
       * @param {number} start - Index of first non-whitespace character for the node
       * @returns {?Node} - null if at a document boundary
       */
    };
    function parse6(src) {
      const cr = [];
      if (src.indexOf("\r") !== -1) {
        src = src.replace(/\r\n?/g, (match2, offset2) => {
          if (match2.length > 1) cr.push(offset2);
          return "\n";
        });
      }
      const documents = [];
      let offset = 0;
      do {
        const doc = new Document();
        const context = new ParseContext({
          src
        });
        offset = doc.parse(context, offset);
        documents.push(doc);
      } while (offset < src.length);
      documents.setOrigRanges = () => {
        if (cr.length === 0) return false;
        for (let i = 1; i < cr.length; ++i) cr[i] -= i;
        let crOffset = 0;
        for (let i = 0; i < documents.length; ++i) {
          crOffset = documents[i].setOrigRanges(cr, crOffset);
        }
        cr.splice(0, cr.length);
        return true;
      };
      documents.toString = () => documents.join("...\n");
      return documents;
    }
    exports2.parse = parse6;
  }
});

// node_modules/oas-resolver/node_modules/yaml/dist/resolveSeq-d03cb037.js
var require_resolveSeq_d03cb0372 = __commonJS({
  "node_modules/oas-resolver/node_modules/yaml/dist/resolveSeq-d03cb037.js"(exports2) {
    "use strict";
    var PlainValue = require_PlainValue_ec8e588e2();
    function addCommentBefore(str2, indent, comment) {
      if (!comment) return str2;
      const cc = comment.replace(/[\s\S]^/gm, `$&${indent}#`);
      return `#${cc}
${indent}${str2}`;
    }
    function addComment(str2, indent, comment) {
      return !comment ? str2 : comment.indexOf("\n") === -1 ? `${str2} #${comment}` : `${str2}
` + comment.replace(/^/gm, `${indent || ""}#`);
    }
    var Node = class {
    };
    function toJSON3(value, arg, ctx) {
      if (Array.isArray(value)) return value.map((v, i) => toJSON3(v, String(i), ctx));
      if (value && typeof value.toJSON === "function") {
        const anchor = ctx && ctx.anchors && ctx.anchors.get(value);
        if (anchor) ctx.onCreate = (res2) => {
          anchor.res = res2;
          delete ctx.onCreate;
        };
        const res = value.toJSON(arg, ctx);
        if (anchor && ctx.onCreate) ctx.onCreate(res);
        return res;
      }
      if ((!ctx || !ctx.keep) && typeof value === "bigint") return Number(value);
      return value;
    }
    var Scalar = class extends Node {
      constructor(value) {
        super();
        this.value = value;
      }
      toJSON(arg, ctx) {
        return ctx && ctx.keep ? this.value : toJSON3(this.value, arg, ctx);
      }
      toString() {
        return String(this.value);
      }
    };
    function collectionFromPath(schema2, path, value) {
      let v = value;
      for (let i = path.length - 1; i >= 0; --i) {
        const k = path[i];
        if (Number.isInteger(k) && k >= 0) {
          const a = [];
          a[k] = v;
          v = a;
        } else {
          const o = {};
          Object.defineProperty(o, k, {
            value: v,
            writable: true,
            enumerable: true,
            configurable: true
          });
          v = o;
        }
      }
      return schema2.createNode(v, false);
    }
    var isEmptyPath = (path) => path == null || typeof path === "object" && path[Symbol.iterator]().next().done;
    var Collection = class _Collection extends Node {
      constructor(schema2) {
        super();
        PlainValue._defineProperty(this, "items", []);
        this.schema = schema2;
      }
      addIn(path, value) {
        if (isEmptyPath(path)) this.add(value);
        else {
          const [key, ...rest] = path;
          const node2 = this.get(key, true);
          if (node2 instanceof _Collection) node2.addIn(rest, value);
          else if (node2 === void 0 && this.schema) this.set(key, collectionFromPath(this.schema, rest, value));
          else throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
        }
      }
      deleteIn([key, ...rest]) {
        if (rest.length === 0) return this.delete(key);
        const node2 = this.get(key, true);
        if (node2 instanceof _Collection) return node2.deleteIn(rest);
        else throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
      }
      getIn([key, ...rest], keepScalar) {
        const node2 = this.get(key, true);
        if (rest.length === 0) return !keepScalar && node2 instanceof Scalar ? node2.value : node2;
        else return node2 instanceof _Collection ? node2.getIn(rest, keepScalar) : void 0;
      }
      hasAllNullValues() {
        return this.items.every((node2) => {
          if (!node2 || node2.type !== "PAIR") return false;
          const n = node2.value;
          return n == null || n instanceof Scalar && n.value == null && !n.commentBefore && !n.comment && !n.tag;
        });
      }
      hasIn([key, ...rest]) {
        if (rest.length === 0) return this.has(key);
        const node2 = this.get(key, true);
        return node2 instanceof _Collection ? node2.hasIn(rest) : false;
      }
      setIn([key, ...rest], value) {
        if (rest.length === 0) {
          this.set(key, value);
        } else {
          const node2 = this.get(key, true);
          if (node2 instanceof _Collection) node2.setIn(rest, value);
          else if (node2 === void 0 && this.schema) this.set(key, collectionFromPath(this.schema, rest, value));
          else throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
        }
      }
      // overridden in implementations
      /* istanbul ignore next */
      toJSON() {
        return null;
      }
      toString(ctx, {
        blockItem,
        flowChars,
        isMap,
        itemIndent
      }, onComment, onChompKeep) {
        const {
          indent,
          indentStep,
          stringify: stringify3
        } = ctx;
        const inFlow = this.type === PlainValue.Type.FLOW_MAP || this.type === PlainValue.Type.FLOW_SEQ || ctx.inFlow;
        if (inFlow) itemIndent += indentStep;
        const allNullValues = isMap && this.hasAllNullValues();
        ctx = Object.assign({}, ctx, {
          allNullValues,
          indent: itemIndent,
          inFlow,
          type: null
        });
        let chompKeep = false;
        let hasItemWithNewLine = false;
        const nodes = this.items.reduce((nodes2, item, i) => {
          let comment;
          if (item) {
            if (!chompKeep && item.spaceBefore) nodes2.push({
              type: "comment",
              str: ""
            });
            if (item.commentBefore) item.commentBefore.match(/^.*$/gm).forEach((line) => {
              nodes2.push({
                type: "comment",
                str: `#${line}`
              });
            });
            if (item.comment) comment = item.comment;
            if (inFlow && (!chompKeep && item.spaceBefore || item.commentBefore || item.comment || item.key && (item.key.commentBefore || item.key.comment) || item.value && (item.value.commentBefore || item.value.comment))) hasItemWithNewLine = true;
          }
          chompKeep = false;
          let str3 = stringify3(item, ctx, () => comment = null, () => chompKeep = true);
          if (inFlow && !hasItemWithNewLine && str3.includes("\n")) hasItemWithNewLine = true;
          if (inFlow && i < this.items.length - 1) str3 += ",";
          str3 = addComment(str3, itemIndent, comment);
          if (chompKeep && (comment || inFlow)) chompKeep = false;
          nodes2.push({
            type: "item",
            str: str3
          });
          return nodes2;
        }, []);
        let str2;
        if (nodes.length === 0) {
          str2 = flowChars.start + flowChars.end;
        } else if (inFlow) {
          const {
            start,
            end
          } = flowChars;
          const strings = nodes.map((n) => n.str);
          if (hasItemWithNewLine || strings.reduce((sum, str3) => sum + str3.length + 2, 2) > _Collection.maxFlowStringSingleLineLength) {
            str2 = start;
            for (const s of strings) {
              str2 += s ? `
${indentStep}${indent}${s}` : "\n";
            }
            str2 += `
${indent}${end}`;
          } else {
            str2 = `${start} ${strings.join(" ")} ${end}`;
          }
        } else {
          const strings = nodes.map(blockItem);
          str2 = strings.shift();
          for (const s of strings) str2 += s ? `
${indent}${s}` : "\n";
        }
        if (this.comment) {
          str2 += "\n" + this.comment.replace(/^/gm, `${indent}#`);
          if (onComment) onComment();
        } else if (chompKeep && onChompKeep) onChompKeep();
        return str2;
      }
    };
    PlainValue._defineProperty(Collection, "maxFlowStringSingleLineLength", 60);
    function asItemIndex(key) {
      let idx = key instanceof Scalar ? key.value : key;
      if (idx && typeof idx === "string") idx = Number(idx);
      return Number.isInteger(idx) && idx >= 0 ? idx : null;
    }
    var YAMLSeq = class extends Collection {
      add(value) {
        this.items.push(value);
      }
      delete(key) {
        const idx = asItemIndex(key);
        if (typeof idx !== "number") return false;
        const del = this.items.splice(idx, 1);
        return del.length > 0;
      }
      get(key, keepScalar) {
        const idx = asItemIndex(key);
        if (typeof idx !== "number") return void 0;
        const it = this.items[idx];
        return !keepScalar && it instanceof Scalar ? it.value : it;
      }
      has(key) {
        const idx = asItemIndex(key);
        return typeof idx === "number" && idx < this.items.length;
      }
      set(key, value) {
        const idx = asItemIndex(key);
        if (typeof idx !== "number") throw new Error(`Expected a valid index, not ${key}.`);
        this.items[idx] = value;
      }
      toJSON(_, ctx) {
        const seq2 = [];
        if (ctx && ctx.onCreate) ctx.onCreate(seq2);
        let i = 0;
        for (const item of this.items) seq2.push(toJSON3(item, String(i++), ctx));
        return seq2;
      }
      toString(ctx, onComment, onChompKeep) {
        if (!ctx) return JSON.stringify(this);
        return super.toString(ctx, {
          blockItem: (n) => n.type === "comment" ? n.str : `- ${n.str}`,
          flowChars: {
            start: "[",
            end: "]"
          },
          isMap: false,
          itemIndent: (ctx.indent || "") + "  "
        }, onComment, onChompKeep);
      }
    };
    var stringifyKey = (key, jsKey, ctx) => {
      if (jsKey === null) return "";
      if (typeof jsKey !== "object") return String(jsKey);
      if (key instanceof Node && ctx && ctx.doc) return key.toString({
        anchors: /* @__PURE__ */ Object.create(null),
        doc: ctx.doc,
        indent: "",
        indentStep: ctx.indentStep,
        inFlow: true,
        inStringifyKey: true,
        stringify: ctx.stringify
      });
      return JSON.stringify(jsKey);
    };
    var Pair = class _Pair extends Node {
      constructor(key, value = null) {
        super();
        this.key = key;
        this.value = value;
        this.type = _Pair.Type.PAIR;
      }
      get commentBefore() {
        return this.key instanceof Node ? this.key.commentBefore : void 0;
      }
      set commentBefore(cb) {
        if (this.key == null) this.key = new Scalar(null);
        if (this.key instanceof Node) this.key.commentBefore = cb;
        else {
          const msg = "Pair.commentBefore is an alias for Pair.key.commentBefore. To set it, the key must be a Node.";
          throw new Error(msg);
        }
      }
      addToJSMap(ctx, map2) {
        const key = toJSON3(this.key, "", ctx);
        if (map2 instanceof Map) {
          const value = toJSON3(this.value, key, ctx);
          map2.set(key, value);
        } else if (map2 instanceof Set) {
          map2.add(key);
        } else {
          const stringKey = stringifyKey(this.key, key, ctx);
          const value = toJSON3(this.value, stringKey, ctx);
          if (stringKey in map2) Object.defineProperty(map2, stringKey, {
            value,
            writable: true,
            enumerable: true,
            configurable: true
          });
          else map2[stringKey] = value;
        }
        return map2;
      }
      toJSON(_, ctx) {
        const pair = ctx && ctx.mapAsMap ? /* @__PURE__ */ new Map() : {};
        return this.addToJSMap(ctx, pair);
      }
      toString(ctx, onComment, onChompKeep) {
        if (!ctx || !ctx.doc) return JSON.stringify(this);
        const {
          indent: indentSize,
          indentSeq,
          simpleKeys
        } = ctx.doc.options;
        let {
          key,
          value
        } = this;
        let keyComment = key instanceof Node && key.comment;
        if (simpleKeys) {
          if (keyComment) {
            throw new Error("With simple keys, key nodes cannot have comments");
          }
          if (key instanceof Collection) {
            const msg = "With simple keys, collection cannot be used as a key value";
            throw new Error(msg);
          }
        }
        let explicitKey = !simpleKeys && (!key || keyComment || (key instanceof Node ? key instanceof Collection || key.type === PlainValue.Type.BLOCK_FOLDED || key.type === PlainValue.Type.BLOCK_LITERAL : typeof key === "object"));
        const {
          doc,
          indent,
          indentStep,
          stringify: stringify3
        } = ctx;
        ctx = Object.assign({}, ctx, {
          implicitKey: !explicitKey,
          indent: indent + indentStep
        });
        let chompKeep = false;
        let str2 = stringify3(key, ctx, () => keyComment = null, () => chompKeep = true);
        str2 = addComment(str2, ctx.indent, keyComment);
        if (!explicitKey && str2.length > 1024) {
          if (simpleKeys) throw new Error("With simple keys, single line scalar must not span more than 1024 characters");
          explicitKey = true;
        }
        if (ctx.allNullValues && !simpleKeys) {
          if (this.comment) {
            str2 = addComment(str2, ctx.indent, this.comment);
            if (onComment) onComment();
          } else if (chompKeep && !keyComment && onChompKeep) onChompKeep();
          return ctx.inFlow && !explicitKey ? str2 : `? ${str2}`;
        }
        str2 = explicitKey ? `? ${str2}
${indent}:` : `${str2}:`;
        if (this.comment) {
          str2 = addComment(str2, ctx.indent, this.comment);
          if (onComment) onComment();
        }
        let vcb = "";
        let valueComment = null;
        if (value instanceof Node) {
          if (value.spaceBefore) vcb = "\n";
          if (value.commentBefore) {
            const cs = value.commentBefore.replace(/^/gm, `${ctx.indent}#`);
            vcb += `
${cs}`;
          }
          valueComment = value.comment;
        } else if (value && typeof value === "object") {
          value = doc.schema.createNode(value, true);
        }
        ctx.implicitKey = false;
        if (!explicitKey && !this.comment && value instanceof Scalar) ctx.indentAtStart = str2.length + 1;
        chompKeep = false;
        if (!indentSeq && indentSize >= 2 && !ctx.inFlow && !explicitKey && value instanceof YAMLSeq && value.type !== PlainValue.Type.FLOW_SEQ && !value.tag && !doc.anchors.getName(value)) {
          ctx.indent = ctx.indent.substr(2);
        }
        const valueStr = stringify3(value, ctx, () => valueComment = null, () => chompKeep = true);
        let ws = " ";
        if (vcb || this.comment) {
          ws = `${vcb}
${ctx.indent}`;
        } else if (!explicitKey && value instanceof Collection) {
          const flow = valueStr[0] === "[" || valueStr[0] === "{";
          if (!flow || valueStr.includes("\n")) ws = `
${ctx.indent}`;
        } else if (valueStr[0] === "\n") ws = "";
        if (chompKeep && !valueComment && onChompKeep) onChompKeep();
        return addComment(str2 + ws + valueStr, ctx.indent, valueComment);
      }
    };
    PlainValue._defineProperty(Pair, "Type", {
      PAIR: "PAIR",
      MERGE_PAIR: "MERGE_PAIR"
    });
    var getAliasCount = (node2, anchors) => {
      if (node2 instanceof Alias) {
        const anchor = anchors.get(node2.source);
        return anchor.count * anchor.aliasCount;
      } else if (node2 instanceof Collection) {
        let count = 0;
        for (const item of node2.items) {
          const c2 = getAliasCount(item, anchors);
          if (c2 > count) count = c2;
        }
        return count;
      } else if (node2 instanceof Pair) {
        const kc = getAliasCount(node2.key, anchors);
        const vc = getAliasCount(node2.value, anchors);
        return Math.max(kc, vc);
      }
      return 1;
    };
    var Alias = class _Alias extends Node {
      static stringify({
        range,
        source
      }, {
        anchors,
        doc,
        implicitKey,
        inStringifyKey
      }) {
        let anchor = Object.keys(anchors).find((a) => anchors[a] === source);
        if (!anchor && inStringifyKey) anchor = doc.anchors.getName(source) || doc.anchors.newName();
        if (anchor) return `*${anchor}${implicitKey ? " " : ""}`;
        const msg = doc.anchors.getName(source) ? "Alias node must be after source node" : "Source node not found for alias node";
        throw new Error(`${msg} [${range}]`);
      }
      constructor(source) {
        super();
        this.source = source;
        this.type = PlainValue.Type.ALIAS;
      }
      set tag(t) {
        throw new Error("Alias nodes cannot have tags");
      }
      toJSON(arg, ctx) {
        if (!ctx) return toJSON3(this.source, arg, ctx);
        const {
          anchors,
          maxAliasCount
        } = ctx;
        const anchor = anchors.get(this.source);
        if (!anchor || anchor.res === void 0) {
          const msg = "This should not happen: Alias anchor was not resolved?";
          if (this.cstNode) throw new PlainValue.YAMLReferenceError(this.cstNode, msg);
          else throw new ReferenceError(msg);
        }
        if (maxAliasCount >= 0) {
          anchor.count += 1;
          if (anchor.aliasCount === 0) anchor.aliasCount = getAliasCount(this.source, anchors);
          if (anchor.count * anchor.aliasCount > maxAliasCount) {
            const msg = "Excessive alias count indicates a resource exhaustion attack";
            if (this.cstNode) throw new PlainValue.YAMLReferenceError(this.cstNode, msg);
            else throw new ReferenceError(msg);
          }
        }
        return anchor.res;
      }
      // Only called when stringifying an alias mapping key while constructing
      // Object output.
      toString(ctx) {
        return _Alias.stringify(this, ctx);
      }
    };
    PlainValue._defineProperty(Alias, "default", true);
    function findPair(items, key) {
      const k = key instanceof Scalar ? key.value : key;
      for (const it of items) {
        if (it instanceof Pair) {
          if (it.key === key || it.key === k) return it;
          if (it.key && it.key.value === k) return it;
        }
      }
      return void 0;
    }
    var YAMLMap = class extends Collection {
      add(pair, overwrite) {
        if (!pair) pair = new Pair(pair);
        else if (!(pair instanceof Pair)) pair = new Pair(pair.key || pair, pair.value);
        const prev = findPair(this.items, pair.key);
        const sortEntries = this.schema && this.schema.sortMapEntries;
        if (prev) {
          if (overwrite) prev.value = pair.value;
          else throw new Error(`Key ${pair.key} already set`);
        } else if (sortEntries) {
          const i = this.items.findIndex((item) => sortEntries(pair, item) < 0);
          if (i === -1) this.items.push(pair);
          else this.items.splice(i, 0, pair);
        } else {
          this.items.push(pair);
        }
      }
      delete(key) {
        const it = findPair(this.items, key);
        if (!it) return false;
        const del = this.items.splice(this.items.indexOf(it), 1);
        return del.length > 0;
      }
      get(key, keepScalar) {
        const it = findPair(this.items, key);
        const node2 = it && it.value;
        return !keepScalar && node2 instanceof Scalar ? node2.value : node2;
      }
      has(key) {
        return !!findPair(this.items, key);
      }
      set(key, value) {
        this.add(new Pair(key, value), true);
      }
      /**
       * @param {*} arg ignored
       * @param {*} ctx Conversion context, originally set in Document#toJSON()
       * @param {Class} Type If set, forces the returned collection type
       * @returns {*} Instance of Type, Map, or Object
       */
      toJSON(_, ctx, Type2) {
        const map2 = Type2 ? new Type2() : ctx && ctx.mapAsMap ? /* @__PURE__ */ new Map() : {};
        if (ctx && ctx.onCreate) ctx.onCreate(map2);
        for (const item of this.items) item.addToJSMap(ctx, map2);
        return map2;
      }
      toString(ctx, onComment, onChompKeep) {
        if (!ctx) return JSON.stringify(this);
        for (const item of this.items) {
          if (!(item instanceof Pair)) throw new Error(`Map items must all be pairs; found ${JSON.stringify(item)} instead`);
        }
        return super.toString(ctx, {
          blockItem: (n) => n.str,
          flowChars: {
            start: "{",
            end: "}"
          },
          isMap: true,
          itemIndent: ctx.indent || ""
        }, onComment, onChompKeep);
      }
    };
    var MERGE_KEY = "<<";
    var Merge = class extends Pair {
      constructor(pair) {
        if (pair instanceof Pair) {
          let seq2 = pair.value;
          if (!(seq2 instanceof YAMLSeq)) {
            seq2 = new YAMLSeq();
            seq2.items.push(pair.value);
            seq2.range = pair.value.range;
          }
          super(pair.key, seq2);
          this.range = pair.range;
        } else {
          super(new Scalar(MERGE_KEY), new YAMLSeq());
        }
        this.type = Pair.Type.MERGE_PAIR;
      }
      // If the value associated with a merge key is a single mapping node, each of
      // its key/value pairs is inserted into the current mapping, unless the key
      // already exists in it. If the value associated with the merge key is a
      // sequence, then this sequence is expected to contain mapping nodes and each
      // of these nodes is merged in turn according to its order in the sequence.
      // Keys in mapping nodes earlier in the sequence override keys specified in
      // later mapping nodes. -- http://yaml.org/type/merge.html
      addToJSMap(ctx, map2) {
        for (const {
          source
        } of this.value.items) {
          if (!(source instanceof YAMLMap)) throw new Error("Merge sources must be maps");
          const srcMap = source.toJSON(null, ctx, Map);
          for (const [key, value] of srcMap) {
            if (map2 instanceof Map) {
              if (!map2.has(key)) map2.set(key, value);
            } else if (map2 instanceof Set) {
              map2.add(key);
            } else if (!Object.prototype.hasOwnProperty.call(map2, key)) {
              Object.defineProperty(map2, key, {
                value,
                writable: true,
                enumerable: true,
                configurable: true
              });
            }
          }
        }
        return map2;
      }
      toString(ctx, onComment) {
        const seq2 = this.value;
        if (seq2.items.length > 1) return super.toString(ctx, onComment);
        this.value = seq2.items[0];
        const str2 = super.toString(ctx, onComment);
        this.value = seq2;
        return str2;
      }
    };
    var binaryOptions = {
      defaultType: PlainValue.Type.BLOCK_LITERAL,
      lineWidth: 76
    };
    var boolOptions = {
      trueStr: "true",
      falseStr: "false"
    };
    var intOptions = {
      asBigInt: false
    };
    var nullOptions = {
      nullStr: "null"
    };
    var strOptions = {
      defaultType: PlainValue.Type.PLAIN,
      doubleQuoted: {
        jsonEncoding: false,
        minMultiLineLength: 40
      },
      fold: {
        lineWidth: 80,
        minContentWidth: 20
      }
    };
    function resolveScalar(str2, tags, scalarFallback) {
      for (const {
        format: format6,
        test,
        resolve
      } of tags) {
        if (test) {
          const match2 = str2.match(test);
          if (match2) {
            let res = resolve.apply(null, match2);
            if (!(res instanceof Scalar)) res = new Scalar(res);
            if (format6) res.format = format6;
            return res;
          }
        }
      }
      if (scalarFallback) str2 = scalarFallback(str2);
      return new Scalar(str2);
    }
    var FOLD_FLOW = "flow";
    var FOLD_BLOCK = "block";
    var FOLD_QUOTED = "quoted";
    var consumeMoreIndentedLines = (text, i) => {
      let ch = text[i + 1];
      while (ch === " " || ch === "	") {
        do {
          ch = text[i += 1];
        } while (ch && ch !== "\n");
        ch = text[i + 1];
      }
      return i;
    };
    function foldFlowLines(text, indent, mode, {
      indentAtStart,
      lineWidth = 80,
      minContentWidth = 20,
      onFold,
      onOverflow
    }) {
      if (!lineWidth || lineWidth < 0) return text;
      const endStep = Math.max(1 + minContentWidth, 1 + lineWidth - indent.length);
      if (text.length <= endStep) return text;
      const folds = [];
      const escapedFolds = {};
      let end = lineWidth - indent.length;
      if (typeof indentAtStart === "number") {
        if (indentAtStart > lineWidth - Math.max(2, minContentWidth)) folds.push(0);
        else end = lineWidth - indentAtStart;
      }
      let split = void 0;
      let prev = void 0;
      let overflow = false;
      let i = -1;
      let escStart = -1;
      let escEnd = -1;
      if (mode === FOLD_BLOCK) {
        i = consumeMoreIndentedLines(text, i);
        if (i !== -1) end = i + endStep;
      }
      for (let ch; ch = text[i += 1]; ) {
        if (mode === FOLD_QUOTED && ch === "\\") {
          escStart = i;
          switch (text[i + 1]) {
            case "x":
              i += 3;
              break;
            case "u":
              i += 5;
              break;
            case "U":
              i += 9;
              break;
            default:
              i += 1;
          }
          escEnd = i;
        }
        if (ch === "\n") {
          if (mode === FOLD_BLOCK) i = consumeMoreIndentedLines(text, i);
          end = i + endStep;
          split = void 0;
        } else {
          if (ch === " " && prev && prev !== " " && prev !== "\n" && prev !== "	") {
            const next = text[i + 1];
            if (next && next !== " " && next !== "\n" && next !== "	") split = i;
          }
          if (i >= end) {
            if (split) {
              folds.push(split);
              end = split + endStep;
              split = void 0;
            } else if (mode === FOLD_QUOTED) {
              while (prev === " " || prev === "	") {
                prev = ch;
                ch = text[i += 1];
                overflow = true;
              }
              const j = i > escEnd + 1 ? i - 2 : escStart - 1;
              if (escapedFolds[j]) return text;
              folds.push(j);
              escapedFolds[j] = true;
              end = j + endStep;
              split = void 0;
            } else {
              overflow = true;
            }
          }
        }
        prev = ch;
      }
      if (overflow && onOverflow) onOverflow();
      if (folds.length === 0) return text;
      if (onFold) onFold();
      let res = text.slice(0, folds[0]);
      for (let i2 = 0; i2 < folds.length; ++i2) {
        const fold = folds[i2];
        const end2 = folds[i2 + 1] || text.length;
        if (fold === 0) res = `
${indent}${text.slice(0, end2)}`;
        else {
          if (mode === FOLD_QUOTED && escapedFolds[fold]) res += `${text[fold]}\\`;
          res += `
${indent}${text.slice(fold + 1, end2)}`;
        }
      }
      return res;
    }
    var getFoldOptions = ({
      indentAtStart
    }) => indentAtStart ? Object.assign({
      indentAtStart
    }, strOptions.fold) : strOptions.fold;
    var containsDocumentMarker = (str2) => /^(%|---|\.\.\.)/m.test(str2);
    function lineLengthOverLimit(str2, lineWidth, indentLength) {
      if (!lineWidth || lineWidth < 0) return false;
      const limit = lineWidth - indentLength;
      const strLen = str2.length;
      if (strLen <= limit) return false;
      for (let i = 0, start = 0; i < strLen; ++i) {
        if (str2[i] === "\n") {
          if (i - start > limit) return true;
          start = i + 1;
          if (strLen - start <= limit) return false;
        }
      }
      return true;
    }
    function doubleQuotedString(value, ctx) {
      const {
        implicitKey
      } = ctx;
      const {
        jsonEncoding,
        minMultiLineLength
      } = strOptions.doubleQuoted;
      const json3 = JSON.stringify(value);
      if (jsonEncoding) return json3;
      const indent = ctx.indent || (containsDocumentMarker(value) ? "  " : "");
      let str2 = "";
      let start = 0;
      for (let i = 0, ch = json3[i]; ch; ch = json3[++i]) {
        if (ch === " " && json3[i + 1] === "\\" && json3[i + 2] === "n") {
          str2 += json3.slice(start, i) + "\\ ";
          i += 1;
          start = i;
          ch = "\\";
        }
        if (ch === "\\") switch (json3[i + 1]) {
          case "u":
            {
              str2 += json3.slice(start, i);
              const code = json3.substr(i + 2, 4);
              switch (code) {
                case "0000":
                  str2 += "\\0";
                  break;
                case "0007":
                  str2 += "\\a";
                  break;
                case "000b":
                  str2 += "\\v";
                  break;
                case "001b":
                  str2 += "\\e";
                  break;
                case "0085":
                  str2 += "\\N";
                  break;
                case "00a0":
                  str2 += "\\_";
                  break;
                case "2028":
                  str2 += "\\L";
                  break;
                case "2029":
                  str2 += "\\P";
                  break;
                default:
                  if (code.substr(0, 2) === "00") str2 += "\\x" + code.substr(2);
                  else str2 += json3.substr(i, 6);
              }
              i += 5;
              start = i + 1;
            }
            break;
          case "n":
            if (implicitKey || json3[i + 2] === '"' || json3.length < minMultiLineLength) {
              i += 1;
            } else {
              str2 += json3.slice(start, i) + "\n\n";
              while (json3[i + 2] === "\\" && json3[i + 3] === "n" && json3[i + 4] !== '"') {
                str2 += "\n";
                i += 2;
              }
              str2 += indent;
              if (json3[i + 2] === " ") str2 += "\\";
              i += 1;
              start = i + 1;
            }
            break;
          default:
            i += 1;
        }
      }
      str2 = start ? str2 + json3.slice(start) : json3;
      return implicitKey ? str2 : foldFlowLines(str2, indent, FOLD_QUOTED, getFoldOptions(ctx));
    }
    function singleQuotedString(value, ctx) {
      if (ctx.implicitKey) {
        if (/\n/.test(value)) return doubleQuotedString(value, ctx);
      } else {
        if (/[ \t]\n|\n[ \t]/.test(value)) return doubleQuotedString(value, ctx);
      }
      const indent = ctx.indent || (containsDocumentMarker(value) ? "  " : "");
      const res = "'" + value.replace(/'/g, "''").replace(/\n+/g, `$&
${indent}`) + "'";
      return ctx.implicitKey ? res : foldFlowLines(res, indent, FOLD_FLOW, getFoldOptions(ctx));
    }
    function blockString({
      comment,
      type: type2,
      value
    }, ctx, onComment, onChompKeep) {
      if (/\n[\t ]+$/.test(value) || /^\s*$/.test(value)) {
        return doubleQuotedString(value, ctx);
      }
      const indent = ctx.indent || (ctx.forceBlockIndent || containsDocumentMarker(value) ? "  " : "");
      const indentSize = indent ? "2" : "1";
      const literal = type2 === PlainValue.Type.BLOCK_FOLDED ? false : type2 === PlainValue.Type.BLOCK_LITERAL ? true : !lineLengthOverLimit(value, strOptions.fold.lineWidth, indent.length);
      let header = literal ? "|" : ">";
      if (!value) return header + "\n";
      let wsStart = "";
      let wsEnd = "";
      value = value.replace(/[\n\t ]*$/, (ws) => {
        const n = ws.indexOf("\n");
        if (n === -1) {
          header += "-";
        } else if (value === ws || n !== ws.length - 1) {
          header += "+";
          if (onChompKeep) onChompKeep();
        }
        wsEnd = ws.replace(/\n$/, "");
        return "";
      }).replace(/^[\n ]*/, (ws) => {
        if (ws.indexOf(" ") !== -1) header += indentSize;
        const m = ws.match(/ +$/);
        if (m) {
          wsStart = ws.slice(0, -m[0].length);
          return m[0];
        } else {
          wsStart = ws;
          return "";
        }
      });
      if (wsEnd) wsEnd = wsEnd.replace(/\n+(?!\n|$)/g, `$&${indent}`);
      if (wsStart) wsStart = wsStart.replace(/\n+/g, `$&${indent}`);
      if (comment) {
        header += " #" + comment.replace(/ ?[\r\n]+/g, " ");
        if (onComment) onComment();
      }
      if (!value) return `${header}${indentSize}
${indent}${wsEnd}`;
      if (literal) {
        value = value.replace(/\n+/g, `$&${indent}`);
        return `${header}
${indent}${wsStart}${value}${wsEnd}`;
      }
      value = value.replace(/\n+/g, "\n$&").replace(/(?:^|\n)([\t ].*)(?:([\n\t ]*)\n(?![\n\t ]))?/g, "$1$2").replace(/\n+/g, `$&${indent}`);
      const body = foldFlowLines(`${wsStart}${value}${wsEnd}`, indent, FOLD_BLOCK, strOptions.fold);
      return `${header}
${indent}${body}`;
    }
    function plainString(item, ctx, onComment, onChompKeep) {
      const {
        comment,
        type: type2,
        value
      } = item;
      const {
        actualString,
        implicitKey,
        indent,
        inFlow
      } = ctx;
      if (implicitKey && /[\n[\]{},]/.test(value) || inFlow && /[[\]{},]/.test(value)) {
        return doubleQuotedString(value, ctx);
      }
      if (!value || /^[\n\t ,[\]{}#&*!|>'"%@`]|^[?-]$|^[?-][ \t]|[\n:][ \t]|[ \t]\n|[\n\t ]#|[\n\t :]$/.test(value)) {
        return implicitKey || inFlow || value.indexOf("\n") === -1 ? value.indexOf('"') !== -1 && value.indexOf("'") === -1 ? singleQuotedString(value, ctx) : doubleQuotedString(value, ctx) : blockString(item, ctx, onComment, onChompKeep);
      }
      if (!implicitKey && !inFlow && type2 !== PlainValue.Type.PLAIN && value.indexOf("\n") !== -1) {
        return blockString(item, ctx, onComment, onChompKeep);
      }
      if (indent === "" && containsDocumentMarker(value)) {
        ctx.forceBlockIndent = true;
        return blockString(item, ctx, onComment, onChompKeep);
      }
      const str2 = value.replace(/\n+/g, `$&
${indent}`);
      if (actualString) {
        const {
          tags
        } = ctx.doc.schema;
        const resolved = resolveScalar(str2, tags, tags.scalarFallback).value;
        if (typeof resolved !== "string") return doubleQuotedString(value, ctx);
      }
      const body = implicitKey ? str2 : foldFlowLines(str2, indent, FOLD_FLOW, getFoldOptions(ctx));
      if (comment && !inFlow && (body.indexOf("\n") !== -1 || comment.indexOf("\n") !== -1)) {
        if (onComment) onComment();
        return addCommentBefore(body, indent, comment);
      }
      return body;
    }
    function stringifyString(item, ctx, onComment, onChompKeep) {
      const {
        defaultType
      } = strOptions;
      const {
        implicitKey,
        inFlow
      } = ctx;
      let {
        type: type2,
        value
      } = item;
      if (typeof value !== "string") {
        value = String(value);
        item = Object.assign({}, item, {
          value
        });
      }
      const _stringify = (_type) => {
        switch (_type) {
          case PlainValue.Type.BLOCK_FOLDED:
          case PlainValue.Type.BLOCK_LITERAL:
            return blockString(item, ctx, onComment, onChompKeep);
          case PlainValue.Type.QUOTE_DOUBLE:
            return doubleQuotedString(value, ctx);
          case PlainValue.Type.QUOTE_SINGLE:
            return singleQuotedString(value, ctx);
          case PlainValue.Type.PLAIN:
            return plainString(item, ctx, onComment, onChompKeep);
          default:
            return null;
        }
      };
      if (type2 !== PlainValue.Type.QUOTE_DOUBLE && /[\x00-\x08\x0b-\x1f\x7f-\x9f]/.test(value)) {
        type2 = PlainValue.Type.QUOTE_DOUBLE;
      } else if ((implicitKey || inFlow) && (type2 === PlainValue.Type.BLOCK_FOLDED || type2 === PlainValue.Type.BLOCK_LITERAL)) {
        type2 = PlainValue.Type.QUOTE_DOUBLE;
      }
      let res = _stringify(type2);
      if (res === null) {
        res = _stringify(defaultType);
        if (res === null) throw new Error(`Unsupported default string type ${defaultType}`);
      }
      return res;
    }
    function stringifyNumber({
      format: format6,
      minFractionDigits,
      tag,
      value
    }) {
      if (typeof value === "bigint") return String(value);
      if (!isFinite(value)) return isNaN(value) ? ".nan" : value < 0 ? "-.inf" : ".inf";
      let n = JSON.stringify(value);
      if (!format6 && minFractionDigits && (!tag || tag === "tag:yaml.org,2002:float") && /^\d/.test(n)) {
        let i = n.indexOf(".");
        if (i < 0) {
          i = n.length;
          n += ".";
        }
        let d = minFractionDigits - (n.length - i - 1);
        while (d-- > 0) n += "0";
      }
      return n;
    }
    function checkFlowCollectionEnd(errors, cst) {
      let char, name;
      switch (cst.type) {
        case PlainValue.Type.FLOW_MAP:
          char = "}";
          name = "flow map";
          break;
        case PlainValue.Type.FLOW_SEQ:
          char = "]";
          name = "flow sequence";
          break;
        default:
          errors.push(new PlainValue.YAMLSemanticError(cst, "Not a flow collection!?"));
          return;
      }
      let lastItem;
      for (let i = cst.items.length - 1; i >= 0; --i) {
        const item = cst.items[i];
        if (!item || item.type !== PlainValue.Type.COMMENT) {
          lastItem = item;
          break;
        }
      }
      if (lastItem && lastItem.char !== char) {
        const msg = `Expected ${name} to end with ${char}`;
        let err;
        if (typeof lastItem.offset === "number") {
          err = new PlainValue.YAMLSemanticError(cst, msg);
          err.offset = lastItem.offset + 1;
        } else {
          err = new PlainValue.YAMLSemanticError(lastItem, msg);
          if (lastItem.range && lastItem.range.end) err.offset = lastItem.range.end - lastItem.range.start;
        }
        errors.push(err);
      }
    }
    function checkFlowCommentSpace(errors, comment) {
      const prev = comment.context.src[comment.range.start - 1];
      if (prev !== "\n" && prev !== "	" && prev !== " ") {
        const msg = "Comments must be separated from other tokens by white space characters";
        errors.push(new PlainValue.YAMLSemanticError(comment, msg));
      }
    }
    function getLongKeyError(source, key) {
      const sk = String(key);
      const k = sk.substr(0, 8) + "..." + sk.substr(-8);
      return new PlainValue.YAMLSemanticError(source, `The "${k}" key is too long`);
    }
    function resolveComments(collection, comments) {
      for (const {
        afterKey,
        before,
        comment
      } of comments) {
        let item = collection.items[before];
        if (!item) {
          if (comment !== void 0) {
            if (collection.comment) collection.comment += "\n" + comment;
            else collection.comment = comment;
          }
        } else {
          if (afterKey && item.value) item = item.value;
          if (comment === void 0) {
            if (afterKey || !item.commentBefore) item.spaceBefore = true;
          } else {
            if (item.commentBefore) item.commentBefore += "\n" + comment;
            else item.commentBefore = comment;
          }
        }
      }
    }
    function resolveString(doc, node2) {
      const res = node2.strValue;
      if (!res) return "";
      if (typeof res === "string") return res;
      res.errors.forEach((error) => {
        if (!error.source) error.source = node2;
        doc.errors.push(error);
      });
      return res.str;
    }
    function resolveTagHandle(doc, node2) {
      const {
        handle,
        suffix
      } = node2.tag;
      let prefix = doc.tagPrefixes.find((p) => p.handle === handle);
      if (!prefix) {
        const dtp = doc.getDefaults().tagPrefixes;
        if (dtp) prefix = dtp.find((p) => p.handle === handle);
        if (!prefix) throw new PlainValue.YAMLSemanticError(node2, `The ${handle} tag handle is non-default and was not declared.`);
      }
      if (!suffix) throw new PlainValue.YAMLSemanticError(node2, `The ${handle} tag has no suffix.`);
      if (handle === "!" && (doc.version || doc.options.version) === "1.0") {
        if (suffix[0] === "^") {
          doc.warnings.push(new PlainValue.YAMLWarning(node2, "YAML 1.0 ^ tag expansion is not supported"));
          return suffix;
        }
        if (/[:/]/.test(suffix)) {
          const vocab = suffix.match(/^([a-z0-9-]+)\/(.*)/i);
          return vocab ? `tag:${vocab[1]}.yaml.org,2002:${vocab[2]}` : `tag:${suffix}`;
        }
      }
      return prefix.prefix + decodeURIComponent(suffix);
    }
    function resolveTagName(doc, node2) {
      const {
        tag,
        type: type2
      } = node2;
      let nonSpecific = false;
      if (tag) {
        const {
          handle,
          suffix,
          verbatim
        } = tag;
        if (verbatim) {
          if (verbatim !== "!" && verbatim !== "!!") return verbatim;
          const msg = `Verbatim tags aren't resolved, so ${verbatim} is invalid.`;
          doc.errors.push(new PlainValue.YAMLSemanticError(node2, msg));
        } else if (handle === "!" && !suffix) {
          nonSpecific = true;
        } else {
          try {
            return resolveTagHandle(doc, node2);
          } catch (error) {
            doc.errors.push(error);
          }
        }
      }
      switch (type2) {
        case PlainValue.Type.BLOCK_FOLDED:
        case PlainValue.Type.BLOCK_LITERAL:
        case PlainValue.Type.QUOTE_DOUBLE:
        case PlainValue.Type.QUOTE_SINGLE:
          return PlainValue.defaultTags.STR;
        case PlainValue.Type.FLOW_MAP:
        case PlainValue.Type.MAP:
          return PlainValue.defaultTags.MAP;
        case PlainValue.Type.FLOW_SEQ:
        case PlainValue.Type.SEQ:
          return PlainValue.defaultTags.SEQ;
        case PlainValue.Type.PLAIN:
          return nonSpecific ? PlainValue.defaultTags.STR : null;
        default:
          return null;
      }
    }
    function resolveByTagName(doc, node2, tagName) {
      const {
        tags
      } = doc.schema;
      const matchWithTest = [];
      for (const tag of tags) {
        if (tag.tag === tagName) {
          if (tag.test) matchWithTest.push(tag);
          else {
            const res = tag.resolve(doc, node2);
            return res instanceof Collection ? res : new Scalar(res);
          }
        }
      }
      const str2 = resolveString(doc, node2);
      if (typeof str2 === "string" && matchWithTest.length > 0) return resolveScalar(str2, matchWithTest, tags.scalarFallback);
      return null;
    }
    function getFallbackTagName({
      type: type2
    }) {
      switch (type2) {
        case PlainValue.Type.FLOW_MAP:
        case PlainValue.Type.MAP:
          return PlainValue.defaultTags.MAP;
        case PlainValue.Type.FLOW_SEQ:
        case PlainValue.Type.SEQ:
          return PlainValue.defaultTags.SEQ;
        default:
          return PlainValue.defaultTags.STR;
      }
    }
    function resolveTag(doc, node2, tagName) {
      try {
        const res = resolveByTagName(doc, node2, tagName);
        if (res) {
          if (tagName && node2.tag) res.tag = tagName;
          return res;
        }
      } catch (error) {
        if (!error.source) error.source = node2;
        doc.errors.push(error);
        return null;
      }
      try {
        const fallback = getFallbackTagName(node2);
        if (!fallback) throw new Error(`The tag ${tagName} is unavailable`);
        const msg = `The tag ${tagName} is unavailable, falling back to ${fallback}`;
        doc.warnings.push(new PlainValue.YAMLWarning(node2, msg));
        const res = resolveByTagName(doc, node2, fallback);
        res.tag = tagName;
        return res;
      } catch (error) {
        const refError = new PlainValue.YAMLReferenceError(node2, error.message);
        refError.stack = error.stack;
        doc.errors.push(refError);
        return null;
      }
    }
    var isCollectionItem = (node2) => {
      if (!node2) return false;
      const {
        type: type2
      } = node2;
      return type2 === PlainValue.Type.MAP_KEY || type2 === PlainValue.Type.MAP_VALUE || type2 === PlainValue.Type.SEQ_ITEM;
    };
    function resolveNodeProps(errors, node2) {
      const comments = {
        before: [],
        after: []
      };
      let hasAnchor = false;
      let hasTag = false;
      const props = isCollectionItem(node2.context.parent) ? node2.context.parent.props.concat(node2.props) : node2.props;
      for (const {
        start,
        end
      } of props) {
        switch (node2.context.src[start]) {
          case PlainValue.Char.COMMENT: {
            if (!node2.commentHasRequiredWhitespace(start)) {
              const msg = "Comments must be separated from other tokens by white space characters";
              errors.push(new PlainValue.YAMLSemanticError(node2, msg));
            }
            const {
              header,
              valueRange
            } = node2;
            const cc = valueRange && (start > valueRange.start || header && start > header.start) ? comments.after : comments.before;
            cc.push(node2.context.src.slice(start + 1, end));
            break;
          }
          case PlainValue.Char.ANCHOR:
            if (hasAnchor) {
              const msg = "A node can have at most one anchor";
              errors.push(new PlainValue.YAMLSemanticError(node2, msg));
            }
            hasAnchor = true;
            break;
          case PlainValue.Char.TAG:
            if (hasTag) {
              const msg = "A node can have at most one tag";
              errors.push(new PlainValue.YAMLSemanticError(node2, msg));
            }
            hasTag = true;
            break;
        }
      }
      return {
        comments,
        hasAnchor,
        hasTag
      };
    }
    function resolveNodeValue(doc, node2) {
      const {
        anchors,
        errors,
        schema: schema2
      } = doc;
      if (node2.type === PlainValue.Type.ALIAS) {
        const name = node2.rawValue;
        const src = anchors.getNode(name);
        if (!src) {
          const msg = `Aliased anchor not found: ${name}`;
          errors.push(new PlainValue.YAMLReferenceError(node2, msg));
          return null;
        }
        const res = new Alias(src);
        anchors._cstAliases.push(res);
        return res;
      }
      const tagName = resolveTagName(doc, node2);
      if (tagName) return resolveTag(doc, node2, tagName);
      if (node2.type !== PlainValue.Type.PLAIN) {
        const msg = `Failed to resolve ${node2.type} node here`;
        errors.push(new PlainValue.YAMLSyntaxError(node2, msg));
        return null;
      }
      try {
        const str2 = resolveString(doc, node2);
        return resolveScalar(str2, schema2.tags, schema2.tags.scalarFallback);
      } catch (error) {
        if (!error.source) error.source = node2;
        errors.push(error);
        return null;
      }
    }
    function resolveNode(doc, node2) {
      if (!node2) return null;
      if (node2.error) doc.errors.push(node2.error);
      const {
        comments,
        hasAnchor,
        hasTag
      } = resolveNodeProps(doc.errors, node2);
      if (hasAnchor) {
        const {
          anchors
        } = doc;
        const name = node2.anchor;
        const prev = anchors.getNode(name);
        if (prev) anchors.map[anchors.newName(name)] = prev;
        anchors.map[name] = node2;
      }
      if (node2.type === PlainValue.Type.ALIAS && (hasAnchor || hasTag)) {
        const msg = "An alias node must not specify any properties";
        doc.errors.push(new PlainValue.YAMLSemanticError(node2, msg));
      }
      const res = resolveNodeValue(doc, node2);
      if (res) {
        res.range = [node2.range.start, node2.range.end];
        if (doc.options.keepCstNodes) res.cstNode = node2;
        if (doc.options.keepNodeTypes) res.type = node2.type;
        const cb = comments.before.join("\n");
        if (cb) {
          res.commentBefore = res.commentBefore ? `${res.commentBefore}
${cb}` : cb;
        }
        const ca = comments.after.join("\n");
        if (ca) res.comment = res.comment ? `${res.comment}
${ca}` : ca;
      }
      return node2.resolved = res;
    }
    function resolveMap(doc, cst) {
      if (cst.type !== PlainValue.Type.MAP && cst.type !== PlainValue.Type.FLOW_MAP) {
        const msg = `A ${cst.type} node cannot be resolved as a mapping`;
        doc.errors.push(new PlainValue.YAMLSyntaxError(cst, msg));
        return null;
      }
      const {
        comments,
        items
      } = cst.type === PlainValue.Type.FLOW_MAP ? resolveFlowMapItems(doc, cst) : resolveBlockMapItems(doc, cst);
      const map2 = new YAMLMap();
      map2.items = items;
      resolveComments(map2, comments);
      let hasCollectionKey = false;
      for (let i = 0; i < items.length; ++i) {
        const {
          key: iKey
        } = items[i];
        if (iKey instanceof Collection) hasCollectionKey = true;
        if (doc.schema.merge && iKey && iKey.value === MERGE_KEY) {
          items[i] = new Merge(items[i]);
          const sources = items[i].value.items;
          let error = null;
          sources.some((node2) => {
            if (node2 instanceof Alias) {
              const {
                type: type2
              } = node2.source;
              if (type2 === PlainValue.Type.MAP || type2 === PlainValue.Type.FLOW_MAP) return false;
              return error = "Merge nodes aliases can only point to maps";
            }
            return error = "Merge nodes can only have Alias nodes as values";
          });
          if (error) doc.errors.push(new PlainValue.YAMLSemanticError(cst, error));
        } else {
          for (let j = i + 1; j < items.length; ++j) {
            const {
              key: jKey
            } = items[j];
            if (iKey === jKey || iKey && jKey && Object.prototype.hasOwnProperty.call(iKey, "value") && iKey.value === jKey.value) {
              const msg = `Map keys must be unique; "${iKey}" is repeated`;
              doc.errors.push(new PlainValue.YAMLSemanticError(cst, msg));
              break;
            }
          }
        }
      }
      if (hasCollectionKey && !doc.options.mapAsMap) {
        const warn = "Keys with collection values will be stringified as YAML due to JS Object restrictions. Use mapAsMap: true to avoid this.";
        doc.warnings.push(new PlainValue.YAMLWarning(cst, warn));
      }
      cst.resolved = map2;
      return map2;
    }
    var valueHasPairComment = ({
      context: {
        lineStart,
        node: node2,
        src
      },
      props
    }) => {
      if (props.length === 0) return false;
      const {
        start
      } = props[0];
      if (node2 && start > node2.valueRange.start) return false;
      if (src[start] !== PlainValue.Char.COMMENT) return false;
      for (let i = lineStart; i < start; ++i) if (src[i] === "\n") return false;
      return true;
    };
    function resolvePairComment(item, pair) {
      if (!valueHasPairComment(item)) return;
      const comment = item.getPropValue(0, PlainValue.Char.COMMENT, true);
      let found = false;
      const cb = pair.value.commentBefore;
      if (cb && cb.startsWith(comment)) {
        pair.value.commentBefore = cb.substr(comment.length + 1);
        found = true;
      } else {
        const cc = pair.value.comment;
        if (!item.node && cc && cc.startsWith(comment)) {
          pair.value.comment = cc.substr(comment.length + 1);
          found = true;
        }
      }
      if (found) pair.comment = comment;
    }
    function resolveBlockMapItems(doc, cst) {
      const comments = [];
      const items = [];
      let key = void 0;
      let keyStart = null;
      for (let i = 0; i < cst.items.length; ++i) {
        const item = cst.items[i];
        switch (item.type) {
          case PlainValue.Type.BLANK_LINE:
            comments.push({
              afterKey: !!key,
              before: items.length
            });
            break;
          case PlainValue.Type.COMMENT:
            comments.push({
              afterKey: !!key,
              before: items.length,
              comment: item.comment
            });
            break;
          case PlainValue.Type.MAP_KEY:
            if (key !== void 0) items.push(new Pair(key));
            if (item.error) doc.errors.push(item.error);
            key = resolveNode(doc, item.node);
            keyStart = null;
            break;
          case PlainValue.Type.MAP_VALUE:
            {
              if (key === void 0) key = null;
              if (item.error) doc.errors.push(item.error);
              if (!item.context.atLineStart && item.node && item.node.type === PlainValue.Type.MAP && !item.node.context.atLineStart) {
                const msg = "Nested mappings are not allowed in compact mappings";
                doc.errors.push(new PlainValue.YAMLSemanticError(item.node, msg));
              }
              let valueNode = item.node;
              if (!valueNode && item.props.length > 0) {
                valueNode = new PlainValue.PlainValue(PlainValue.Type.PLAIN, []);
                valueNode.context = {
                  parent: item,
                  src: item.context.src
                };
                const pos = item.range.start + 1;
                valueNode.range = {
                  start: pos,
                  end: pos
                };
                valueNode.valueRange = {
                  start: pos,
                  end: pos
                };
                if (typeof item.range.origStart === "number") {
                  const origPos = item.range.origStart + 1;
                  valueNode.range.origStart = valueNode.range.origEnd = origPos;
                  valueNode.valueRange.origStart = valueNode.valueRange.origEnd = origPos;
                }
              }
              const pair = new Pair(key, resolveNode(doc, valueNode));
              resolvePairComment(item, pair);
              items.push(pair);
              if (key && typeof keyStart === "number") {
                if (item.range.start > keyStart + 1024) doc.errors.push(getLongKeyError(cst, key));
              }
              key = void 0;
              keyStart = null;
            }
            break;
          default:
            if (key !== void 0) items.push(new Pair(key));
            key = resolveNode(doc, item);
            keyStart = item.range.start;
            if (item.error) doc.errors.push(item.error);
            next: for (let j = i + 1; ; ++j) {
              const nextItem = cst.items[j];
              switch (nextItem && nextItem.type) {
                case PlainValue.Type.BLANK_LINE:
                case PlainValue.Type.COMMENT:
                  continue next;
                case PlainValue.Type.MAP_VALUE:
                  break next;
                default: {
                  const msg = "Implicit map keys need to be followed by map values";
                  doc.errors.push(new PlainValue.YAMLSemanticError(item, msg));
                  break next;
                }
              }
            }
            if (item.valueRangeContainsNewline) {
              const msg = "Implicit map keys need to be on a single line";
              doc.errors.push(new PlainValue.YAMLSemanticError(item, msg));
            }
        }
      }
      if (key !== void 0) items.push(new Pair(key));
      return {
        comments,
        items
      };
    }
    function resolveFlowMapItems(doc, cst) {
      const comments = [];
      const items = [];
      let key = void 0;
      let explicitKey = false;
      let next = "{";
      for (let i = 0; i < cst.items.length; ++i) {
        const item = cst.items[i];
        if (typeof item.char === "string") {
          const {
            char,
            offset
          } = item;
          if (char === "?" && key === void 0 && !explicitKey) {
            explicitKey = true;
            next = ":";
            continue;
          }
          if (char === ":") {
            if (key === void 0) key = null;
            if (next === ":") {
              next = ",";
              continue;
            }
          } else {
            if (explicitKey) {
              if (key === void 0 && char !== ",") key = null;
              explicitKey = false;
            }
            if (key !== void 0) {
              items.push(new Pair(key));
              key = void 0;
              if (char === ",") {
                next = ":";
                continue;
              }
            }
          }
          if (char === "}") {
            if (i === cst.items.length - 1) continue;
          } else if (char === next) {
            next = ":";
            continue;
          }
          const msg = `Flow map contains an unexpected ${char}`;
          const err = new PlainValue.YAMLSyntaxError(cst, msg);
          err.offset = offset;
          doc.errors.push(err);
        } else if (item.type === PlainValue.Type.BLANK_LINE) {
          comments.push({
            afterKey: !!key,
            before: items.length
          });
        } else if (item.type === PlainValue.Type.COMMENT) {
          checkFlowCommentSpace(doc.errors, item);
          comments.push({
            afterKey: !!key,
            before: items.length,
            comment: item.comment
          });
        } else if (key === void 0) {
          if (next === ",") doc.errors.push(new PlainValue.YAMLSemanticError(item, "Separator , missing in flow map"));
          key = resolveNode(doc, item);
        } else {
          if (next !== ",") doc.errors.push(new PlainValue.YAMLSemanticError(item, "Indicator : missing in flow map entry"));
          items.push(new Pair(key, resolveNode(doc, item)));
          key = void 0;
          explicitKey = false;
        }
      }
      checkFlowCollectionEnd(doc.errors, cst);
      if (key !== void 0) items.push(new Pair(key));
      return {
        comments,
        items
      };
    }
    function resolveSeq(doc, cst) {
      if (cst.type !== PlainValue.Type.SEQ && cst.type !== PlainValue.Type.FLOW_SEQ) {
        const msg = `A ${cst.type} node cannot be resolved as a sequence`;
        doc.errors.push(new PlainValue.YAMLSyntaxError(cst, msg));
        return null;
      }
      const {
        comments,
        items
      } = cst.type === PlainValue.Type.FLOW_SEQ ? resolveFlowSeqItems(doc, cst) : resolveBlockSeqItems(doc, cst);
      const seq2 = new YAMLSeq();
      seq2.items = items;
      resolveComments(seq2, comments);
      if (!doc.options.mapAsMap && items.some((it) => it instanceof Pair && it.key instanceof Collection)) {
        const warn = "Keys with collection values will be stringified as YAML due to JS Object restrictions. Use mapAsMap: true to avoid this.";
        doc.warnings.push(new PlainValue.YAMLWarning(cst, warn));
      }
      cst.resolved = seq2;
      return seq2;
    }
    function resolveBlockSeqItems(doc, cst) {
      const comments = [];
      const items = [];
      for (let i = 0; i < cst.items.length; ++i) {
        const item = cst.items[i];
        switch (item.type) {
          case PlainValue.Type.BLANK_LINE:
            comments.push({
              before: items.length
            });
            break;
          case PlainValue.Type.COMMENT:
            comments.push({
              comment: item.comment,
              before: items.length
            });
            break;
          case PlainValue.Type.SEQ_ITEM:
            if (item.error) doc.errors.push(item.error);
            items.push(resolveNode(doc, item.node));
            if (item.hasProps) {
              const msg = "Sequence items cannot have tags or anchors before the - indicator";
              doc.errors.push(new PlainValue.YAMLSemanticError(item, msg));
            }
            break;
          default:
            if (item.error) doc.errors.push(item.error);
            doc.errors.push(new PlainValue.YAMLSyntaxError(item, `Unexpected ${item.type} node in sequence`));
        }
      }
      return {
        comments,
        items
      };
    }
    function resolveFlowSeqItems(doc, cst) {
      const comments = [];
      const items = [];
      let explicitKey = false;
      let key = void 0;
      let keyStart = null;
      let next = "[";
      let prevItem = null;
      for (let i = 0; i < cst.items.length; ++i) {
        const item = cst.items[i];
        if (typeof item.char === "string") {
          const {
            char,
            offset
          } = item;
          if (char !== ":" && (explicitKey || key !== void 0)) {
            if (explicitKey && key === void 0) key = next ? items.pop() : null;
            items.push(new Pair(key));
            explicitKey = false;
            key = void 0;
            keyStart = null;
          }
          if (char === next) {
            next = null;
          } else if (!next && char === "?") {
            explicitKey = true;
          } else if (next !== "[" && char === ":" && key === void 0) {
            if (next === ",") {
              key = items.pop();
              if (key instanceof Pair) {
                const msg = "Chaining flow sequence pairs is invalid";
                const err = new PlainValue.YAMLSemanticError(cst, msg);
                err.offset = offset;
                doc.errors.push(err);
              }
              if (!explicitKey && typeof keyStart === "number") {
                const keyEnd = item.range ? item.range.start : item.offset;
                if (keyEnd > keyStart + 1024) doc.errors.push(getLongKeyError(cst, key));
                const {
                  src
                } = prevItem.context;
                for (let i2 = keyStart; i2 < keyEnd; ++i2) if (src[i2] === "\n") {
                  const msg = "Implicit keys of flow sequence pairs need to be on a single line";
                  doc.errors.push(new PlainValue.YAMLSemanticError(prevItem, msg));
                  break;
                }
              }
            } else {
              key = null;
            }
            keyStart = null;
            explicitKey = false;
            next = null;
          } else if (next === "[" || char !== "]" || i < cst.items.length - 1) {
            const msg = `Flow sequence contains an unexpected ${char}`;
            const err = new PlainValue.YAMLSyntaxError(cst, msg);
            err.offset = offset;
            doc.errors.push(err);
          }
        } else if (item.type === PlainValue.Type.BLANK_LINE) {
          comments.push({
            before: items.length
          });
        } else if (item.type === PlainValue.Type.COMMENT) {
          checkFlowCommentSpace(doc.errors, item);
          comments.push({
            comment: item.comment,
            before: items.length
          });
        } else {
          if (next) {
            const msg = `Expected a ${next} in flow sequence`;
            doc.errors.push(new PlainValue.YAMLSemanticError(item, msg));
          }
          const value = resolveNode(doc, item);
          if (key === void 0) {
            items.push(value);
            prevItem = item;
          } else {
            items.push(new Pair(key, value));
            key = void 0;
          }
          keyStart = item.range.start;
          next = ",";
        }
      }
      checkFlowCollectionEnd(doc.errors, cst);
      if (key !== void 0) items.push(new Pair(key));
      return {
        comments,
        items
      };
    }
    exports2.Alias = Alias;
    exports2.Collection = Collection;
    exports2.Merge = Merge;
    exports2.Node = Node;
    exports2.Pair = Pair;
    exports2.Scalar = Scalar;
    exports2.YAMLMap = YAMLMap;
    exports2.YAMLSeq = YAMLSeq;
    exports2.addComment = addComment;
    exports2.binaryOptions = binaryOptions;
    exports2.boolOptions = boolOptions;
    exports2.findPair = findPair;
    exports2.intOptions = intOptions;
    exports2.isEmptyPath = isEmptyPath;
    exports2.nullOptions = nullOptions;
    exports2.resolveMap = resolveMap;
    exports2.resolveNode = resolveNode;
    exports2.resolveSeq = resolveSeq;
    exports2.resolveString = resolveString;
    exports2.strOptions = strOptions;
    exports2.stringifyNumber = stringifyNumber;
    exports2.stringifyString = stringifyString;
    exports2.toJSON = toJSON3;
  }
});

// node_modules/oas-resolver/node_modules/yaml/dist/warnings-1000a372.js
var require_warnings_1000a3722 = __commonJS({
  "node_modules/oas-resolver/node_modules/yaml/dist/warnings-1000a372.js"(exports2) {
    "use strict";
    var PlainValue = require_PlainValue_ec8e588e2();
    var resolveSeq = require_resolveSeq_d03cb0372();
    var binary2 = {
      identify: (value) => value instanceof Uint8Array,
      // Buffer inherits from Uint8Array
      default: false,
      tag: "tag:yaml.org,2002:binary",
      /**
       * Returns a Buffer in node and an Uint8Array in browsers
       *
       * To use the resulting buffer as an image, you'll want to do something like:
       *
       *   const blob = new Blob([buffer], { type: 'image/jpeg' })
       *   document.querySelector('#photo').src = URL.createObjectURL(blob)
       */
      resolve: (doc, node2) => {
        const src = resolveSeq.resolveString(doc, node2);
        if (typeof Buffer === "function") {
          return Buffer.from(src, "base64");
        } else if (typeof atob === "function") {
          const str2 = atob(src.replace(/[\n\r]/g, ""));
          const buffer = new Uint8Array(str2.length);
          for (let i = 0; i < str2.length; ++i) buffer[i] = str2.charCodeAt(i);
          return buffer;
        } else {
          const msg = "This environment does not support reading binary tags; either Buffer or atob is required";
          doc.errors.push(new PlainValue.YAMLReferenceError(node2, msg));
          return null;
        }
      },
      options: resolveSeq.binaryOptions,
      stringify: ({
        comment,
        type: type2,
        value
      }, ctx, onComment, onChompKeep) => {
        let src;
        if (typeof Buffer === "function") {
          src = value instanceof Buffer ? value.toString("base64") : Buffer.from(value.buffer).toString("base64");
        } else if (typeof btoa === "function") {
          let s = "";
          for (let i = 0; i < value.length; ++i) s += String.fromCharCode(value[i]);
          src = btoa(s);
        } else {
          throw new Error("This environment does not support writing binary tags; either Buffer or btoa is required");
        }
        if (!type2) type2 = resolveSeq.binaryOptions.defaultType;
        if (type2 === PlainValue.Type.QUOTE_DOUBLE) {
          value = src;
        } else {
          const {
            lineWidth
          } = resolveSeq.binaryOptions;
          const n = Math.ceil(src.length / lineWidth);
          const lines = new Array(n);
          for (let i = 0, o = 0; i < n; ++i, o += lineWidth) {
            lines[i] = src.substr(o, lineWidth);
          }
          value = lines.join(type2 === PlainValue.Type.BLOCK_LITERAL ? "\n" : " ");
        }
        return resolveSeq.stringifyString({
          comment,
          type: type2,
          value
        }, ctx, onComment, onChompKeep);
      }
    };
    function parsePairs(doc, cst) {
      const seq2 = resolveSeq.resolveSeq(doc, cst);
      for (let i = 0; i < seq2.items.length; ++i) {
        let item = seq2.items[i];
        if (item instanceof resolveSeq.Pair) continue;
        else if (item instanceof resolveSeq.YAMLMap) {
          if (item.items.length > 1) {
            const msg = "Each pair must have its own sequence indicator";
            throw new PlainValue.YAMLSemanticError(cst, msg);
          }
          const pair = item.items[0] || new resolveSeq.Pair();
          if (item.commentBefore) pair.commentBefore = pair.commentBefore ? `${item.commentBefore}
${pair.commentBefore}` : item.commentBefore;
          if (item.comment) pair.comment = pair.comment ? `${item.comment}
${pair.comment}` : item.comment;
          item = pair;
        }
        seq2.items[i] = item instanceof resolveSeq.Pair ? item : new resolveSeq.Pair(item);
      }
      return seq2;
    }
    function createPairs(schema2, iterable, ctx) {
      const pairs3 = new resolveSeq.YAMLSeq(schema2);
      pairs3.tag = "tag:yaml.org,2002:pairs";
      for (const it of iterable) {
        let key, value;
        if (Array.isArray(it)) {
          if (it.length === 2) {
            key = it[0];
            value = it[1];
          } else throw new TypeError(`Expected [key, value] tuple: ${it}`);
        } else if (it && it instanceof Object) {
          const keys = Object.keys(it);
          if (keys.length === 1) {
            key = keys[0];
            value = it[key];
          } else throw new TypeError(`Expected { key: value } tuple: ${it}`);
        } else {
          key = it;
        }
        const pair = schema2.createPair(key, value, ctx);
        pairs3.items.push(pair);
      }
      return pairs3;
    }
    var pairs2 = {
      default: false,
      tag: "tag:yaml.org,2002:pairs",
      resolve: parsePairs,
      createNode: createPairs
    };
    var YAMLOMap = class _YAMLOMap extends resolveSeq.YAMLSeq {
      constructor() {
        super();
        PlainValue._defineProperty(this, "add", resolveSeq.YAMLMap.prototype.add.bind(this));
        PlainValue._defineProperty(this, "delete", resolveSeq.YAMLMap.prototype.delete.bind(this));
        PlainValue._defineProperty(this, "get", resolveSeq.YAMLMap.prototype.get.bind(this));
        PlainValue._defineProperty(this, "has", resolveSeq.YAMLMap.prototype.has.bind(this));
        PlainValue._defineProperty(this, "set", resolveSeq.YAMLMap.prototype.set.bind(this));
        this.tag = _YAMLOMap.tag;
      }
      toJSON(_, ctx) {
        const map2 = /* @__PURE__ */ new Map();
        if (ctx && ctx.onCreate) ctx.onCreate(map2);
        for (const pair of this.items) {
          let key, value;
          if (pair instanceof resolveSeq.Pair) {
            key = resolveSeq.toJSON(pair.key, "", ctx);
            value = resolveSeq.toJSON(pair.value, key, ctx);
          } else {
            key = resolveSeq.toJSON(pair, "", ctx);
          }
          if (map2.has(key)) throw new Error("Ordered maps must not include duplicate keys");
          map2.set(key, value);
        }
        return map2;
      }
    };
    PlainValue._defineProperty(YAMLOMap, "tag", "tag:yaml.org,2002:omap");
    function parseOMap(doc, cst) {
      const pairs3 = parsePairs(doc, cst);
      const seenKeys = [];
      for (const {
        key
      } of pairs3.items) {
        if (key instanceof resolveSeq.Scalar) {
          if (seenKeys.includes(key.value)) {
            const msg = "Ordered maps must not include duplicate keys";
            throw new PlainValue.YAMLSemanticError(cst, msg);
          } else {
            seenKeys.push(key.value);
          }
        }
      }
      return Object.assign(new YAMLOMap(), pairs3);
    }
    function createOMap(schema2, iterable, ctx) {
      const pairs3 = createPairs(schema2, iterable, ctx);
      const omap3 = new YAMLOMap();
      omap3.items = pairs3.items;
      return omap3;
    }
    var omap2 = {
      identify: (value) => value instanceof Map,
      nodeClass: YAMLOMap,
      default: false,
      tag: "tag:yaml.org,2002:omap",
      resolve: parseOMap,
      createNode: createOMap
    };
    var YAMLSet = class _YAMLSet extends resolveSeq.YAMLMap {
      constructor() {
        super();
        this.tag = _YAMLSet.tag;
      }
      add(key) {
        const pair = key instanceof resolveSeq.Pair ? key : new resolveSeq.Pair(key);
        const prev = resolveSeq.findPair(this.items, pair.key);
        if (!prev) this.items.push(pair);
      }
      get(key, keepPair) {
        const pair = resolveSeq.findPair(this.items, key);
        return !keepPair && pair instanceof resolveSeq.Pair ? pair.key instanceof resolveSeq.Scalar ? pair.key.value : pair.key : pair;
      }
      set(key, value) {
        if (typeof value !== "boolean") throw new Error(`Expected boolean value for set(key, value) in a YAML set, not ${typeof value}`);
        const prev = resolveSeq.findPair(this.items, key);
        if (prev && !value) {
          this.items.splice(this.items.indexOf(prev), 1);
        } else if (!prev && value) {
          this.items.push(new resolveSeq.Pair(key));
        }
      }
      toJSON(_, ctx) {
        return super.toJSON(_, ctx, Set);
      }
      toString(ctx, onComment, onChompKeep) {
        if (!ctx) return JSON.stringify(this);
        if (this.hasAllNullValues()) return super.toString(ctx, onComment, onChompKeep);
        else throw new Error("Set items must all have null values");
      }
    };
    PlainValue._defineProperty(YAMLSet, "tag", "tag:yaml.org,2002:set");
    function parseSet(doc, cst) {
      const map2 = resolveSeq.resolveMap(doc, cst);
      if (!map2.hasAllNullValues()) throw new PlainValue.YAMLSemanticError(cst, "Set items must all have null values");
      return Object.assign(new YAMLSet(), map2);
    }
    function createSet(schema2, iterable, ctx) {
      const set4 = new YAMLSet();
      for (const value of iterable) set4.items.push(schema2.createPair(value, null, ctx));
      return set4;
    }
    var set3 = {
      identify: (value) => value instanceof Set,
      nodeClass: YAMLSet,
      default: false,
      tag: "tag:yaml.org,2002:set",
      resolve: parseSet,
      createNode: createSet
    };
    var parseSexagesimal = (sign, parts) => {
      const n = parts.split(":").reduce((n2, p) => n2 * 60 + Number(p), 0);
      return sign === "-" ? -n : n;
    };
    var stringifySexagesimal = ({
      value
    }) => {
      if (isNaN(value) || !isFinite(value)) return resolveSeq.stringifyNumber(value);
      let sign = "";
      if (value < 0) {
        sign = "-";
        value = Math.abs(value);
      }
      const parts = [value % 60];
      if (value < 60) {
        parts.unshift(0);
      } else {
        value = Math.round((value - parts[0]) / 60);
        parts.unshift(value % 60);
        if (value >= 60) {
          value = Math.round((value - parts[0]) / 60);
          parts.unshift(value);
        }
      }
      return sign + parts.map((n) => n < 10 ? "0" + String(n) : String(n)).join(":").replace(/000000\d*$/, "");
    };
    var intTime = {
      identify: (value) => typeof value === "number",
      default: true,
      tag: "tag:yaml.org,2002:int",
      format: "TIME",
      test: /^([-+]?)([0-9][0-9_]*(?::[0-5]?[0-9])+)$/,
      resolve: (str2, sign, parts) => parseSexagesimal(sign, parts.replace(/_/g, "")),
      stringify: stringifySexagesimal
    };
    var floatTime = {
      identify: (value) => typeof value === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      format: "TIME",
      test: /^([-+]?)([0-9][0-9_]*(?::[0-5]?[0-9])+\.[0-9_]*)$/,
      resolve: (str2, sign, parts) => parseSexagesimal(sign, parts.replace(/_/g, "")),
      stringify: stringifySexagesimal
    };
    var timestamp2 = {
      identify: (value) => value instanceof Date,
      default: true,
      tag: "tag:yaml.org,2002:timestamp",
      // If the time zone is omitted, the timestamp is assumed to be specified in UTC. The time part
      // may be omitted altogether, resulting in a date format. In such a case, the time part is
      // assumed to be 00:00:00Z (start of day, UTC).
      test: RegExp("^(?:([0-9]{4})-([0-9]{1,2})-([0-9]{1,2})(?:(?:t|T|[ \\t]+)([0-9]{1,2}):([0-9]{1,2}):([0-9]{1,2}(\\.[0-9]+)?)(?:[ \\t]*(Z|[-+][012]?[0-9](?::[0-9]{2})?))?)?)$"),
      resolve: (str2, year, month, day, hour, minute, second, millisec, tz) => {
        if (millisec) millisec = (millisec + "00").substr(1, 3);
        let date = Date.UTC(year, month - 1, day, hour || 0, minute || 0, second || 0, millisec || 0);
        if (tz && tz !== "Z") {
          let d = parseSexagesimal(tz[0], tz.slice(1));
          if (Math.abs(d) < 30) d *= 60;
          date -= 6e4 * d;
        }
        return new Date(date);
      },
      stringify: ({
        value
      }) => value.toISOString().replace(/((T00:00)?:00)?\.000Z$/, "")
    };
    function shouldWarn(deprecation) {
      const env = typeof process !== "undefined" && process.env || {};
      if (deprecation) {
        if (typeof YAML_SILENCE_DEPRECATION_WARNINGS !== "undefined") return !YAML_SILENCE_DEPRECATION_WARNINGS;
        return !env.YAML_SILENCE_DEPRECATION_WARNINGS;
      }
      if (typeof YAML_SILENCE_WARNINGS !== "undefined") return !YAML_SILENCE_WARNINGS;
      return !env.YAML_SILENCE_WARNINGS;
    }
    function warn(warning, type2) {
      if (shouldWarn(false)) {
        const emit = typeof process !== "undefined" && process.emitWarning;
        if (emit) emit(warning, type2);
        else {
          console.warn(type2 ? `${type2}: ${warning}` : warning);
        }
      }
    }
    function warnFileDeprecation(filename) {
      if (shouldWarn(true)) {
        const path = filename.replace(/.*yaml[/\\]/i, "").replace(/\.js$/, "").replace(/\\/g, "/");
        warn(`The endpoint 'yaml/${path}' will be removed in a future release.`, "DeprecationWarning");
      }
    }
    var warned = {};
    function warnOptionDeprecation(name, alternative) {
      if (!warned[name] && shouldWarn(true)) {
        warned[name] = true;
        let msg = `The option '${name}' will be removed in a future release`;
        msg += alternative ? `, use '${alternative}' instead.` : ".";
        warn(msg, "DeprecationWarning");
      }
    }
    exports2.binary = binary2;
    exports2.floatTime = floatTime;
    exports2.intTime = intTime;
    exports2.omap = omap2;
    exports2.pairs = pairs2;
    exports2.set = set3;
    exports2.timestamp = timestamp2;
    exports2.warn = warn;
    exports2.warnFileDeprecation = warnFileDeprecation;
    exports2.warnOptionDeprecation = warnOptionDeprecation;
  }
});

// node_modules/oas-resolver/node_modules/yaml/dist/Schema-88e323a7.js
var require_Schema_88e323a72 = __commonJS({
  "node_modules/oas-resolver/node_modules/yaml/dist/Schema-88e323a7.js"(exports2) {
    "use strict";
    var PlainValue = require_PlainValue_ec8e588e2();
    var resolveSeq = require_resolveSeq_d03cb0372();
    var warnings = require_warnings_1000a3722();
    function createMap(schema2, obj, ctx) {
      const map3 = new resolveSeq.YAMLMap(schema2);
      if (obj instanceof Map) {
        for (const [key, value] of obj) map3.items.push(schema2.createPair(key, value, ctx));
      } else if (obj && typeof obj === "object") {
        for (const key of Object.keys(obj)) map3.items.push(schema2.createPair(key, obj[key], ctx));
      }
      if (typeof schema2.sortMapEntries === "function") {
        map3.items.sort(schema2.sortMapEntries);
      }
      return map3;
    }
    var map2 = {
      createNode: createMap,
      default: true,
      nodeClass: resolveSeq.YAMLMap,
      tag: "tag:yaml.org,2002:map",
      resolve: resolveSeq.resolveMap
    };
    function createSeq(schema2, obj, ctx) {
      const seq3 = new resolveSeq.YAMLSeq(schema2);
      if (obj && obj[Symbol.iterator]) {
        for (const it of obj) {
          const v = schema2.createNode(it, ctx.wrapScalars, null, ctx);
          seq3.items.push(v);
        }
      }
      return seq3;
    }
    var seq2 = {
      createNode: createSeq,
      default: true,
      nodeClass: resolveSeq.YAMLSeq,
      tag: "tag:yaml.org,2002:seq",
      resolve: resolveSeq.resolveSeq
    };
    var string = {
      identify: (value) => typeof value === "string",
      default: true,
      tag: "tag:yaml.org,2002:str",
      resolve: resolveSeq.resolveString,
      stringify(item, ctx, onComment, onChompKeep) {
        ctx = Object.assign({
          actualString: true
        }, ctx);
        return resolveSeq.stringifyString(item, ctx, onComment, onChompKeep);
      },
      options: resolveSeq.strOptions
    };
    var failsafe2 = [map2, seq2, string];
    var intIdentify$2 = (value) => typeof value === "bigint" || Number.isInteger(value);
    var intResolve$1 = (src, part, radix) => resolveSeq.intOptions.asBigInt ? BigInt(src) : parseInt(part, radix);
    function intStringify$1(node2, radix, prefix) {
      const {
        value
      } = node2;
      if (intIdentify$2(value) && value >= 0) return prefix + value.toString(radix);
      return resolveSeq.stringifyNumber(node2);
    }
    var nullObj = {
      identify: (value) => value == null,
      createNode: (schema2, value, ctx) => ctx.wrapScalars ? new resolveSeq.Scalar(null) : null,
      default: true,
      tag: "tag:yaml.org,2002:null",
      test: /^(?:~|[Nn]ull|NULL)?$/,
      resolve: () => null,
      options: resolveSeq.nullOptions,
      stringify: () => resolveSeq.nullOptions.nullStr
    };
    var boolObj = {
      identify: (value) => typeof value === "boolean",
      default: true,
      tag: "tag:yaml.org,2002:bool",
      test: /^(?:[Tt]rue|TRUE|[Ff]alse|FALSE)$/,
      resolve: (str2) => str2[0] === "t" || str2[0] === "T",
      options: resolveSeq.boolOptions,
      stringify: ({
        value
      }) => value ? resolveSeq.boolOptions.trueStr : resolveSeq.boolOptions.falseStr
    };
    var octObj = {
      identify: (value) => intIdentify$2(value) && value >= 0,
      default: true,
      tag: "tag:yaml.org,2002:int",
      format: "OCT",
      test: /^0o([0-7]+)$/,
      resolve: (str2, oct) => intResolve$1(str2, oct, 8),
      options: resolveSeq.intOptions,
      stringify: (node2) => intStringify$1(node2, 8, "0o")
    };
    var intObj = {
      identify: intIdentify$2,
      default: true,
      tag: "tag:yaml.org,2002:int",
      test: /^[-+]?[0-9]+$/,
      resolve: (str2) => intResolve$1(str2, str2, 10),
      options: resolveSeq.intOptions,
      stringify: resolveSeq.stringifyNumber
    };
    var hexObj = {
      identify: (value) => intIdentify$2(value) && value >= 0,
      default: true,
      tag: "tag:yaml.org,2002:int",
      format: "HEX",
      test: /^0x([0-9a-fA-F]+)$/,
      resolve: (str2, hex) => intResolve$1(str2, hex, 16),
      options: resolveSeq.intOptions,
      stringify: (node2) => intStringify$1(node2, 16, "0x")
    };
    var nanObj = {
      identify: (value) => typeof value === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      test: /^(?:[-+]?\.inf|(\.nan))$/i,
      resolve: (str2, nan) => nan ? NaN : str2[0] === "-" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY,
      stringify: resolveSeq.stringifyNumber
    };
    var expObj = {
      identify: (value) => typeof value === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      format: "EXP",
      test: /^[-+]?(?:\.[0-9]+|[0-9]+(?:\.[0-9]*)?)[eE][-+]?[0-9]+$/,
      resolve: (str2) => parseFloat(str2),
      stringify: ({
        value
      }) => Number(value).toExponential()
    };
    var floatObj = {
      identify: (value) => typeof value === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      test: /^[-+]?(?:\.([0-9]+)|[0-9]+\.([0-9]*))$/,
      resolve(str2, frac1, frac2) {
        const frac = frac1 || frac2;
        const node2 = new resolveSeq.Scalar(parseFloat(str2));
        if (frac && frac[frac.length - 1] === "0") node2.minFractionDigits = frac.length;
        return node2;
      },
      stringify: resolveSeq.stringifyNumber
    };
    var core2 = failsafe2.concat([nullObj, boolObj, octObj, intObj, hexObj, nanObj, expObj, floatObj]);
    var intIdentify$1 = (value) => typeof value === "bigint" || Number.isInteger(value);
    var stringifyJSON = ({
      value
    }) => JSON.stringify(value);
    var json3 = [map2, seq2, {
      identify: (value) => typeof value === "string",
      default: true,
      tag: "tag:yaml.org,2002:str",
      resolve: resolveSeq.resolveString,
      stringify: stringifyJSON
    }, {
      identify: (value) => value == null,
      createNode: (schema2, value, ctx) => ctx.wrapScalars ? new resolveSeq.Scalar(null) : null,
      default: true,
      tag: "tag:yaml.org,2002:null",
      test: /^null$/,
      resolve: () => null,
      stringify: stringifyJSON
    }, {
      identify: (value) => typeof value === "boolean",
      default: true,
      tag: "tag:yaml.org,2002:bool",
      test: /^true|false$/,
      resolve: (str2) => str2 === "true",
      stringify: stringifyJSON
    }, {
      identify: intIdentify$1,
      default: true,
      tag: "tag:yaml.org,2002:int",
      test: /^-?(?:0|[1-9][0-9]*)$/,
      resolve: (str2) => resolveSeq.intOptions.asBigInt ? BigInt(str2) : parseInt(str2, 10),
      stringify: ({
        value
      }) => intIdentify$1(value) ? value.toString() : JSON.stringify(value)
    }, {
      identify: (value) => typeof value === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      test: /^-?(?:0|[1-9][0-9]*)(?:\.[0-9]*)?(?:[eE][-+]?[0-9]+)?$/,
      resolve: (str2) => parseFloat(str2),
      stringify: stringifyJSON
    }];
    json3.scalarFallback = (str2) => {
      throw new SyntaxError(`Unresolved plain scalar ${JSON.stringify(str2)}`);
    };
    var boolStringify = ({
      value
    }) => value ? resolveSeq.boolOptions.trueStr : resolveSeq.boolOptions.falseStr;
    var intIdentify = (value) => typeof value === "bigint" || Number.isInteger(value);
    function intResolve(sign, src, radix) {
      let str2 = src.replace(/_/g, "");
      if (resolveSeq.intOptions.asBigInt) {
        switch (radix) {
          case 2:
            str2 = `0b${str2}`;
            break;
          case 8:
            str2 = `0o${str2}`;
            break;
          case 16:
            str2 = `0x${str2}`;
            break;
        }
        const n2 = BigInt(str2);
        return sign === "-" ? BigInt(-1) * n2 : n2;
      }
      const n = parseInt(str2, radix);
      return sign === "-" ? -1 * n : n;
    }
    function intStringify(node2, radix, prefix) {
      const {
        value
      } = node2;
      if (intIdentify(value)) {
        const str2 = value.toString(radix);
        return value < 0 ? "-" + prefix + str2.substr(1) : prefix + str2;
      }
      return resolveSeq.stringifyNumber(node2);
    }
    var yaml11 = failsafe2.concat([{
      identify: (value) => value == null,
      createNode: (schema2, value, ctx) => ctx.wrapScalars ? new resolveSeq.Scalar(null) : null,
      default: true,
      tag: "tag:yaml.org,2002:null",
      test: /^(?:~|[Nn]ull|NULL)?$/,
      resolve: () => null,
      options: resolveSeq.nullOptions,
      stringify: () => resolveSeq.nullOptions.nullStr
    }, {
      identify: (value) => typeof value === "boolean",
      default: true,
      tag: "tag:yaml.org,2002:bool",
      test: /^(?:Y|y|[Yy]es|YES|[Tt]rue|TRUE|[Oo]n|ON)$/,
      resolve: () => true,
      options: resolveSeq.boolOptions,
      stringify: boolStringify
    }, {
      identify: (value) => typeof value === "boolean",
      default: true,
      tag: "tag:yaml.org,2002:bool",
      test: /^(?:N|n|[Nn]o|NO|[Ff]alse|FALSE|[Oo]ff|OFF)$/i,
      resolve: () => false,
      options: resolveSeq.boolOptions,
      stringify: boolStringify
    }, {
      identify: intIdentify,
      default: true,
      tag: "tag:yaml.org,2002:int",
      format: "BIN",
      test: /^([-+]?)0b([0-1_]+)$/,
      resolve: (str2, sign, bin) => intResolve(sign, bin, 2),
      stringify: (node2) => intStringify(node2, 2, "0b")
    }, {
      identify: intIdentify,
      default: true,
      tag: "tag:yaml.org,2002:int",
      format: "OCT",
      test: /^([-+]?)0([0-7_]+)$/,
      resolve: (str2, sign, oct) => intResolve(sign, oct, 8),
      stringify: (node2) => intStringify(node2, 8, "0")
    }, {
      identify: intIdentify,
      default: true,
      tag: "tag:yaml.org,2002:int",
      test: /^([-+]?)([0-9][0-9_]*)$/,
      resolve: (str2, sign, abs) => intResolve(sign, abs, 10),
      stringify: resolveSeq.stringifyNumber
    }, {
      identify: intIdentify,
      default: true,
      tag: "tag:yaml.org,2002:int",
      format: "HEX",
      test: /^([-+]?)0x([0-9a-fA-F_]+)$/,
      resolve: (str2, sign, hex) => intResolve(sign, hex, 16),
      stringify: (node2) => intStringify(node2, 16, "0x")
    }, {
      identify: (value) => typeof value === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      test: /^(?:[-+]?\.inf|(\.nan))$/i,
      resolve: (str2, nan) => nan ? NaN : str2[0] === "-" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY,
      stringify: resolveSeq.stringifyNumber
    }, {
      identify: (value) => typeof value === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      format: "EXP",
      test: /^[-+]?([0-9][0-9_]*)?(\.[0-9_]*)?[eE][-+]?[0-9]+$/,
      resolve: (str2) => parseFloat(str2.replace(/_/g, "")),
      stringify: ({
        value
      }) => Number(value).toExponential()
    }, {
      identify: (value) => typeof value === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      test: /^[-+]?(?:[0-9][0-9_]*)?\.([0-9_]*)$/,
      resolve(str2, frac) {
        const node2 = new resolveSeq.Scalar(parseFloat(str2.replace(/_/g, "")));
        if (frac) {
          const f = frac.replace(/_/g, "");
          if (f[f.length - 1] === "0") node2.minFractionDigits = f.length;
        }
        return node2;
      },
      stringify: resolveSeq.stringifyNumber
    }], warnings.binary, warnings.omap, warnings.pairs, warnings.set, warnings.intTime, warnings.floatTime, warnings.timestamp);
    var schemas = {
      core: core2,
      failsafe: failsafe2,
      json: json3,
      yaml11
    };
    var tags = {
      binary: warnings.binary,
      bool: boolObj,
      float: floatObj,
      floatExp: expObj,
      floatNaN: nanObj,
      floatTime: warnings.floatTime,
      int: intObj,
      intHex: hexObj,
      intOct: octObj,
      intTime: warnings.intTime,
      map: map2,
      null: nullObj,
      omap: warnings.omap,
      pairs: warnings.pairs,
      seq: seq2,
      set: warnings.set,
      timestamp: warnings.timestamp
    };
    function findTagObject(value, tagName, tags2) {
      if (tagName) {
        const match2 = tags2.filter((t) => t.tag === tagName);
        const tagObj = match2.find((t) => !t.format) || match2[0];
        if (!tagObj) throw new Error(`Tag ${tagName} not found`);
        return tagObj;
      }
      return tags2.find((t) => (t.identify && t.identify(value) || t.class && value instanceof t.class) && !t.format);
    }
    function createNode(value, tagName, ctx) {
      if (value instanceof resolveSeq.Node) return value;
      const {
        defaultPrefix,
        onTagObj,
        prevObjects,
        schema: schema2,
        wrapScalars
      } = ctx;
      if (tagName && tagName.startsWith("!!")) tagName = defaultPrefix + tagName.slice(2);
      let tagObj = findTagObject(value, tagName, schema2.tags);
      if (!tagObj) {
        if (typeof value.toJSON === "function") value = value.toJSON();
        if (!value || typeof value !== "object") return wrapScalars ? new resolveSeq.Scalar(value) : value;
        tagObj = value instanceof Map ? map2 : value[Symbol.iterator] ? seq2 : map2;
      }
      if (onTagObj) {
        onTagObj(tagObj);
        delete ctx.onTagObj;
      }
      const obj = {
        value: void 0,
        node: void 0
      };
      if (value && typeof value === "object" && prevObjects) {
        const prev = prevObjects.get(value);
        if (prev) {
          const alias = new resolveSeq.Alias(prev);
          ctx.aliasNodes.push(alias);
          return alias;
        }
        obj.value = value;
        prevObjects.set(value, obj);
      }
      obj.node = tagObj.createNode ? tagObj.createNode(ctx.schema, value, ctx) : wrapScalars ? new resolveSeq.Scalar(value) : value;
      if (tagName && obj.node instanceof resolveSeq.Node) obj.node.tag = tagName;
      return obj.node;
    }
    function getSchemaTags(schemas2, knownTags, customTags, schemaId) {
      let tags2 = schemas2[schemaId.replace(/\W/g, "")];
      if (!tags2) {
        const keys = Object.keys(schemas2).map((key) => JSON.stringify(key)).join(", ");
        throw new Error(`Unknown schema "${schemaId}"; use one of ${keys}`);
      }
      if (Array.isArray(customTags)) {
        for (const tag of customTags) tags2 = tags2.concat(tag);
      } else if (typeof customTags === "function") {
        tags2 = customTags(tags2.slice());
      }
      for (let i = 0; i < tags2.length; ++i) {
        const tag = tags2[i];
        if (typeof tag === "string") {
          const tagObj = knownTags[tag];
          if (!tagObj) {
            const keys = Object.keys(knownTags).map((key) => JSON.stringify(key)).join(", ");
            throw new Error(`Unknown custom tag "${tag}"; use one of ${keys}`);
          }
          tags2[i] = tagObj;
        }
      }
      return tags2;
    }
    var sortMapEntriesByKey = (a, b) => a.key < b.key ? -1 : a.key > b.key ? 1 : 0;
    var Schema2 = class _Schema {
      // TODO: remove in v2
      // TODO: remove in v2
      constructor({
        customTags,
        merge: merge2,
        schema: schema2,
        sortMapEntries,
        tags: deprecatedCustomTags
      }) {
        this.merge = !!merge2;
        this.name = schema2;
        this.sortMapEntries = sortMapEntries === true ? sortMapEntriesByKey : sortMapEntries || null;
        if (!customTags && deprecatedCustomTags) warnings.warnOptionDeprecation("tags", "customTags");
        this.tags = getSchemaTags(schemas, tags, customTags || deprecatedCustomTags, schema2);
      }
      createNode(value, wrapScalars, tagName, ctx) {
        const baseCtx = {
          defaultPrefix: _Schema.defaultPrefix,
          schema: this,
          wrapScalars
        };
        const createCtx = ctx ? Object.assign(ctx, baseCtx) : baseCtx;
        return createNode(value, tagName, createCtx);
      }
      createPair(key, value, ctx) {
        if (!ctx) ctx = {
          wrapScalars: true
        };
        const k = this.createNode(key, ctx.wrapScalars, null, ctx);
        const v = this.createNode(value, ctx.wrapScalars, null, ctx);
        return new resolveSeq.Pair(k, v);
      }
    };
    PlainValue._defineProperty(Schema2, "defaultPrefix", PlainValue.defaultTagPrefix);
    PlainValue._defineProperty(Schema2, "defaultTags", PlainValue.defaultTags);
    exports2.Schema = Schema2;
  }
});

// node_modules/oas-resolver/node_modules/yaml/dist/Document-9b4560a1.js
var require_Document_9b4560a12 = __commonJS({
  "node_modules/oas-resolver/node_modules/yaml/dist/Document-9b4560a1.js"(exports2) {
    "use strict";
    var PlainValue = require_PlainValue_ec8e588e2();
    var resolveSeq = require_resolveSeq_d03cb0372();
    var Schema2 = require_Schema_88e323a72();
    var defaultOptions = {
      anchorPrefix: "a",
      customTags: null,
      indent: 2,
      indentSeq: true,
      keepCstNodes: false,
      keepNodeTypes: true,
      keepBlobsInJSON: true,
      mapAsMap: false,
      maxAliasCount: 100,
      prettyErrors: false,
      // TODO Set true in v2
      simpleKeys: false,
      version: "1.2"
    };
    var scalarOptions = {
      get binary() {
        return resolveSeq.binaryOptions;
      },
      set binary(opt) {
        Object.assign(resolveSeq.binaryOptions, opt);
      },
      get bool() {
        return resolveSeq.boolOptions;
      },
      set bool(opt) {
        Object.assign(resolveSeq.boolOptions, opt);
      },
      get int() {
        return resolveSeq.intOptions;
      },
      set int(opt) {
        Object.assign(resolveSeq.intOptions, opt);
      },
      get null() {
        return resolveSeq.nullOptions;
      },
      set null(opt) {
        Object.assign(resolveSeq.nullOptions, opt);
      },
      get str() {
        return resolveSeq.strOptions;
      },
      set str(opt) {
        Object.assign(resolveSeq.strOptions, opt);
      }
    };
    var documentOptions = {
      "1.0": {
        schema: "yaml-1.1",
        merge: true,
        tagPrefixes: [{
          handle: "!",
          prefix: PlainValue.defaultTagPrefix
        }, {
          handle: "!!",
          prefix: "tag:private.yaml.org,2002:"
        }]
      },
      1.1: {
        schema: "yaml-1.1",
        merge: true,
        tagPrefixes: [{
          handle: "!",
          prefix: "!"
        }, {
          handle: "!!",
          prefix: PlainValue.defaultTagPrefix
        }]
      },
      1.2: {
        schema: "core",
        merge: false,
        tagPrefixes: [{
          handle: "!",
          prefix: "!"
        }, {
          handle: "!!",
          prefix: PlainValue.defaultTagPrefix
        }]
      }
    };
    function stringifyTag(doc, tag) {
      if ((doc.version || doc.options.version) === "1.0") {
        const priv = tag.match(/^tag:private\.yaml\.org,2002:([^:/]+)$/);
        if (priv) return "!" + priv[1];
        const vocab = tag.match(/^tag:([a-zA-Z0-9-]+)\.yaml\.org,2002:(.*)/);
        return vocab ? `!${vocab[1]}/${vocab[2]}` : `!${tag.replace(/^tag:/, "")}`;
      }
      let p = doc.tagPrefixes.find((p2) => tag.indexOf(p2.prefix) === 0);
      if (!p) {
        const dtp = doc.getDefaults().tagPrefixes;
        p = dtp && dtp.find((p2) => tag.indexOf(p2.prefix) === 0);
      }
      if (!p) return tag[0] === "!" ? tag : `!<${tag}>`;
      const suffix = tag.substr(p.prefix.length).replace(/[!,[\]{}]/g, (ch) => ({
        "!": "%21",
        ",": "%2C",
        "[": "%5B",
        "]": "%5D",
        "{": "%7B",
        "}": "%7D"
      })[ch]);
      return p.handle + suffix;
    }
    function getTagObject(tags, item) {
      if (item instanceof resolveSeq.Alias) return resolveSeq.Alias;
      if (item.tag) {
        const match2 = tags.filter((t) => t.tag === item.tag);
        if (match2.length > 0) return match2.find((t) => t.format === item.format) || match2[0];
      }
      let tagObj, obj;
      if (item instanceof resolveSeq.Scalar) {
        obj = item.value;
        const match2 = tags.filter((t) => t.identify && t.identify(obj) || t.class && obj instanceof t.class);
        tagObj = match2.find((t) => t.format === item.format) || match2.find((t) => !t.format);
      } else {
        obj = item;
        tagObj = tags.find((t) => t.nodeClass && obj instanceof t.nodeClass);
      }
      if (!tagObj) {
        const name = obj && obj.constructor ? obj.constructor.name : typeof obj;
        throw new Error(`Tag not resolved for ${name} value`);
      }
      return tagObj;
    }
    function stringifyProps(node2, tagObj, {
      anchors,
      doc
    }) {
      const props = [];
      const anchor = doc.anchors.getName(node2);
      if (anchor) {
        anchors[anchor] = node2;
        props.push(`&${anchor}`);
      }
      if (node2.tag) {
        props.push(stringifyTag(doc, node2.tag));
      } else if (!tagObj.default) {
        props.push(stringifyTag(doc, tagObj.tag));
      }
      return props.join(" ");
    }
    function stringify3(item, ctx, onComment, onChompKeep) {
      const {
        anchors,
        schema: schema2
      } = ctx.doc;
      let tagObj;
      if (!(item instanceof resolveSeq.Node)) {
        const createCtx = {
          aliasNodes: [],
          onTagObj: (o) => tagObj = o,
          prevObjects: /* @__PURE__ */ new Map()
        };
        item = schema2.createNode(item, true, null, createCtx);
        for (const alias of createCtx.aliasNodes) {
          alias.source = alias.source.node;
          let name = anchors.getName(alias.source);
          if (!name) {
            name = anchors.newName();
            anchors.map[name] = alias.source;
          }
        }
      }
      if (item instanceof resolveSeq.Pair) return item.toString(ctx, onComment, onChompKeep);
      if (!tagObj) tagObj = getTagObject(schema2.tags, item);
      const props = stringifyProps(item, tagObj, ctx);
      if (props.length > 0) ctx.indentAtStart = (ctx.indentAtStart || 0) + props.length + 1;
      const str2 = typeof tagObj.stringify === "function" ? tagObj.stringify(item, ctx, onComment, onChompKeep) : item instanceof resolveSeq.Scalar ? resolveSeq.stringifyString(item, ctx, onComment, onChompKeep) : item.toString(ctx, onComment, onChompKeep);
      if (!props) return str2;
      return item instanceof resolveSeq.Scalar || str2[0] === "{" || str2[0] === "[" ? `${props} ${str2}` : `${props}
${ctx.indent}${str2}`;
    }
    var Anchors = class _Anchors {
      static validAnchorNode(node2) {
        return node2 instanceof resolveSeq.Scalar || node2 instanceof resolveSeq.YAMLSeq || node2 instanceof resolveSeq.YAMLMap;
      }
      constructor(prefix) {
        PlainValue._defineProperty(this, "map", /* @__PURE__ */ Object.create(null));
        this.prefix = prefix;
      }
      createAlias(node2, name) {
        this.setAnchor(node2, name);
        return new resolveSeq.Alias(node2);
      }
      createMergePair(...sources) {
        const merge2 = new resolveSeq.Merge();
        merge2.value.items = sources.map((s) => {
          if (s instanceof resolveSeq.Alias) {
            if (s.source instanceof resolveSeq.YAMLMap) return s;
          } else if (s instanceof resolveSeq.YAMLMap) {
            return this.createAlias(s);
          }
          throw new Error("Merge sources must be Map nodes or their Aliases");
        });
        return merge2;
      }
      getName(node2) {
        const {
          map: map2
        } = this;
        return Object.keys(map2).find((a) => map2[a] === node2);
      }
      getNames() {
        return Object.keys(this.map);
      }
      getNode(name) {
        return this.map[name];
      }
      newName(prefix) {
        if (!prefix) prefix = this.prefix;
        const names = Object.keys(this.map);
        for (let i = 1; true; ++i) {
          const name = `${prefix}${i}`;
          if (!names.includes(name)) return name;
        }
      }
      // During parsing, map & aliases contain CST nodes
      resolveNodes() {
        const {
          map: map2,
          _cstAliases
        } = this;
        Object.keys(map2).forEach((a) => {
          map2[a] = map2[a].resolved;
        });
        _cstAliases.forEach((a) => {
          a.source = a.source.resolved;
        });
        delete this._cstAliases;
      }
      setAnchor(node2, name) {
        if (node2 != null && !_Anchors.validAnchorNode(node2)) {
          throw new Error("Anchors may only be set for Scalar, Seq and Map nodes");
        }
        if (name && /[\x00-\x19\s,[\]{}]/.test(name)) {
          throw new Error("Anchor names must not contain whitespace or control characters");
        }
        const {
          map: map2
        } = this;
        const prev = node2 && Object.keys(map2).find((a) => map2[a] === node2);
        if (prev) {
          if (!name) {
            return prev;
          } else if (prev !== name) {
            delete map2[prev];
            map2[name] = node2;
          }
        } else {
          if (!name) {
            if (!node2) return null;
            name = this.newName();
          }
          map2[name] = node2;
        }
        return name;
      }
    };
    var visit3 = (node2, tags) => {
      if (node2 && typeof node2 === "object") {
        const {
          tag
        } = node2;
        if (node2 instanceof resolveSeq.Collection) {
          if (tag) tags[tag] = true;
          node2.items.forEach((n) => visit3(n, tags));
        } else if (node2 instanceof resolveSeq.Pair) {
          visit3(node2.key, tags);
          visit3(node2.value, tags);
        } else if (node2 instanceof resolveSeq.Scalar) {
          if (tag) tags[tag] = true;
        }
      }
      return tags;
    };
    var listTagNames = (node2) => Object.keys(visit3(node2, {}));
    function parseContents(doc, contents) {
      const comments = {
        before: [],
        after: []
      };
      let body = void 0;
      let spaceBefore = false;
      for (const node2 of contents) {
        if (node2.valueRange) {
          if (body !== void 0) {
            const msg = "Document contains trailing content not separated by a ... or --- line";
            doc.errors.push(new PlainValue.YAMLSyntaxError(node2, msg));
            break;
          }
          const res = resolveSeq.resolveNode(doc, node2);
          if (spaceBefore) {
            res.spaceBefore = true;
            spaceBefore = false;
          }
          body = res;
        } else if (node2.comment !== null) {
          const cc = body === void 0 ? comments.before : comments.after;
          cc.push(node2.comment);
        } else if (node2.type === PlainValue.Type.BLANK_LINE) {
          spaceBefore = true;
          if (body === void 0 && comments.before.length > 0 && !doc.commentBefore) {
            doc.commentBefore = comments.before.join("\n");
            comments.before = [];
          }
        }
      }
      doc.contents = body || null;
      if (!body) {
        doc.comment = comments.before.concat(comments.after).join("\n") || null;
      } else {
        const cb = comments.before.join("\n");
        if (cb) {
          const cbNode = body instanceof resolveSeq.Collection && body.items[0] ? body.items[0] : body;
          cbNode.commentBefore = cbNode.commentBefore ? `${cb}
${cbNode.commentBefore}` : cb;
        }
        doc.comment = comments.after.join("\n") || null;
      }
    }
    function resolveTagDirective({
      tagPrefixes
    }, directive) {
      const [handle, prefix] = directive.parameters;
      if (!handle || !prefix) {
        const msg = "Insufficient parameters given for %TAG directive";
        throw new PlainValue.YAMLSemanticError(directive, msg);
      }
      if (tagPrefixes.some((p) => p.handle === handle)) {
        const msg = "The %TAG directive must only be given at most once per handle in the same document.";
        throw new PlainValue.YAMLSemanticError(directive, msg);
      }
      return {
        handle,
        prefix
      };
    }
    function resolveYamlDirective(doc, directive) {
      let [version] = directive.parameters;
      if (directive.name === "YAML:1.0") version = "1.0";
      if (!version) {
        const msg = "Insufficient parameters given for %YAML directive";
        throw new PlainValue.YAMLSemanticError(directive, msg);
      }
      if (!documentOptions[version]) {
        const v0 = doc.version || doc.options.version;
        const msg = `Document will be parsed as YAML ${v0} rather than YAML ${version}`;
        doc.warnings.push(new PlainValue.YAMLWarning(directive, msg));
      }
      return version;
    }
    function parseDirectives(doc, directives, prevDoc) {
      const directiveComments = [];
      let hasDirectives = false;
      for (const directive of directives) {
        const {
          comment,
          name
        } = directive;
        switch (name) {
          case "TAG":
            try {
              doc.tagPrefixes.push(resolveTagDirective(doc, directive));
            } catch (error) {
              doc.errors.push(error);
            }
            hasDirectives = true;
            break;
          case "YAML":
          case "YAML:1.0":
            if (doc.version) {
              const msg = "The %YAML directive must only be given at most once per document.";
              doc.errors.push(new PlainValue.YAMLSemanticError(directive, msg));
            }
            try {
              doc.version = resolveYamlDirective(doc, directive);
            } catch (error) {
              doc.errors.push(error);
            }
            hasDirectives = true;
            break;
          default:
            if (name) {
              const msg = `YAML only supports %TAG and %YAML directives, and not %${name}`;
              doc.warnings.push(new PlainValue.YAMLWarning(directive, msg));
            }
        }
        if (comment) directiveComments.push(comment);
      }
      if (prevDoc && !hasDirectives && "1.1" === (doc.version || prevDoc.version || doc.options.version)) {
        const copyTagPrefix = ({
          handle,
          prefix
        }) => ({
          handle,
          prefix
        });
        doc.tagPrefixes = prevDoc.tagPrefixes.map(copyTagPrefix);
        doc.version = prevDoc.version;
      }
      doc.commentBefore = directiveComments.join("\n") || null;
    }
    function assertCollection(contents) {
      if (contents instanceof resolveSeq.Collection) return true;
      throw new Error("Expected a YAML collection as document contents");
    }
    var Document = class _Document {
      constructor(options) {
        this.anchors = new Anchors(options.anchorPrefix);
        this.commentBefore = null;
        this.comment = null;
        this.contents = null;
        this.directivesEndMarker = null;
        this.errors = [];
        this.options = options;
        this.schema = null;
        this.tagPrefixes = [];
        this.version = null;
        this.warnings = [];
      }
      add(value) {
        assertCollection(this.contents);
        return this.contents.add(value);
      }
      addIn(path, value) {
        assertCollection(this.contents);
        this.contents.addIn(path, value);
      }
      delete(key) {
        assertCollection(this.contents);
        return this.contents.delete(key);
      }
      deleteIn(path) {
        if (resolveSeq.isEmptyPath(path)) {
          if (this.contents == null) return false;
          this.contents = null;
          return true;
        }
        assertCollection(this.contents);
        return this.contents.deleteIn(path);
      }
      getDefaults() {
        return _Document.defaults[this.version] || _Document.defaults[this.options.version] || {};
      }
      get(key, keepScalar) {
        return this.contents instanceof resolveSeq.Collection ? this.contents.get(key, keepScalar) : void 0;
      }
      getIn(path, keepScalar) {
        if (resolveSeq.isEmptyPath(path)) return !keepScalar && this.contents instanceof resolveSeq.Scalar ? this.contents.value : this.contents;
        return this.contents instanceof resolveSeq.Collection ? this.contents.getIn(path, keepScalar) : void 0;
      }
      has(key) {
        return this.contents instanceof resolveSeq.Collection ? this.contents.has(key) : false;
      }
      hasIn(path) {
        if (resolveSeq.isEmptyPath(path)) return this.contents !== void 0;
        return this.contents instanceof resolveSeq.Collection ? this.contents.hasIn(path) : false;
      }
      set(key, value) {
        assertCollection(this.contents);
        this.contents.set(key, value);
      }
      setIn(path, value) {
        if (resolveSeq.isEmptyPath(path)) this.contents = value;
        else {
          assertCollection(this.contents);
          this.contents.setIn(path, value);
        }
      }
      setSchema(id, customTags) {
        if (!id && !customTags && this.schema) return;
        if (typeof id === "number") id = id.toFixed(1);
        if (id === "1.0" || id === "1.1" || id === "1.2") {
          if (this.version) this.version = id;
          else this.options.version = id;
          delete this.options.schema;
        } else if (id && typeof id === "string") {
          this.options.schema = id;
        }
        if (Array.isArray(customTags)) this.options.customTags = customTags;
        const opt = Object.assign({}, this.getDefaults(), this.options);
        this.schema = new Schema2.Schema(opt);
      }
      parse(node2, prevDoc) {
        if (this.options.keepCstNodes) this.cstNode = node2;
        if (this.options.keepNodeTypes) this.type = "DOCUMENT";
        const {
          directives = [],
          contents = [],
          directivesEndMarker,
          error,
          valueRange
        } = node2;
        if (error) {
          if (!error.source) error.source = this;
          this.errors.push(error);
        }
        parseDirectives(this, directives, prevDoc);
        if (directivesEndMarker) this.directivesEndMarker = true;
        this.range = valueRange ? [valueRange.start, valueRange.end] : null;
        this.setSchema();
        this.anchors._cstAliases = [];
        parseContents(this, contents);
        this.anchors.resolveNodes();
        if (this.options.prettyErrors) {
          for (const error2 of this.errors) if (error2 instanceof PlainValue.YAMLError) error2.makePretty();
          for (const warn of this.warnings) if (warn instanceof PlainValue.YAMLError) warn.makePretty();
        }
        return this;
      }
      listNonDefaultTags() {
        return listTagNames(this.contents).filter((t) => t.indexOf(Schema2.Schema.defaultPrefix) !== 0);
      }
      setTagPrefix(handle, prefix) {
        if (handle[0] !== "!" || handle[handle.length - 1] !== "!") throw new Error("Handle must start and end with !");
        if (prefix) {
          const prev = this.tagPrefixes.find((p) => p.handle === handle);
          if (prev) prev.prefix = prefix;
          else this.tagPrefixes.push({
            handle,
            prefix
          });
        } else {
          this.tagPrefixes = this.tagPrefixes.filter((p) => p.handle !== handle);
        }
      }
      toJSON(arg, onAnchor) {
        const {
          keepBlobsInJSON,
          mapAsMap,
          maxAliasCount
        } = this.options;
        const keep = keepBlobsInJSON && (typeof arg !== "string" || !(this.contents instanceof resolveSeq.Scalar));
        const ctx = {
          doc: this,
          indentStep: "  ",
          keep,
          mapAsMap: keep && !!mapAsMap,
          maxAliasCount,
          stringify: stringify3
          // Requiring directly in Pair would create circular dependencies
        };
        const anchorNames = Object.keys(this.anchors.map);
        if (anchorNames.length > 0) ctx.anchors = new Map(anchorNames.map((name) => [this.anchors.map[name], {
          alias: [],
          aliasCount: 0,
          count: 1
        }]));
        const res = resolveSeq.toJSON(this.contents, arg, ctx);
        if (typeof onAnchor === "function" && ctx.anchors) for (const {
          count,
          res: res2
        } of ctx.anchors.values()) onAnchor(res2, count);
        return res;
      }
      toString() {
        if (this.errors.length > 0) throw new Error("Document with errors cannot be stringified");
        const indentSize = this.options.indent;
        if (!Number.isInteger(indentSize) || indentSize <= 0) {
          const s = JSON.stringify(indentSize);
          throw new Error(`"indent" option must be a positive integer, not ${s}`);
        }
        this.setSchema();
        const lines = [];
        let hasDirectives = false;
        if (this.version) {
          let vd = "%YAML 1.2";
          if (this.schema.name === "yaml-1.1") {
            if (this.version === "1.0") vd = "%YAML:1.0";
            else if (this.version === "1.1") vd = "%YAML 1.1";
          }
          lines.push(vd);
          hasDirectives = true;
        }
        const tagNames = this.listNonDefaultTags();
        this.tagPrefixes.forEach(({
          handle,
          prefix
        }) => {
          if (tagNames.some((t) => t.indexOf(prefix) === 0)) {
            lines.push(`%TAG ${handle} ${prefix}`);
            hasDirectives = true;
          }
        });
        if (hasDirectives || this.directivesEndMarker) lines.push("---");
        if (this.commentBefore) {
          if (hasDirectives || !this.directivesEndMarker) lines.unshift("");
          lines.unshift(this.commentBefore.replace(/^/gm, "#"));
        }
        const ctx = {
          anchors: /* @__PURE__ */ Object.create(null),
          doc: this,
          indent: "",
          indentStep: " ".repeat(indentSize),
          stringify: stringify3
          // Requiring directly in nodes would create circular dependencies
        };
        let chompKeep = false;
        let contentComment = null;
        if (this.contents) {
          if (this.contents instanceof resolveSeq.Node) {
            if (this.contents.spaceBefore && (hasDirectives || this.directivesEndMarker)) lines.push("");
            if (this.contents.commentBefore) lines.push(this.contents.commentBefore.replace(/^/gm, "#"));
            ctx.forceBlockIndent = !!this.comment;
            contentComment = this.contents.comment;
          }
          const onChompKeep = contentComment ? null : () => chompKeep = true;
          const body = stringify3(this.contents, ctx, () => contentComment = null, onChompKeep);
          lines.push(resolveSeq.addComment(body, "", contentComment));
        } else if (this.contents !== void 0) {
          lines.push(stringify3(this.contents, ctx));
        }
        if (this.comment) {
          if ((!chompKeep || contentComment) && lines[lines.length - 1] !== "") lines.push("");
          lines.push(this.comment.replace(/^/gm, "#"));
        }
        return lines.join("\n") + "\n";
      }
    };
    PlainValue._defineProperty(Document, "defaults", documentOptions);
    exports2.Document = Document;
    exports2.defaultOptions = defaultOptions;
    exports2.scalarOptions = scalarOptions;
  }
});

// node_modules/oas-resolver/node_modules/yaml/dist/index.js
var require_dist5 = __commonJS({
  "node_modules/oas-resolver/node_modules/yaml/dist/index.js"(exports2) {
    "use strict";
    var parseCst = require_parse_cst2();
    var Document$1 = require_Document_9b4560a12();
    var Schema2 = require_Schema_88e323a72();
    var PlainValue = require_PlainValue_ec8e588e2();
    var warnings = require_warnings_1000a3722();
    require_resolveSeq_d03cb0372();
    function createNode(value, wrapScalars = true, tag) {
      if (tag === void 0 && typeof wrapScalars === "string") {
        tag = wrapScalars;
        wrapScalars = true;
      }
      const options = Object.assign({}, Document$1.Document.defaults[Document$1.defaultOptions.version], Document$1.defaultOptions);
      const schema2 = new Schema2.Schema(options);
      return schema2.createNode(value, wrapScalars, tag);
    }
    var Document = class extends Document$1.Document {
      constructor(options) {
        super(Object.assign({}, Document$1.defaultOptions, options));
      }
    };
    function parseAllDocuments(src, options) {
      const stream = [];
      let prev;
      for (const cstDoc of parseCst.parse(src)) {
        const doc = new Document(options);
        doc.parse(cstDoc, prev);
        stream.push(doc);
        prev = doc;
      }
      return stream;
    }
    function parseDocument(src, options) {
      const cst = parseCst.parse(src);
      const doc = new Document(options).parse(cst[0]);
      if (cst.length > 1) {
        const errMsg = "Source contains multiple documents; please use YAML.parseAllDocuments()";
        doc.errors.unshift(new PlainValue.YAMLSemanticError(cst[1], errMsg));
      }
      return doc;
    }
    function parse6(src, options) {
      const doc = parseDocument(src, options);
      doc.warnings.forEach((warning) => warnings.warn(warning));
      if (doc.errors.length > 0) throw doc.errors[0];
      return doc.toJSON();
    }
    function stringify3(value, options) {
      const doc = new Document(options);
      doc.contents = value;
      return String(doc);
    }
    var YAML = {
      createNode,
      defaultOptions: Document$1.defaultOptions,
      Document,
      parse: parse6,
      parseAllDocuments,
      parseCST: parseCst.parse,
      parseDocument,
      scalarOptions: Document$1.scalarOptions,
      stringify: stringify3
    };
    exports2.YAML = YAML;
  }
});

// node_modules/oas-resolver/node_modules/yaml/index.js
var require_yaml3 = __commonJS({
  "node_modules/oas-resolver/node_modules/yaml/index.js"(exports2, module2) {
    module2.exports = require_dist5().YAML;
  }
});

// node_modules/reftools/lib/dereference.js
var require_dereference2 = __commonJS({
  "node_modules/reftools/lib/dereference.js"(exports2, module2) {
    "use strict";
    var recurse = require_recurse().recurse;
    var clone2 = require_clone().shallowClone;
    var jptr = require_jptr().jptr;
    var isRef2 = require_isref().isRef;
    var getLogger = function(options) {
      if (options && options.verbose) {
        return {
          warn: function() {
            var args = Array.prototype.slice.call(arguments);
            console.warn.apply(console, args);
          }
        };
      } else {
        return {
          warn: function() {
          }
        };
      }
    };
    function dereference(o, definitions, options) {
      if (!options) options = {};
      if (!options.cache) options.cache = {};
      if (!options.state) options.state = {};
      options.state.identityDetection = true;
      options.depth = options.depth ? options.depth + 1 : 1;
      let obj = options.depth > 1 ? o : clone2(o);
      let container = { data: obj };
      let defs = options.depth > 1 ? definitions : clone2(definitions);
      if (!options.master) options.master = obj;
      let logger = getLogger(options);
      let changes = 1;
      while (changes > 0) {
        changes = 0;
        recurse(container, options.state, function(obj2, key, state) {
          if (isRef2(obj2, key)) {
            let $ref = obj2[key];
            changes++;
            if (!options.cache[$ref]) {
              let entry = {};
              entry.path = state.path.split("/$ref")[0];
              entry.key = $ref;
              logger.warn("Dereffing %s at %s", $ref, entry.path);
              entry.source = defs;
              entry.data = jptr(entry.source, entry.key);
              if (entry.data === false) {
                entry.data = jptr(options.master, entry.key);
                entry.source = options.master;
              }
              if (entry.data === false) {
                logger.warn("Missing $ref target", entry.key);
              }
              options.cache[$ref] = entry;
              entry.data = state.parent[state.pkey] = dereference(jptr(entry.source, entry.key), entry.source, options);
              if (options.$ref && typeof state.parent[state.pkey] === "object" && state.parent[state.pkey] !== null) state.parent[state.pkey][options.$ref] = $ref;
              entry.resolved = true;
            } else {
              let entry = options.cache[$ref];
              if (entry.resolved) {
                logger.warn("Patching %s for %s", $ref, entry.path);
                state.parent[state.pkey] = entry.data;
                if (options.$ref && typeof state.parent[state.pkey] === "object" && state.parent[state.pkey] !== null) state.parent[state.pkey][options.$ref] = $ref;
              } else if ($ref === entry.path) {
                throw new Error(`Tight circle at ${entry.path}`);
              } else {
                logger.warn("Unresolved ref");
                state.parent[state.pkey] = jptr(entry.source, entry.path);
                if (state.parent[state.pkey] === false) {
                  state.parent[state.pkey] = jptr(entry.source, entry.key);
                }
                if (options.$ref && typeof state.parent[state.pkey] === "object" && state.parent[state.pkey] !== null) state.parent[options.$ref] = $ref;
              }
            }
          }
        });
      }
      return container.data;
    }
    module2.exports = {
      dereference
    };
  }
});

// node_modules/fast-safe-stringify/index.js
var require_fast_safe_stringify = __commonJS({
  "node_modules/fast-safe-stringify/index.js"(exports2, module2) {
    module2.exports = stringify3;
    stringify3.default = stringify3;
    stringify3.stable = deterministicStringify;
    stringify3.stableStringify = deterministicStringify;
    var LIMIT_REPLACE_NODE = "[...]";
    var CIRCULAR_REPLACE_NODE = "[Circular]";
    var arr = [];
    var replacerStack = [];
    function defaultOptions() {
      return {
        depthLimit: Number.MAX_SAFE_INTEGER,
        edgesLimit: Number.MAX_SAFE_INTEGER
      };
    }
    function stringify3(obj, replacer, spacer, options) {
      if (typeof options === "undefined") {
        options = defaultOptions();
      }
      decirc(obj, "", 0, [], void 0, 0, options);
      var res;
      try {
        if (replacerStack.length === 0) {
          res = JSON.stringify(obj, replacer, spacer);
        } else {
          res = JSON.stringify(obj, replaceGetterValues(replacer), spacer);
        }
      } catch (_) {
        return JSON.stringify("[unable to serialize, circular reference is too complex to analyze]");
      } finally {
        while (arr.length !== 0) {
          var part = arr.pop();
          if (part.length === 4) {
            Object.defineProperty(part[0], part[1], part[3]);
          } else {
            part[0][part[1]] = part[2];
          }
        }
      }
      return res;
    }
    function setReplace(replace, val, k, parent) {
      var propertyDescriptor = Object.getOwnPropertyDescriptor(parent, k);
      if (propertyDescriptor.get !== void 0) {
        if (propertyDescriptor.configurable) {
          Object.defineProperty(parent, k, { value: replace });
          arr.push([parent, k, val, propertyDescriptor]);
        } else {
          replacerStack.push([val, k, replace]);
        }
      } else {
        parent[k] = replace;
        arr.push([parent, k, val]);
      }
    }
    function decirc(val, k, edgeIndex, stack, parent, depth, options) {
      depth += 1;
      var i;
      if (typeof val === "object" && val !== null) {
        for (i = 0; i < stack.length; i++) {
          if (stack[i] === val) {
            setReplace(CIRCULAR_REPLACE_NODE, val, k, parent);
            return;
          }
        }
        if (typeof options.depthLimit !== "undefined" && depth > options.depthLimit) {
          setReplace(LIMIT_REPLACE_NODE, val, k, parent);
          return;
        }
        if (typeof options.edgesLimit !== "undefined" && edgeIndex + 1 > options.edgesLimit) {
          setReplace(LIMIT_REPLACE_NODE, val, k, parent);
          return;
        }
        stack.push(val);
        if (Array.isArray(val)) {
          for (i = 0; i < val.length; i++) {
            decirc(val[i], i, i, stack, val, depth, options);
          }
        } else {
          var keys = Object.keys(val);
          for (i = 0; i < keys.length; i++) {
            var key = keys[i];
            decirc(val[key], key, i, stack, val, depth, options);
          }
        }
        stack.pop();
      }
    }
    function compareFunction(a, b) {
      if (a < b) {
        return -1;
      }
      if (a > b) {
        return 1;
      }
      return 0;
    }
    function deterministicStringify(obj, replacer, spacer, options) {
      if (typeof options === "undefined") {
        options = defaultOptions();
      }
      var tmp = deterministicDecirc(obj, "", 0, [], void 0, 0, options) || obj;
      var res;
      try {
        if (replacerStack.length === 0) {
          res = JSON.stringify(tmp, replacer, spacer);
        } else {
          res = JSON.stringify(tmp, replaceGetterValues(replacer), spacer);
        }
      } catch (_) {
        return JSON.stringify("[unable to serialize, circular reference is too complex to analyze]");
      } finally {
        while (arr.length !== 0) {
          var part = arr.pop();
          if (part.length === 4) {
            Object.defineProperty(part[0], part[1], part[3]);
          } else {
            part[0][part[1]] = part[2];
          }
        }
      }
      return res;
    }
    function deterministicDecirc(val, k, edgeIndex, stack, parent, depth, options) {
      depth += 1;
      var i;
      if (typeof val === "object" && val !== null) {
        for (i = 0; i < stack.length; i++) {
          if (stack[i] === val) {
            setReplace(CIRCULAR_REPLACE_NODE, val, k, parent);
            return;
          }
        }
        try {
          if (typeof val.toJSON === "function") {
            return;
          }
        } catch (_) {
          return;
        }
        if (typeof options.depthLimit !== "undefined" && depth > options.depthLimit) {
          setReplace(LIMIT_REPLACE_NODE, val, k, parent);
          return;
        }
        if (typeof options.edgesLimit !== "undefined" && edgeIndex + 1 > options.edgesLimit) {
          setReplace(LIMIT_REPLACE_NODE, val, k, parent);
          return;
        }
        stack.push(val);
        if (Array.isArray(val)) {
          for (i = 0; i < val.length; i++) {
            deterministicDecirc(val[i], i, i, stack, val, depth, options);
          }
        } else {
          var tmp = {};
          var keys = Object.keys(val).sort(compareFunction);
          for (i = 0; i < keys.length; i++) {
            var key = keys[i];
            deterministicDecirc(val[key], key, i, stack, val, depth, options);
            tmp[key] = val[key];
          }
          if (typeof parent !== "undefined") {
            arr.push([parent, k, val]);
            parent[k] = tmp;
          } else {
            return tmp;
          }
        }
        stack.pop();
      }
    }
    function replaceGetterValues(replacer) {
      replacer = typeof replacer !== "undefined" ? replacer : function(k, v) {
        return v;
      };
      return function(key, val) {
        if (replacerStack.length > 0) {
          for (var i = 0; i < replacerStack.length; i++) {
            var part = replacerStack[i];
            if (part[1] === key && part[0] === val) {
              val = part[2];
              replacerStack.splice(i, 1);
              break;
            }
          }
        }
        return replacer.call(this, key, val);
      };
    }
  }
});

// node_modules/oas-kit-common/index.js
var require_oas_kit_common = __commonJS({
  "node_modules/oas-kit-common/index.js"(exports2, module2) {
    "use strict";
    var sjs = require_fast_safe_stringify();
    var colour = process.env.NODE_DISABLE_COLORS ? { red: "", yellow: "", green: "", normal: "" } : { red: "\x1B[31m", yellow: "\x1B[33;1m", green: "\x1B[32m", normal: "\x1B[0m" };
    function uniqueOnly(value, index, self2) {
      return self2.indexOf(value) === index;
    }
    function hasDuplicates(array) {
      return new Set(array).size !== array.length;
    }
    function allSame(array) {
      return new Set(array).size <= 1;
    }
    function deepEquals(obj1, obj2) {
      function _equals(obj12, obj22) {
        return sjs.stringify(obj12) === sjs.stringify(Object.assign({}, obj12, obj22));
      }
      return _equals(obj1, obj2) && _equals(obj2, obj1);
    }
    function compressArray(arr) {
      let result = [];
      for (let candidate of arr) {
        let dupe = result.find(function(e, i, a) {
          return deepEquals(e, candidate);
        });
        if (!dupe) result.push(candidate);
      }
      return result;
    }
    function distinctArray(arr) {
      return arr.length === compressArray(arr).length;
    }
    function firstDupe(arr) {
      return arr.find(function(e, i, a) {
        return arr.indexOf(e) < i;
      });
    }
    function hash(s) {
      let hash2 = 0;
      let chr;
      if (s.length === 0) return hash2;
      for (let i = 0; i < s.length; i++) {
        chr = s.charCodeAt(i);
        hash2 = (hash2 << 5) - hash2 + chr;
        hash2 |= 0;
      }
      return hash2;
    }
    String.prototype.toCamelCase = function camelize() {
      return this.toLowerCase().replace(/[-_ \/\.](.)/g, function(match2, group1) {
        return group1.toUpperCase();
      });
    };
    var parameterTypeProperties = [
      "format",
      "minimum",
      "maximum",
      "exclusiveMinimum",
      "exclusiveMaximum",
      "minLength",
      "maxLength",
      "multipleOf",
      "minItems",
      "maxItems",
      "uniqueItems",
      "minProperties",
      "maxProperties",
      "additionalProperties",
      "pattern",
      "enum",
      "default"
    ];
    var arrayProperties = [
      "items",
      "minItems",
      "maxItems",
      "uniqueItems"
    ];
    var httpMethods = [
      "get",
      "post",
      "put",
      "delete",
      "patch",
      "head",
      "options",
      "trace"
    ];
    function sanitise(s) {
      s = s.replace("[]", "Array");
      let components = s.split("/");
      components[0] = components[0].replace(/[^A-Za-z0-9_\-\.]+|\s+/gm, "_");
      return components.join("/");
    }
    function sanitiseAll(s) {
      return sanitise(s.split("/").join("_"));
    }
    module2.exports = {
      colour,
      uniqueOnly,
      hasDuplicates,
      allSame,
      distinctArray,
      firstDupe,
      hash,
      parameterTypeProperties,
      arrayProperties,
      httpMethods,
      sanitise,
      sanitiseAll
    };
  }
});

// node_modules/oas-resolver/index.js
var require_oas_resolver = __commonJS({
  "node_modules/oas-resolver/index.js"(exports2, module2) {
    "use strict";
    var fs3 = require("fs");
    var path = require("path");
    var url = require("url");
    var fetch4 = (init_lib(), __toCommonJS(lib_exports));
    var yaml = require_yaml3();
    var jptr = require_jptr().jptr;
    var recurse = require_recurse().recurse;
    var clone2 = require_clone().clone;
    var deRef = require_dereference2().dereference;
    var isRef2 = require_isref().isRef;
    var common2 = require_oas_kit_common();
    function unique(arr) {
      return [...new Set(arr)];
    }
    function readFileAsync(filename, encoding, options, pointer, def) {
      return new Promise(function(resolve2, reject) {
        fs3.readFile(filename, encoding, function(err, data) {
          if (err) {
            if (options.ignoreIOErrors && def) {
              if (options.verbose) console.warn("FAILED", pointer);
              options.externalRefs[pointer].failed = true;
              resolve2(def);
            } else {
              reject(err);
            }
          } else {
            resolve2(data);
          }
        });
      });
    }
    function resolveAllFragment(obj, context, src, parentPath, base, options) {
      let attachPoint = options.externalRefs[src + parentPath].paths[0];
      let baseUrl = url.parse(base);
      let seen = {};
      let changes = 1;
      while (changes) {
        changes = 0;
        recurse(obj, { identityDetection: true }, function(obj2, key, state) {
          if (isRef2(obj2, key)) {
            if (obj2[key].startsWith("#")) {
              if (!seen[obj2[key]] && !obj2.$fixed) {
                let target = clone2(jptr(context, obj2[key]));
                if (options.verbose > 1) console.warn((target === false ? common2.colour.red : common2.colour.green) + "Fragment resolution", obj2[key], common2.colour.normal);
                if (target === false) {
                  state.parent[state.pkey] = {};
                  if (options.fatal) {
                    let ex = new Error("Fragment $ref resolution failed " + obj2[key]);
                    if (options.promise) options.promise.reject(ex);
                    else throw ex;
                  }
                } else {
                  changes++;
                  state.parent[state.pkey] = target;
                  seen[obj2[key]] = state.path.replace("/%24ref", "");
                }
              } else {
                if (!obj2.$fixed) {
                  let newRef = (attachPoint + "/" + seen[obj2[key]]).split("/#/").join("/");
                  state.parent[state.pkey] = { $ref: newRef, "x-miro": obj2[key], $fixed: true };
                  if (options.verbose > 1) console.warn("Replacing with", newRef);
                  changes++;
                }
              }
            } else if (baseUrl.protocol) {
              let newRef = url.resolve(base, obj2[key]).toString();
              if (options.verbose > 1) console.warn(common2.colour.yellow + "Rewriting external url ref", obj2[key], "as", newRef, common2.colour.normal);
              obj2["x-miro"] = obj2[key];
              if (options.externalRefs[obj2[key]]) {
                if (!options.externalRefs[newRef]) {
                  options.externalRefs[newRef] = options.externalRefs[obj2[key]];
                }
                options.externalRefs[newRef].failed = options.externalRefs[obj2[key]].failed;
              }
              obj2[key] = newRef;
            } else if (!obj2["x-miro"]) {
              let newRef = url.resolve(base, obj2[key]).toString();
              let failed = false;
              if (options.externalRefs[obj2[key]]) {
                failed = options.externalRefs[obj2[key]].failed;
              }
              if (!failed) {
                if (options.verbose > 1) console.warn(common2.colour.yellow + "Rewriting external ref", obj2[key], "as", newRef, common2.colour.normal);
                obj2["x-miro"] = obj2[key];
                obj2[key] = newRef;
              }
            }
          }
        });
      }
      recurse(obj, {}, function(obj2, key, state) {
        if (isRef2(obj2, key)) {
          if (typeof obj2.$fixed !== "undefined") delete obj2.$fixed;
        }
      });
      if (options.verbose > 1) console.warn("Finished fragment resolution");
      return obj;
    }
    function filterData(data, options) {
      if (!options.filters || !options.filters.length) return data;
      for (let filter of options.filters) {
        data = filter(data, options);
      }
      return data;
    }
    function testProtocol(input, backup) {
      if (input && input.length > 2) return input;
      if (backup && backup.length > 2) return backup;
      return "file:";
    }
    function resolveExternal(root, pointer, options, callback) {
      var u = url.parse(options.source);
      var base = options.source.split("\\").join("/").split("/");
      let doc = base.pop();
      if (!doc) base.pop();
      let fragment = "";
      let fnComponents = pointer.split("#");
      if (fnComponents.length > 1) {
        fragment = "#" + fnComponents[1];
        pointer = fnComponents[0];
      }
      base = base.join("/");
      let u2 = url.parse(pointer);
      let effectiveProtocol = testProtocol(u2.protocol, u.protocol);
      let target;
      if (effectiveProtocol === "file:") {
        target = path.resolve(base ? base + "/" : "", pointer);
      } else {
        target = url.resolve(base ? base + "/" : "", pointer);
      }
      if (options.cache[target]) {
        if (options.verbose) console.warn("CACHED", target, fragment);
        let context = clone2(options.cache[target]);
        let data = options.externalRef = context;
        if (fragment) {
          data = jptr(data, fragment);
          if (data === false) {
            data = {};
            if (options.fatal) {
              let ex = new Error("Cached $ref resolution failed " + target + fragment);
              if (options.promise) options.promise.reject(ex);
              else throw ex;
            }
          }
        }
        data = resolveAllFragment(data, context, pointer, fragment, target, options);
        data = filterData(data, options);
        callback(clone2(data), target, options);
        return Promise.resolve(data);
      }
      if (options.verbose) console.warn("GET", target, fragment);
      if (options.handlers && options.handlers[effectiveProtocol]) {
        return options.handlers[effectiveProtocol](base, pointer, fragment, options).then(function(data) {
          options.externalRef = data;
          data = filterData(data, options);
          options.cache[target] = data;
          callback(data, target, options);
          return data;
        }).catch(function(ex) {
          if (options.verbose) console.warn(ex);
          throw ex;
        });
      } else if (effectiveProtocol && effectiveProtocol.startsWith("http")) {
        const fetchOptions = Object.assign({}, options.fetchOptions, { agent: options.agent });
        return options.fetch(target, fetchOptions).then(function(res) {
          if (res.status !== 200) {
            if (options.ignoreIOErrors) {
              if (options.verbose) console.warn("FAILED", pointer);
              options.externalRefs[pointer].failed = true;
              return '{"$ref":"' + pointer + '"}';
            } else {
              throw new Error(`Received status code ${res.status}: ${target}`);
            }
          }
          return res.text();
        }).then(function(data) {
          try {
            let context = yaml.parse(data, { schema: "core", prettyErrors: true });
            data = options.externalRef = context;
            options.cache[target] = clone2(data);
            if (fragment) {
              data = jptr(data, fragment);
              if (data === false) {
                data = {};
                if (options.fatal) {
                  let ex = new Error("Remote $ref resolution failed " + target + fragment);
                  if (options.promise) options.promise.reject(ex);
                  else throw ex;
                }
              }
            }
            data = resolveAllFragment(data, context, pointer, fragment, target, options);
            data = filterData(data, options);
          } catch (ex) {
            if (options.verbose) console.warn(ex);
            if (options.promise && options.fatal) options.promise.reject(ex);
            else throw ex;
          }
          callback(data, target, options);
          return data;
        }).catch(function(err) {
          if (options.verbose) console.warn(err);
          options.cache[target] = {};
          if (options.promise && options.fatal) options.promise.reject(err);
          else throw err;
        });
      } else {
        const def = '{"$ref":"' + pointer + '"}';
        return readFileAsync(target, options.encoding || "utf8", options, pointer, def).then(function(data) {
          try {
            let context = yaml.parse(data, { schema: "core", prettyErrors: true });
            data = options.externalRef = context;
            options.cache[target] = clone2(data);
            if (fragment) {
              data = jptr(data, fragment);
              if (data === false) {
                data = {};
                if (options.fatal) {
                  let ex = new Error("File $ref resolution failed " + target + fragment);
                  if (options.promise) options.promise.reject(ex);
                  else throw ex;
                }
              }
            }
            data = resolveAllFragment(data, context, pointer, fragment, target, options);
            data = filterData(data, options);
          } catch (ex) {
            if (options.verbose) console.warn(ex);
            if (options.promise && options.fatal) options.promise.reject(ex);
            else throw ex;
          }
          callback(data, target, options);
          return data;
        }).catch(function(err) {
          if (options.verbose) console.warn(err);
          if (options.promise && options.fatal) options.promise.reject(err);
          else throw err;
        });
      }
    }
    function scanExternalRefs(options) {
      return new Promise(function(res, rej) {
        function inner(obj, key, state) {
          if (obj[key] && isRef2(obj[key], "$ref")) {
            let $ref = obj[key].$ref;
            if (!$ref.startsWith("#")) {
              let $extra = "";
              if (!refs[$ref]) {
                let potential = Object.keys(refs).find(function(e, i, a) {
                  return $ref.startsWith(e + "/");
                });
                if (potential) {
                  if (options.verbose) console.warn("Found potential subschema at", potential);
                  $extra = "/" + ($ref.split("#")[1] || "").replace(potential.split("#")[1] || "");
                  $extra = $extra.split("/undefined").join("");
                  $ref = potential;
                }
              }
              if (!refs[$ref]) {
                refs[$ref] = { resolved: false, paths: [], extras: {}, description: obj[key].description };
              }
              if (refs[$ref].resolved) {
                if (refs[$ref].failed) {
                } else if (options.rewriteRefs) {
                  let newRef = refs[$ref].resolvedAt;
                  if (options.verbose > 1) console.warn("Rewriting ref", $ref, newRef);
                  obj[key]["x-miro"] = $ref;
                  obj[key].$ref = newRef + $extra;
                } else {
                  obj[key] = clone2(refs[$ref].data);
                }
              } else {
                refs[$ref].paths.push(state.path);
                refs[$ref].extras[state.path] = $extra;
              }
            }
          }
        }
        let refs = options.externalRefs;
        if (options.resolver.depth > 0 && options.source === options.resolver.base) {
          return res(refs);
        }
        recurse(options.openapi.definitions, { identityDetection: true, path: "#/definitions" }, inner);
        recurse(options.openapi.components, { identityDetection: true, path: "#/components" }, inner);
        recurse(options.openapi, { identityDetection: true }, inner);
        res(refs);
      });
    }
    function findExternalRefs(options) {
      return new Promise(function(res, rej) {
        scanExternalRefs(options).then(function(refs) {
          for (let ref in refs) {
            if (!refs[ref].resolved) {
              let depth = options.resolver.depth;
              if (depth > 0) depth++;
              options.resolver.actions[depth].push(function() {
                return resolveExternal(options.openapi, ref, options, function(data, source, options2) {
                  if (!refs[ref].resolved) {
                    let external = {};
                    external.context = refs[ref];
                    external.$ref = ref;
                    external.original = clone2(data);
                    external.updated = data;
                    external.source = source;
                    options2.externals.push(external);
                    refs[ref].resolved = true;
                  }
                  let localOptions = Object.assign({}, options2, {
                    source: "",
                    resolver: {
                      actions: options2.resolver.actions,
                      depth: options2.resolver.actions.length - 1,
                      base: options2.resolver.base
                    }
                  });
                  if (options2.patch && refs[ref].description && !data.description && typeof data === "object") {
                    data.description = refs[ref].description;
                  }
                  refs[ref].data = data;
                  let pointers = unique(refs[ref].paths);
                  pointers = pointers.sort(function(a, b) {
                    const aComp = a.startsWith("#/components/") || a.startsWith("#/definitions/");
                    const bComp = b.startsWith("#/components/") || b.startsWith("#/definitions/");
                    if (aComp && !bComp) return -1;
                    if (bComp && !aComp) return 1;
                    return 0;
                  });
                  for (let ptr of pointers) {
                    if (refs[ref].resolvedAt && ptr !== refs[ref].resolvedAt && ptr.indexOf("x-ms-examples/") < 0) {
                      if (options2.verbose > 1) console.warn("Creating pointer to data at", ptr);
                      jptr(options2.openapi, ptr, { $ref: refs[ref].resolvedAt + refs[ref].extras[ptr], "x-miro": ref + refs[ref].extras[ptr] });
                    } else {
                      if (refs[ref].resolvedAt) {
                        if (options2.verbose > 1) console.warn("Avoiding circular reference");
                      } else {
                        refs[ref].resolvedAt = ptr;
                        if (options2.verbose > 1) console.warn("Creating initial clone of data at", ptr);
                      }
                      let cdata = clone2(data);
                      jptr(options2.openapi, ptr, cdata);
                    }
                  }
                  if (options2.resolver.actions[localOptions.resolver.depth].length === 0) {
                    options2.resolver.actions[localOptions.resolver.depth].push(function() {
                      return findExternalRefs(localOptions);
                    });
                  }
                });
              });
            }
          }
        }).catch(function(ex) {
          if (options.verbose) console.warn(ex);
          rej(ex);
        });
        let result = { options };
        result.actions = options.resolver.actions[options.resolver.depth];
        res(result);
      });
    }
    var serial = (funcs) => funcs.reduce((promise, func) => promise.then((result) => func().then(Array.prototype.concat.bind(result))), Promise.resolve([]));
    function loopReferences(options, res, rej) {
      options.resolver.actions.push([]);
      findExternalRefs(options).then(function(data) {
        serial(data.actions).then(function() {
          if (options.resolver.depth >= options.resolver.actions.length) {
            console.warn("Ran off the end of resolver actions");
            return res(true);
          } else {
            options.resolver.depth++;
            if (options.resolver.actions[options.resolver.depth].length) {
              setTimeout(function() {
                loopReferences(data.options, res, rej);
              }, 0);
            } else {
              if (options.verbose > 1) console.warn(common2.colour.yellow + "Finished external resolution!", common2.colour.normal);
              if (options.resolveInternal) {
                if (options.verbose > 1) console.warn(common2.colour.yellow + "Starting internal resolution!", common2.colour.normal);
                options.openapi = deRef(options.openapi, options.original, { verbose: options.verbose - 1 });
                if (options.verbose > 1) console.warn(common2.colour.yellow + "Finished internal resolution!", common2.colour.normal);
              }
              recurse(options.openapi, {}, function(obj, key, state) {
                if (isRef2(obj, key)) {
                  if (!options.preserveMiro) delete obj["x-miro"];
                }
              });
              res(options);
            }
          }
        }).catch(function(ex) {
          if (options.verbose) console.warn(ex);
          rej(ex);
        });
      }).catch(function(ex) {
        if (options.verbose) console.warn(ex);
        rej(ex);
      });
    }
    function setupOptions(options) {
      if (!options.cache) options.cache = {};
      if (!options.fetch) options.fetch = fetch4;
      if (options.source) {
        let srcUrl = url.parse(options.source);
        if (!srcUrl.protocol || srcUrl.protocol.length <= 2) {
          options.source = path.resolve(options.source);
        }
      }
      options.externals = [];
      options.externalRefs = {};
      options.rewriteRefs = true;
      options.resolver = {};
      options.resolver.depth = 0;
      options.resolver.base = options.source;
      options.resolver.actions = [[]];
    }
    function optionalResolve(options) {
      setupOptions(options);
      return new Promise(function(res, rej) {
        if (options.resolve)
          loopReferences(options, res, rej);
        else
          res(options);
      });
    }
    function resolve(openapi, source, options) {
      if (!options) options = {};
      options.openapi = openapi;
      options.source = source;
      options.resolve = true;
      setupOptions(options);
      return new Promise(function(res, rej) {
        loopReferences(options, res, rej);
      });
    }
    module2.exports = {
      optionalResolve,
      resolve
    };
  }
});

// node_modules/oas-schema-walker/index.js
var require_oas_schema_walker = __commonJS({
  "node_modules/oas-schema-walker/index.js"(exports2, module2) {
    "use strict";
    function getDefaultState() {
      return { depth: 0, seen: /* @__PURE__ */ new WeakMap(), top: true, combine: false, allowRefSiblings: false };
    }
    function walkSchema(schema2, parent, state, callback) {
      if (typeof state.depth === "undefined") state = getDefaultState();
      if (schema2 === null || typeof schema2 === "undefined") return schema2;
      if (typeof schema2.$ref !== "undefined") {
        let temp = { $ref: schema2.$ref };
        if (state.allowRefSiblings && schema2.description) {
          temp.description = schema2.description;
        }
        callback(temp, parent, state);
        return temp;
      }
      if (state.combine) {
        if (schema2.allOf && Array.isArray(schema2.allOf) && schema2.allOf.length === 1) {
          schema2 = Object.assign({}, schema2.allOf[0], schema2);
          delete schema2.allOf;
        }
        if (schema2.anyOf && Array.isArray(schema2.anyOf) && schema2.anyOf.length === 1) {
          schema2 = Object.assign({}, schema2.anyOf[0], schema2);
          delete schema2.anyOf;
        }
        if (schema2.oneOf && Array.isArray(schema2.oneOf) && schema2.oneOf.length === 1) {
          schema2 = Object.assign({}, schema2.oneOf[0], schema2);
          delete schema2.oneOf;
        }
      }
      callback(schema2, parent, state);
      if (state.seen.has(schema2)) {
        return schema2;
      }
      if (typeof schema2 === "object" && schema2 !== null) state.seen.set(schema2, true);
      state.top = false;
      state.depth++;
      if (typeof schema2.items !== "undefined") {
        state.property = "items";
        walkSchema(schema2.items, schema2, state, callback);
      }
      if (schema2.additionalItems) {
        if (typeof schema2.additionalItems === "object") {
          state.property = "additionalItems";
          walkSchema(schema2.additionalItems, schema2, state, callback);
        }
      }
      if (schema2.additionalProperties) {
        if (typeof schema2.additionalProperties === "object") {
          state.property = "additionalProperties";
          walkSchema(schema2.additionalProperties, schema2, state, callback);
        }
      }
      if (schema2.properties) {
        for (let prop in schema2.properties) {
          let subSchema = schema2.properties[prop];
          state.property = "properties/" + prop;
          walkSchema(subSchema, schema2, state, callback);
        }
      }
      if (schema2.patternProperties) {
        for (let prop in schema2.patternProperties) {
          let subSchema = schema2.patternProperties[prop];
          state.property = "patternProperties/" + prop;
          walkSchema(subSchema, schema2, state, callback);
        }
      }
      if (schema2.allOf) {
        for (let index in schema2.allOf) {
          let subSchema = schema2.allOf[index];
          state.property = "allOf/" + index;
          walkSchema(subSchema, schema2, state, callback);
        }
      }
      if (schema2.anyOf) {
        for (let index in schema2.anyOf) {
          let subSchema = schema2.anyOf[index];
          state.property = "anyOf/" + index;
          walkSchema(subSchema, schema2, state, callback);
        }
      }
      if (schema2.oneOf) {
        for (let index in schema2.oneOf) {
          let subSchema = schema2.oneOf[index];
          state.property = "oneOf/" + index;
          walkSchema(subSchema, schema2, state, callback);
        }
      }
      if (schema2.not) {
        state.property = "not";
        walkSchema(schema2.not, schema2, state, callback);
      }
      state.depth--;
      return schema2;
    }
    module2.exports = {
      getDefaultState,
      walkSchema
    };
  }
});

// node_modules/swagger2openapi/lib/statusCodes.js
var require_statusCodes = __commonJS({
  "node_modules/swagger2openapi/lib/statusCodes.js"(exports2, module2) {
    "use strict";
    var http4 = require("http");
    var ours = {
      "default": "Default response",
      "1XX": "Informational",
      "103": "Early hints",
      // not in Node < 10
      "2XX": "Successful",
      "3XX": "Redirection",
      "4XX": "Client Error",
      "5XX": "Server Error",
      "7XX": "Developer Error"
      // April fools RFC
    };
    module2.exports = {
      statusCodes: Object.assign({}, ours, http4.STATUS_CODES)
    };
  }
});

// node_modules/swagger2openapi/package.json
var require_package = __commonJS({
  "node_modules/swagger2openapi/package.json"(exports2, module2) {
    module2.exports = {
      name: "swagger2openapi",
      version: "7.0.8",
      description: "Convert Swagger 2.0 definitions to OpenApi 3.0 and validate",
      main: "index.js",
      bin: {
        swagger2openapi: "./swagger2openapi.js",
        "oas-validate": "./oas-validate.js",
        boast: "./boast.js"
      },
      funding: "https://github.com/Mermade/oas-kit?sponsor=1",
      scripts: {
        test: "mocha"
      },
      browserify: {
        transform: [
          [
            "babelify",
            {
              presets: [
                "es2015"
              ]
            }
          ]
        ]
      },
      repository: {
        url: "https://github.com/Mermade/oas-kit.git",
        type: "git"
      },
      bugs: {
        url: "https://github.com/mermade/oas-kit/issues"
      },
      author: "Mike Ralphson <mike.ralphson@gmail.com>",
      license: "BSD-3-Clause",
      dependencies: {
        "call-me-maybe": "^1.0.1",
        "node-fetch": "^2.6.1",
        "node-fetch-h2": "^2.3.0",
        "node-readfiles": "^0.2.0",
        "oas-kit-common": "^1.0.8",
        "oas-resolver": "^2.5.6",
        "oas-schema-walker": "^1.1.5",
        "oas-validator": "^5.0.8",
        reftools: "^1.1.9",
        yaml: "^1.10.0",
        yargs: "^17.0.1"
      },
      keywords: [
        "swagger",
        "openapi",
        "openapi2",
        "openapi3",
        "converter",
        "conversion",
        "validator",
        "validation",
        "resolver",
        "lint",
        "linter"
      ],
      gitHead: "b1bba3fc5007e96a991bf2a015cf0534ac36b88b"
    };
  }
});

// node_modules/swagger2openapi/index.js
var require_swagger2openapi = __commonJS({
  "node_modules/swagger2openapi/index.js"(exports2, module2) {
    "use strict";
    var fs3 = require("fs");
    var url = require("url");
    var pathlib = require("path");
    var maybe = require_maybe();
    var fetch4 = (init_lib(), __toCommonJS(lib_exports));
    var yaml = require_yaml2();
    var jptr = require_jptr();
    var resolveInternal = jptr.jptr;
    var isRef2 = require_isref().isRef;
    var clone2 = require_clone().clone;
    var cclone = require_clone().circularClone;
    var recurse = require_recurse().recurse;
    var resolver = require_oas_resolver();
    var sw = require_oas_schema_walker();
    var common2 = require_oas_kit_common();
    var statusCodes = require_statusCodes().statusCodes;
    var ourVersion = require_package().version;
    var targetVersion = "3.0.0";
    var componentNames;
    var S2OError = class extends Error {
      constructor(message) {
        super(message);
        this.name = "S2OError";
      }
    };
    function throwError2(message, options) {
      let err = new S2OError(message);
      err.options = options;
      if (options.promise) {
        options.promise.reject(err);
      } else {
        throw err;
      }
    }
    function throwOrWarn(message, container, options) {
      if (options.warnOnly) {
        container[options.warnProperty || "x-s2o-warning"] = message;
      } else {
        throwError2(message, options);
      }
    }
    function fixUpSubSchema(schema2, parent, options) {
      if (schema2.nullable) options.patches++;
      if (schema2.discriminator && typeof schema2.discriminator === "string") {
        schema2.discriminator = { propertyName: schema2.discriminator };
      }
      if (schema2.items && Array.isArray(schema2.items)) {
        if (schema2.items.length === 0) {
          schema2.items = {};
        } else if (schema2.items.length === 1) {
          schema2.items = schema2.items[0];
        } else schema2.items = { anyOf: schema2.items };
      }
      if (schema2.type && Array.isArray(schema2.type)) {
        if (options.patch) {
          options.patches++;
          if (schema2.type.length === 0) {
            delete schema2.type;
          } else {
            if (!schema2.oneOf) schema2.oneOf = [];
            for (let type2 of schema2.type) {
              let newSchema = {};
              if (type2 === "null") {
                schema2.nullable = true;
              } else {
                newSchema.type = type2;
                for (let prop of common2.arrayProperties) {
                  if (typeof schema2.prop !== "undefined") {
                    newSchema[prop] = schema2[prop];
                    delete schema2[prop];
                  }
                }
              }
              if (newSchema.type) {
                schema2.oneOf.push(newSchema);
              }
            }
            delete schema2.type;
            if (schema2.oneOf.length === 0) {
              delete schema2.oneOf;
            } else if (schema2.oneOf.length < 2) {
              schema2.type = schema2.oneOf[0].type;
              if (Object.keys(schema2.oneOf[0]).length > 1) {
                throwOrWarn("Lost properties from oneOf", schema2, options);
              }
              delete schema2.oneOf;
            }
          }
          if (schema2.type && Array.isArray(schema2.type) && schema2.type.length === 1) {
            schema2.type = schema2.type[0];
          }
        } else {
          throwError2("(Patchable) schema type must not be an array", options);
        }
      }
      if (schema2.type && schema2.type === "null") {
        delete schema2.type;
        schema2.nullable = true;
      }
      if (schema2.type === "array" && !schema2.items) {
        schema2.items = {};
      }
      if (schema2.type === "file") {
        schema2.type = "string";
        schema2.format = "binary";
      }
      if (typeof schema2.required === "boolean") {
        if (schema2.required && schema2.name) {
          if (typeof parent.required === "undefined") {
            parent.required = [];
          }
          if (Array.isArray(parent.required)) parent.required.push(schema2.name);
        }
        delete schema2.required;
      }
      if (schema2.xml && typeof schema2.xml.namespace === "string") {
        if (!schema2.xml.namespace) delete schema2.xml.namespace;
      }
      if (typeof schema2.allowEmptyValue !== "undefined") {
        options.patches++;
        delete schema2.allowEmptyValue;
      }
    }
    function fixUpSubSchemaExtensions(schema2, parent) {
      if (schema2["x-required"] && Array.isArray(schema2["x-required"])) {
        if (!schema2.required) schema2.required = [];
        schema2.required = schema2.required.concat(schema2["x-required"]);
        delete schema2["x-required"];
      }
      if (schema2["x-anyOf"]) {
        schema2.anyOf = schema2["x-anyOf"];
        delete schema2["x-anyOf"];
      }
      if (schema2["x-oneOf"]) {
        schema2.oneOf = schema2["x-oneOf"];
        delete schema2["x-oneOf"];
      }
      if (schema2["x-not"]) {
        schema2.not = schema2["x-not"];
        delete schema2["x-not"];
      }
      if (typeof schema2["x-nullable"] === "boolean") {
        schema2.nullable = schema2["x-nullable"];
        delete schema2["x-nullable"];
      }
      if (typeof schema2["x-discriminator"] === "object" && typeof schema2["x-discriminator"].propertyName === "string") {
        schema2.discriminator = schema2["x-discriminator"];
        delete schema2["x-discriminator"];
        for (let entry in schema2.discriminator.mapping) {
          let schemaOrRef = schema2.discriminator.mapping[entry];
          if (schemaOrRef.startsWith("#/definitions/")) {
            schema2.discriminator.mapping[entry] = schemaOrRef.replace("#/definitions/", "#/components/schemas/");
          }
        }
      }
    }
    function fixUpSchema(schema2, options) {
      sw.walkSchema(schema2, {}, {}, function(schema3, parent, state) {
        fixUpSubSchemaExtensions(schema3, parent);
        fixUpSubSchema(schema3, parent, options);
      });
    }
    function getMiroComponentName(ref) {
      if (ref.indexOf("#") >= 0) {
        ref = ref.split("#")[1].split("/").pop();
      } else {
        ref = ref.split("/").pop().split(".")[0];
      }
      return encodeURIComponent(common2.sanitise(ref));
    }
    function fixupRefs(obj, key, state) {
      let options = state.payload.options;
      if (isRef2(obj, key)) {
        if (obj[key].startsWith("#/components/")) {
        } else if (obj[key] === "#/consumes") {
          delete obj[key];
          state.parent[state.pkey] = clone2(options.openapi.consumes);
        } else if (obj[key] === "#/produces") {
          delete obj[key];
          state.parent[state.pkey] = clone2(options.openapi.produces);
        } else if (obj[key].startsWith("#/definitions/")) {
          let keys = obj[key].replace("#/definitions/", "").split("/");
          const ref = jptr.jpunescape(keys[0]);
          let newKey = componentNames.schemas[decodeURIComponent(ref)];
          if (newKey) {
            keys[0] = newKey;
          } else {
            throwOrWarn("Could not resolve reference " + obj[key], obj, options);
          }
          obj[key] = "#/components/schemas/" + keys.join("/");
        } else if (obj[key].startsWith("#/parameters/")) {
          obj[key] = "#/components/parameters/" + common2.sanitise(obj[key].replace("#/parameters/", ""));
        } else if (obj[key].startsWith("#/responses/")) {
          obj[key] = "#/components/responses/" + common2.sanitise(obj[key].replace("#/responses/", ""));
        } else if (obj[key].startsWith("#")) {
          let target = clone2(jptr.jptr(options.openapi, obj[key]));
          if (target === false) throwOrWarn("direct $ref not found " + obj[key], obj, options);
          else if (options.refmap[obj[key]]) {
            obj[key] = options.refmap[obj[key]];
          } else {
            let oldRef = obj[key];
            oldRef = oldRef.replace("/properties/headers/", "");
            oldRef = oldRef.replace("/properties/responses/", "");
            oldRef = oldRef.replace("/properties/parameters/", "");
            oldRef = oldRef.replace("/properties/schemas/", "");
            let type2 = "schemas";
            let schemaIndex = oldRef.lastIndexOf("/schema");
            type2 = oldRef.indexOf("/headers/") > schemaIndex ? "headers" : oldRef.indexOf("/responses/") > schemaIndex ? "responses" : oldRef.indexOf("/example") > schemaIndex ? "examples" : oldRef.indexOf("/x-") > schemaIndex ? "extensions" : oldRef.indexOf("/parameters/") > schemaIndex ? "parameters" : "schemas";
            if (type2 === "schemas") {
              fixUpSchema(target, options);
            }
            if (type2 !== "responses" && type2 !== "extensions") {
              let prefix = type2.substr(0, type2.length - 1);
              if (prefix === "parameter" && target.name && target.name === common2.sanitise(target.name)) {
                prefix = encodeURIComponent(target.name);
              }
              let suffix = 1;
              if (obj["x-miro"]) {
                prefix = getMiroComponentName(obj["x-miro"]);
                suffix = "";
              }
              while (jptr.jptr(options.openapi, "#/components/" + type2 + "/" + prefix + suffix)) {
                suffix = suffix === "" ? 2 : ++suffix;
              }
              let newRef = "#/components/" + type2 + "/" + prefix + suffix;
              let refSuffix = "";
              if (type2 === "examples") {
                target = { value: target };
                refSuffix = "/value";
              }
              jptr.jptr(options.openapi, newRef, target);
              options.refmap[obj[key]] = newRef + refSuffix;
              obj[key] = newRef + refSuffix;
            }
          }
        }
        delete obj["x-miro"];
        if (Object.keys(obj).length > 1) {
          const tmpRef = obj[key];
          const inSchema = state.path.indexOf("/schema") >= 0;
          if (options.refSiblings === "preserve") {
          } else if (inSchema && options.refSiblings === "allOf") {
            delete obj.$ref;
            state.parent[state.pkey] = { allOf: [{ $ref: tmpRef }, obj] };
          } else {
            state.parent[state.pkey] = { $ref: tmpRef };
          }
        }
      }
      if (key === "x-ms-odata" && typeof obj[key] === "string" && obj[key].startsWith("#/")) {
        let keys = obj[key].replace("#/definitions/", "").replace("#/components/schemas/", "").split("/");
        let newKey = componentNames.schemas[decodeURIComponent(keys[0])];
        if (newKey) {
          keys[0] = newKey;
        } else {
          throwOrWarn("Could not resolve reference " + obj[key], obj, options);
        }
        obj[key] = "#/components/schemas/" + keys.join("/");
      }
    }
    function dedupeRefs(openapi, options) {
      for (let ref in options.refmap) {
        jptr.jptr(openapi, ref, { $ref: options.refmap[ref] });
      }
    }
    function processSecurity(securityObject) {
      for (let s in securityObject) {
        for (let k in securityObject[s]) {
          let sname = common2.sanitise(k);
          if (k !== sname) {
            securityObject[s][sname] = securityObject[s][k];
            delete securityObject[s][k];
          }
        }
      }
    }
    function processSecurityScheme(scheme, options) {
      if (scheme.type === "basic") {
        scheme.type = "http";
        scheme.scheme = "basic";
      }
      if (scheme.type === "oauth2") {
        let flow = {};
        let flowName = scheme.flow;
        if (scheme.flow === "application") flowName = "clientCredentials";
        if (scheme.flow === "accessCode") flowName = "authorizationCode";
        if (typeof scheme.authorizationUrl !== "undefined") flow.authorizationUrl = scheme.authorizationUrl.split("?")[0].trim() || "/";
        if (typeof scheme.tokenUrl === "string") flow.tokenUrl = scheme.tokenUrl.split("?")[0].trim() || "/";
        flow.scopes = scheme.scopes || {};
        scheme.flows = {};
        scheme.flows[flowName] = flow;
        delete scheme.flow;
        delete scheme.authorizationUrl;
        delete scheme.tokenUrl;
        delete scheme.scopes;
        if (typeof scheme.name !== "undefined") {
          if (options.patch) {
            options.patches++;
            delete scheme.name;
          } else {
            throwError2("(Patchable) oauth2 securitySchemes should not have name property", options);
          }
        }
      }
    }
    function keepParameters(value) {
      return value && !value["x-s2o-delete"];
    }
    function processHeader(header, options) {
      if (header.$ref) {
        header.$ref = header.$ref.replace("#/responses/", "#/components/responses/");
      } else {
        if (header.type && !header.schema) {
          header.schema = {};
        }
        if (header.type) header.schema.type = header.type;
        if (header.items && header.items.type !== "array") {
          if (header.items.collectionFormat !== header.collectionFormat) {
            throwOrWarn("Nested collectionFormats are not supported", header, options);
          }
          delete header.items.collectionFormat;
        }
        if (header.type === "array") {
          if (header.collectionFormat === "ssv") {
            throwOrWarn("collectionFormat:ssv is no longer supported for headers", header, options);
          } else if (header.collectionFormat === "pipes") {
            throwOrWarn("collectionFormat:pipes is no longer supported for headers", header, options);
          } else if (header.collectionFormat === "multi") {
            header.explode = true;
          } else if (header.collectionFormat === "tsv") {
            throwOrWarn("collectionFormat:tsv is no longer supported", header, options);
            header["x-collectionFormat"] = "tsv";
          } else {
            header.style = "simple";
          }
          delete header.collectionFormat;
        } else if (header.collectionFormat) {
          if (options.patch) {
            options.patches++;
            delete header.collectionFormat;
          } else {
            throwError2("(Patchable) collectionFormat is only applicable to header.type array", options);
          }
        }
        delete header.type;
        for (let prop of common2.parameterTypeProperties) {
          if (typeof header[prop] !== "undefined") {
            header.schema[prop] = header[prop];
            delete header[prop];
          }
        }
        for (let prop of common2.arrayProperties) {
          if (typeof header[prop] !== "undefined") {
            header.schema[prop] = header[prop];
            delete header[prop];
          }
        }
      }
    }
    function fixParamRef(param, options) {
      if (param.$ref.indexOf("#/parameters/") >= 0) {
        let refComponents = param.$ref.split("#/parameters/");
        param.$ref = refComponents[0] + "#/components/parameters/" + common2.sanitise(refComponents[1]);
      }
      if (param.$ref.indexOf("#/definitions/") >= 0) {
        throwOrWarn("Definition used as parameter", param, options);
      }
    }
    function attachRequestBody(op, options) {
      let newOp = {};
      for (let key of Object.keys(op)) {
        newOp[key] = op[key];
        if (key === "parameters") {
          newOp.requestBody = {};
          if (options.rbname) newOp[options.rbname] = "";
        }
      }
      newOp.requestBody = {};
      return newOp;
    }
    function processParameter(param, op, path, method, index, openapi, options) {
      let result = {};
      let singularRequestBody = true;
      let originalType;
      if (op && op.consumes && typeof op.consumes === "string") {
        if (options.patch) {
          options.patches++;
          op.consumes = [op.consumes];
        } else {
          return throwError2("(Patchable) operation.consumes must be an array", options);
        }
      }
      if (!Array.isArray(openapi.consumes)) delete openapi.consumes;
      let consumes = ((op ? op.consumes : null) || (openapi.consumes || [])).filter(common2.uniqueOnly);
      if (param && param.$ref && typeof param.$ref === "string") {
        fixParamRef(param, options);
        let ptr = decodeURIComponent(param.$ref.replace("#/components/parameters/", ""));
        let rbody = false;
        let target = openapi.components.parameters[ptr];
        if ((!target || target["x-s2o-delete"]) && param.$ref.startsWith("#/")) {
          param["x-s2o-delete"] = true;
          rbody = true;
        }
        if (rbody) {
          let ref = param.$ref;
          let newParam = resolveInternal(openapi, param.$ref);
          if (!newParam && ref.startsWith("#/")) {
            throwOrWarn("Could not resolve reference " + ref, param, options);
          } else {
            if (newParam) param = newParam;
          }
        }
      }
      if (param && (param.name || param.in)) {
        if (typeof param["x-deprecated"] === "boolean") {
          param.deprecated = param["x-deprecated"];
          delete param["x-deprecated"];
        }
        if (typeof param["x-example"] !== "undefined") {
          param.example = param["x-example"];
          delete param["x-example"];
        }
        if (param.in !== "body" && !param.type) {
          if (options.patch) {
            options.patches++;
            param.type = "string";
          } else {
            throwError2("(Patchable) parameter.type is mandatory for non-body parameters", options);
          }
        }
        if (param.type && typeof param.type === "object" && param.type.$ref) {
          param.type = resolveInternal(openapi, param.type.$ref);
        }
        if (param.type === "file") {
          param["x-s2o-originalType"] = param.type;
          originalType = param.type;
        }
        if (param.description && typeof param.description === "object" && param.description.$ref) {
          param.description = resolveInternal(openapi, param.description.$ref);
        }
        if (param.description === null) delete param.description;
        let oldCollectionFormat = param.collectionFormat;
        if (param.type === "array" && !oldCollectionFormat) {
          oldCollectionFormat = "csv";
        }
        if (oldCollectionFormat) {
          if (param.type !== "array") {
            if (options.patch) {
              options.patches++;
              delete param.collectionFormat;
            } else {
              throwError2("(Patchable) collectionFormat is only applicable to param.type array", options);
            }
          }
          if (oldCollectionFormat === "csv" && (param.in === "query" || param.in === "cookie")) {
            param.style = "form";
            param.explode = false;
          }
          if (oldCollectionFormat === "csv" && (param.in === "path" || param.in === "header")) {
            param.style = "simple";
          }
          if (oldCollectionFormat === "ssv") {
            if (param.in === "query") {
              param.style = "spaceDelimited";
            } else {
              throwOrWarn("collectionFormat:ssv is no longer supported except for in:query parameters", param, options);
            }
          }
          if (oldCollectionFormat === "pipes") {
            if (param.in === "query") {
              param.style = "pipeDelimited";
            } else {
              throwOrWarn("collectionFormat:pipes is no longer supported except for in:query parameters", param, options);
            }
          }
          if (oldCollectionFormat === "multi") {
            param.explode = true;
          }
          if (oldCollectionFormat === "tsv") {
            throwOrWarn("collectionFormat:tsv is no longer supported", param, options);
            param["x-collectionFormat"] = "tsv";
          }
          delete param.collectionFormat;
        }
        if (param.type && param.type !== "body" && param.in !== "formData") {
          if (param.items && param.schema) {
            throwOrWarn("parameter has array,items and schema", param, options);
          } else {
            if (param.schema) options.patches++;
            if (!param.schema || typeof param.schema !== "object") param.schema = {};
            param.schema.type = param.type;
            if (param.items) {
              param.schema.items = param.items;
              delete param.items;
              recurse(param.schema.items, null, function(obj, key, state) {
                if (key === "collectionFormat" && typeof obj[key] === "string") {
                  if (oldCollectionFormat && obj[key] !== oldCollectionFormat) {
                    throwOrWarn("Nested collectionFormats are not supported", param, options);
                  }
                  delete obj[key];
                }
              });
            }
            for (let prop of common2.parameterTypeProperties) {
              if (typeof param[prop] !== "undefined") param.schema[prop] = param[prop];
              delete param[prop];
            }
          }
        }
        if (param.schema) {
          fixUpSchema(param.schema, options);
        }
        if (param["x-ms-skip-url-encoding"]) {
          if (param.in === "query") {
            param.allowReserved = true;
            delete param["x-ms-skip-url-encoding"];
          }
        }
      }
      if (param && param.in === "formData") {
        singularRequestBody = false;
        result.content = {};
        let contentType = "application/x-www-form-urlencoded";
        if (consumes.length && consumes.indexOf("multipart/form-data") >= 0) {
          contentType = "multipart/form-data";
        }
        result.content[contentType] = {};
        if (param.schema) {
          result.content[contentType].schema = param.schema;
          if (param.schema.$ref) {
            result["x-s2o-name"] = decodeURIComponent(param.schema.$ref.replace("#/components/schemas/", ""));
          }
        } else {
          result.content[contentType].schema = {};
          result.content[contentType].schema.type = "object";
          result.content[contentType].schema.properties = {};
          result.content[contentType].schema.properties[param.name] = {};
          let schema2 = result.content[contentType].schema;
          let target = result.content[contentType].schema.properties[param.name];
          if (param.description) target.description = param.description;
          if (param.example) target.example = param.example;
          if (param.type) target.type = param.type;
          for (let prop of common2.parameterTypeProperties) {
            if (typeof param[prop] !== "undefined") target[prop] = param[prop];
          }
          if (param.required === true) {
            if (!schema2.required) schema2.required = [];
            schema2.required.push(param.name);
            result.required = true;
          }
          if (typeof param.default !== "undefined") target.default = param.default;
          if (target.properties) target.properties = param.properties;
          if (param.allOf) target.allOf = param.allOf;
          if (param.type === "array" && param.items) {
            target.items = param.items;
            if (target.items.collectionFormat) delete target.items.collectionFormat;
          }
          if (originalType === "file" || param["x-s2o-originalType"] === "file") {
            target.type = "string";
            target.format = "binary";
          }
          copyExtensions(param, target);
        }
      } else if (param && param.type === "file") {
        if (param.required) result.required = param.required;
        result.content = {};
        result.content["application/octet-stream"] = {};
        result.content["application/octet-stream"].schema = {};
        result.content["application/octet-stream"].schema.type = "string";
        result.content["application/octet-stream"].schema.format = "binary";
        copyExtensions(param, result);
      }
      if (param && param.in === "body") {
        result.content = {};
        if (param.name) result["x-s2o-name"] = (op && op.operationId ? common2.sanitiseAll(op.operationId) : "") + ("_" + param.name).toCamelCase();
        if (param.description) result.description = param.description;
        if (param.required) result.required = param.required;
        if (op && options.rbname && param.name) {
          op[options.rbname] = param.name;
        }
        if (param.schema && param.schema.$ref) {
          result["x-s2o-name"] = decodeURIComponent(param.schema.$ref.replace("#/components/schemas/", ""));
        } else if (param.schema && param.schema.type === "array" && param.schema.items && param.schema.items.$ref) {
          result["x-s2o-name"] = decodeURIComponent(param.schema.items.$ref.replace("#/components/schemas/", "")) + "Array";
        }
        if (!consumes.length) {
          consumes.push("application/json");
        }
        for (let mimetype of consumes) {
          result.content[mimetype] = {};
          result.content[mimetype].schema = clone2(param.schema || {});
          fixUpSchema(result.content[mimetype].schema, options);
        }
        copyExtensions(param, result);
      }
      if (Object.keys(result).length > 0) {
        param["x-s2o-delete"] = true;
        if (op) {
          if (op.requestBody && singularRequestBody) {
            op.requestBody["x-s2o-overloaded"] = true;
            let opId = op.operationId || index;
            throwOrWarn("Operation " + opId + " has multiple requestBodies", op, options);
          } else {
            if (!op.requestBody) {
              op = path[method] = attachRequestBody(op, options);
            }
            if (op.requestBody.content && op.requestBody.content["multipart/form-data"] && op.requestBody.content["multipart/form-data"].schema && op.requestBody.content["multipart/form-data"].schema.properties && result.content["multipart/form-data"] && result.content["multipart/form-data"].schema && result.content["multipart/form-data"].schema.properties) {
              op.requestBody.content["multipart/form-data"].schema.properties = Object.assign(op.requestBody.content["multipart/form-data"].schema.properties, result.content["multipart/form-data"].schema.properties);
              op.requestBody.content["multipart/form-data"].schema.required = (op.requestBody.content["multipart/form-data"].schema.required || []).concat(result.content["multipart/form-data"].schema.required || []);
              if (!op.requestBody.content["multipart/form-data"].schema.required.length) {
                delete op.requestBody.content["multipart/form-data"].schema.required;
              }
            } else if (op.requestBody.content && op.requestBody.content["application/x-www-form-urlencoded"] && op.requestBody.content["application/x-www-form-urlencoded"].schema && op.requestBody.content["application/x-www-form-urlencoded"].schema.properties && result.content["application/x-www-form-urlencoded"] && result.content["application/x-www-form-urlencoded"].schema && result.content["application/x-www-form-urlencoded"].schema.properties) {
              op.requestBody.content["application/x-www-form-urlencoded"].schema.properties = Object.assign(op.requestBody.content["application/x-www-form-urlencoded"].schema.properties, result.content["application/x-www-form-urlencoded"].schema.properties);
              op.requestBody.content["application/x-www-form-urlencoded"].schema.required = (op.requestBody.content["application/x-www-form-urlencoded"].schema.required || []).concat(result.content["application/x-www-form-urlencoded"].schema.required || []);
              if (!op.requestBody.content["application/x-www-form-urlencoded"].schema.required.length) {
                delete op.requestBody.content["application/x-www-form-urlencoded"].schema.required;
              }
            } else {
              op.requestBody = Object.assign(op.requestBody, result);
              if (!op.requestBody["x-s2o-name"]) {
                if (op.requestBody.schema && op.requestBody.schema.$ref) {
                  op.requestBody["x-s2o-name"] = decodeURIComponent(op.requestBody.schema.$ref.replace("#/components/schemas/", "")).split("/").join("");
                } else if (op.operationId) {
                  op.requestBody["x-s2o-name"] = common2.sanitiseAll(op.operationId);
                }
              }
            }
          }
        }
      }
      if (param && !param["x-s2o-delete"]) {
        delete param.type;
        for (let prop of common2.parameterTypeProperties) {
          delete param[prop];
        }
        if (param.in === "path" && (typeof param.required === "undefined" || param.required !== true)) {
          if (options.patch) {
            options.patches++;
            param.required = true;
          } else {
            throwError2("(Patchable) path parameters must be required:true [" + param.name + " in " + index + "]", options);
          }
        }
      }
      return op;
    }
    function copyExtensions(src, tgt) {
      for (let prop in src) {
        if (prop.startsWith("x-") && !prop.startsWith("x-s2o")) {
          tgt[prop] = src[prop];
        }
      }
    }
    function processResponse(response, name, op, openapi, options) {
      if (!response) return false;
      if (response.$ref && typeof response.$ref === "string") {
        if (response.$ref.indexOf("#/definitions/") >= 0) {
          throwOrWarn("definition used as response: " + response.$ref, response, options);
        } else {
          if (response.$ref.startsWith("#/responses/")) {
            response.$ref = "#/components/responses/" + common2.sanitise(decodeURIComponent(response.$ref.replace("#/responses/", "")));
          }
        }
      } else {
        if (typeof response.description === "undefined" || response.description === null || response.description === "" && options.patch) {
          if (options.patch) {
            if (typeof response === "object" && !Array.isArray(response)) {
              options.patches++;
              response.description = statusCodes[response] || "";
            }
          } else {
            throwError2("(Patchable) response.description is mandatory", options);
          }
        }
        if (typeof response.schema !== "undefined") {
          fixUpSchema(response.schema, options);
          if (response.schema.$ref && typeof response.schema.$ref === "string" && response.schema.$ref.startsWith("#/responses/")) {
            response.schema.$ref = "#/components/responses/" + common2.sanitise(decodeURIComponent(response.schema.$ref.replace("#/responses/", "")));
          }
          if (op && op.produces && typeof op.produces === "string") {
            if (options.patch) {
              options.patches++;
              op.produces = [op.produces];
            } else {
              return throwError2("(Patchable) operation.produces must be an array", options);
            }
          }
          if (openapi.produces && !Array.isArray(openapi.produces)) delete openapi.produces;
          let produces = ((op ? op.produces : null) || (openapi.produces || [])).filter(common2.uniqueOnly);
          if (!produces.length) produces.push("*/*");
          response.content = {};
          for (let mimetype of produces) {
            response.content[mimetype] = {};
            response.content[mimetype].schema = clone2(response.schema);
            if (response.examples && response.examples[mimetype]) {
              let example = {};
              example.value = response.examples[mimetype];
              response.content[mimetype].examples = {};
              response.content[mimetype].examples.response = example;
              delete response.examples[mimetype];
            }
            if (response.content[mimetype].schema.type === "file") {
              response.content[mimetype].schema = { type: "string", format: "binary" };
            }
          }
          delete response.schema;
        }
        for (let mimetype in response.examples) {
          if (!response.content) response.content = {};
          if (!response.content[mimetype]) response.content[mimetype] = {};
          response.content[mimetype].examples = {};
          response.content[mimetype].examples.response = {};
          response.content[mimetype].examples.response.value = response.examples[mimetype];
        }
        delete response.examples;
        if (response.headers) {
          for (let h in response.headers) {
            if (h.toLowerCase() === "status code") {
              if (options.patch) {
                options.patches++;
                delete response.headers[h];
              } else {
                throwError2('(Patchable) "Status Code" is not a valid header', options);
              }
            } else {
              processHeader(response.headers[h], options);
            }
          }
        }
      }
    }
    function processPaths(container, containerName, options, requestBodyCache, openapi) {
      for (let p in container) {
        let path = container[p];
        if (path && path["x-trace"] && typeof path["x-trace"] === "object") {
          path.trace = path["x-trace"];
          delete path["x-trace"];
        }
        if (path && path["x-summary"] && typeof path["x-summary"] === "string") {
          path.summary = path["x-summary"];
          delete path["x-summary"];
        }
        if (path && path["x-description"] && typeof path["x-description"] === "string") {
          path.description = path["x-description"];
          delete path["x-description"];
        }
        if (path && path["x-servers"] && Array.isArray(path["x-servers"])) {
          path.servers = path["x-servers"];
          delete path["x-servers"];
        }
        for (let method in path) {
          if (common2.httpMethods.indexOf(method) >= 0 || method === "x-amazon-apigateway-any-method") {
            let op = path[method];
            if (op && op.parameters && Array.isArray(op.parameters)) {
              if (path.parameters) {
                for (let param of path.parameters) {
                  if (typeof param.$ref === "string") {
                    fixParamRef(param, options);
                    param = resolveInternal(openapi, param.$ref);
                  }
                  let match2 = op.parameters.find(function(e, i, a) {
                    return e.name === param.name && e.in === param.in;
                  });
                  if (!match2 && (param.in === "formData" || param.in === "body" || param.type === "file")) {
                    op = processParameter(param, op, path, method, p, openapi, options);
                    if (options.rbname && op[options.rbname] === "") {
                      delete op[options.rbname];
                    }
                  }
                }
              }
              for (let param of op.parameters) {
                op = processParameter(param, op, path, method, method + ":" + p, openapi, options);
              }
              if (options.rbname && op[options.rbname] === "") {
                delete op[options.rbname];
              }
              if (!options.debug) {
                if (op.parameters) op.parameters = op.parameters.filter(keepParameters);
              }
            }
            if (op && op.security) processSecurity(op.security);
            if (typeof op === "object") {
              if (!op.responses) {
                let defaultResp = {};
                defaultResp.description = "Default response";
                op.responses = { default: defaultResp };
              }
              for (let r2 in op.responses) {
                let response = op.responses[r2];
                processResponse(response, r2, op, openapi, options);
              }
            }
            if (op && op["x-servers"] && Array.isArray(op["x-servers"])) {
              op.servers = op["x-servers"];
              delete op["x-servers"];
            } else if (op && op.schemes && op.schemes.length) {
              for (let scheme of op.schemes) {
                if (!openapi.schemes || openapi.schemes.indexOf(scheme) < 0) {
                  if (!op.servers) {
                    op.servers = [];
                  }
                  if (Array.isArray(openapi.servers)) {
                    for (let server of openapi.servers) {
                      let newServer = clone2(server);
                      let serverUrl = url.parse(newServer.url);
                      serverUrl.protocol = scheme;
                      newServer.url = serverUrl.format();
                      op.servers.push(newServer);
                    }
                  }
                }
              }
            }
            if (options.debug) {
              op["x-s2o-consumes"] = op.consumes || [];
              op["x-s2o-produces"] = op.produces || [];
            }
            if (op) {
              delete op.consumes;
              delete op.produces;
              delete op.schemes;
              if (op["x-ms-examples"]) {
                for (let e in op["x-ms-examples"]) {
                  let example = op["x-ms-examples"][e];
                  let se = common2.sanitiseAll(e);
                  if (example.parameters) {
                    for (let p2 in example.parameters) {
                      let value = example.parameters[p2];
                      for (let param of (op.parameters || []).concat(path.parameters || [])) {
                        if (param.$ref) {
                          param = jptr.jptr(openapi, param.$ref);
                        }
                        if (param.name === p2 && !param.example) {
                          if (!param.examples) {
                            param.examples = {};
                          }
                          param.examples[e] = { value };
                        }
                      }
                    }
                  }
                  if (example.responses) {
                    for (let r2 in example.responses) {
                      if (example.responses[r2].headers) {
                        for (let h in example.responses[r2].headers) {
                          let value = example.responses[r2].headers[h];
                          for (let rh in op.responses[r2].headers) {
                            if (rh === h) {
                              let header = op.responses[r2].headers[rh];
                              header.example = value;
                            }
                          }
                        }
                      }
                      if (example.responses[r2].body) {
                        openapi.components.examples[se] = { value: clone2(example.responses[r2].body) };
                        if (op.responses[r2] && op.responses[r2].content) {
                          for (let ct in op.responses[r2].content) {
                            let contentType = op.responses[r2].content[ct];
                            if (!contentType.examples) {
                              contentType.examples = {};
                            }
                            contentType.examples[e] = { $ref: "#/components/examples/" + se };
                          }
                        }
                      }
                    }
                  }
                }
                delete op["x-ms-examples"];
              }
              if (op.parameters && op.parameters.length === 0) delete op.parameters;
              if (op.requestBody) {
                let effectiveOperationId = op.operationId ? common2.sanitiseAll(op.operationId) : common2.sanitiseAll(method + p).toCamelCase();
                let rbName = common2.sanitise(op.requestBody["x-s2o-name"] || effectiveOperationId || "");
                delete op.requestBody["x-s2o-name"];
                let rbStr = JSON.stringify(op.requestBody);
                let rbHash = common2.hash(rbStr);
                if (!requestBodyCache[rbHash]) {
                  let entry = {};
                  entry.name = rbName;
                  entry.body = op.requestBody;
                  entry.refs = [];
                  requestBodyCache[rbHash] = entry;
                }
                let ptr = "#/" + containerName + "/" + encodeURIComponent(jptr.jpescape(p)) + "/" + method + "/requestBody";
                requestBodyCache[rbHash].refs.push(ptr);
              }
            }
          }
        }
        if (path && path.parameters) {
          for (let p2 in path.parameters) {
            let param = path.parameters[p2];
            processParameter(param, null, path, null, p, openapi, options);
          }
          if (!options.debug && Array.isArray(path.parameters)) {
            path.parameters = path.parameters.filter(keepParameters);
          }
        }
      }
    }
    function main2(openapi, options) {
      let requestBodyCache = {};
      componentNames = { schemas: {} };
      if (openapi.security) processSecurity(openapi.security);
      for (let s in openapi.components.securitySchemes) {
        let sname = common2.sanitise(s);
        if (s !== sname) {
          if (openapi.components.securitySchemes[sname]) {
            throwError2("Duplicate sanitised securityScheme name " + sname, options);
          }
          openapi.components.securitySchemes[sname] = openapi.components.securitySchemes[s];
          delete openapi.components.securitySchemes[s];
        }
        processSecurityScheme(openapi.components.securitySchemes[sname], options);
      }
      for (let s in openapi.components.schemas) {
        let sname = common2.sanitiseAll(s);
        let suffix = "";
        if (s !== sname) {
          while (openapi.components.schemas[sname + suffix]) {
            suffix = suffix ? ++suffix : 2;
          }
          openapi.components.schemas[sname + suffix] = openapi.components.schemas[s];
          delete openapi.components.schemas[s];
        }
        componentNames.schemas[s] = sname + suffix;
        fixUpSchema(openapi.components.schemas[sname + suffix], options);
      }
      options.refmap = {};
      recurse(openapi, { payload: { options } }, fixupRefs);
      dedupeRefs(openapi, options);
      for (let p in openapi.components.parameters) {
        let sname = common2.sanitise(p);
        if (p !== sname) {
          if (openapi.components.parameters[sname]) {
            throwError2("Duplicate sanitised parameter name " + sname, options);
          }
          openapi.components.parameters[sname] = openapi.components.parameters[p];
          delete openapi.components.parameters[p];
        }
        let param = openapi.components.parameters[sname];
        processParameter(param, null, null, null, sname, openapi, options);
      }
      for (let r2 in openapi.components.responses) {
        let sname = common2.sanitise(r2);
        if (r2 !== sname) {
          if (openapi.components.responses[sname]) {
            throwError2("Duplicate sanitised response name " + sname, options);
          }
          openapi.components.responses[sname] = openapi.components.responses[r2];
          delete openapi.components.responses[r2];
        }
        let response = openapi.components.responses[sname];
        processResponse(response, sname, null, openapi, options);
        if (response.headers) {
          for (let h in response.headers) {
            if (h.toLowerCase() === "status code") {
              if (options.patch) {
                options.patches++;
                delete response.headers[h];
              } else {
                throwError2('(Patchable) "Status Code" is not a valid header', options);
              }
            } else {
              processHeader(response.headers[h], options);
            }
          }
        }
      }
      for (let r2 in openapi.components.requestBodies) {
        let rb = openapi.components.requestBodies[r2];
        let rbStr = JSON.stringify(rb);
        let rbHash = common2.hash(rbStr);
        let entry = {};
        entry.name = r2;
        entry.body = rb;
        entry.refs = [];
        requestBodyCache[rbHash] = entry;
      }
      processPaths(openapi.paths, "paths", options, requestBodyCache, openapi);
      if (openapi["x-ms-paths"]) {
        processPaths(openapi["x-ms-paths"], "x-ms-paths", options, requestBodyCache, openapi);
      }
      if (!options.debug) {
        for (let p in openapi.components.parameters) {
          let param = openapi.components.parameters[p];
          if (param["x-s2o-delete"]) {
            delete openapi.components.parameters[p];
          }
        }
      }
      if (options.debug) {
        openapi["x-s2o-consumes"] = openapi.consumes || [];
        openapi["x-s2o-produces"] = openapi.produces || [];
      }
      delete openapi.consumes;
      delete openapi.produces;
      delete openapi.schemes;
      let rbNamesGenerated = [];
      openapi.components.requestBodies = {};
      if (!options.resolveInternal) {
        let counter = 1;
        for (let e in requestBodyCache) {
          let entry = requestBodyCache[e];
          if (entry.refs.length > 1) {
            let suffix = "";
            if (!entry.name) {
              entry.name = "requestBody";
              suffix = counter++;
            }
            while (rbNamesGenerated.indexOf(entry.name + suffix) >= 0) {
              suffix = suffix ? ++suffix : 2;
            }
            entry.name = entry.name + suffix;
            rbNamesGenerated.push(entry.name);
            openapi.components.requestBodies[entry.name] = clone2(entry.body);
            for (let r2 in entry.refs) {
              let ref = {};
              ref.$ref = "#/components/requestBodies/" + entry.name;
              jptr.jptr(openapi, entry.refs[r2], ref);
            }
          }
        }
      }
      if (openapi.components.responses && Object.keys(openapi.components.responses).length === 0) {
        delete openapi.components.responses;
      }
      if (openapi.components.parameters && Object.keys(openapi.components.parameters).length === 0) {
        delete openapi.components.parameters;
      }
      if (openapi.components.examples && Object.keys(openapi.components.examples).length === 0) {
        delete openapi.components.examples;
      }
      if (openapi.components.requestBodies && Object.keys(openapi.components.requestBodies).length === 0) {
        delete openapi.components.requestBodies;
      }
      if (openapi.components.securitySchemes && Object.keys(openapi.components.securitySchemes).length === 0) {
        delete openapi.components.securitySchemes;
      }
      if (openapi.components.headers && Object.keys(openapi.components.headers).length === 0) {
        delete openapi.components.headers;
      }
      if (openapi.components.schemas && Object.keys(openapi.components.schemas).length === 0) {
        delete openapi.components.schemas;
      }
      if (openapi.components && Object.keys(openapi.components).length === 0) {
        delete openapi.components;
      }
      return openapi;
    }
    function extractServerParameters(server) {
      if (!server || !server.url || typeof server.url !== "string") return server;
      server.url = server.url.split("{{").join("{");
      server.url = server.url.split("}}").join("}");
      server.url.replace(/\{(.+?)\}/g, function(match2, group1) {
        if (!server.variables) {
          server.variables = {};
        }
        server.variables[group1] = { default: "unknown" };
      });
      return server;
    }
    function fixInfo(openapi, options, reject) {
      if (typeof openapi.info === "undefined" || openapi.info === null) {
        if (options.patch) {
          options.patches++;
          openapi.info = { version: "", title: "" };
        } else {
          return reject(new S2OError("(Patchable) info object is mandatory"));
        }
      }
      if (typeof openapi.info !== "object" || Array.isArray(openapi.info)) {
        return reject(new S2OError("info must be an object"));
      }
      if (typeof openapi.info.title === "undefined" || openapi.info.title === null) {
        if (options.patch) {
          options.patches++;
          openapi.info.title = "";
        } else {
          return reject(new S2OError("(Patchable) info.title cannot be null"));
        }
      }
      if (typeof openapi.info.version === "undefined" || openapi.info.version === null) {
        if (options.patch) {
          options.patches++;
          openapi.info.version = "";
        } else {
          return reject(new S2OError("(Patchable) info.version cannot be null"));
        }
      }
      if (typeof openapi.info.version !== "string") {
        if (options.patch) {
          options.patches++;
          openapi.info.version = openapi.info.version.toString();
        } else {
          return reject(new S2OError("(Patchable) info.version must be a string"));
        }
      }
      if (typeof openapi.info.logo !== "undefined") {
        if (options.patch) {
          options.patches++;
          openapi.info["x-logo"] = openapi.info.logo;
          delete openapi.info.logo;
        } else return reject(new S2OError("(Patchable) info should not have logo property"));
      }
      if (typeof openapi.info.termsOfService !== "undefined") {
        if (openapi.info.termsOfService === null) {
          if (options.patch) {
            options.patches++;
            openapi.info.termsOfService = "";
          } else {
            return reject(new S2OError("(Patchable) info.termsOfService cannot be null"));
          }
        }
        try {
          let u = new URL(openapi.info.termsOfService);
        } catch (ex) {
          if (options.patch) {
            options.patches++;
            delete openapi.info.termsOfService;
          } else return reject(new S2OError("(Patchable) info.termsOfService must be a URL"));
        }
      }
    }
    function fixPaths(openapi, options, reject) {
      if (typeof openapi.paths === "undefined") {
        if (options.patch) {
          options.patches++;
          openapi.paths = {};
        } else {
          return reject(new S2OError("(Patchable) paths object is mandatory"));
        }
      }
    }
    function detectObjectReferences(obj, options) {
      const seen = /* @__PURE__ */ new WeakSet();
      recurse(obj, { identityDetection: true }, function(obj2, key, state) {
        if (typeof obj2[key] === "object" && obj2[key] !== null) {
          if (seen.has(obj2[key])) {
            if (options.anchors) {
              obj2[key] = clone2(obj2[key]);
            } else {
              throwError2("YAML anchor or merge key at " + state.path, options);
            }
          } else {
            seen.add(obj2[key]);
          }
        }
      });
    }
    function convertObj(swagger, options, callback) {
      return maybe(callback, new Promise(function(resolve, reject) {
        if (!swagger) swagger = {};
        options.original = swagger;
        if (!options.text) options.text = yaml.stringify(swagger);
        options.externals = [];
        options.externalRefs = {};
        options.rewriteRefs = true;
        options.preserveMiro = true;
        options.promise = {};
        options.promise.resolve = resolve;
        options.promise.reject = reject;
        options.patches = 0;
        if (!options.cache) options.cache = {};
        if (options.source) options.cache[options.source] = options.original;
        detectObjectReferences(swagger, options);
        if (swagger.openapi && typeof swagger.openapi === "string" && swagger.openapi.startsWith("3.")) {
          options.openapi = cclone(swagger);
          fixInfo(options.openapi, options, reject);
          fixPaths(options.openapi, options, reject);
          resolver.optionalResolve(options).then(function() {
            if (options.direct) {
              return resolve(options.openapi);
            } else {
              return resolve(options);
            }
          }).catch(function(ex) {
            console.warn(ex);
            reject(ex);
          });
          return;
        }
        if (!swagger.swagger || swagger.swagger != "2.0") {
          return reject(new S2OError("Unsupported swagger/OpenAPI version: " + (swagger.openapi ? swagger.openapi : swagger.swagger)));
        }
        let openapi = options.openapi = {};
        openapi.openapi = typeof options.targetVersion === "string" && options.targetVersion.startsWith("3.") ? options.targetVersion : targetVersion;
        if (options.origin) {
          if (!openapi["x-origin"]) {
            openapi["x-origin"] = [];
          }
          let origin = {};
          origin.url = options.source || options.origin;
          origin.format = "swagger";
          origin.version = swagger.swagger;
          origin.converter = {};
          origin.converter.url = "https://github.com/mermade/oas-kit";
          origin.converter.version = ourVersion;
          openapi["x-origin"].push(origin);
        }
        openapi = Object.assign(openapi, cclone(swagger));
        delete openapi.swagger;
        recurse(openapi, {}, function(obj, key, state) {
          if (obj[key] === null && !key.startsWith("x-") && key !== "default" && state.path.indexOf("/example") < 0) delete obj[key];
        });
        if (swagger.host) {
          for (let s of Array.isArray(swagger.schemes) ? swagger.schemes : [""]) {
            let server = {};
            let basePath = (swagger.basePath || "").replace(/\/$/, "");
            server.url = (s ? s + ":" : "") + "//" + swagger.host + basePath;
            extractServerParameters(server);
            if (!openapi.servers) openapi.servers = [];
            openapi.servers.push(server);
          }
        } else if (swagger.basePath) {
          let server = {};
          server.url = swagger.basePath;
          extractServerParameters(server);
          if (!openapi.servers) openapi.servers = [];
          openapi.servers.push(server);
        }
        delete openapi.host;
        delete openapi.basePath;
        if (openapi["x-servers"] && Array.isArray(openapi["x-servers"])) {
          openapi.servers = openapi["x-servers"];
          delete openapi["x-servers"];
        }
        if (swagger["x-ms-parameterized-host"]) {
          let xMsPHost = swagger["x-ms-parameterized-host"];
          let server = {};
          server.url = xMsPHost.hostTemplate + (swagger.basePath ? swagger.basePath : "");
          server.variables = {};
          const paramNames = server.url.match(/\{\w+\}/g);
          for (let msp in xMsPHost.parameters) {
            let param = xMsPHost.parameters[msp];
            if (param.$ref) {
              param = clone2(resolveInternal(openapi, param.$ref));
            }
            if (!msp.startsWith("x-")) {
              delete param.required;
              delete param.type;
              delete param.in;
              if (typeof param.default === "undefined") {
                if (param.enum) {
                  param.default = param.enum[0];
                } else {
                  param.default = "none";
                }
              }
              if (!param.name) {
                param.name = paramNames[msp].replace("{", "").replace("}", "");
              }
              server.variables[param.name] = param;
              delete param.name;
            }
          }
          if (!openapi.servers) openapi.servers = [];
          if (xMsPHost.useSchemePrefix === false) {
            openapi.servers.push(server);
          } else {
            swagger.schemes.forEach((scheme) => {
              openapi.servers.push(
                Object.assign({}, server, { url: scheme + "://" + server.url })
              );
            });
          }
          delete openapi["x-ms-parameterized-host"];
        }
        fixInfo(openapi, options, reject);
        fixPaths(openapi, options, reject);
        if (typeof openapi.consumes === "string") {
          openapi.consumes = [openapi.consumes];
        }
        if (typeof openapi.produces === "string") {
          openapi.produces = [openapi.produces];
        }
        openapi.components = {};
        if (openapi["x-callbacks"]) {
          openapi.components.callbacks = openapi["x-callbacks"];
          delete openapi["x-callbacks"];
        }
        openapi.components.examples = {};
        openapi.components.headers = {};
        if (openapi["x-links"]) {
          openapi.components.links = openapi["x-links"];
          delete openapi["x-links"];
        }
        openapi.components.parameters = openapi.parameters || {};
        openapi.components.responses = openapi.responses || {};
        openapi.components.requestBodies = {};
        openapi.components.securitySchemes = openapi.securityDefinitions || {};
        openapi.components.schemas = openapi.definitions || {};
        delete openapi.definitions;
        delete openapi.responses;
        delete openapi.parameters;
        delete openapi.securityDefinitions;
        resolver.optionalResolve(options).then(function() {
          main2(options.openapi, options);
          if (options.direct) {
            resolve(options.openapi);
          } else {
            resolve(options);
          }
        }).catch(function(ex) {
          console.warn(ex);
          reject(ex);
        });
      }));
    }
    function convertStr(str2, options, callback) {
      return maybe(callback, new Promise(function(resolve, reject) {
        let obj = null;
        let error = null;
        try {
          obj = JSON.parse(str2);
          options.text = JSON.stringify(obj, null, 2);
        } catch (ex) {
          error = ex;
          try {
            obj = yaml.parse(str2, { schema: "core", prettyErrors: true });
            options.sourceYaml = true;
            options.text = str2;
          } catch (ex2) {
            error = ex2;
          }
        }
        if (obj) {
          convertObj(obj, options).then((options2) => resolve(options2)).catch((ex) => reject(ex));
        } else {
          reject(new S2OError(error ? error.message : "Could not parse string"));
        }
      }));
    }
    function convertUrl(url2, options, callback) {
      return maybe(callback, new Promise(function(resolve, reject) {
        options.origin = true;
        if (!options.source) {
          options.source = url2;
        }
        if (options.verbose) {
          console.warn("GET " + url2);
        }
        if (!options.fetch) {
          options.fetch = fetch4;
        }
        const fetchOptions = Object.assign({}, options.fetchOptions, { agent: options.agent });
        options.fetch(url2, fetchOptions).then(function(res) {
          if (res.status !== 200) throw new S2OError(`Received status code ${res.status}: ${url2}`);
          return res.text();
        }).then(function(body) {
          convertStr(body, options).then((options2) => resolve(options2)).catch((ex) => reject(ex));
        }).catch(function(err) {
          reject(err);
        });
      }));
    }
    function convertFile(filename, options, callback) {
      return maybe(callback, new Promise(function(resolve, reject) {
        fs3.readFile(filename, options.encoding || "utf8", function(err, s) {
          if (err) {
            reject(err);
          } else {
            options.sourceFile = filename;
            convertStr(s, options).then((options2) => resolve(options2)).catch((ex) => reject(ex));
          }
        });
      }));
    }
    function convertStream(readable, options, callback) {
      return maybe(callback, new Promise(function(resolve, reject) {
        let data = "";
        readable.on("data", function(chunk) {
          data += chunk;
        }).on("end", function() {
          convertStr(data, options).then((options2) => resolve(options2)).catch((ex) => reject(ex));
        });
      }));
    }
    module2.exports = {
      S2OError,
      targetVersion,
      convert: convertObj,
      convertObj,
      convertUrl,
      convertStr,
      convertFile,
      convertStream
    };
  }
});

// src/main.ts
var import_command_line_args = __toESM(require_dist());

// node_modules/@readme/httpsnippet/dist/chunk-Y7NI4MMY.js
var DEFAULT_INDENTATION_CHARACTER = "";
var DEFAULT_LINE_JOIN = "\n";
var CodeBuilder = class {
  /**
   * Helper object to format and aggragate lines of code.
   * Lines are aggregated in a `code` array, and need to be joined to obtain a proper code snippet.
   */
  constructor({ indent, join } = {}) {
    this.postProcessors = [];
    this.code = [];
    this.indentationCharacter = DEFAULT_INDENTATION_CHARACTER;
    this.lineJoin = DEFAULT_LINE_JOIN;
    this.indentLine = (line, indentationLevel = 0) => {
      const indent2 = this.indentationCharacter.repeat(indentationLevel);
      return `${indent2}${line}`;
    };
    this.unshift = (line, indentationLevel) => {
      const newLine = this.indentLine(line, indentationLevel);
      this.code.unshift(newLine);
    };
    this.push = (line, indentationLevel) => {
      const newLine = this.indentLine(line, indentationLevel);
      this.code.push(newLine);
    };
    this.blank = () => {
      this.code.push("");
    };
    this.join = () => {
      const unreplacedCode = this.code.join(this.lineJoin);
      const replacedOutput = this.postProcessors.reduce((accumulator, replacer) => replacer(accumulator), unreplacedCode);
      return replacedOutput;
    };
    this.addPostProcessor = (postProcessor) => {
      this.postProcessors = [...this.postProcessors, postProcessor];
    };
    this.indentationCharacter = indent || DEFAULT_INDENTATION_CHARACTER;
    this.lineJoin = join ?? DEFAULT_LINE_JOIN;
  }
};

// node_modules/@readme/httpsnippet/dist/chunk-QBICEG2V.js
var import_stringify_object = __toESM(require_stringify_object(), 1);
function escapeString(rawValue, options = {}) {
  const { delimiter = '"', escapeChar = "\\", escapeNewlines = true } = options;
  const stringValue = rawValue.toString();
  return [...stringValue].map((c2) => {
    if (c2 === "\b") {
      return `${escapeChar}b`;
    } else if (c2 === "	") {
      return `${escapeChar}t`;
    } else if (c2 === "\n") {
      if (escapeNewlines) {
        return `${escapeChar}n`;
      }
      return c2;
    } else if (c2 === "\f") {
      return `${escapeChar}f`;
    } else if (c2 === "\r") {
      if (escapeNewlines) {
        return `${escapeChar}r`;
      }
      return c2;
    } else if (c2 === escapeChar) {
      return escapeChar + escapeChar;
    } else if (c2 === delimiter) {
      return escapeChar + delimiter;
    } else if (c2 < " " || c2 > "~") {
      return JSON.stringify(c2).slice(1, -1);
    }
    return c2;
  }).join("");
}
var escapeForSingleQuotes = (value) => escapeString(value, { delimiter: "'" });
var escapeForDoubleQuotes = (value) => escapeString(value, { delimiter: '"' });
var libcurl = {
  info: {
    key: "libcurl",
    title: "Libcurl",
    link: "http://curl.haxx.se/libcurl",
    description: "Simple REST and HTTP API Client for C",
    extname: ".c"
  },
  convert: ({ method, fullUrl, headersObj, allHeaders, postData }) => {
    const { push, blank, join } = new CodeBuilder();
    push("CURL *hnd = curl_easy_init();");
    blank();
    push(`curl_easy_setopt(hnd, CURLOPT_CUSTOMREQUEST, "${method.toUpperCase()}");`);
    push("curl_easy_setopt(hnd, CURLOPT_WRITEDATA, stdout);");
    push(`curl_easy_setopt(hnd, CURLOPT_URL, "${fullUrl}");`);
    const headers = Object.keys(headersObj);
    if (headers.length) {
      blank();
      push("struct curl_slist *headers = NULL;");
      headers.forEach((header) => {
        push(`headers = curl_slist_append(headers, "${header}: ${escapeForDoubleQuotes(headersObj[header])}");`);
      });
      push("curl_easy_setopt(hnd, CURLOPT_HTTPHEADER, headers);");
    }
    if (allHeaders.cookie) {
      blank();
      push(`curl_easy_setopt(hnd, CURLOPT_COOKIE, "${allHeaders.cookie}");`);
    }
    if (postData.text) {
      blank();
      push(`curl_easy_setopt(hnd, CURLOPT_POSTFIELDS, ${JSON.stringify(postData.text)});`);
    }
    blank();
    push("CURLcode ret = curl_easy_perform(hnd);");
    return join();
  }
};
var c = {
  info: {
    key: "c",
    title: "C",
    default: "libcurl",
    cli: "c"
  },
  clientsById: {
    libcurl
  }
};
var getHeaderName = (headers, name) => Object.keys(headers).find((header) => header.toLowerCase() === name.toLowerCase());
var getHeader = (headers, name) => {
  const headerName = getHeaderName(headers, name);
  if (!headerName) {
    return void 0;
  }
  return headers[headerName];
};
var hasHeader = (headers, name) => Boolean(getHeaderName(headers, name));
var isMimeTypeJSON = (mimeType) => ["application/json", "application/x-json", "text/json", "text/x-json", "+json"].some(
  (type2) => mimeType.indexOf(type2) > -1
);
var Keyword = class {
  constructor(name) {
    this.name = "";
    this.toString = () => `:${this.name}`;
    this.name = name;
  }
};
var File = class {
  constructor(path) {
    this.path = "";
    this.toString = () => `(clojure.java.io/file "${this.path}")`;
    this.path = path;
  }
};
var jsType = (input) => {
  if (input === void 0) {
    return null;
  }
  if (input === null) {
    return "null";
  }
  return input.constructor.name.toLowerCase();
};
var objEmpty = (input) => {
  if (input === void 0) {
    return true;
  } else if (jsType(input) === "object") {
    return Object.keys(input).length === 0;
  }
  return false;
};
var filterEmpty = (input) => {
  Object.keys(input).filter((x) => objEmpty(input[x])).forEach((x) => {
    delete input[x];
  });
  return input;
};
var padBlock = (padSize, input) => {
  const padding = " ".repeat(padSize);
  return input.replace(/\n/g, `
${padding}`);
};
var jsToEdn = (js) => {
  switch (jsType(js)) {
    case "string":
      return `"${js.replace(/"/g, '\\"')}"`;
    case "file":
      return js.toString();
    case "keyword":
      return js.toString();
    case "null":
      return "nil";
    case "regexp":
      return `#"${js.source}"`;
    case "object": {
      const obj = Object.keys(js).reduce((accumulator, key) => {
        const val = padBlock(key.length + 2, jsToEdn(js[key]));
        return `${accumulator}:${key} ${val}
 `;
      }, "").trim();
      return `{${padBlock(1, obj)}}`;
    }
    case "array": {
      const arr = js.reduce((accumulator, value) => `${accumulator} ${jsToEdn(value)}`, "").trim();
      return `[${padBlock(1, arr)}]`;
    }
    default:
      return js.toString();
  }
};
var clj_http = {
  info: {
    key: "clj_http",
    title: "clj-http",
    link: "https://github.com/dakrone/clj-http",
    description: "An idiomatic clojure http client wrapping the apache client.",
    extname: ".clj"
  },
  convert: ({ queryObj, method, postData, url, allHeaders }, options) => {
    const { push, join } = new CodeBuilder({ indent: options?.indent });
    const methods = ["get", "post", "put", "delete", "patch", "head", "options"];
    method = method.toLowerCase();
    if (!methods.includes(method)) {
      push("Method not supported");
      return join();
    }
    const params2 = {
      headers: allHeaders,
      "query-params": queryObj
    };
    switch (postData.mimeType) {
      case "application/json":
        {
          params2["content-type"] = new Keyword("json");
          params2["form-params"] = postData.jsonObj;
          const header = getHeaderName(params2.headers, "content-type");
          if (header) {
            delete params2.headers[header];
          }
        }
        break;
      case "application/x-www-form-urlencoded":
        {
          params2["form-params"] = postData.paramsObj;
          const header = getHeaderName(params2.headers, "content-type");
          if (header) {
            delete params2.headers[header];
          }
        }
        break;
      case "text/plain":
        {
          params2.body = postData.text;
          const header = getHeaderName(params2.headers, "content-type");
          if (header) {
            delete params2.headers[header];
          }
        }
        break;
      case "multipart/form-data": {
        if (postData.params) {
          params2.multipart = postData.params.map((param) => {
            if (param.fileName && !param.value) {
              return {
                name: param.name,
                content: new File(param.fileName)
              };
            }
            return {
              name: param.name,
              content: param.value
            };
          });
          const header = getHeaderName(params2.headers, "content-type");
          if (header) {
            delete params2.headers[header];
          }
        }
        break;
      }
    }
    switch (getHeader(params2.headers, "accept")) {
      case "application/json":
        {
          params2.accept = new Keyword("json");
          const header = getHeaderName(params2.headers, "accept");
          if (header) {
            delete params2.headers[header];
          }
        }
        break;
    }
    push("(require '[clj-http.client :as client])\n");
    if (objEmpty(filterEmpty(params2))) {
      push(`(client/${method} "${url}")`);
    } else {
      const padding = 11 + method.length + url.length;
      const formattedParams = padBlock(padding, jsToEdn(filterEmpty(params2)));
      push(`(client/${method} "${url}" ${formattedParams})`);
    }
    return join();
  }
};
var clojure = {
  info: {
    key: "clojure",
    title: "Clojure",
    default: "clj_http"
  },
  clientsById: {
    clj_http
  }
};
var getDecompressionMethods = (allHeaders) => {
  let acceptEncodings = getHeader(allHeaders, "accept-encoding");
  if (!acceptEncodings) {
    return [];
  }
  const supportedMethods22 = {
    gzip: "DecompressionMethods.GZip",
    deflate: "DecompressionMethods.Deflate"
  };
  const methods = [];
  if (typeof acceptEncodings === "string") {
    acceptEncodings = [acceptEncodings];
  }
  acceptEncodings.forEach((acceptEncoding) => {
    acceptEncoding.split(",").forEach((encoding) => {
      const match2 = /\s*([^;\s]+)/.exec(encoding);
      if (match2) {
        const method = supportedMethods22[match2[1]];
        if (method) {
          methods.push(method);
        }
      }
    });
  });
  return methods;
};
var httpclient = {
  info: {
    key: "httpclient",
    title: "HttpClient",
    link: "https://docs.microsoft.com/en-us/dotnet/api/system.net.http.httpclient",
    description: ".NET Standard HTTP Client",
    extname: ".cs"
  },
  convert: ({ allHeaders, postData, method, fullUrl }, options) => {
    const opts = {
      indent: "    ",
      ...options
    };
    const { push, join } = new CodeBuilder({ indent: opts.indent });
    push("using System.Net.Http.Headers;");
    let clienthandler = "";
    const cookies = Boolean(allHeaders.cookie);
    const decompressionMethods = getDecompressionMethods(allHeaders);
    if (cookies || decompressionMethods.length) {
      clienthandler = "clientHandler";
      push("var clientHandler = new HttpClientHandler");
      push("{");
      if (cookies) {
        push("UseCookies = false,", 1);
      }
      if (decompressionMethods.length) {
        push(`AutomaticDecompression = ${decompressionMethods.join(" | ")},`, 1);
      }
      push("};");
    }
    push(`var client = new HttpClient(${clienthandler});`);
    push("var request = new HttpRequestMessage");
    push("{");
    const methods = ["GET", "POST", "PUT", "DELETE", "PATCH", "HEAD", "OPTIONS", "TRACE"];
    method = method.toUpperCase();
    if (method && methods.includes(method)) {
      method = `HttpMethod.${method[0]}${method.substring(1).toLowerCase()}`;
    } else {
      method = `new HttpMethod("${method}")`;
    }
    push(`Method = ${method},`, 1);
    push(`RequestUri = new Uri("${fullUrl}"),`, 1);
    const headers = Object.keys(allHeaders).filter((header) => {
      switch (header.toLowerCase()) {
        case "content-type":
        case "content-length":
        case "accept-encoding":
          return false;
        default:
          return true;
      }
    });
    if (headers.length) {
      push("Headers =", 1);
      push("{", 1);
      headers.forEach((key) => {
        push(`{ "${key}", "${escapeForDoubleQuotes(allHeaders[key])}" },`, 2);
      });
      push("},", 1);
    }
    if (postData.text) {
      const contentType = postData.mimeType;
      switch (contentType) {
        case "application/x-www-form-urlencoded":
          push("Content = new FormUrlEncodedContent(new Dictionary<string, string>", 1);
          push("{", 1);
          postData.params?.forEach((param) => {
            push(`{ "${param.name}", "${param.value}" },`, 2);
          });
          push("}),", 1);
          break;
        case "multipart/form-data":
          push("Content = new MultipartFormDataContent", 1);
          push("{", 1);
          postData.params?.forEach((param) => {
            push(`new StringContent(${JSON.stringify(param.value || "")})`, 2);
            push("{", 2);
            push("Headers =", 3);
            push("{", 3);
            if (param.contentType) {
              push(`ContentType = new MediaTypeHeaderValue("${param.contentType}"),`, 4);
            }
            push('ContentDisposition = new ContentDispositionHeaderValue("form-data")', 4);
            push("{", 4);
            push(`Name = "${param.name}",`, 5);
            if (param.fileName) {
              push(`FileName = "${param.fileName}",`, 5);
            }
            push("}", 4);
            push("}", 3);
            push("},", 2);
          });
          push("},", 1);
          break;
        default:
          push(`Content = new StringContent(${JSON.stringify(postData.text || "")})`, 1);
          push("{", 1);
          push("Headers =", 2);
          push("{", 2);
          push(`ContentType = new MediaTypeHeaderValue("${contentType}")`, 3);
          push("}", 2);
          push("}", 1);
          break;
      }
    }
    push("};");
    push("using (var response = await client.SendAsync(request))");
    push("{");
    push("response.EnsureSuccessStatusCode();", 1);
    push("var body = await response.Content.ReadAsStringAsync();", 1);
    push("Console.WriteLine(body);", 1);
    push("}");
    return join();
  }
};
function title(s) {
  return s[0].toUpperCase() + s.slice(1).toLowerCase();
}
var restsharp = {
  info: {
    key: "restsharp",
    title: "RestSharp",
    link: "http://restsharp.org/",
    description: "Simple REST and HTTP API Client for .NET",
    extname: ".cs",
    installation: "dotnet add package RestSharp"
  },
  convert: ({ method, fullUrl, headersObj, cookies, postData, uriObj }) => {
    const { push, join } = new CodeBuilder();
    const isSupportedMethod = ["GET", "POST", "PUT", "DELETE", "PATCH", "HEAD", "OPTIONS"].includes(
      method.toUpperCase()
    );
    if (!isSupportedMethod) {
      return "Method not supported";
    }
    push("using RestSharp;\n\n");
    push(`var options = new RestClientOptions("${fullUrl}");`);
    push("var client = new RestClient(options);");
    push('var request = new RestRequest("");');
    const isMultipart = postData.mimeType && postData.mimeType === "multipart/form-data";
    if (isMultipart) {
      push("request.AlwaysMultipartFormData = true;");
    }
    Object.keys(headersObj).forEach((key) => {
      if (postData.mimeType && key.toLowerCase() === "content-type" && postData.text) {
        if (isMultipart && postData.boundary) {
          push(`request.FormBoundary = "${postData.boundary}";`);
        }
        return;
      }
      push(`request.AddHeader("${key}", "${escapeForDoubleQuotes(headersObj[key])}");`);
    });
    cookies.forEach(({ name, value }) => {
      push(`request.AddCookie("${name}", "${escapeForDoubleQuotes(value)}", "${uriObj.pathname}", "${uriObj.host}");`);
    });
    switch (postData.mimeType) {
      case "multipart/form-data":
        if (!postData.params)
          break;
        postData.params.forEach((param) => {
          if (param.fileName) {
            push(`request.AddFile("${param.name}", "${param.fileName}");`);
          } else {
            push(`request.AddParameter("${param.name}", "${param.value}");`);
          }
        });
        break;
      case "application/x-www-form-urlencoded":
        if (!postData.params)
          break;
        postData.params.forEach((param) => {
          push(`request.AddParameter("${param.name}", "${param.value}");`);
        });
        break;
      case "application/json": {
        if (!postData.text)
          break;
        const text = JSON.stringify(postData.text);
        push(`request.AddJsonBody(${text}, false);`);
        break;
      }
      default:
        if (!postData.text)
          break;
        push(`request.AddStringBody("${postData.text}", "${postData.mimeType}");`);
    }
    push(`var response = await client.${title(method)}Async(request);
`);
    push('Console.WriteLine("{0}", response.Content);\n');
    return join();
  }
};
var csharp = {
  info: {
    key: "csharp",
    title: "C#",
    default: "restsharp",
    cli: "dotnet"
  },
  clientsById: {
    httpclient,
    restsharp
  }
};
var native = {
  info: {
    key: "native",
    title: "NewRequest",
    link: "http://golang.org/pkg/net/http/#NewRequest",
    description: "Golang HTTP client request",
    extname: ".go"
  },
  convert: ({ postData, method, allHeaders, fullUrl }, options = {}) => {
    const { blank, push, join } = new CodeBuilder({ indent: "	" });
    const { showBoilerplate = true, checkErrors = false, printBody = true, timeout = -1 } = options;
    const errorPlaceholder = checkErrors ? "err" : "_";
    const indent = showBoilerplate ? 1 : 0;
    const errorCheck = () => {
      if (checkErrors) {
        push("if err != nil {", indent);
        push("panic(err)", indent + 1);
        push("}", indent);
      }
    };
    if (showBoilerplate) {
      push("package main");
      blank();
      push("import (");
      push('"fmt"', indent);
      if (timeout > 0) {
        push('"time"', indent);
      }
      if (postData.text) {
        push('"strings"', indent);
      }
      push('"net/http"', indent);
      if (printBody) {
        push('"io"', indent);
      }
      push(")");
      blank();
      push("func main() {");
      blank();
    }
    const hasTimeout = timeout > 0;
    const hasClient = hasTimeout;
    const client = hasClient ? "client" : "http.DefaultClient";
    if (hasClient) {
      push("client := http.Client{", indent);
      if (hasTimeout) {
        push(`Timeout: time.Duration(${timeout} * time.Second),`, indent + 1);
      }
      push("}", indent);
      blank();
    }
    push(`url := "${fullUrl}"`, indent);
    blank();
    if (postData.text) {
      push(`payload := strings.NewReader(${JSON.stringify(postData.text)})`, indent);
      blank();
      push(`req, ${errorPlaceholder} := http.NewRequest("${method}", url, payload)`, indent);
      blank();
    } else {
      push(`req, ${errorPlaceholder} := http.NewRequest("${method}", url, nil)`, indent);
      blank();
    }
    errorCheck();
    if (Object.keys(allHeaders).length) {
      Object.keys(allHeaders).forEach((key) => {
        push(`req.Header.Add("${key}", "${escapeForDoubleQuotes(allHeaders[key])}")`, indent);
      });
      blank();
    }
    push(`res, ${errorPlaceholder} := ${client}.Do(req)`, indent);
    errorCheck();
    if (printBody) {
      blank();
      push("defer res.Body.Close()", indent);
      push(`body, ${errorPlaceholder} := io.ReadAll(res.Body)`, indent);
      errorCheck();
    }
    blank();
    if (printBody) {
      push("fmt.Println(string(body))", indent);
    }
    if (showBoilerplate) {
      blank();
      push("}");
    }
    return join();
  }
};
var go = {
  info: {
    key: "go",
    title: "Go",
    default: "native",
    cli: "go"
  },
  clientsById: {
    native
  }
};
var CRLF = "\r\n";
var http11 = {
  info: {
    key: "http1.1",
    title: "HTTP/1.1",
    link: "https://tools.ietf.org/html/rfc7230",
    description: "HTTP/1.1 request string in accordance with RFC 7230",
    extname: null
  },
  convert: ({ method, fullUrl, uriObj, httpVersion, allHeaders, postData }, options) => {
    const opts = {
      absoluteURI: false,
      autoContentLength: true,
      autoHost: true,
      ...options
    };
    const { blank, push, join } = new CodeBuilder({ indent: "", join: CRLF });
    const requestUrl = opts.absoluteURI ? fullUrl : uriObj.path;
    push(`${method} ${requestUrl} ${httpVersion}`);
    const headerKeys = Object.keys(allHeaders);
    headerKeys.forEach((key) => {
      const keyCapitalized = key.toLowerCase().replace(/(^|-)(\w)/g, (input) => input.toUpperCase());
      push(`${keyCapitalized}: ${allHeaders[key]}`);
    });
    if (opts.autoHost && !headerKeys.includes("host")) {
      push(`Host: ${uriObj.host}`);
    }
    if (opts.autoContentLength && postData.text && !headerKeys.includes("content-length")) {
      const length = Buffer.byteLength(postData.text, "ascii").toString();
      push(`Content-Length: ${length}`);
    }
    blank();
    const headerSection = join();
    const messageBody = postData.text || "";
    return `${headerSection}${CRLF}${messageBody}`;
  }
};
var http = {
  info: {
    key: "http",
    title: "HTTP",
    default: "http1.1"
  },
  clientsById: {
    "http1.1": http11
  }
};
var asynchttp = {
  info: {
    key: "asynchttp",
    title: "AsyncHttp",
    link: "https://github.com/AsyncHttpClient/async-http-client",
    description: "Asynchronous Http and WebSocket Client library for Java",
    extname: ".java"
  },
  convert: ({ method, allHeaders, postData, fullUrl }, options) => {
    const opts = {
      indent: "  ",
      ...options
    };
    const { blank, push, join } = new CodeBuilder({ indent: opts.indent });
    push("AsyncHttpClient client = new DefaultAsyncHttpClient();");
    push(`client.prepare("${method.toUpperCase()}", "${fullUrl}")`);
    Object.keys(allHeaders).forEach((key) => {
      push(`.setHeader("${key}", "${escapeForDoubleQuotes(allHeaders[key])}")`, 1);
    });
    if (postData.text) {
      push(`.setBody(${JSON.stringify(postData.text)})`, 1);
    }
    push(".execute()", 1);
    push(".toCompletableFuture()", 1);
    push(".thenAccept(System.out::println)", 1);
    push(".join();", 1);
    blank();
    push("client.close();");
    return join();
  }
};
var nethttp = {
  info: {
    key: "nethttp",
    title: "java.net.http",
    link: "https://openjdk.java.net/groups/net/httpclient/intro.html",
    description: "Java Standardized HTTP Client API",
    extname: ".java"
  },
  convert: ({ allHeaders, fullUrl, method, postData }, options) => {
    const opts = {
      indent: "  ",
      ...options
    };
    const { push, join } = new CodeBuilder({ indent: opts.indent });
    push("HttpRequest request = HttpRequest.newBuilder()");
    push(`.uri(URI.create("${fullUrl}"))`, 2);
    Object.keys(allHeaders).forEach((key) => {
      push(`.header("${key}", "${escapeForDoubleQuotes(allHeaders[key])}")`, 2);
    });
    if (postData.text) {
      push(
        `.method("${method.toUpperCase()}", HttpRequest.BodyPublishers.ofString(${JSON.stringify(postData.text)}))`,
        2
      );
    } else {
      push(`.method("${method.toUpperCase()}", HttpRequest.BodyPublishers.noBody())`, 2);
    }
    push(".build();", 2);
    push(
      "HttpResponse<String> response = HttpClient.newHttpClient().send(request, HttpResponse.BodyHandlers.ofString());"
    );
    push("System.out.println(response.body());");
    return join();
  }
};
var okhttp = {
  info: {
    key: "okhttp",
    title: "OkHttp",
    link: "http://square.github.io/okhttp/",
    description: "An HTTP Request Client Library",
    extname: ".java"
  },
  convert: ({ postData, method, fullUrl, allHeaders }, options) => {
    const opts = {
      indent: "  ",
      ...options
    };
    const { push, blank, join } = new CodeBuilder({ indent: opts.indent });
    const methods = ["GET", "POST", "PUT", "DELETE", "PATCH", "HEAD"];
    const methodsWithBody = ["POST", "PUT", "DELETE", "PATCH"];
    push("OkHttpClient client = new OkHttpClient();");
    blank();
    if (postData.text) {
      if (postData.boundary) {
        push(`MediaType mediaType = MediaType.parse("${postData.mimeType}; boundary=${postData.boundary}");`);
      } else {
        push(`MediaType mediaType = MediaType.parse("${postData.mimeType}");`);
      }
      push(`RequestBody body = RequestBody.create(mediaType, ${JSON.stringify(postData.text)});`);
    }
    push("Request request = new Request.Builder()");
    push(`.url("${fullUrl}")`, 1);
    if (!methods.includes(method.toUpperCase())) {
      if (postData.text) {
        push(`.method("${method.toUpperCase()}", body)`, 1);
      } else {
        push(`.method("${method.toUpperCase()}", null)`, 1);
      }
    } else if (methodsWithBody.includes(method.toUpperCase())) {
      if (postData.text) {
        push(`.${method.toLowerCase()}(body)`, 1);
      } else {
        push(`.${method.toLowerCase()}(null)`, 1);
      }
    } else {
      push(`.${method.toLowerCase()}()`, 1);
    }
    Object.keys(allHeaders).forEach((key) => {
      push(`.addHeader("${key}", "${escapeForDoubleQuotes(allHeaders[key])}")`, 1);
    });
    push(".build();", 1);
    blank();
    push("Response response = client.newCall(request).execute();");
    return join();
  }
};
var unirest = {
  info: {
    key: "unirest",
    title: "Unirest",
    link: "http://unirest.io/java.html",
    description: "Lightweight HTTP Request Client Library",
    extname: ".java"
  },
  convert: ({ method, allHeaders, postData, fullUrl }, options) => {
    const opts = {
      indent: "  ",
      ...options
    };
    const { join, push } = new CodeBuilder({ indent: opts.indent });
    const methods = ["GET", "POST", "PUT", "DELETE", "PATCH", "HEAD", "OPTIONS"];
    if (!methods.includes(method.toUpperCase())) {
      push(`HttpResponse<String> response = Unirest.customMethod("${method.toUpperCase()}","${fullUrl}")`);
    } else {
      push(`HttpResponse<String> response = Unirest.${method.toLowerCase()}("${fullUrl}")`);
    }
    Object.keys(allHeaders).forEach((key) => {
      push(`.header("${key}", "${escapeForDoubleQuotes(allHeaders[key])}")`, 1);
    });
    if (postData.text) {
      push(`.body(${JSON.stringify(postData.text)})`, 1);
    }
    push(".asString();", 1);
    return join();
  }
};
var java = {
  info: {
    key: "java",
    title: "Java",
    default: "unirest"
  },
  clientsById: {
    asynchttp,
    nethttp,
    okhttp,
    unirest
  }
};
var axios = {
  info: {
    key: "axios",
    title: "Axios",
    link: "https://github.com/axios/axios",
    description: "Promise based HTTP client for the browser and node.js",
    extname: ".js",
    installation: "npm install axios --save"
  },
  convert: ({ allHeaders, method, url, queryObj, postData }, options) => {
    const opts = {
      indent: "  ",
      ...options
    };
    const { blank, push, join, addPostProcessor } = new CodeBuilder({ indent: opts.indent });
    push("import axios from 'axios';");
    blank();
    const requestOptions = {
      method,
      url
    };
    if (Object.keys(queryObj).length) {
      requestOptions.params = queryObj;
    }
    if (Object.keys(allHeaders).length) {
      requestOptions.headers = allHeaders;
    }
    switch (postData.mimeType) {
      case "application/x-www-form-urlencoded":
        if (postData.params) {
          push("const encodedParams = new URLSearchParams();");
          postData.params.forEach((param) => {
            push(`encodedParams.set('${param.name}', '${param.value}');`);
          });
          blank();
          requestOptions.data = "encodedParams,";
          addPostProcessor((code) => code.replace(/'encodedParams,'/, "encodedParams,"));
        }
        break;
      case "application/json":
        if (postData.jsonObj) {
          requestOptions.data = postData.jsonObj;
        }
        break;
      case "multipart/form-data":
        if (!postData.params) {
          break;
        }
        push("const form = new FormData();");
        postData.params.forEach((param) => {
          push(`form.append('${param.name}', '${param.value || param.fileName || ""}');`);
        });
        blank();
        requestOptions.data = "[form]";
        break;
      default:
        if (postData.text) {
          requestOptions.data = postData.text;
        }
    }
    const optionString = (0, import_stringify_object.default)(requestOptions, {
      indent: "  ",
      inlineCharacterLimit: 80
    }).replace('"[form]"', "form");
    push(`const options = ${optionString};`);
    blank();
    push("axios");
    push(".request(options)", 1);
    push(".then(function (response) {", 1);
    push("console.log(response.data);", 2);
    push("})", 1);
    push(".catch(function (error) {", 1);
    push("console.error(error);", 2);
    push("});", 1);
    return join();
  }
};
var fetch2 = {
  info: {
    key: "fetch",
    title: "fetch",
    link: "https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch",
    description: "Perform asynchronous HTTP requests with the Fetch API",
    extname: ".js"
  },
  convert: ({ method, allHeaders, postData, fullUrl }, inputOpts) => {
    const opts = {
      indent: "  ",
      credentials: null,
      ...inputOpts
    };
    const { blank, join, push } = new CodeBuilder({ indent: opts.indent });
    const options = {
      method
    };
    if (Object.keys(allHeaders).length) {
      options.headers = allHeaders;
    }
    if (opts.credentials !== null) {
      options.credentials = opts.credentials;
    }
    switch (postData.mimeType) {
      case "application/x-www-form-urlencoded":
        options.body = postData.paramsObj ? postData.paramsObj : postData.text;
        break;
      case "application/json":
        if (postData.jsonObj) {
          options.body = postData.jsonObj;
        }
        break;
      case "multipart/form-data":
        if (!postData.params) {
          break;
        }
        const contentTypeHeader = getHeaderName(allHeaders, "content-type");
        if (contentTypeHeader) {
          delete allHeaders[contentTypeHeader];
        }
        push("const form = new FormData();");
        postData.params.forEach((param) => {
          push(`form.append('${param.name}', '${param.value || param.fileName || ""}');`);
        });
        blank();
        break;
      default:
        if (postData.text) {
          options.body = postData.text;
        }
    }
    if (options.headers && !Object.keys(options.headers).length) {
      delete options.headers;
    }
    push(
      `const options = ${(0, import_stringify_object.default)(options, {
        indent: opts.indent,
        inlineCharacterLimit: 80,
        // The Fetch API body only accepts string parameters, but stringified JSON can be difficult
        // to read, so we keep the object as a literal and use this transform function to wrap the
        // literal in a `JSON.stringify` call.
        transform: (object, property, originalResult) => {
          if (property === "body") {
            if (postData.mimeType === "application/x-www-form-urlencoded") {
              return `new URLSearchParams(${originalResult})`;
            } else if (postData.mimeType === "application/json") {
              return `JSON.stringify(${originalResult})`;
            }
          }
          return originalResult;
        }
      })};`
    );
    blank();
    if (postData.params && postData.mimeType === "multipart/form-data") {
      push("options.body = form;");
      blank();
    }
    push(`fetch('${fullUrl}', options)`);
    push(".then(response => response.json())", 1);
    push(".then(response => console.log(response))", 1);
    push(".catch(err => console.error(err));", 1);
    return join();
  }
};
var jquery = {
  info: {
    key: "jquery",
    title: "jQuery",
    link: "http://api.jquery.com/jquery.ajax/",
    description: "Perform an asynchronous HTTP (Ajax) requests with jQuery",
    extname: ".js"
  },
  convert: ({ fullUrl, method, allHeaders, postData }, options) => {
    const opts = {
      indent: "  ",
      ...options
    };
    const { blank, push, join } = new CodeBuilder({ indent: opts.indent });
    const settings = {
      async: true,
      crossDomain: true,
      url: fullUrl,
      method,
      headers: allHeaders
    };
    switch (postData.mimeType) {
      case "application/x-www-form-urlencoded":
        settings.data = postData.paramsObj ? postData.paramsObj : postData.text;
        break;
      case "application/json":
        settings.processData = false;
        settings.data = postData.text;
        break;
      case "multipart/form-data":
        if (!postData.params) {
          break;
        }
        push("const form = new FormData();");
        postData.params.forEach((param) => {
          push(`form.append('${param.name}', '${param.value || param.fileName || ""}');`);
        });
        settings.processData = false;
        settings.contentType = false;
        settings.mimeType = "multipart/form-data";
        settings.data = "[form]";
        if (hasHeader(allHeaders, "content-type")) {
          if (getHeader(allHeaders, "content-type")?.includes("boundary")) {
            const headerName = getHeaderName(allHeaders, "content-type");
            if (headerName) {
              delete settings.headers[headerName];
            }
          }
        }
        blank();
        break;
      default:
        if (postData.text) {
          settings.data = postData.text;
        }
    }
    const stringifiedSettings = (0, import_stringify_object.default)(settings, { indent: opts.indent }).replace("'[form]'", "form");
    push(`const settings = ${stringifiedSettings};`);
    blank();
    push("$.ajax(settings).done(function (response) {");
    push("console.log(response);", 1);
    push("});");
    return join();
  }
};
var xhr = {
  info: {
    key: "xhr",
    title: "XMLHttpRequest",
    link: "https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest",
    description: "W3C Standard API that provides scripted client functionality",
    extname: ".js"
  },
  convert: ({ postData, allHeaders, method, fullUrl }, options) => {
    const opts = {
      indent: "  ",
      cors: true,
      ...options
    };
    const { blank, push, join } = new CodeBuilder({ indent: opts.indent });
    switch (postData.mimeType) {
      case "application/json":
        push(
          `const data = JSON.stringify(${(0, import_stringify_object.default)(postData.jsonObj, {
            indent: opts.indent
          })});`
        );
        blank();
        break;
      case "multipart/form-data":
        if (!postData.params) {
          break;
        }
        push("const data = new FormData();");
        postData.params.forEach((param) => {
          push(`data.append('${param.name}', '${param.value || param.fileName || ""}');`);
        });
        if (hasHeader(allHeaders, "content-type")) {
          if (getHeader(allHeaders, "content-type")?.includes("boundary")) {
            const headerName = getHeaderName(allHeaders, "content-type");
            if (headerName) {
              delete allHeaders[headerName];
            }
          }
        }
        blank();
        break;
      default:
        push(`const data = ${postData.text ? `'${postData.text}'` : "null"};`);
        blank();
    }
    push("const xhr = new XMLHttpRequest();");
    if (opts.cors) {
      push("xhr.withCredentials = true;");
    }
    blank();
    push("xhr.addEventListener('readystatechange', function () {");
    push("if (this.readyState === this.DONE) {", 1);
    push("console.log(this.responseText);", 2);
    push("}", 1);
    push("});");
    blank();
    push(`xhr.open('${method}', '${fullUrl}');`);
    Object.keys(allHeaders).forEach((key) => {
      push(`xhr.setRequestHeader('${key}', '${escapeForSingleQuotes(allHeaders[key])}');`);
    });
    blank();
    push("xhr.send(data);");
    return join();
  }
};
var javascript = {
  info: {
    key: "javascript",
    title: "JavaScript",
    default: "xhr"
  },
  clientsById: {
    xhr,
    axios,
    fetch: fetch2,
    jquery
  }
};
var native2 = {
  info: {
    key: "native",
    title: "Native JSON",
    link: "https://www.json.org/json-en.html",
    description: "A JSON represetation of any HAR payload.",
    extname: ".json"
  },
  convert: ({ postData }, inputOpts) => {
    const opts = {
      indent: "  ",
      ...inputOpts
    };
    let payload = "";
    switch (postData.mimeType) {
      case "application/x-www-form-urlencoded":
        payload = postData.paramsObj ? postData.paramsObj : postData.text;
        break;
      case "application/json":
        if (postData.jsonObj) {
          payload = postData.jsonObj;
        }
        break;
      case "multipart/form-data":
        if (!postData.params) {
          break;
        }
        const multipartPayload = {};
        postData.params.forEach((param) => {
          multipartPayload[param.name] = param.value;
        });
        payload = multipartPayload;
        break;
      default:
        if (postData.text) {
          payload = postData.text;
        }
    }
    if (typeof payload === "undefined" || payload === "") {
      return "No JSON body";
    }
    return JSON.stringify(payload, null, opts.indent);
  }
};
var json = {
  info: {
    key: "json",
    title: "JSON",
    default: "native"
  },
  clientsById: {
    native: native2
  }
};
var okhttp2 = {
  info: {
    key: "okhttp",
    title: "OkHttp",
    link: "http://square.github.io/okhttp/",
    description: "An HTTP Request Client Library",
    extname: ".kt"
  },
  convert: ({ postData, fullUrl, method, allHeaders }, options) => {
    const opts = {
      indent: "  ",
      ...options
    };
    const { blank, join, push } = new CodeBuilder({ indent: opts.indent });
    const methods = ["GET", "POST", "PUT", "DELETE", "PATCH", "HEAD"];
    const methodsWithBody = ["POST", "PUT", "DELETE", "PATCH"];
    push("val client = OkHttpClient()");
    blank();
    if (postData.text) {
      if (postData.boundary) {
        push(`val mediaType = MediaType.parse("${postData.mimeType}; boundary=${postData.boundary}")`);
      } else {
        push(`val mediaType = MediaType.parse("${postData.mimeType}")`);
      }
      push(`val body = RequestBody.create(mediaType, ${JSON.stringify(postData.text)})`);
    }
    push("val request = Request.Builder()");
    push(`.url("${fullUrl}")`, 1);
    if (!methods.includes(method.toUpperCase())) {
      if (postData.text) {
        push(`.method("${method.toUpperCase()}", body)`, 1);
      } else {
        push(`.method("${method.toUpperCase()}", null)`, 1);
      }
    } else if (methodsWithBody.includes(method.toUpperCase())) {
      if (postData.text) {
        push(`.${method.toLowerCase()}(body)`, 1);
      } else {
        push(`.${method.toLowerCase()}(null)`, 1);
      }
    } else {
      push(`.${method.toLowerCase()}()`, 1);
    }
    Object.keys(allHeaders).forEach((key) => {
      push(`.addHeader("${key}", "${escapeForDoubleQuotes(allHeaders[key])}")`, 1);
    });
    push(".build()", 1);
    blank();
    push("val response = client.newCall(request).execute()");
    return join();
  }
};
var kotlin = {
  info: {
    key: "kotlin",
    title: "Kotlin",
    default: "okhttp"
  },
  clientsById: {
    okhttp: okhttp2
  }
};
var axios2 = {
  info: {
    key: "axios",
    title: "Axios",
    link: "https://github.com/axios/axios",
    description: "Promise based HTTP client for the browser and node.js",
    extname: ".cjs",
    installation: "npm install axios --save"
  },
  convert: ({ method, fullUrl, allHeaders, postData }, options) => {
    const opts = {
      indent: "  ",
      ...options
    };
    const { blank, join, push, addPostProcessor } = new CodeBuilder({ indent: opts.indent });
    push("const axios = require('axios');");
    const reqOpts = {
      method,
      url: fullUrl
    };
    if (Object.keys(allHeaders).length) {
      reqOpts.headers = allHeaders;
    }
    switch (postData.mimeType) {
      case "application/x-www-form-urlencoded":
        if (postData.params) {
          push("const { URLSearchParams } = require('url');");
          blank();
          push("const encodedParams = new URLSearchParams();");
          postData.params.forEach((param) => {
            push(`encodedParams.set('${param.name}', '${param.value}');`);
          });
          blank();
          reqOpts.data = "encodedParams,";
          addPostProcessor((code) => code.replace(/'encodedParams,'/, "encodedParams,"));
        }
        break;
      case "application/json":
        blank();
        if (postData.jsonObj) {
          reqOpts.data = postData.jsonObj;
        }
        break;
      default:
        blank();
        if (postData.text) {
          reqOpts.data = postData.text;
        }
    }
    const stringifiedOptions = (0, import_stringify_object.default)(reqOpts, { indent: "  ", inlineCharacterLimit: 80 });
    push(`const options = ${stringifiedOptions};`);
    blank();
    push("axios");
    push(".request(options)", 1);
    push(".then(function (response) {", 1);
    push("console.log(response.data);", 2);
    push("})", 1);
    push(".catch(function (error) {", 1);
    push("console.error(error);", 2);
    push("});", 1);
    return join();
  }
};
var fetch22 = {
  info: {
    key: "fetch",
    title: "Fetch",
    link: "https://github.com/bitinn/node-fetch",
    description: "Simplified HTTP node-fetch client",
    extname: ".cjs",
    installation: "npm install node-fetch@2 --save"
  },
  convert: ({ method, fullUrl, postData, headersObj, cookies }, options) => {
    const opts = {
      indent: "  ",
      ...options
    };
    let includeFS = false;
    const { blank, push, join, unshift } = new CodeBuilder({ indent: opts.indent });
    push("const fetch = require('node-fetch');");
    const url = fullUrl;
    const reqOpts = {
      method
    };
    if (Object.keys(headersObj).length) {
      reqOpts.headers = headersObj;
    }
    switch (postData.mimeType) {
      case "application/x-www-form-urlencoded":
        unshift("const { URLSearchParams } = require('url');");
        push("const encodedParams = new URLSearchParams();");
        blank();
        postData.params?.forEach((param) => {
          push(`encodedParams.set('${param.name}', '${param.value}');`);
        });
        reqOpts.body = "encodedParams";
        break;
      case "application/json":
        if (postData.jsonObj) {
          reqOpts.body = postData.jsonObj;
        }
        break;
      case "multipart/form-data":
        if (!postData.params) {
          break;
        }
        const contentTypeHeader = getHeaderName(headersObj, "content-type");
        if (contentTypeHeader) {
          delete headersObj[contentTypeHeader];
        }
        unshift("const FormData = require('form-data');");
        push("const formData = new FormData();");
        blank();
        postData.params.forEach((param) => {
          if (!param.fileName && !param.fileName && !param.contentType) {
            push(`formData.append('${param.name}', '${param.value}');`);
            return;
          }
          if (param.fileName) {
            includeFS = true;
            push(`formData.append('${param.name}', fs.createReadStream('${param.fileName}'));`);
          }
        });
        break;
      default:
        if (postData.text) {
          reqOpts.body = postData.text;
        }
    }
    if (cookies.length) {
      const cookiesString = cookies.map(({ name, value }) => `${encodeURIComponent(name)}=${encodeURIComponent(value)}`).join("; ");
      if (reqOpts.headers) {
        reqOpts.headers.cookie = cookiesString;
      } else {
        reqOpts.headers = {};
        reqOpts.headers.cookie = cookiesString;
      }
    }
    blank();
    push(`const url = '${url}';`);
    if (reqOpts.headers && !Object.keys(reqOpts.headers).length) {
      delete reqOpts.headers;
    }
    const stringifiedOptions = (0, import_stringify_object.default)(reqOpts, {
      indent: "  ",
      inlineCharacterLimit: 80,
      // The Fetch API body only accepts string parameters, but stringified JSON can be difficult to
      // read, so we keep the object as a literal and use this transform function to wrap the literal
      // in a `JSON.stringify` call.
      transform: (object, property, originalResult) => {
        if (property === "body" && postData.mimeType === "application/json") {
          return `JSON.stringify(${originalResult})`;
        }
        return originalResult;
      }
    });
    push(`const options = ${stringifiedOptions};`);
    blank();
    if (includeFS) {
      unshift("const fs = require('fs');");
    }
    if (postData.params && postData.mimeType === "multipart/form-data") {
      push("options.body = formData;");
      blank();
    }
    push("fetch(url, options)");
    push(".then(res => res.json())", 1);
    push(".then(json => console.log(json))", 1);
    push(".catch(err => console.error('error:' + err));", 1);
    return join().replace(/'encodedParams'/, "encodedParams").replace(/"fs\.createReadStream\(\\"(.+)\\"\)"/, 'fs.createReadStream("$1")');
  }
};
var native3 = {
  info: {
    key: "native",
    title: "HTTP",
    link: "http://nodejs.org/api/http.html#http_http_request_options_callback",
    description: "Node.js native HTTP interface",
    extname: ".cjs"
  },
  convert: ({ uriObj, method, allHeaders, postData }, options = {}) => {
    const { indent = "  " } = options;
    const { blank, join, push, unshift } = new CodeBuilder({ indent });
    const reqOpts = {
      method,
      hostname: uriObj.hostname,
      port: uriObj.port,
      path: uriObj.path,
      headers: allHeaders
    };
    push(`const http = require('${uriObj.protocol?.replace(":", "")}');`);
    blank();
    push(`const options = ${(0, import_stringify_object.default)(reqOpts, { indent })};`);
    blank();
    push("const req = http.request(options, function (res) {");
    push("const chunks = [];", 1);
    blank();
    push("res.on('data', function (chunk) {", 1);
    push("chunks.push(chunk);", 2);
    push("});", 1);
    blank();
    push("res.on('end', function () {", 1);
    push("const body = Buffer.concat(chunks);", 2);
    push("console.log(body.toString());", 2);
    push("});", 1);
    push("});");
    blank();
    switch (postData.mimeType) {
      case "application/x-www-form-urlencoded":
        if (postData.paramsObj) {
          unshift("const qs = require('querystring');");
          push(
            `req.write(qs.stringify(${(0, import_stringify_object.default)(postData.paramsObj, {
              indent: "  ",
              inlineCharacterLimit: 80
            })}));`
          );
        }
        break;
      case "application/json":
        if (postData.jsonObj) {
          push(
            `req.write(JSON.stringify(${(0, import_stringify_object.default)(postData.jsonObj, {
              indent: "  ",
              inlineCharacterLimit: 80
            })}));`
          );
        }
        break;
      default:
        if (postData.text) {
          push(`req.write(${(0, import_stringify_object.default)(postData.text, { indent })});`);
        }
    }
    push("req.end();");
    return join();
  }
};
var request = {
  info: {
    key: "request",
    title: "Request",
    link: "https://github.com/request/request",
    description: "Simplified HTTP request client",
    extname: ".cjs",
    installation: "npm install request --save"
  },
  convert: ({ method, url, fullUrl, postData, headersObj, cookies }, options) => {
    const opts = {
      indent: "  ",
      ...options
    };
    let includeFS = false;
    const { push, blank, join, unshift, addPostProcessor } = new CodeBuilder({ indent: opts.indent });
    push("const request = require('request');");
    blank();
    const reqOpts = {
      method,
      url: fullUrl
    };
    if (Object.keys(headersObj).length) {
      reqOpts.headers = headersObj;
    }
    switch (postData.mimeType) {
      case "application/x-www-form-urlencoded":
        reqOpts.form = postData.paramsObj;
        break;
      case "application/json":
        if (postData.jsonObj) {
          reqOpts.body = postData.jsonObj;
          reqOpts.json = true;
        }
        break;
      case "multipart/form-data":
        if (!postData.params) {
          break;
        }
        reqOpts.formData = {};
        postData.params.forEach((param) => {
          if (!param.fileName && !param.fileName && !param.contentType) {
            reqOpts.formData[param.name] = param.value;
            return;
          }
          let attachment = {};
          if (param.fileName) {
            includeFS = true;
            attachment = {
              value: `fs.createReadStream(${param.fileName})`,
              options: {
                filename: param.fileName,
                contentType: param.contentType ? param.contentType : null
              }
            };
          } else if (param.value) {
            attachment.value = param.value;
          }
          reqOpts.formData[param.name] = attachment;
        });
        addPostProcessor((code) => code.replace(/'fs\.createReadStream\((.*)\)'/, "fs.createReadStream('$1')"));
        break;
      default:
        if (postData.text) {
          reqOpts.body = postData.text;
        }
    }
    if (cookies.length) {
      reqOpts.jar = "JAR";
      push("const jar = request.jar();");
      cookies.forEach(({ name, value }) => {
        push(`jar.setCookie(request.cookie('${encodeURIComponent(name)}=${encodeURIComponent(value)}'), '${url}');`);
      });
      blank();
      addPostProcessor((code) => code.replace(/'JAR'/, "jar"));
    }
    if (includeFS) {
      unshift("const fs = require('fs');");
    }
    push(`const options = ${(0, import_stringify_object.default)(reqOpts, { indent: "  ", inlineCharacterLimit: 80 })};`);
    blank();
    push("request(options, function (error, response, body) {");
    push("if (error) throw new Error(error);", 1);
    blank();
    push("console.log(body);", 1);
    push("});");
    return join();
  }
};
var unirest2 = {
  info: {
    key: "unirest",
    title: "Unirest",
    link: "http://unirest.io/nodejs.html",
    description: "Lightweight HTTP Request Client Library",
    extname: ".cjs"
  },
  convert: ({ method, url, cookies, queryObj, postData, headersObj }, options) => {
    const opts = {
      indent: "  ",
      ...options
    };
    let includeFS = false;
    const { addPostProcessor, blank, join, push, unshift } = new CodeBuilder({
      indent: opts.indent
    });
    push("const unirest = require('unirest');");
    blank();
    push(`const req = unirest('${method}', '${url}');`);
    blank();
    if (cookies.length) {
      push("const CookieJar = unirest.jar();");
      cookies.forEach((cookie) => {
        push(`CookieJar.add('${encodeURIComponent(cookie.name)}=${encodeURIComponent(cookie.value)}', '${url}');`);
      });
      push("req.jar(CookieJar);");
      blank();
    }
    if (Object.keys(queryObj).length) {
      push(`req.query(${(0, import_stringify_object.default)(queryObj, { indent: opts.indent })});`);
      blank();
    }
    if (Object.keys(headersObj).length) {
      push(`req.headers(${(0, import_stringify_object.default)(headersObj, { indent: opts.indent })});`);
      blank();
    }
    switch (postData.mimeType) {
      case "application/x-www-form-urlencoded":
        if (postData.paramsObj) {
          push(`req.form(${(0, import_stringify_object.default)(postData.paramsObj, { indent: opts.indent })});`);
          blank();
        }
        break;
      case "application/json":
        if (postData.jsonObj) {
          push("req.type('json');");
          push(`req.send(${(0, import_stringify_object.default)(postData.jsonObj, { indent: opts.indent })});`);
          blank();
        }
        break;
      case "multipart/form-data": {
        if (!postData.params) {
          break;
        }
        const multipart = [];
        postData.params.forEach((param) => {
          const part = {};
          if (param.fileName && !param.value) {
            includeFS = true;
            part.body = `fs.createReadStream('${param.fileName}')`;
            addPostProcessor((code) => code.replace(/'fs\.createReadStream\(\\'(.+)\\'\)'/, "fs.createReadStream('$1')"));
          } else if (param.value) {
            part.body = param.value;
          }
          if (part.body) {
            if (param.contentType) {
              part["content-type"] = param.contentType;
            }
            multipart.push(part);
          }
        });
        push(`req.multipart(${(0, import_stringify_object.default)(multipart, { indent: opts.indent })});`);
        blank();
        break;
      }
      default:
        if (postData.text) {
          push(`req.send(${(0, import_stringify_object.default)(postData.text, { indent: opts.indent })});`);
          blank();
        }
    }
    if (includeFS) {
      unshift("const fs = require('fs');");
    }
    push("req.end(function (res) {");
    push("if (res.error) throw new Error(res.error);", 1);
    blank();
    push("console.log(res.body);", 1);
    push("});");
    return join();
  }
};
var node = {
  info: {
    key: "node",
    title: "Node.js",
    default: "native",
    cli: "node %s"
  },
  clientsById: {
    native: native3,
    request,
    unirest: unirest2,
    axios: axios2,
    fetch: fetch22
  }
};
var nsDeclaration = (nsClass, name, parameters, indent) => {
  const opening = `${nsClass} *${name} = `;
  const literal = literalRepresentation(parameters, indent ? opening.length : void 0);
  return `${opening}${literal};`;
};
var literalRepresentation = (value, indentation) => {
  const join = indentation === void 0 ? ", " : `,
   ${" ".repeat(indentation)}`;
  switch (Object.prototype.toString.call(value)) {
    case "[object Number]":
      return `@${value}`;
    case "[object Array]": {
      const valuesRepresentation = value.map((val) => literalRepresentation(val));
      return `@[ ${valuesRepresentation.join(join)} ]`;
    }
    case "[object Object]": {
      const keyValuePairs = [];
      Object.keys(value).forEach((key) => {
        keyValuePairs.push(`@"${key}": ${literalRepresentation(value[key])}`);
      });
      return `@{ ${keyValuePairs.join(join)} }`;
    }
    case "[object Boolean]":
      return value ? "@YES" : "@NO";
    default:
      if (value === null || value === void 0) {
        return "";
      }
      return `@"${value.toString().replace(/"/g, '\\"')}"`;
  }
};
var nsurlsession = {
  info: {
    key: "nsurlsession",
    title: "NSURLSession",
    link: "https://developer.apple.com/library/mac/documentation/Foundation/Reference/NSURLSession_class/index.html",
    description: "Foundation's NSURLSession request",
    extname: ".m"
  },
  convert: ({ allHeaders, postData, method, fullUrl }, options) => {
    const opts = {
      indent: "    ",
      pretty: true,
      timeout: 10,
      ...options
    };
    const { push, join, blank } = new CodeBuilder({ indent: opts.indent });
    const req = {
      hasHeaders: false,
      hasBody: false
    };
    push("#import <Foundation/Foundation.h>");
    if (Object.keys(allHeaders).length) {
      req.hasHeaders = true;
      blank();
      push(nsDeclaration("NSDictionary", "headers", allHeaders, opts.pretty));
    }
    if (postData.text || postData.jsonObj || postData.params) {
      req.hasBody = true;
      switch (postData.mimeType) {
        case "application/x-www-form-urlencoded":
          if (postData.params?.length) {
            blank();
            const [head, ...tail] = postData.params;
            push(
              `NSMutableData *postData = [[NSMutableData alloc] initWithData:[@"${head.name}=${head.value}" dataUsingEncoding:NSUTF8StringEncoding]];`
            );
            tail.forEach(({ name, value }) => {
              push(`[postData appendData:[@"&${name}=${value}" dataUsingEncoding:NSUTF8StringEncoding]];`);
            });
          } else {
            req.hasBody = false;
          }
          break;
        case "application/json":
          if (postData.jsonObj) {
            push(nsDeclaration("NSDictionary", "parameters", postData.jsonObj, opts.pretty));
            blank();
            push("NSData *postData = [NSJSONSerialization dataWithJSONObject:parameters options:0 error:nil];");
          }
          break;
        case "multipart/form-data":
          push(nsDeclaration("NSArray", "parameters", postData.params || [], opts.pretty));
          push(`NSString *boundary = @"${postData.boundary}";`);
          blank();
          push("NSError *error;");
          push("NSMutableString *body = [NSMutableString string];");
          push("for (NSDictionary *param in parameters) {");
          push('[body appendFormat:@"--%@\\r\\n", boundary];', 1);
          push('if (param[@"fileName"]) {', 1);
          push(
            '[body appendFormat:@"Content-Disposition:form-data; name=\\"%@\\"; filename=\\"%@\\"\\r\\n", param[@"name"], param[@"fileName"]];',
            2
          );
          push('[body appendFormat:@"Content-Type: %@\\r\\n\\r\\n", param[@"contentType"]];', 2);
          push(
            '[body appendFormat:@"%@", [NSString stringWithContentsOfFile:param[@"fileName"] encoding:NSUTF8StringEncoding error:&error]];',
            2
          );
          push("if (error) {", 2);
          push('NSLog(@"%@", error);', 3);
          push("}", 2);
          push("} else {", 1);
          push('[body appendFormat:@"Content-Disposition:form-data; name=\\"%@\\"\\r\\n\\r\\n", param[@"name"]];', 2);
          push('[body appendFormat:@"%@", param[@"value"]];', 2);
          push("}", 1);
          push("}");
          push('[body appendFormat:@"\\r\\n--%@--\\r\\n", boundary];');
          push("NSData *postData = [body dataUsingEncoding:NSUTF8StringEncoding];");
          break;
        default:
          blank();
          push(
            `NSData *postData = [[NSData alloc] initWithData:[@"${postData.text}" dataUsingEncoding:NSUTF8StringEncoding]];`
          );
      }
    }
    blank();
    push(`NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@"${fullUrl}"]`);
    push("                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy");
    push(`                                                   timeoutInterval:${opts.timeout.toFixed(1)}];`);
    push(`[request setHTTPMethod:@"${method}"];`);
    if (req.hasHeaders) {
      push("[request setAllHTTPHeaderFields:headers];");
    }
    if (req.hasBody) {
      push("[request setHTTPBody:postData];");
    }
    blank();
    push("NSURLSession *session = [NSURLSession sharedSession];");
    push("NSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request");
    push(
      "                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {"
    );
    push("                                            if (error) {", 1);
    push('                                            NSLog(@"%@", error);', 2);
    push("                                            } else {", 1);
    push(
      "                                            NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;",
      2
    );
    push('                                            NSLog(@"%@", httpResponse);', 2);
    push("                                            }", 1);
    push("                                            }];");
    push("[dataTask resume];");
    return join();
  }
};
var objc = {
  info: {
    key: "objc",
    title: "Objective-C",
    default: "nsurlsession"
  },
  clientsById: {
    nsurlsession
  }
};
var cohttp = {
  info: {
    key: "cohttp",
    title: "CoHTTP",
    link: "https://github.com/mirage/ocaml-cohttp",
    description: "Cohttp is a very lightweight HTTP server using Lwt or Async for OCaml",
    extname: ".ml",
    installation: "opam install cohttp-lwt-unix cohttp-async"
  },
  convert: ({ fullUrl, allHeaders, postData, method }, options) => {
    const opts = {
      indent: "  ",
      ...options
    };
    const methods = ["get", "post", "head", "delete", "patch", "put", "options"];
    const { push, blank, join } = new CodeBuilder({ indent: opts.indent });
    push("open Cohttp_lwt_unix");
    push("open Cohttp");
    push("open Lwt");
    blank();
    push(`let uri = Uri.of_string "${fullUrl}" in`);
    const headers = Object.keys(allHeaders);
    if (headers.length === 1) {
      push(
        `let headers = Header.add (Header.init ()) "${headers[0]}" "${escapeForDoubleQuotes(
          allHeaders[headers[0]]
        )}" in`
      );
    } else if (headers.length > 1) {
      push("let headers = Header.add_list (Header.init ()) [");
      headers.forEach((key) => {
        push(`("${key}", "${escapeForDoubleQuotes(allHeaders[key])}");`, 1);
      });
      push("] in");
    }
    if (postData.text) {
      push(`let body = Cohttp_lwt_body.of_string ${JSON.stringify(postData.text)} in`);
    }
    blank();
    const h = headers.length ? "~headers " : "";
    const b = postData.text ? "~body " : "";
    const m = methods.includes(method.toLowerCase()) ? `\`${method.toUpperCase()}` : `(Code.method_of_string "${method}")`;
    push(`Client.call ${h}${b}${m} uri`);
    push(">>= fun (res, body_stream) ->");
    push("(* Do stuff with the result *)", 1);
    return join();
  }
};
var ocaml = {
  info: {
    key: "ocaml",
    title: "OCaml",
    default: "cohttp"
  },
  clientsById: {
    cohttp
  }
};
var convertType = (obj, indent, lastIndent) => {
  lastIndent = lastIndent || "";
  indent = indent || "";
  switch (Object.prototype.toString.call(obj)) {
    case "[object Boolean]":
      return obj;
    case "[object Null]":
      return "null";
    case "[object Undefined]":
      return "null";
    case "[object String]":
      return `'${escapeString(obj, { delimiter: "'", escapeNewlines: false })}'`;
    case "[object Number]":
      return obj.toString();
    case "[object Array]": {
      const contents = obj.map((item) => convertType(item, `${indent}${indent}`, indent)).join(`,
${indent}`);
      return `[
${indent}${contents}
${lastIndent}]`;
    }
    case "[object Object]": {
      const result = [];
      for (const i in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, i)) {
          result.push(`${convertType(i, indent)} => ${convertType(obj[i], `${indent}${indent}`, indent)}`);
        }
      }
      return `[
${indent}${result.join(`,
${indent}`)}
${lastIndent}]`;
    }
    default:
      return "null";
  }
};
var supportedMethods = [
  "ACL",
  "BASELINE_CONTROL",
  "CHECKIN",
  "CHECKOUT",
  "CONNECT",
  "COPY",
  "DELETE",
  "GET",
  "HEAD",
  "LABEL",
  "LOCK",
  "MERGE",
  "MKACTIVITY",
  "MKCOL",
  "MKWORKSPACE",
  "MOVE",
  "OPTIONS",
  "POST",
  "PROPFIND",
  "PROPPATCH",
  "PUT",
  "REPORT",
  "TRACE",
  "UNCHECKOUT",
  "UNLOCK",
  "UPDATE",
  "VERSION_CONTROL"
];
var curl = {
  info: {
    key: "curl",
    title: "cURL",
    link: "http://php.net/manual/en/book.curl.php",
    description: "PHP with ext-curl",
    extname: ".php"
  },
  convert: ({ uriObj, postData, fullUrl, method, httpVersion, cookies, headersObj }, options = {}) => {
    const {
      closingTag = false,
      indent = "  ",
      maxRedirects = 10,
      namedErrors = false,
      noTags = false,
      shortTags = false,
      timeout = 30
    } = options;
    const { push, blank, join } = new CodeBuilder({ indent });
    if (!noTags) {
      push(shortTags ? "<?" : "<?php");
      blank();
    }
    push("$curl = curl_init();");
    blank();
    const curlOptions = [
      {
        escape: true,
        name: "CURLOPT_PORT",
        value: uriObj.port
      },
      {
        escape: true,
        name: "CURLOPT_URL",
        value: fullUrl
      },
      {
        escape: false,
        name: "CURLOPT_RETURNTRANSFER",
        value: "true"
      },
      {
        escape: true,
        name: "CURLOPT_ENCODING",
        value: ""
      },
      {
        escape: false,
        name: "CURLOPT_MAXREDIRS",
        value: maxRedirects
      },
      {
        escape: false,
        name: "CURLOPT_TIMEOUT",
        value: timeout
      },
      {
        escape: false,
        name: "CURLOPT_HTTP_VERSION",
        value: httpVersion === "HTTP/1.0" ? "CURL_HTTP_VERSION_1_0" : "CURL_HTTP_VERSION_1_1"
      },
      {
        escape: true,
        name: "CURLOPT_CUSTOMREQUEST",
        value: method
      },
      {
        escape: !postData.jsonObj,
        name: "CURLOPT_POSTFIELDS",
        value: postData ? postData.jsonObj ? `json_encode(${convertType(postData.jsonObj, indent.repeat(2), indent)})` : postData.text : void 0
      }
    ];
    push("curl_setopt_array($curl, [");
    const curlopts = new CodeBuilder({ indent, join: `
${indent}` });
    curlOptions.forEach(({ value, name, escape: escape22 }) => {
      if (value !== null && value !== void 0) {
        curlopts.push(`${name} => ${escape22 ? JSON.stringify(value) : value},`);
      }
    });
    const curlCookies = cookies.map((cookie) => `${encodeURIComponent(cookie.name)}=${encodeURIComponent(cookie.value)}`);
    if (curlCookies.length) {
      curlopts.push(`CURLOPT_COOKIE => "${curlCookies.join("; ")}",`);
    }
    const headers = Object.keys(headersObj).sort().map((key) => `"${key}: ${escapeForDoubleQuotes(headersObj[key])}"`);
    if (headers.length) {
      curlopts.push("CURLOPT_HTTPHEADER => [");
      curlopts.push(headers.join(`,
${indent}${indent}`), 1);
      curlopts.push("],");
    }
    push(curlopts.join(), 1);
    push("]);");
    blank();
    push("$response = curl_exec($curl);");
    push("$err = curl_error($curl);");
    blank();
    push("curl_close($curl);");
    blank();
    push("if ($err) {");
    if (namedErrors) {
      push('echo array_flip(get_defined_constants(true)["curl"])[$err];', 1);
    } else {
      push('echo "cURL Error #:" . $err;', 1);
    }
    push("} else {");
    push("echo $response;", 1);
    push("}");
    if (!noTags && closingTag) {
      blank();
      push("?>");
    }
    return join();
  }
};
var guzzle = {
  info: {
    key: "guzzle",
    title: "Guzzle",
    link: "http://docs.guzzlephp.org/en/stable/",
    description: "PHP with Guzzle",
    extname: ".php",
    installation: "composer require guzzlehttp/guzzle"
  },
  convert: ({ postData, fullUrl, method, cookies, headersObj }, options) => {
    const opts = {
      closingTag: false,
      indent: "  ",
      noTags: false,
      shortTags: false,
      ...options
    };
    const { push, blank, join } = new CodeBuilder({ indent: opts.indent });
    const { code: requestCode, push: requestPush, join: requestJoin } = new CodeBuilder({ indent: opts.indent });
    if (!opts.noTags) {
      push(opts.shortTags ? "<?" : "<?php");
    }
    push("require_once('vendor/autoload.php');");
    blank();
    switch (postData.mimeType) {
      case "application/x-www-form-urlencoded":
        requestPush(`'form_params' => ${convertType(postData.paramsObj, opts.indent + opts.indent, opts.indent)},`, 1);
        break;
      case "multipart/form-data": {
        const fields = [];
        if (postData.params) {
          postData.params.forEach((param) => {
            if (param.fileName) {
              const field = {
                name: param.name,
                filename: param.fileName,
                contents: param.value
              };
              if (param.contentType) {
                field.headers = { "Content-Type": param.contentType };
              }
              fields.push(field);
            } else if (param.value) {
              fields.push({
                name: param.name,
                contents: param.value
              });
            }
          });
        }
        if (fields.length) {
          requestPush(`'multipart' => ${convertType(fields, opts.indent + opts.indent, opts.indent)}`, 1);
          if (hasHeader(headersObj, "content-type")) {
            if (getHeader(headersObj, "content-type")?.indexOf("boundary")) {
              const headerName = getHeaderName(headersObj, "content-type");
              if (headerName) {
                delete headersObj[headerName];
              }
            }
          }
        }
        break;
      }
      default:
        if (postData.text) {
          requestPush(`'body' => ${convertType(postData.text)},`, 1);
        }
    }
    const headers = Object.keys(headersObj).sort().map(function(key) {
      return `${opts.indent}${opts.indent}'${key}' => '${escapeForSingleQuotes(headersObj[key])}',`;
    });
    const cookieString = cookies.map((cookie) => `${encodeURIComponent(cookie.name)}=${encodeURIComponent(cookie.value)}`).join("; ");
    if (cookieString.length) {
      headers.push(`${opts.indent}${opts.indent}'cookie' => '${escapeForSingleQuotes(cookieString)}',`);
    }
    if (headers.length) {
      requestPush("'headers' => [", 1);
      requestPush(headers.join("\n"));
      requestPush("],", 1);
    }
    push("$client = new \\GuzzleHttp\\Client();");
    blank();
    if (requestCode.length) {
      push(`$response = $client->request('${method}', '${fullUrl}', [`);
      push(requestJoin());
      push("]);");
    } else {
      push(`$response = $client->request('${method}', '${fullUrl}');`);
    }
    blank();
    push("echo $response->getBody();");
    if (!opts.noTags && opts.closingTag) {
      blank();
      push("?>");
    }
    return join();
  }
};
var http1 = {
  info: {
    key: "http1",
    title: "HTTP v1",
    link: "http://php.net/manual/en/book.http.php",
    description: "PHP with pecl/http v1",
    extname: ".php"
  },
  convert: ({ method, url, postData, queryObj, headersObj, cookiesObj }, options = {}) => {
    const { closingTag = false, indent = "  ", noTags = false, shortTags = false } = options;
    const { push, blank, join } = new CodeBuilder({ indent });
    if (!noTags) {
      push(shortTags ? "<?" : "<?php");
      blank();
    }
    if (!supportedMethods.includes(method.toUpperCase())) {
      push(`HttpRequest::methodRegister('${method}');`);
    }
    push("$request = new HttpRequest();");
    push(`$request->setUrl(${convertType(url)});`);
    if (supportedMethods.includes(method.toUpperCase())) {
      push(`$request->setMethod(HTTP_METH_${method.toUpperCase()});`);
    } else {
      push(`$request->setMethod(HttpRequest::HTTP_METH_${method.toUpperCase()});`);
    }
    blank();
    if (Object.keys(queryObj).length) {
      push(`$request->setQueryData(${convertType(queryObj, indent)});`);
      blank();
    }
    if (Object.keys(headersObj).length) {
      push(`$request->setHeaders(${convertType(headersObj, indent)});`);
      blank();
    }
    if (Object.keys(cookiesObj).length) {
      push(`$request->setCookies(${convertType(cookiesObj, indent)});`);
      blank();
    }
    switch (postData.mimeType) {
      case "application/x-www-form-urlencoded":
        push(`$request->setContentType(${convertType(postData.mimeType)});`);
        push(`$request->setPostFields(${convertType(postData.paramsObj, indent)});`);
        blank();
        break;
      case "application/json":
        push(`$request->setContentType(${convertType(postData.mimeType)});`);
        push(`$request->setBody(json_encode(${convertType(postData.jsonObj, indent)}));`);
        blank();
        break;
      default:
        if (postData.text) {
          push(`$request->setBody(${convertType(postData.text)});`);
          blank();
        }
    }
    push("try {");
    push("$response = $request->send();", 1);
    blank();
    push("echo $response->getBody();", 1);
    push("} catch (HttpException $ex) {");
    push("echo $ex;", 1);
    push("}");
    if (!noTags && closingTag) {
      blank();
      push("?>");
    }
    return join();
  }
};
var http2 = {
  info: {
    key: "http2",
    title: "HTTP v2",
    link: "http://devel-m6w6.rhcloud.com/mdref/http",
    description: "PHP with pecl/http v2",
    extname: ".php"
  },
  convert: ({ postData, headersObj, method, queryObj, cookiesObj, url }, options = {}) => {
    const { closingTag = false, indent = "  ", noTags = false, shortTags = false } = options;
    const { push, blank, join } = new CodeBuilder({ indent });
    let hasBody = false;
    if (!noTags) {
      push(shortTags ? "<?" : "<?php");
      blank();
    }
    push("$client = new http\\Client;");
    push("$request = new http\\Client\\Request;");
    blank();
    switch (postData.mimeType) {
      case "application/x-www-form-urlencoded":
        push("$body = new http\\Message\\Body;");
        push(`$body->append(new http\\QueryString(${convertType(postData.paramsObj, indent)}));`);
        blank();
        hasBody = true;
        break;
      case "multipart/form-data": {
        if (!postData.params) {
          break;
        }
        const files = [];
        const fields = {};
        postData.params.forEach(({ name, fileName, value, contentType }) => {
          if (fileName) {
            files.push({
              name,
              type: contentType,
              file: fileName,
              data: value
            });
            return;
          }
          if (value) {
            fields[name] = value;
          }
        });
        const field = Object.keys(fields).length ? convertType(fields, indent) : "null";
        const formValue = files.length ? convertType(files, indent) : "null";
        push("$body = new http\\Message\\Body;");
        push(`$body->addForm(${field}, ${formValue});`);
        if (hasHeader(headersObj, "content-type")) {
          if (getHeader(headersObj, "content-type")?.indexOf("boundary")) {
            const headerName = getHeaderName(headersObj, "content-type");
            if (headerName) {
              delete headersObj[headerName];
            }
          }
        }
        blank();
        hasBody = true;
        break;
      }
      case "application/json":
        push("$body = new http\\Message\\Body;");
        push(`$body->append(json_encode(${convertType(postData.jsonObj, indent)}));`);
        hasBody = true;
        break;
      default:
        if (postData.text) {
          push("$body = new http\\Message\\Body;");
          push(`$body->append(${convertType(postData.text)});`);
          blank();
          hasBody = true;
        }
    }
    push(`$request->setRequestUrl(${convertType(url)});`);
    push(`$request->setRequestMethod(${convertType(method)});`);
    if (hasBody) {
      push("$request->setBody($body);");
      blank();
    }
    if (Object.keys(queryObj).length) {
      push(`$request->setQuery(new http\\QueryString(${convertType(queryObj, indent)}));`);
      blank();
    }
    if (Object.keys(headersObj).length) {
      push(`$request->setHeaders(${convertType(headersObj, indent)});`);
      blank();
    }
    if (Object.keys(cookiesObj).length) {
      blank();
      push(`$client->setCookies(${convertType(cookiesObj, indent)});`);
      blank();
    }
    push("$client->enqueue($request)->send();");
    push("$response = $client->getResponse();");
    blank();
    push("echo $response->getBody();");
    if (!noTags && closingTag) {
      blank();
      push("?>");
    }
    return join();
  }
};
var php = {
  info: {
    key: "php",
    title: "PHP",
    default: "curl",
    cli: "php %s"
  },
  clientsById: {
    curl,
    guzzle,
    http1,
    http2
  }
};
var generatePowershellConvert = (command) => {
  const convert2 = ({ method, headersObj, cookies, uriObj, fullUrl, postData, allHeaders }) => {
    const { push, join } = new CodeBuilder();
    const methods = ["GET", "POST", "PUT", "DELETE", "PATCH", "HEAD", "OPTIONS"];
    if (!methods.includes(method.toUpperCase())) {
      return "Method not supported";
    }
    const commandOptions = [];
    const headers = Object.keys(headersObj);
    if (headers.length) {
      push("$headers=@{}");
      headers.forEach((key) => {
        if (key !== "connection") {
          push(`$headers.Add("${key}", "${escapeString(headersObj[key], { escapeChar: "`" })}")`);
        }
      });
      commandOptions.push("-Headers $headers");
    }
    if (cookies.length) {
      push("$session = New-Object Microsoft.PowerShell.Commands.WebRequestSession");
      cookies.forEach((cookie) => {
        push("$cookie = New-Object System.Net.Cookie");
        push(`$cookie.Name = '${cookie.name}'`);
        push(`$cookie.Value = '${cookie.value}'`);
        push(`$cookie.Domain = '${uriObj.host}'`);
        push("$session.Cookies.Add($cookie)");
      });
      commandOptions.push("-WebSession $session");
    }
    if (postData.text) {
      commandOptions.push(
        `-ContentType '${escapeString(getHeader(allHeaders, "content-type"), { delimiter: "'", escapeChar: "`" })}'`
      );
      commandOptions.push(`-Body '${postData.text}'`);
    }
    push(`$response = ${command} -Uri '${fullUrl}' -Method ${method} ${commandOptions.join(" ")}`.trim());
    return join();
  };
  return convert2;
};
var restmethod = {
  info: {
    key: "restmethod",
    title: "Invoke-RestMethod",
    link: "https://docs.microsoft.com/en-us/powershell/module/Microsoft.PowerShell.Utility/Invoke-RestMethod",
    description: "Powershell Invoke-RestMethod client",
    extname: ".ps1"
  },
  convert: generatePowershellConvert("Invoke-RestMethod")
};
var webrequest = {
  info: {
    key: "webrequest",
    title: "Invoke-WebRequest",
    link: "https://docs.microsoft.com/en-us/powershell/module/Microsoft.PowerShell.Utility/Invoke-WebRequest",
    description: "Powershell Invoke-WebRequest client",
    extname: ".ps1"
  },
  convert: generatePowershellConvert("Invoke-WebRequest")
};
var powershell = {
  info: {
    key: "powershell",
    title: "Powershell",
    default: "webrequest"
  },
  clientsById: {
    webrequest,
    restmethod
  }
};
function concatValues(concatType, values, pretty, indentation, indentLevel) {
  const currentIndent = indentation.repeat(indentLevel);
  const closingBraceIndent = indentation.repeat(indentLevel - 1);
  const join = pretty ? `,
${currentIndent}` : ", ";
  const openingBrace = concatType === "object" ? "{" : "[";
  const closingBrace = concatType === "object" ? "}" : "]";
  if (pretty) {
    return `${openingBrace}
${currentIndent}${values.join(join)}
${closingBraceIndent}${closingBrace}`;
  }
  if (concatType === "object" && values.length > 0) {
    return `${openingBrace} ${values.join(join)} ${closingBrace}`;
  }
  return `${openingBrace}${values.join(join)}${closingBrace}`;
}
var literalRepresentation2 = (value, opts, indentLevel) => {
  indentLevel = indentLevel === void 0 ? 1 : indentLevel + 1;
  switch (Object.prototype.toString.call(value)) {
    case "[object Number]":
      return value;
    case "[object Array]": {
      let pretty = false;
      const valuesRepresentation = value.map((v) => {
        if (Object.prototype.toString.call(v) === "[object Object]") {
          pretty = Object.keys(v).length > 1;
        }
        return literalRepresentation2(v, opts, indentLevel);
      });
      return concatValues("array", valuesRepresentation, pretty, opts.indent, indentLevel);
    }
    case "[object Object]": {
      const keyValuePairs = [];
      for (const key in value) {
        keyValuePairs.push(`"${key}": ${literalRepresentation2(value[key], opts, indentLevel)}`);
      }
      return concatValues("object", keyValuePairs, opts.pretty && keyValuePairs.length > 1, opts.indent, indentLevel);
    }
    case "[object Null]":
      return "None";
    case "[object Boolean]":
      return value ? "True" : "False";
    default:
      if (value === null || value === void 0) {
        return "";
      }
      return `"${value.toString().replace(/"/g, '\\"')}"`;
  }
};
var builtInMethods = ["HEAD", "GET", "POST", "PUT", "PATCH", "DELETE", "OPTIONS"];
var requests = {
  info: {
    key: "requests",
    title: "Requests",
    link: "http://docs.python-requests.org/en/latest/api/#requests.request",
    description: "Requests HTTP library",
    extname: ".py",
    installation: "python -m pip install requests"
  },
  convert: ({ fullUrl, postData, allHeaders, method }, options) => {
    const opts = {
      indent: "    ",
      pretty: true,
      ...options
    };
    const { push, blank, join, addPostProcessor } = new CodeBuilder({ indent: opts.indent });
    push("import requests");
    blank();
    push(`url = "${fullUrl}"`);
    blank();
    const headers = allHeaders;
    let payload = {};
    const files = {};
    let hasFiles = false;
    let hasPayload = false;
    let jsonPayload = false;
    switch (postData.mimeType) {
      case "application/json":
        if (postData.jsonObj) {
          push(`payload = ${literalRepresentation2(postData.jsonObj, opts)}`);
          jsonPayload = true;
          hasPayload = true;
        }
        break;
      case "multipart/form-data":
        if (!postData.params) {
          break;
        }
        payload = {};
        postData.params.forEach((p) => {
          if (p.fileName) {
            if (p.contentType) {
              files[p.name] = `('${p.fileName}', open('${p.fileName}', 'rb'), '${p.contentType}')`;
            } else {
              files[p.name] = `('${p.fileName}', open('${p.fileName}', 'rb'))`;
            }
            hasFiles = true;
          } else {
            payload[p.name] = p.value;
            hasPayload = true;
          }
        });
        if (hasFiles) {
          push(`files = ${literalRepresentation2(files, opts)}`);
          if (hasPayload) {
            push(`payload = ${literalRepresentation2(payload, opts)}`);
          }
          const headerName = getHeaderName(headers, "content-type");
          if (headerName) {
            delete headers[headerName];
          }
        } else {
          const nonFilePayload = JSON.stringify(postData.text);
          if (nonFilePayload) {
            push(`payload = ${nonFilePayload}`);
            hasPayload = true;
          }
        }
        addPostProcessor(
          (code) => code.replace(/"\('(.+)', open\('(.+)', 'rb'\)\)"/g, '("$1", open("$2", "rb"))').replace(/"\('(.+)', open\('(.+)', 'rb'\), '(.+)'\)"/g, '("$1", open("$2", "rb"), "$3")')
        );
        break;
      default: {
        if (postData.mimeType === "application/x-www-form-urlencoded" && postData.paramsObj) {
          push(`payload = ${literalRepresentation2(postData.paramsObj, opts)}`);
          hasPayload = true;
          break;
        }
        const stringPayload = JSON.stringify(postData.text);
        if (stringPayload) {
          push(`payload = ${stringPayload}`);
          hasPayload = true;
        }
      }
    }
    const headerCount = Object.keys(headers).length;
    if (headerCount === 0 && (hasPayload || hasFiles)) {
      blank();
    } else if (headerCount === 1) {
      Object.keys(headers).forEach((header) => {
        push(`headers = {"${header}": "${escapeForDoubleQuotes(headers[header])}"}`);
        blank();
      });
    } else if (headerCount > 1) {
      let count = 1;
      push("headers = {");
      Object.keys(headers).forEach((header) => {
        if (count !== headerCount) {
          push(`"${header}": "${escapeForDoubleQuotes(headers[header])}",`, 1);
        } else {
          push(`"${header}": "${escapeForDoubleQuotes(headers[header])}"`, 1);
        }
        count += 1;
      });
      push("}");
      blank();
    }
    let request2 = builtInMethods.includes(method) ? `response = requests.${method.toLowerCase()}(url` : `response = requests.request("${method}", url`;
    if (hasPayload) {
      if (jsonPayload) {
        request2 += ", json=payload";
      } else {
        request2 += ", data=payload";
      }
    }
    if (hasFiles) {
      request2 += ", files=files";
    }
    if (headerCount > 0) {
      request2 += ", headers=headers";
    }
    request2 += ")";
    push(request2);
    blank();
    push("print(response.text)");
    return join();
  }
};
var python = {
  info: {
    key: "python",
    title: "Python",
    default: "requests",
    cli: "python3 %s"
  },
  clientsById: {
    requests
  }
};
var httr = {
  info: {
    key: "httr",
    title: "httr",
    link: "https://cran.r-project.org/web/packages/httr/vignettes/quickstart.html",
    description: "httr: Tools for Working with URLs and HTTP",
    extname: ".r"
  },
  convert: ({ url, queryObj, queryString, postData, allHeaders, method }) => {
    const { push, blank, join } = new CodeBuilder();
    push("library(httr)");
    blank();
    push(`url <- "${url}"`);
    blank();
    const qs2 = queryObj;
    delete queryObj.key;
    const queryCount = Object.keys(qs2).length;
    if (queryString.length === 1) {
      push(`queryString <- list(${Object.keys(qs2)} = "${Object.values(qs2).toString()}")`);
      blank();
    } else if (queryString.length > 1) {
      push("queryString <- list(");
      Object.keys(qs2).forEach((query, i) => {
        if (i !== queryCount - 1) {
          push(`  ${query} = "${qs2[query].toString()}",`);
        } else {
          push(`  ${query} = "${qs2[query].toString()}"`);
        }
      });
      push(")");
      blank();
    }
    const payload = JSON.stringify(postData.text);
    if (payload) {
      push(`payload <- ${payload}`);
      blank();
    }
    if (postData.text || postData.jsonObj || postData.params) {
      switch (postData.mimeType) {
        case "application/x-www-form-urlencoded":
          push('encode <- "form"');
          blank();
          break;
        case "application/json":
          push('encode <- "json"');
          blank();
          break;
        case "multipart/form-data":
          push('encode <- "multipart"');
          blank();
          break;
        default:
          push('encode <- "raw"');
          blank();
          break;
      }
    }
    const cookieHeader = getHeader(allHeaders, "cookie");
    const acceptHeader = getHeader(allHeaders, "accept");
    const setCookies = cookieHeader ? `set_cookies(\`${String(cookieHeader).replace(/;/g, '", `').replace(/` /g, "`").replace(/[=]/g, '` = "')}")` : void 0;
    const setAccept = acceptHeader ? `accept("${escapeForDoubleQuotes(acceptHeader)}")` : void 0;
    const setContentType = `content_type("${escapeForDoubleQuotes(postData.mimeType)}")`;
    const otherHeaders = Object.entries(allHeaders).filter(([key]) => !["cookie", "accept", "content-type"].includes(key.toLowerCase())).map(([key, value]) => `'${key}' = '${escapeForSingleQuotes(value)}'`).join(", ");
    const setHeaders = otherHeaders ? `add_headers(${otherHeaders})` : void 0;
    let request2 = `response <- VERB("${method}", url`;
    if (payload) {
      request2 += ", body = payload";
    }
    if (queryString.length) {
      request2 += ", query = queryString";
    }
    const headerAdditions = [setHeaders, setContentType, setAccept, setCookies].filter((x) => !!x).join(", ");
    if (headerAdditions) {
      request2 += `, ${headerAdditions}`;
    }
    if (postData.text || postData.jsonObj || postData.params) {
      request2 += ", encode = encode";
    }
    request2 += ")";
    push(request2);
    blank();
    push('content(response, "text")');
    return join();
  }
};
var r = {
  info: {
    key: "r",
    title: "R",
    default: "httr"
  },
  clientsById: {
    httr
  }
};
var native4 = {
  info: {
    key: "native",
    title: "net::http",
    link: "http://ruby-doc.org/stdlib-2.2.1/libdoc/net/http/rdoc/Net/HTTP.html",
    description: "Ruby HTTP client",
    extname: ".rb"
  },
  convert: ({ uriObj, method: rawMethod, fullUrl, postData, allHeaders }) => {
    const { push, blank, join } = new CodeBuilder();
    push("require 'uri'");
    push("require 'net/http'");
    blank();
    const method = rawMethod.toUpperCase();
    const methods = [
      "GET",
      "POST",
      "HEAD",
      "DELETE",
      "PATCH",
      "PUT",
      "OPTIONS",
      "COPY",
      "LOCK",
      "UNLOCK",
      "MOVE",
      "TRACE"
    ];
    const capMethod = method.charAt(0) + method.substring(1).toLowerCase();
    if (!methods.includes(method)) {
      push(`class Net::HTTP::${capMethod} < Net::HTTPRequest`);
      push(`  METHOD = '${method.toUpperCase()}'`);
      push(`  REQUEST_HAS_BODY = '${postData.text ? "true" : "false"}'`);
      push("  RESPONSE_HAS_BODY = true");
      push("end");
      blank();
    }
    push(`url = URI("${fullUrl}")`);
    blank();
    push("http = Net::HTTP.new(url.host, url.port)");
    if (uriObj.protocol === "https:") {
      push("http.use_ssl = true");
    }
    blank();
    push(`request = Net::HTTP::${capMethod}.new(url)`);
    const headers = Object.keys(allHeaders);
    if (headers.length) {
      headers.forEach((key) => {
        push(`request["${key}"] = '${escapeForSingleQuotes(allHeaders[key])}'`);
      });
    }
    if (postData.text) {
      push(`request.body = ${JSON.stringify(postData.text)}`);
    }
    blank();
    push("response = http.request(request)");
    push("puts response.read_body");
    return join();
  }
};
var ruby = {
  info: {
    key: "ruby",
    title: "Ruby",
    default: "native"
  },
  clientsById: {
    native: native4
  }
};
var quote = (value = "") => {
  const safe = /^[a-z0-9-_/.@%^=:]+$/i;
  const isShellSafe = safe.test(value);
  if (isShellSafe) {
    return value;
  }
  return `'${value.replace(/'/g, "'\\''")}'`;
};
var escape2 = (value) => value.replace(/\r/g, "\\r").replace(/\n/g, "\\n");
var params = {
  "http1.0": "0",
  "url ": "",
  cookie: "b",
  data: "d",
  form: "F",
  globoff: "g",
  header: "H",
  insecure: "k",
  request: "X"
};
var getArg = (short) => (longName) => {
  if (short) {
    const shortName = params[longName];
    if (!shortName) {
      return "";
    }
    return `-${shortName}`;
  }
  return `--${longName}`;
};
var curl2 = {
  info: {
    key: "curl",
    title: "cURL",
    link: "http://curl.haxx.se/",
    description: "cURL is a command line tool and library for transferring data with URL syntax",
    extname: ".sh"
  },
  convert: ({ fullUrl, method, httpVersion, headersObj, allHeaders, postData }, options = {}) => {
    const { indent = "  ", short = false, binary: binary2 = false, globOff = false } = options;
    const indentJSON = "  ";
    const { push, join } = new CodeBuilder({
      ...typeof indent === "string" ? { indent } : {},
      join: indent !== false ? ` \\
${indent}` : " "
    });
    const arg = getArg(short);
    let formattedUrl = quote(fullUrl);
    push(`curl ${arg("request")} ${method}`);
    if (globOff) {
      formattedUrl = unescape(formattedUrl);
      push(arg("globoff"));
    }
    push(`${arg("url ")}${formattedUrl}`);
    if (httpVersion === "HTTP/1.0") {
      push(arg("http1.0"));
    }
    if (getHeader(allHeaders, "accept-encoding")) {
      push("--compressed");
    }
    if (postData.mimeType === "multipart/form-data") {
      const contentTypeHeaderName = getHeaderName(headersObj, "content-type");
      if (contentTypeHeaderName) {
        const contentTypeHeader = headersObj[contentTypeHeaderName];
        if (contentTypeHeaderName && contentTypeHeader) {
          const noBoundary = String(contentTypeHeader).replace(/; boundary.+?(?=(;|$))/, "");
          headersObj[contentTypeHeaderName] = noBoundary;
          allHeaders[contentTypeHeaderName] = noBoundary;
        }
      }
    }
    Object.keys(headersObj).sort().forEach((key) => {
      const header = `${key}: ${headersObj[key]}`;
      push(`${arg("header")} ${quote(header)}`);
    });
    if (allHeaders.cookie) {
      push(`${arg("cookie")} ${quote(allHeaders.cookie)}`);
    }
    switch (postData.mimeType) {
      case "multipart/form-data":
        postData.params?.forEach((param) => {
          let post = "";
          if (param.fileName) {
            post = `${param.name}='@${param.fileName}'`;
          } else {
            post = quote(`${param.name}=${param.value}`);
          }
          push(`${arg("form")} ${post}`);
        });
        break;
      case "application/x-www-form-urlencoded":
        if (postData.params) {
          postData.params.forEach((param) => {
            const unencoded = param.name;
            const encoded = encodeURIComponent(param.name);
            const needsEncoding = encoded !== unencoded;
            const name = needsEncoding ? encoded : unencoded;
            const flag = binary2 ? "--data-binary" : needsEncoding ? "--data-urlencode" : arg("data");
            push(`${flag} ${quote(`${name}=${param.value}`)}`);
          });
        } else {
          push(`${binary2 ? "--data-binary" : arg("data")} ${quote(postData.text)}`);
        }
        break;
      default:
        if (!postData.text) {
          break;
        }
        let builtPayload = false;
        if (isMimeTypeJSON(postData.mimeType)) {
          if (postData.text.length > 20) {
            try {
              const jsonPayload = JSON.parse(postData.text);
              builtPayload = true;
              if (postData.text.indexOf("'") > 0) {
                push(
                  `${binary2 ? "--data-binary" : arg("data")} @- <<EOF
${JSON.stringify(
                    jsonPayload,
                    null,
                    indentJSON
                  )}
EOF`
                );
              } else {
                push(
                  `${binary2 ? "--data-binary" : arg("data")} '
${JSON.stringify(jsonPayload, null, indentJSON)}
'`
                );
              }
            } catch (err) {
            }
          }
        }
        if (!builtPayload) {
          push(`${binary2 ? "--data-binary" : arg("data")} ${quote(postData.text)}`);
        }
    }
    return join();
  }
};
var httpie = {
  info: {
    key: "httpie",
    title: "HTTPie",
    link: "http://httpie.org/",
    description: "a CLI, cURL-like tool for humans",
    extname: ".sh",
    installation: "brew install httpie"
  },
  convert: ({ allHeaders, postData, queryObj, fullUrl, method, url }, options) => {
    const opts = {
      body: false,
      cert: false,
      headers: false,
      indent: "  ",
      pretty: false,
      print: false,
      queryParams: false,
      short: false,
      style: false,
      timeout: false,
      verbose: false,
      verify: false,
      ...options
    };
    const { push, join, unshift } = new CodeBuilder({
      indent: opts.indent,
      // @ts-expect-error SEEMS LEGIT
      join: opts.indent !== false ? ` \\
${opts.indent}` : " "
    });
    let raw = false;
    const flags2 = [];
    if (opts.headers) {
      flags2.push(opts.short ? "-h" : "--headers");
    }
    if (opts.body) {
      flags2.push(opts.short ? "-b" : "--body");
    }
    if (opts.verbose) {
      flags2.push(opts.short ? "-v" : "--verbose");
    }
    if (opts.print) {
      flags2.push(`${opts.short ? "-p" : "--print"}=${opts.print}`);
    }
    if (opts.verify) {
      flags2.push(`--verify=${opts.verify}`);
    }
    if (opts.cert) {
      flags2.push(`--cert=${opts.cert}`);
    }
    if (opts.pretty) {
      flags2.push(`--pretty=${opts.pretty}`);
    }
    if (opts.style) {
      flags2.push(`--style=${opts.style}`);
    }
    if (opts.timeout) {
      flags2.push(`--timeout=${opts.timeout}`);
    }
    if (opts.queryParams) {
      Object.keys(queryObj).forEach((name) => {
        const value = queryObj[name];
        if (Array.isArray(value)) {
          value.forEach((val) => {
            push(`${name}==${quote(val)}`);
          });
        } else {
          push(`${name}==${quote(value)}`);
        }
      });
    }
    Object.keys(allHeaders).sort().forEach((key) => {
      push(`${key}:${quote(allHeaders[key])}`);
    });
    if (postData.mimeType === "application/x-www-form-urlencoded") {
      if (postData.params && postData.params.length) {
        flags2.push(opts.short ? "-f" : "--form");
        postData.params.forEach((param) => {
          push(`${param.name}=${quote(param.value)}`);
        });
      }
    } else {
      raw = true;
    }
    const cliFlags = flags2.length ? `${flags2.join(" ")} ` : "";
    url = quote(opts.queryParams ? url : fullUrl);
    unshift(`http ${cliFlags}${method} ${url}`);
    if (raw && postData.text) {
      const postDataText = quote(postData.text);
      unshift(`echo ${postDataText} | `);
    }
    return join();
  }
};
var wget = {
  info: {
    key: "wget",
    title: "Wget",
    link: "https://www.gnu.org/software/wget/",
    description: "a free software package for retrieving files using HTTP, HTTPS",
    extname: ".sh"
  },
  convert: ({ method, postData, allHeaders, fullUrl }, options) => {
    const opts = {
      indent: "  ",
      short: false,
      verbose: false,
      ...options
    };
    const { push, join } = new CodeBuilder({
      ...typeof opts.indent === "string" ? { indent: opts.indent } : {},
      join: opts.indent !== false ? ` \\
${opts.indent}` : " "
    });
    if (opts.verbose) {
      push(`wget ${opts.short ? "-v" : "--verbose"}`);
    } else {
      push(`wget ${opts.short ? "-q" : "--quiet"}`);
    }
    push(`--method ${quote(method)}`);
    Object.keys(allHeaders).forEach((key) => {
      const header = `${key}: ${allHeaders[key]}`;
      push(`--header ${quote(header)}`);
    });
    if (postData.text) {
      push(`--body-data ${escape2(quote(postData.text))}`);
    }
    push(opts.short ? "-O" : "--output-document");
    push(`- ${quote(fullUrl)}`);
    return join();
  }
};
var shell = {
  info: {
    key: "shell",
    title: "Shell",
    default: "curl",
    cli: "%s"
  },
  clientsById: {
    curl: curl2,
    httpie,
    wget
  }
};
var buildString = (length, str2) => str2.repeat(length);
var concatArray = (arr, pretty, indentation, indentLevel) => {
  const currentIndent = buildString(indentLevel, indentation);
  const closingBraceIndent = buildString(indentLevel - 1, indentation);
  const join = pretty ? `,
${currentIndent}` : ", ";
  if (pretty) {
    return `[
${currentIndent}${arr.join(join)}
${closingBraceIndent}]`;
  }
  return `[${arr.join(join)}]`;
};
var literalDeclaration = (name, parameters, opts) => `let ${name} = ${literalRepresentation3(parameters, opts)}`;
var literalRepresentation3 = (value, opts, indentLevel) => {
  indentLevel = indentLevel === void 0 ? 1 : indentLevel + 1;
  switch (Object.prototype.toString.call(value)) {
    case "[object Number]":
      return value;
    case "[object Array]": {
      let pretty = false;
      const valuesRepresentation = value.map((v) => {
        if (Object.prototype.toString.call(v) === "[object Object]") {
          pretty = Object.keys(v).length > 1;
        }
        return literalRepresentation3(v, opts, indentLevel);
      });
      return concatArray(valuesRepresentation, pretty, opts.indent, indentLevel);
    }
    case "[object Object]": {
      const keyValuePairs = [];
      for (const key in value) {
        keyValuePairs.push(`"${key}": ${literalRepresentation3(value[key], opts, indentLevel)}`);
      }
      return concatArray(
        keyValuePairs,
        // @ts-expect-error needs better types
        opts.pretty && keyValuePairs.length > 1,
        // @ts-expect-error needs better types
        opts.indent,
        indentLevel
      );
    }
    case "[object Boolean]":
      return value.toString();
    default:
      if (value === null || value === void 0) {
        return "nil";
      }
      return `"${value.toString().replace(/"/g, '\\"')}"`;
  }
};
var urlsession = {
  info: {
    key: "urlsession",
    title: "URLSession",
    link: "https://developer.apple.com/documentation/foundation/urlsession",
    description: "Foundation's URLSession request",
    extname: ".swift"
  },
  convert: ({ allHeaders, postData, uriObj, queryObj, method }, options) => {
    const opts = {
      indent: "  ",
      pretty: true,
      timeout: 10,
      ...options
    };
    const { push, blank, join } = new CodeBuilder({ indent: opts.indent });
    push("import Foundation");
    blank();
    const hasBody = postData.text || postData.jsonObj || postData.params;
    if (hasBody) {
      switch (postData.mimeType) {
        case "application/x-www-form-urlencoded":
          if (postData.params?.length) {
            const parameters = postData.params.map((p) => `"${p.name}": "${p.value}"`);
            if (opts.pretty) {
              push("let parameters = [");
              parameters.forEach((param) => push(`${param},`, 1));
              push("]");
            } else {
              push(`let parameters = [${parameters.join(", ")}]`);
            }
            push('let joinedParameters = parameters.map { "\\($0.key)=\\($0.value)" }.joined(separator: "&")');
            push("let postData = Data(joinedParameters.utf8)");
            blank();
          }
          break;
        case "application/json":
          if (postData.jsonObj) {
            push(`${literalDeclaration("parameters", postData.jsonObj, opts)} as [String : Any?]`);
            blank();
            push("let postData = try JSONSerialization.data(withJSONObject: parameters, options: [])");
            blank();
          }
          break;
        case "multipart/form-data":
          push(literalDeclaration("parameters", postData.params, opts));
          blank();
          push(`let boundary = "${postData.boundary}"`);
          blank();
          push('var body = ""');
          push("for param in parameters {");
          push('let paramName = param["name"]!', 1);
          push('body += "--\\(boundary)\\r\\n"', 1);
          push('body += "Content-Disposition:form-data; name=\\"\\(paramName)\\""', 1);
          push('if let filename = param["fileName"] {', 1);
          push('let contentType = param["contentType"]!', 2);
          push("let fileContent = try String(contentsOfFile: filename, encoding: .utf8)", 2);
          push('body += "; filename=\\"\\(filename)\\"\\r\\n"', 2);
          push('body += "Content-Type: \\(contentType)\\r\\n\\r\\n"', 2);
          push("body += fileContent", 2);
          push('} else if let paramValue = param["value"] {', 1);
          push('body += "\\r\\n\\r\\n\\(paramValue)"', 2);
          push("}", 1);
          push("}");
          blank();
          push("let postData = Data(body.utf8)");
          blank();
          break;
        default:
          push(`let postData = Data("${postData.text}".utf8)`);
          blank();
      }
    }
    push(`let url = URL(string: "${uriObj.href}")!`);
    const queries = queryObj ? Object.entries(queryObj) : [];
    if (queries.length < 1) {
      push("var request = URLRequest(url: url)");
    } else {
      push("var components = URLComponents(url: url, resolvingAgainstBaseURL: true)!");
      push("let queryItems: [URLQueryItem] = [");
      queries.forEach((query) => {
        const key = query[0];
        const value = query[1];
        switch (Object.prototype.toString.call(value)) {
          case "[object String]":
            push(`URLQueryItem(name: "${key}", value: "${value}"),`, 1);
            break;
          case "[object Array]":
            value.forEach((val) => {
              push(`URLQueryItem(name: "${key}", value: "${val}"),`, 1);
            });
            break;
        }
      });
      push("]");
      push("components.queryItems = components.queryItems.map { $0 + queryItems } ?? queryItems");
      blank();
      push("var request = URLRequest(url: components.url!)");
    }
    push(`request.httpMethod = "${method}"`);
    push(`request.timeoutInterval = ${opts.timeout}`);
    if (Object.keys(allHeaders).length) {
      push(`request.allHTTPHeaderFields = ${literalRepresentation3(allHeaders, opts)}`);
    }
    if (hasBody) {
      push("request.httpBody = postData");
    }
    blank();
    push("let (data, _) = try await URLSession.shared.data(for: request)");
    push("print(String(decoding: data, as: UTF8.self))");
    return join();
  }
};
var swift = {
  info: {
    key: "swift",
    title: "Swift",
    default: "urlsession"
  },
  clientsById: {
    urlsession
  }
};
var targets = {
  c,
  clojure,
  csharp,
  go,
  http,
  java,
  javascript,
  json,
  kotlin,
  node,
  objc,
  ocaml,
  php,
  powershell,
  python,
  r,
  ruby,
  shell,
  swift
};
var isClient = (client) => {
  if (!client) {
    throw new Error("clients must be objects");
  }
  if (!Object.prototype.hasOwnProperty.call(client, "info")) {
    throw new Error("targets client must contain an `info` object");
  }
  if (!Object.prototype.hasOwnProperty.call(client.info, "key")) {
    throw new Error("targets client must have an `info` object with property `key`");
  }
  if (!client.info.key) {
    throw new Error("client.info.key must contain an identifier unique to this target");
  }
  if (!Object.prototype.hasOwnProperty.call(client.info, "title")) {
    throw new Error("targets client must have an `info` object with property `title`");
  }
  if (!Object.prototype.hasOwnProperty.call(client.info, "description")) {
    throw new Error("targets client must have an `info` object with property `description`");
  }
  if (!Object.prototype.hasOwnProperty.call(client.info, "link")) {
    throw new Error("targets client must have an `info` object with property `link`");
  }
  if (!Object.prototype.hasOwnProperty.call(client.info, "extname")) {
    throw new Error("targets client must have an `info` object with the property `extname`");
  }
  if (!Object.prototype.hasOwnProperty.call(client, "convert") || typeof client.convert !== "function") {
    throw new Error("targets client must have a `convert` property containing a conversion function");
  }
  return true;
};
var addClientPlugin = (plugin) => {
  addTargetClient(plugin.target, plugin.client);
};
var addTargetClient = (targetId, client) => {
  if (!isClient(client)) ;
  if (!Object.prototype.hasOwnProperty.call(targets, targetId)) {
    throw new Error(`Sorry, but no ${targetId} target exists to add clients to`);
  }
  if (Object.prototype.hasOwnProperty.call(targets[targetId], client.info.key)) {
    throw new Error(
      `the target ${targetId} already has a client with the key ${client.info.key}, please use a different key`
    );
  }
  targets[targetId].clientsById[client.info.key] = client;
};

// node_modules/@readme/oas-to-snippet/dist/chunk-CJ2JA7HH.js
var DEFAULT_LANGUAGES = {
  c: {
    highlight: "text/x-csrc",
    httpsnippet: {
      lang: "c",
      default: "libcurl",
      targets: {
        libcurl: { name: "libcurl" }
      }
    }
  },
  clojure: {
    highlight: "clojure",
    httpsnippet: {
      lang: "clojure",
      default: "clj_http",
      targets: {
        clj_http: { name: "clj-http" }
      }
    }
  },
  cplusplus: {
    highlight: "text/x-c++src",
    httpsnippet: {
      lang: "c",
      default: "libcurl",
      targets: {
        libcurl: { name: "libcurl" }
      }
    }
  },
  csharp: {
    highlight: "text/x-csharp",
    httpsnippet: {
      lang: "csharp",
      default: "restsharp",
      targets: {
        httpclient: { name: "HttpClient" },
        restsharp: { name: "RestSharp" }
      }
    }
  },
  http: {
    highlight: "http",
    httpsnippet: {
      lang: "http",
      default: "http1.1",
      targets: {
        "http1.1": { name: "HTTP 1.1" }
      }
    }
  },
  go: {
    highlight: "go",
    httpsnippet: {
      lang: "go",
      default: "native",
      targets: {
        native: { name: "http.NewRequest" }
      }
    }
  },
  java: {
    highlight: "java",
    httpsnippet: {
      lang: "java",
      default: "okhttp",
      targets: {
        asynchttp: { name: "AsyncHttp" },
        nethttp: { name: "java.net.http" },
        okhttp: { name: "OkHttp" },
        unirest: { name: "Unirest" }
      }
    }
  },
  javascript: {
    highlight: "javascript",
    httpsnippet: {
      lang: "javascript",
      default: "fetch",
      targets: {
        axios: { name: "Axios" },
        fetch: { name: "fetch" },
        jquery: { name: "jQuery" },
        xhr: { name: "XMLHttpRequest" }
      }
    }
  },
  json: {
    highlight: "json",
    httpsnippet: {
      lang: "json",
      default: "native",
      targets: {
        native: { name: "JSON" }
      }
    }
  },
  kotlin: {
    highlight: "java",
    httpsnippet: {
      lang: "kotlin",
      default: "okhttp",
      targets: {
        okhttp: { name: "OkHttp" }
      }
    }
  },
  node: {
    highlight: "javascript",
    httpsnippet: {
      lang: "node",
      default: "fetch",
      targets: {
        axios: { name: "Axios" },
        fetch: { name: "node-fetch" },
        native: { name: "http" },
        request: { name: "Request" }
      }
    }
  },
  objectivec: {
    highlight: "objectivec",
    httpsnippet: {
      lang: "objc",
      default: "nsurlsession",
      targets: {
        nsurlsession: { name: "NSURLSession" }
      }
    }
  },
  ocaml: {
    highlight: "ocaml",
    httpsnippet: {
      lang: "ocaml",
      default: "cohttp",
      targets: {
        cohttp: { name: "CoHTTP" }
      }
    }
  },
  php: {
    highlight: "php",
    httpsnippet: {
      lang: "php",
      default: "guzzle",
      targets: {
        curl: { name: "cURL" },
        guzzle: { name: "Guzzle" }
      }
    }
  },
  powershell: {
    highlight: "powershell",
    httpsnippet: {
      lang: "powershell",
      default: "webrequest",
      targets: {
        restmethod: { name: "Invoke-RestMethod" },
        webrequest: { name: "Invoke-WebRequest" }
      }
    }
  },
  python: {
    highlight: "python",
    httpsnippet: {
      lang: "python",
      default: "requests",
      targets: {
        requests: { name: "Requests" }
      }
    }
  },
  r: {
    highlight: "r",
    httpsnippet: {
      lang: "r",
      default: "httr",
      targets: {
        httr: { name: "httr" }
      }
    }
  },
  ruby: {
    highlight: "ruby",
    httpsnippet: {
      lang: "ruby",
      default: "native",
      targets: {
        native: { name: "net::http" }
      }
    }
  },
  shell: {
    highlight: "shell",
    httpsnippet: {
      lang: "shell",
      default: "curl",
      targets: {
        curl: {
          name: "cURL",
          opts: {
            escapeBrackets: true,
            indent: "     "
          }
        },
        httpie: { name: "HTTPie" }
      }
    }
  },
  swift: {
    highlight: "swift",
    httpsnippet: {
      lang: "swift",
      default: "urlsession",
      targets: {
        urlsession: { name: "URLSession" }
      }
    }
  }
};
function getSupportedLanguages({
  plugins
} = { plugins: [] }) {
  const languages = JSON.parse(JSON.stringify(DEFAULT_LANGUAGES));
  Object.entries(targets).forEach(([target, { clientsById }]) => {
    if (!(target in languages)) {
      return;
    }
    Object.entries(clientsById).forEach(([client, data]) => {
      if (!(client in languages[target].httpsnippet.targets)) {
        return;
      }
      if ("installation" in data.info) {
        languages[target].httpsnippet.targets[client].install = data.info.installation;
      }
    });
  });
  (plugins || []).forEach(({ target, client: { info: clientInfo } }) => {
    const clientKey = clientInfo.key;
    languages[target].httpsnippet.targets[clientKey] = {
      name: clientInfo.title
    };
    if (clientInfo.installation) {
      languages[target].httpsnippet.targets[clientKey].install = clientInfo.installation;
    }
  });
  return languages;
}
function getLanguageConfig(languages, lang) {
  let config;
  let language;
  let target;
  if (Array.isArray(lang)) {
    if (lang[0] in languages) {
      if (lang[1] in languages[lang[0]].httpsnippet.targets) {
        config = languages[lang[0]];
        language = config.httpsnippet.lang;
        target = lang[1];
      }
    }
  } else if (lang in languages) {
    config = languages[lang];
    language = config.httpsnippet.lang;
    target = config.httpsnippet.default;
  } else {
    throw new Error("An unknown language was supplied.");
  }
  return {
    config,
    language,
    target
  };
}
function getClientInstallationInstructions(languages, lang, registryIdentifier) {
  const { config, target } = getLanguageConfig(languages, lang);
  const install = config?.httpsnippet.targets[target || ""]?.install;
  if (!install) {
    return void 0;
  }
  return registryIdentifier ? install.replace("{packageName}", registryIdentifier) : install;
}

// src/generateCodeSamplesOverlay.ts
var import_fs = __toESM(require("fs"));

// node_modules/oas/dist/chunk-SITXIAYE.js
var import_jsonpointer = __toESM(require_jsonpointer(), 1);
function findSchemaDefinition($ref, definition = {}) {
  const origRef = $ref;
  $ref = $ref.trim();
  if ($ref === "") {
    return false;
  }
  if ($ref.startsWith("#")) {
    $ref = decodeURIComponent($ref.substring(1));
  } else {
    throw new Error(`Could not find a definition for ${origRef}.`);
  }
  const current = import_jsonpointer.default.get(definition, $ref);
  if (current === void 0) {
    throw new Error(`Could not find a definition for ${origRef}.`);
  }
  return current;
}
var supportedMethods2 = /* @__PURE__ */ new Set(["get", "put", "post", "delete", "options", "head", "patch", "trace"]);

// node_modules/oas/dist/chunk-JCLIAFTG.js
var CODE_SAMPLES = "code-samples";
var EXPLORER_ENABLED = "explorer-enabled";
var HEADERS = "headers";
var METRICS_ENABLED = "metrics-enabled";
var PARAMETER_ORDERING = "parameter-ordering";
var PROXY_ENABLED = "proxy-enabled";
var SAMPLES_LANGUAGES = "samples-languages";
var SIMPLE_MODE = "simple-mode";
var DISABLE_TAG_SORTING = "disable-tag-sorting";
var extensionDefaults = {
  [CODE_SAMPLES]: void 0,
  [DISABLE_TAG_SORTING]: false,
  [EXPLORER_ENABLED]: true,
  [HEADERS]: void 0,
  [METRICS_ENABLED]: true,
  [PARAMETER_ORDERING]: ["path", "query", "body", "cookie", "form", "header"],
  [PROXY_ENABLED]: true,
  [SAMPLES_LANGUAGES]: ["shell", "node", "ruby", "php", "python", "java", "csharp"],
  [SIMPLE_MODE]: true
};
function hasRootExtension(extension, api) {
  return Boolean(api && extension in api);
}
function getExtension(extension, api, operation) {
  if (operation) {
    if (operation.hasExtension("x-readme")) {
      const data = operation.getExtension("x-readme");
      if (data && typeof data === "object" && extension in data) {
        return data[extension];
      }
    }
    if (operation.hasExtension(`x-${extension}`)) {
      return operation.getExtension(`x-${extension}`);
    } else if (operation.hasExtension(extension)) {
      return operation.getExtension(extension);
    }
  }
  if (extension === CODE_SAMPLES) {
    return extensionDefaults[extension];
  }
  if (hasRootExtension("x-readme", api)) {
    const data = api?.["x-readme"];
    if (data && typeof data === "object" && extension in data) {
      return data[extension];
    }
  }
  if (hasRootExtension(`x-${extension}`, api)) {
    return api?.[`x-${extension}`];
  } else if (hasRootExtension(extension, api)) {
    return api?.[extension];
  }
  if (extension in extensionDefaults) {
    return extensionDefaults[extension];
  }
  return void 0;
}
function validateParameterOrdering(ordering, extension) {
  const defaultValue = extensionDefaults[PARAMETER_ORDERING];
  const requiredLength = defaultValue.length;
  const defaultsHuman = `${defaultValue.slice(0, -1).join(", ")}, and ${defaultValue.slice(-1)}`;
  if (ordering.length !== requiredLength) {
    throw new TypeError(`"${extension}" must contain ${requiredLength} items comprised of: ${defaultsHuman}`);
  }
  const intersection = ordering.filter((value) => defaultValue.includes(value.toLowerCase()));
  if (intersection.length !== requiredLength) {
    throw new TypeError(`"${extension}" must contain ${requiredLength} items comprised of: ${defaultsHuman}`);
  }
}

// node_modules/oas/dist/chunk-MHJ3WXXI.js
function isRef(check) {
  return check.$ref !== void 0;
}
function isOAS31(check) {
  return check.openapi === "3.1.0";
}
function isSchema(check, isPolymorphicAllOfChild = false) {
  return check.type !== void 0 || check.allOf !== void 0 || check.anyOf !== void 0 || check.oneOf !== void 0 || isPolymorphicAllOfChild;
}

// node_modules/oas/dist/chunk-LDL5I3B3.js
var import_json_schema_merge_allof = __toESM(require_src2(), 1);
var import_jsonpointer2 = __toESM(require_jsonpointer(), 1);

// node_modules/remove-undefined-objects/dist/index.mjs
function isObject(obj) {
  return typeof obj === "object" && obj !== null && !Array.isArray(obj);
}
function isEmptyObject(obj) {
  return typeof obj === "object" && obj !== null && !Object.keys(obj).length;
}
function stripEmptyObjects(obj) {
  const cleanObj = obj;
  if (!isObject(obj) && !Array.isArray(cleanObj)) {
    return cleanObj;
  } else if (obj === null) {
    return void 0;
  }
  if (!Array.isArray(cleanObj)) {
    Object.keys(cleanObj).forEach((key) => {
      let value = cleanObj[key];
      if (typeof value === "object" && value !== null) {
        value = stripEmptyObjects(value);
        if (isEmptyObject(value)) {
          delete cleanObj[key];
        } else {
          cleanObj[key] = value;
        }
      } else if (value === null) {
      }
    });
    return cleanObj;
  }
  cleanObj.forEach((o, idx) => {
    let value = o;
    if (typeof value === "object" && value !== null) {
      value = stripEmptyObjects(value);
      if (isEmptyObject(value)) {
        delete cleanObj[idx];
      } else {
        cleanObj[idx] = value;
      }
    } else if (value === null) {
      delete cleanObj[idx];
    }
  });
  return cleanObj.filter((el) => el !== void 0);
}
function removeUndefinedObjects(obj) {
  if (obj === void 0) {
    return void 0;
  }
  let withoutUndefined = JSON.parse(JSON.stringify(obj));
  withoutUndefined = stripEmptyObjects(withoutUndefined);
  if (isEmptyObject(withoutUndefined))
    return void 0;
  return withoutUndefined;
}

// node_modules/oas/dist/chunk-LDL5I3B3.js
function cloneObject(obj) {
  if (typeof obj === "undefined") {
    return void 0;
  }
  return JSON.parse(JSON.stringify(obj));
}
function hasSchemaType(schema2, discriminator) {
  if (Array.isArray(schema2.type)) {
    return schema2.type.includes(discriminator);
  }
  return schema2.type === discriminator;
}
function isObject2(val) {
  return typeof val === "object" && val !== null && !Array.isArray(val);
}
function isPrimitive(val) {
  return typeof val === "string" || typeof val === "number" || typeof val === "boolean";
}
function matchesMediaType(types22, mediaType) {
  return types22.some((type2) => {
    return mediaType.indexOf(type2) > -1;
  });
}
var matches_mimetype_default = {
  formUrlEncoded: (mimeType) => {
    return matchesMediaType(["application/x-www-form-urlencoded"], mimeType);
  },
  json: (contentType) => {
    return matchesMediaType(
      ["application/json", "application/x-json", "text/json", "text/x-json", "+json"],
      contentType
    );
  },
  multipart: (contentType) => {
    return matchesMediaType(
      ["multipart/mixed", "multipart/related", "multipart/form-data", "multipart/alternative"],
      contentType
    );
  },
  wildcard: (contentType) => {
    return contentType === "*/*";
  },
  xml: (contentType) => {
    return matchesMediaType(
      [
        "application/xml",
        "application/xml-external-parsed-entity",
        "application/xml-dtd",
        "text/xml",
        "text/xml-external-parsed-entity",
        "+xml"
      ],
      contentType
    );
  }
};
var UNSUPPORTED_SCHEMA_PROPS = [
  "example",
  // OpenAPI supports `example` but we're mapping it to `examples` in this library.
  "externalDocs",
  "xml"
];
function encodePointer(str2) {
  return str2.replace("~", "~0").replace("/", "~1");
}
function getSchemaVersionString(schema2, api) {
  if (!isOAS31(api)) {
    return "http://json-schema.org/draft-04/schema#";
  }
  if (schema2.$schema) {
    return schema2.$schema;
  }
  if (api.jsonSchemaDialect) {
    return api.jsonSchemaDialect;
  }
  return "https://json-schema.org/draft/2020-12/schema#";
}
function isPolymorphicSchema(schema2) {
  return "allOf" in schema2 || "anyOf" in schema2 || "oneOf" in schema2;
}
function isRequestBodySchema(schema2) {
  return "content" in schema2;
}
function searchForValueByPropAndPointer(property, pointer, schemas = []) {
  if (!schemas.length || !pointer.length) {
    return void 0;
  }
  const locSplit = pointer.split("/").filter(Boolean).reverse();
  const pointers = [];
  let point = "";
  for (let i = 0; i < locSplit.length; i += 1) {
    point = `/${locSplit[i]}${point}`;
    pointers.push(point);
  }
  let foundValue;
  const rev = [...schemas].reverse();
  for (let i = 0; i < pointers.length; i += 1) {
    for (let ii = 0; ii < rev.length; ii += 1) {
      let schema2 = rev[ii];
      if (property === "example") {
        if ("example" in schema2) {
          schema2 = schema2.example;
        } else {
          if (!Array.isArray(schema2.examples) || !schema2.examples.length) {
            continue;
          }
          schema2 = [...schema2.examples].shift();
        }
      } else {
        schema2 = schema2.default;
      }
      try {
        foundValue = import_jsonpointer2.default.get(schema2, pointers[i]);
      } catch (err) {
      }
      if (foundValue !== void 0) {
        break;
      }
    }
    if (foundValue !== void 0) {
      break;
    }
  }
  return foundValue;
}
function toJSONSchema(data, opts = {}) {
  let schema2 = data === true ? {} : { ...data };
  const schemaAdditionalProperties = isSchema(schema2) ? schema2.additionalProperties : null;
  const {
    addEnumsToDescriptions,
    currentLocation,
    globalDefaults,
    hideReadOnlyProperties,
    hideWriteOnlyProperties,
    isPolymorphicAllOfChild,
    prevDefaultSchemas,
    prevExampleSchemas,
    refLogger,
    transformer
  } = {
    addEnumsToDescriptions: false,
    currentLocation: "",
    globalDefaults: {},
    hideReadOnlyProperties: false,
    hideWriteOnlyProperties: false,
    isPolymorphicAllOfChild: false,
    prevDefaultSchemas: [],
    prevExampleSchemas: [],
    refLogger: () => true,
    transformer: (s) => s,
    ...opts
  };
  if (isRef(schema2)) {
    refLogger(schema2.$ref, "ref");
    return transformer({
      $ref: schema2.$ref
    });
  }
  if (isSchema(schema2, isPolymorphicAllOfChild)) {
    if ("allOf" in schema2 && Array.isArray(schema2.allOf)) {
      try {
        schema2 = (0, import_json_schema_merge_allof.default)(schema2, {
          ignoreAdditionalProperties: true,
          resolvers: {
            // `merge-json-schema-allof` by default takes the first `description` when you're
            // merging an `allOf` but because generally when you're merging two schemas together
            // with an `allOf` you want data in the subsequent schemas to be applied to the first
            // and `description` should be a part of that.
            description: (obj) => {
              return obj.slice(-1)[0];
            },
            // `merge-json-schema-allof` doesn't support merging enum arrays but since that's a
            // safe and simple operation as enums always contain primitives we can handle it
            // ourselves with a custom resolver.
            enum: (obj) => {
              let arr = [];
              obj.forEach((e) => {
                arr = arr.concat(e);
              });
              return arr;
            },
            // JSON Schema ony supports examples with the `examples` property, since we're
            // ingesting OpenAPI definitions we need to add a custom resolver for its `example`
            // property.
            example: (obj) => obj[0],
            // JSON Schema has no support for `format` on anything other than `string`, but since
            // OpenAPI has it on `integer` and `number` we need to add a custom resolver here so we
            // can still merge schemas that may have those.
            format: (obj) => obj[0],
            // Since JSON Schema obviously doesn't know about our vendor extension we need to tell
            // the library to essentially ignore and pass it along.
            "x-readme-ref-name": (obj) => obj[0]
          }
        });
      } catch (e) {
        const { ...schemaWithoutAllOf } = schema2;
        schema2 = schemaWithoutAllOf;
        delete schema2.allOf;
      }
      if (isRef(schema2)) {
        refLogger(schema2.$ref, "ref");
        return transformer({
          $ref: schema2.$ref
        });
      }
    }
    ["anyOf", "oneOf"].forEach((polyType) => {
      if (polyType in schema2 && Array.isArray(schema2[polyType])) {
        schema2[polyType].forEach((item, idx) => {
          const polyOptions = {
            addEnumsToDescriptions,
            currentLocation: `${currentLocation}/${idx}`,
            globalDefaults,
            hideReadOnlyProperties,
            hideWriteOnlyProperties,
            isPolymorphicAllOfChild: false,
            prevDefaultSchemas,
            prevExampleSchemas,
            refLogger,
            transformer
          };
          if ("properties" in schema2) {
            schema2[polyType][idx] = toJSONSchema(
              { required: schema2.required, allOf: [item, { properties: schema2.properties }] },
              polyOptions
            );
          } else if ("items" in schema2) {
            schema2[polyType][idx] = toJSONSchema(
              { allOf: [item, { items: schema2.items }] },
              polyOptions
            );
          } else {
            schema2[polyType][idx] = toJSONSchema(item, polyOptions);
          }
          if (isObject2(schema2[polyType][idx]) && "required" in schema2[polyType][idx] && typeof schema2[polyType][idx].required === "boolean") {
            delete schema2[polyType][idx].required;
          }
        });
      }
    });
    if ("discriminator" in schema2) {
      if ("mapping" in schema2.discriminator && typeof schema2.discriminator.mapping === "object") {
        const mapping = schema2.discriminator.mapping;
        Object.keys(mapping).forEach((k) => {
          refLogger(mapping[k], "discriminator");
        });
      }
    }
  }
  if (!("type" in schema2) && !isPolymorphicSchema(schema2) && !isRequestBodySchema(schema2)) {
    if ("properties" in schema2) {
      schema2.type = "object";
    } else if ("items" in schema2) {
      schema2.type = "array";
    } else {
    }
  }
  if ("type" in schema2) {
    if ("nullable" in schema2) {
      if (Array.isArray(schema2.type)) {
        schema2.type.push("null");
      } else if (schema2.type !== null && schema2.type !== "null") {
        schema2.type = [schema2.type, "null"];
      }
      delete schema2.nullable;
    }
    if (schema2.type === null) {
      schema2.type = "null";
    } else if (Array.isArray(schema2.type)) {
      if (schema2.type.includes(null)) {
        schema2.type[schema2.type.indexOf(null)] = "null";
      }
      schema2.type = Array.from(new Set(schema2.type));
      if (schema2.type.length === 1) {
        schema2.type = schema2.type.shift();
      } else if (schema2.type.includes("array") || schema2.type.includes("boolean") || schema2.type.includes("object")) {
        const isNullable = schema2.type.includes("null");
        if (schema2.type.length === 2 && isNullable) {
        } else {
          const nonPrimitives = [];
          Object.entries({
            // https://json-schema.org/understanding-json-schema/reference/array.html
            array: [
              "additionalItems",
              "contains",
              "items",
              "maxContains",
              "maxItems",
              "minContains",
              "minItems",
              "prefixItems",
              "uniqueItems"
            ],
            // https://json-schema.org/understanding-json-schema/reference/boolean.html
            boolean: [
              // Booleans don't have any boolean-specific properties.
            ],
            // https://json-schema.org/understanding-json-schema/reference/object.html
            object: [
              "additionalProperties",
              "maxProperties",
              "minProperties",
              "nullable",
              "patternProperties",
              "properties",
              "propertyNames",
              "required"
            ]
          }).forEach(([typeKey, keywords]) => {
            if (!schema2.type.includes(typeKey)) {
              return;
            }
            const reducedSchema = removeUndefinedObjects({
              type: isNullable ? [typeKey, "null"] : typeKey,
              allowEmptyValue: schema2.allowEmptyValue ?? void 0,
              deprecated: schema2.deprecated ?? void 0,
              description: schema2.description ?? void 0,
              readOnly: schema2.readOnly ?? void 0,
              title: schema2.title ?? void 0,
              writeOnly: schema2.writeOnly ?? void 0
            });
            keywords.forEach((t) => {
              if (t in schema2) {
                reducedSchema[t] = schema2[t];
                delete schema2[t];
              }
            });
            nonPrimitives.push(reducedSchema);
          });
          schema2.type = schema2.type.filter((t) => t !== "array" && t !== "boolean" && t !== "object");
          if (schema2.type.length === 1) {
            schema2.type = schema2.type.shift();
          }
          if (schema2.type.length > 1) {
            schema2 = { oneOf: [schema2, ...nonPrimitives] };
          } else {
            schema2 = { oneOf: nonPrimitives };
          }
        }
      }
    }
  }
  if (isSchema(schema2, isPolymorphicAllOfChild)) {
    if ("default" in schema2 && isObject2(schema2.default)) {
      prevDefaultSchemas.push({ default: schema2.default });
    }
    if ("example" in schema2) {
      if (isPrimitive(schema2.example)) {
        schema2.examples = [schema2.example];
      } else if (Array.isArray(schema2.example)) {
        schema2.examples = schema2.example.filter((example) => isPrimitive(example));
        if (!schema2.examples.length) {
          delete schema2.examples;
        }
      } else {
        prevExampleSchemas.push({ example: schema2.example });
      }
      delete schema2.example;
    } else if ("examples" in schema2) {
      let reshapedExamples = false;
      if (typeof schema2.examples === "object" && !Array.isArray(schema2.examples)) {
        const examples = [];
        Object.keys(schema2.examples).forEach((name) => {
          const example = schema2.examples[name];
          if ("$ref" in example) {
            refLogger(example.$ref, "ref");
          } else if ("value" in example) {
            if (isPrimitive(example.value)) {
              examples.push(example.value);
              reshapedExamples = true;
            } else if (Array.isArray(example.value) && isPrimitive(example.value[0])) {
              examples.push(example.value[0]);
              reshapedExamples = true;
            } else {
              prevExampleSchemas.push({
                example: example.value
              });
            }
          }
        });
        if (examples.length) {
          reshapedExamples = true;
          schema2.examples = examples;
        }
      } else if (Array.isArray(schema2.examples) && isPrimitive(schema2.examples[0])) {
        reshapedExamples = true;
      }
      if (!reshapedExamples) {
        delete schema2.examples;
      }
    }
    if (!hasSchemaType(schema2, "array") && !hasSchemaType(schema2, "object") && !schema2.examples) {
      const foundExample = searchForValueByPropAndPointer("example", currentLocation, prevExampleSchemas);
      if (foundExample) {
        if (isPrimitive(foundExample) || Array.isArray(foundExample) && isPrimitive(foundExample[0])) {
          schema2.examples = [foundExample];
        }
      }
    }
    if (hasSchemaType(schema2, "array")) {
      if ("items" in schema2) {
        if (!Array.isArray(schema2.items) && Object.keys(schema2.items).length === 1 && isRef(schema2.items)) {
          refLogger(schema2.items.$ref, "ref");
        } else if (schema2.items !== true) {
          schema2.items = toJSONSchema(schema2.items, {
            addEnumsToDescriptions,
            currentLocation: `${currentLocation}/0`,
            globalDefaults,
            hideReadOnlyProperties,
            hideWriteOnlyProperties,
            prevExampleSchemas,
            refLogger,
            transformer
          });
          if (isObject2(schema2.items) && "required" in schema2.items && !Array.isArray(schema2.items.required)) {
            delete schema2.items.required;
          }
        }
      } else if ("properties" in schema2 || "additionalProperties" in schema2) {
        schema2.type = "object";
      } else {
        schema2.items = {};
      }
    } else if (hasSchemaType(schema2, "object")) {
      if ("properties" in schema2) {
        Object.keys(schema2.properties).forEach((prop) => {
          if (Array.isArray(schema2.properties[prop]) || typeof schema2.properties[prop] === "object" && schema2.properties[prop] !== null) {
            const newPropSchema = toJSONSchema(schema2.properties[prop], {
              addEnumsToDescriptions,
              currentLocation: `${currentLocation}/${encodePointer(prop)}`,
              globalDefaults,
              hideReadOnlyProperties,
              hideWriteOnlyProperties,
              prevDefaultSchemas,
              prevExampleSchemas,
              refLogger,
              transformer
            });
            let propShouldBeUpdated = true;
            if ((hideReadOnlyProperties || hideWriteOnlyProperties) && !Object.keys(newPropSchema).length) {
              if (Object.keys(schema2.properties[prop]).length > 0) {
                delete schema2.properties[prop];
                propShouldBeUpdated = false;
              }
            }
            if (propShouldBeUpdated) {
              schema2.properties[prop] = newPropSchema;
              if (isObject2(newPropSchema) && "required" in newPropSchema && typeof newPropSchema.required === "boolean" && newPropSchema.required === true) {
                if ("required" in schema2 && Array.isArray(schema2.required)) {
                  schema2.required.push(prop);
                } else {
                  schema2.required = [prop];
                }
                delete schema2.properties[prop].required;
              }
            }
          }
        });
        if (hideReadOnlyProperties || hideWriteOnlyProperties) {
          if (!Object.keys(schema2.properties).length) {
            return transformer({});
          }
        }
      }
      if (typeof schemaAdditionalProperties === "object" && schemaAdditionalProperties !== null) {
        if (!("type" in schemaAdditionalProperties) && !("$ref" in schemaAdditionalProperties) && // We know it will be a schema object because it's dereferenced
        !isPolymorphicSchema(schemaAdditionalProperties)) {
          schema2.additionalProperties = true;
        } else {
          schema2.additionalProperties = toJSONSchema(schemaAdditionalProperties, {
            addEnumsToDescriptions,
            currentLocation,
            globalDefaults,
            hideReadOnlyProperties,
            hideWriteOnlyProperties,
            prevDefaultSchemas,
            prevExampleSchemas,
            refLogger,
            transformer
          });
        }
      }
      if (!isPolymorphicSchema(schema2) && !("properties" in schema2) && !("additionalProperties" in schema2)) {
        schema2.additionalProperties = true;
      }
    }
  }
  if (isSchema(schema2, isPolymorphicAllOfChild) && globalDefaults && Object.keys(globalDefaults).length > 0 && currentLocation) {
    try {
      const userJwtDefault = import_jsonpointer2.default.get(globalDefaults, currentLocation);
      if (userJwtDefault) {
        schema2.default = userJwtDefault;
      }
    } catch (err) {
    }
  }
  if ("default" in schema2 && typeof schema2.default !== "undefined") {
    if (hasSchemaType(schema2, "object")) {
      delete schema2.default;
    } else {
      if ("enum" in schema2 && !addEnumsToDescriptions) {
        schema2.description = schema2.description ? `${schema2.description.replace(/\n$/, "")}

Default: \`${schema2.default}\`` : `Default: ${schema2.default}`;
      }
      if ("allowEmptyValue" in schema2 && schema2.allowEmptyValue && schema2.default === "" || schema2.default !== "") {
      } else {
        delete schema2.default;
      }
    }
  } else if (prevDefaultSchemas.length) {
    const foundDefault = searchForValueByPropAndPointer("default", currentLocation, prevDefaultSchemas);
    if (isPrimitive(foundDefault) || foundDefault === null || Array.isArray(foundDefault) && hasSchemaType(schema2, "array")) {
      schema2.default = foundDefault;
    }
  }
  if (isSchema(schema2, isPolymorphicAllOfChild) && "enum" in schema2 && Array.isArray(schema2.enum)) {
    schema2.enum = Array.from(new Set(schema2.enum));
    if (addEnumsToDescriptions) {
      const enums = schema2.enum.filter(Boolean).map((str2) => `\`${str2}\``).join(" ");
      if (enums.length) {
        if ("description" in schema2) {
          schema2.description += `

${enums}`;
        } else {
          schema2.description = enums;
        }
      }
    }
  }
  if ("anyOf" in schema2 || "oneOf" in schema2) {
    if ("properties" in schema2) {
      delete schema2.properties;
    }
    if ("items" in schema2) {
      delete schema2.items;
    }
  }
  for (let i = 0; i < UNSUPPORTED_SCHEMA_PROPS.length; i += 1) {
    delete schema2[UNSUPPORTED_SCHEMA_PROPS[i]];
  }
  if (hideReadOnlyProperties && "readOnly" in schema2 && schema2.readOnly === true) {
    return {};
  } else if (hideWriteOnlyProperties && "writeOnly" in schema2 && schema2.writeOnly === true) {
    return {};
  }
  return transformer(schema2);
}
var types = {
  path: "Path Params",
  query: "Query Params",
  body: "Body Params",
  cookie: "Cookie Params",
  formData: "Form Data",
  header: "Headers",
  metadata: "Metadata"
  // This a special type reserved for https://npm.im/api
};
function getParametersAsJSONSchema(operation, api, opts) {
  let hasCircularRefs = false;
  let hasDiscriminatorMappingRefs = false;
  function refLogger(ref, type2) {
    if (type2 === "ref") {
      hasCircularRefs = true;
    } else {
      hasDiscriminatorMappingRefs = true;
    }
  }
  function getDeprecated(schema2, type2) {
    if (opts.retainDeprecatedProperties) {
      return null;
    }
    if (!schema2 || !schema2.properties)
      return null;
    const deprecatedBody = cloneObject(schema2);
    const requiredParams = schema2.required || [];
    const allDeprecatedProps = {};
    Object.keys(deprecatedBody.properties).forEach((key) => {
      const deprecatedProp = deprecatedBody.properties[key];
      if (deprecatedProp.deprecated && !requiredParams.includes(key) && !deprecatedProp.readOnly) {
        allDeprecatedProps[key] = deprecatedProp;
      }
    });
    deprecatedBody.properties = allDeprecatedProps;
    const deprecatedSchema = toJSONSchema(deprecatedBody, {
      globalDefaults: opts.globalDefaults,
      hideReadOnlyProperties: opts.hideReadOnlyProperties,
      hideWriteOnlyProperties: opts.hideWriteOnlyProperties,
      prevExampleSchemas: [],
      refLogger,
      transformer: opts.transformer
    });
    if (Object.keys(deprecatedSchema).length === 0 || Object.keys(deprecatedSchema.properties).length === 0) {
      return null;
    }
    Object.keys(schema2.properties).forEach((key) => {
      if (schema2.properties[key].deprecated && !requiredParams.includes(key)) {
        delete schema2.properties[key];
      }
    });
    return {
      type: type2,
      schema: isPrimitive(deprecatedSchema) ? deprecatedSchema : {
        ...deprecatedSchema,
        $schema: getSchemaVersionString(deprecatedSchema, api)
      }
    };
  }
  function transformRequestBody() {
    const requestBody = operation.getRequestBody();
    if (!requestBody || !Array.isArray(requestBody))
      return null;
    const [mediaType, mediaTypeObject, description] = requestBody;
    const type2 = mediaType === "application/x-www-form-urlencoded" ? "formData" : "body";
    if (!mediaTypeObject.schema || !Object.keys(mediaTypeObject.schema).length) {
      return null;
    }
    const prevExampleSchemas = [];
    if ("example" in mediaTypeObject) {
      prevExampleSchemas.push({ example: mediaTypeObject.example });
    } else if ("examples" in mediaTypeObject) {
      prevExampleSchemas.push({
        examples: Object.values(mediaTypeObject.examples).map((example) => example.value).filter((val) => val !== void 0)
      });
    }
    const requestSchema = cloneObject(mediaTypeObject.schema);
    const cleanedSchema = toJSONSchema(requestSchema, {
      globalDefaults: opts.globalDefaults,
      hideReadOnlyProperties: opts.hideReadOnlyProperties,
      hideWriteOnlyProperties: opts.hideWriteOnlyProperties,
      prevExampleSchemas,
      refLogger,
      transformer: opts.transformer
    });
    if (!Object.keys(cleanedSchema).length) {
      return null;
    }
    return {
      type: type2,
      label: types[type2],
      schema: isPrimitive(cleanedSchema) ? cleanedSchema : {
        ...cleanedSchema,
        $schema: getSchemaVersionString(cleanedSchema, api)
      },
      deprecatedProps: getDeprecated(cleanedSchema, type2),
      ...description ? { description } : {}
    };
  }
  function transformComponents() {
    if (!("components" in api)) {
      return false;
    }
    const components2 = {
      ...Object.keys(api.components).map((componentType) => ({ [componentType]: {} })).reduce((prev, next) => Object.assign(prev, next), {})
    };
    Object.keys(api.components).forEach((componentType) => {
      if (typeof api.components[componentType] === "object" && !Array.isArray(api.components[componentType])) {
        Object.keys(api.components[componentType]).forEach((schemaName) => {
          const componentSchema = cloneObject(api.components[componentType][schemaName]);
          components2[componentType][schemaName] = toJSONSchema(componentSchema, {
            globalDefaults: opts.globalDefaults,
            hideReadOnlyProperties: opts.hideReadOnlyProperties,
            hideWriteOnlyProperties: opts.hideWriteOnlyProperties,
            refLogger,
            transformer: opts.transformer
          });
        });
      }
    });
    Object.keys(components2).forEach((componentType) => {
      if (!Object.keys(components2[componentType]).length) {
        delete components2[componentType];
      }
    });
    return components2;
  }
  function transformParameters() {
    const operationParams = operation.getParameters();
    const transformed = Object.keys(types).map((type2) => {
      const required = [];
      const parameters = operationParams.filter((param) => param.in === type2);
      if (parameters.length === 0) {
        return null;
      }
      const properties = parameters.reduce((prev, current) => {
        let schema22 = {};
        if ("schema" in current) {
          const currentSchema = current.schema ? cloneObject(current.schema) : {};
          if (current.example) {
            currentSchema.example = current.example;
          } else if (current.examples) {
            currentSchema.examples = current.examples;
          }
          if (current.deprecated)
            currentSchema.deprecated = current.deprecated;
          const interimSchema = toJSONSchema(currentSchema, {
            currentLocation: `/${current.name}`,
            globalDefaults: opts.globalDefaults,
            hideReadOnlyProperties: opts.hideReadOnlyProperties,
            hideWriteOnlyProperties: opts.hideWriteOnlyProperties,
            refLogger,
            transformer: opts.transformer
          });
          schema22 = isPrimitive(interimSchema) ? interimSchema : {
            ...interimSchema,
            // Note: this applies a `$schema` version to each field in the larger schema
            // object. It's not really **correct** but it's what we have to do because
            // there's a chance that the end user has indicated the schemas are different.
            $schema: getSchemaVersionString(currentSchema, api)
          };
        } else if ("content" in current && typeof current.content === "object") {
          const contentKeys = Object.keys(current.content);
          if (contentKeys.length) {
            let contentType;
            if (contentKeys.length === 1) {
              contentType = contentKeys[0];
            } else {
              const jsonLikeContentTypes = contentKeys.filter((k) => matches_mimetype_default.json(k));
              if (jsonLikeContentTypes.length) {
                contentType = jsonLikeContentTypes[0];
              } else {
                contentType = contentKeys[0];
              }
            }
            if (typeof current.content[contentType] === "object" && "schema" in current.content[contentType]) {
              const currentSchema = current.content[contentType].schema ? cloneObject(current.content[contentType].schema) : {};
              if (current.example) {
                currentSchema.example = current.example;
              } else if (current.examples) {
                currentSchema.examples = current.examples;
              }
              if (current.deprecated)
                currentSchema.deprecated = current.deprecated;
              const interimSchema = toJSONSchema(currentSchema, {
                currentLocation: `/${current.name}`,
                globalDefaults: opts.globalDefaults,
                hideReadOnlyProperties: opts.hideReadOnlyProperties,
                hideWriteOnlyProperties: opts.hideWriteOnlyProperties,
                refLogger,
                transformer: opts.transformer
              });
              schema22 = isPrimitive(interimSchema) ? interimSchema : {
                ...interimSchema,
                // Note: this applies a `$schema` version to each field in the larger schema
                // object. It's not really **correct** but it's what we have to do because
                // there's a chance that the end user has indicated the schemas are different.
                $schema: getSchemaVersionString(currentSchema, api)
              };
            }
          }
        }
        if (current.description) {
          if (!isPrimitive(schema22)) {
            schema22.description = current.description;
          }
        }
        prev[current.name] = schema22;
        if (current.required) {
          required.push(current.name);
        }
        return prev;
      }, {});
      const schema2 = {
        type: "object",
        properties,
        required
      };
      return {
        type: type2,
        label: types[type2],
        schema: schema2,
        deprecatedProps: getDeprecated(schema2, type2)
      };
    }).filter(Boolean);
    if (!opts.mergeIntoBodyAndMetadata) {
      return transformed;
    } else if (!transformed.length) {
      return [];
    }
    const deprecatedProps = transformed.map((r2) => r2.deprecatedProps?.schema || null).filter(Boolean);
    return [
      {
        type: "metadata",
        label: types.metadata,
        schema: {
          allOf: transformed.map((r2) => r2.schema)
        },
        deprecatedProps: deprecatedProps.length ? {
          type: "metadata",
          schema: {
            allOf: deprecatedProps
          }
        } : null
      }
    ];
  }
  if (!operation.hasParameters() && !operation.hasRequestBody()) {
    return null;
  }
  const typeKeys = getExtension(PARAMETER_ORDERING, api, operation).map((k) => k.toLowerCase());
  typeKeys[typeKeys.indexOf("form")] = "formData";
  typeKeys.push("metadata");
  const jsonSchema = [transformRequestBody()].concat(...transformParameters()).filter(Boolean);
  const shouldIncludeComponents = hasCircularRefs || hasDiscriminatorMappingRefs && opts.includeDiscriminatorMappingRefs;
  const components = shouldIncludeComponents ? transformComponents() : false;
  return jsonSchema.map((group) => {
    if (components && shouldIncludeComponents) {
      group.schema.components = components;
    }
    if (!group.deprecatedProps)
      delete group.deprecatedProps;
    return group;
  }).sort((a, b) => {
    return typeKeys.indexOf(a.type) - typeKeys.indexOf(b.type);
  });
}

// node_modules/oas/dist/chunk-OVRW7C6X.js
var import_json_schema_merge_allof2 = __toESM(require_src2(), 1);
var import_memoizee = __toESM(require_memoizee(), 1);
function dedupeCommonParameters(parameters, commonParameters) {
  return commonParameters.filter((param) => {
    return !parameters.find((param2) => {
      if (param.name && param2.name) {
        return param.name === param2.name && param.in === param2.in;
      } else if (isRef(param) && isRef(param2)) {
        return param.$ref === param2.$ref;
      }
      return false;
    });
  });
}
function usesPolymorphism(schema2) {
  if (schema2.oneOf) {
    return "oneOf";
  } else if (schema2.anyOf) {
    return "anyOf";
  } else if (schema2.allOf) {
    return "allOf";
  }
  return false;
}
function objectify(thing) {
  if (!isObject2(thing)) {
    return {};
  }
  return thing;
}
function normalizeArray(arr) {
  if (Array.isArray(arr)) {
    return arr;
  }
  return [arr];
}
function isFunc(thing) {
  return typeof thing === "function";
}
function deeplyStripKey(input, keyToStrip, predicate = (obj, key) => true) {
  if (typeof input !== "object" || Array.isArray(input) || input === null || !keyToStrip) {
    return input;
  }
  const obj = { ...input };
  Object.keys(obj).forEach((k) => {
    if (k === keyToStrip && predicate(obj[k], k)) {
      delete obj[k];
      return;
    }
    obj[k] = deeplyStripKey(obj[k], keyToStrip, predicate);
  });
  return obj;
}
var sampleDefaults = (genericSample) => {
  return (schema2) => typeof schema2.default === typeof genericSample ? schema2.default : genericSample;
};
var primitives = {
  string: sampleDefaults("string"),
  string_email: sampleDefaults("user@example.com"),
  "string_date-time": sampleDefaults((/* @__PURE__ */ new Date()).toISOString()),
  string_date: sampleDefaults((/* @__PURE__ */ new Date()).toISOString().substring(0, 10)),
  "string_YYYY-MM-DD": sampleDefaults((/* @__PURE__ */ new Date()).toISOString().substring(0, 10)),
  string_uuid: sampleDefaults("3fa85f64-5717-4562-b3fc-2c963f66afa6"),
  string_hostname: sampleDefaults("example.com"),
  string_ipv4: sampleDefaults("198.51.100.42"),
  string_ipv6: sampleDefaults("2001:0db8:5b96:0000:0000:426f:8e17:642a"),
  number: sampleDefaults(0),
  number_float: sampleDefaults(0),
  integer: sampleDefaults(0),
  boolean: sampleDefaults(true)
};
var primitive = (schema2) => {
  schema2 = objectify(schema2);
  const { format: format6 } = schema2;
  let { type: type2 } = schema2;
  if (type2 === "null") {
    return null;
  } else if (Array.isArray(type2)) {
    if (type2.length === 1) {
      type2 = type2[0];
    } else {
      if (type2.includes("null")) {
        type2 = type2.filter((t) => t !== "null");
      }
      type2 = type2.shift();
    }
  }
  const fn = primitives[`${type2}_${format6}`] || primitives[type2];
  if (isFunc(fn)) {
    return fn(schema2);
  }
  return `Unknown Type: ${schema2.type}`;
};
function sampleFromSchema(schema2, opts = {}) {
  const objectifySchema = objectify(schema2);
  let { type: type2 } = objectifySchema;
  const hasPolymorphism = usesPolymorphism(objectifySchema);
  if (hasPolymorphism === "allOf") {
    try {
      return sampleFromSchema(
        (0, import_json_schema_merge_allof2.default)(objectifySchema, {
          resolvers: {
            // Ignore any unrecognized OAS-specific keywords that might be present on the schema
            // (like `xml`).
            defaultResolver: import_json_schema_merge_allof2.default.options.resolvers.title
          }
        }),
        opts
      );
    } catch (error) {
      return void 0;
    }
  } else if (hasPolymorphism) {
    const samples = objectifySchema[hasPolymorphism].map((s) => {
      return sampleFromSchema(s, opts);
    });
    if (samples.length === 1) {
      return samples[0];
    } else if (samples.some((s) => s === null)) {
      return samples.find((s) => s !== null);
    }
    return samples[0];
  }
  const { example, additionalProperties, properties, items } = objectifySchema;
  const { includeReadOnly, includeWriteOnly } = opts;
  if (example !== void 0) {
    return deeplyStripKey(example, "$$ref", (val) => {
      return typeof val === "string" && val.indexOf("#") > -1;
    });
  }
  if (!type2) {
    if (properties || additionalProperties) {
      type2 = "object";
    } else if (items) {
      type2 = "array";
    } else {
      return void 0;
    }
  }
  if (type2 === "object" || Array.isArray(type2) && type2.includes("object")) {
    const props = objectify(properties);
    const obj = {};
    for (const name in props) {
      if (props[name] && props[name].deprecated) {
        continue;
      }
      if (props[name] && props[name].readOnly && !includeReadOnly) {
        continue;
      }
      if (props[name] && props[name].writeOnly && !includeWriteOnly) {
        continue;
      }
      if (props[name].examples?.length) {
        obj[name] = props[name].examples[0];
        continue;
      }
      obj[name] = sampleFromSchema(props[name], opts);
    }
    if (additionalProperties === true) {
      obj.additionalProp = {};
    } else if (additionalProperties) {
      const additionalProps = objectify(additionalProperties);
      const additionalPropVal = sampleFromSchema(additionalProps, opts);
      obj.additionalProp = additionalPropVal;
    }
    return obj;
  }
  if (type2 === "array" || Array.isArray(type2) && type2.includes("array")) {
    if (typeof items === "undefined") {
      return [];
    }
    if (Array.isArray(items.anyOf)) {
      return items.anyOf.map((i) => sampleFromSchema(i, opts));
    }
    if (Array.isArray(items.oneOf)) {
      return items.oneOf.map((i) => sampleFromSchema(i, opts));
    }
    return [sampleFromSchema(items, opts)];
  }
  if (schema2.enum) {
    if (schema2.default) {
      return schema2.default;
    }
    return normalizeArray(schema2.enum)[0];
  }
  if (type2 === "file") {
    return void 0;
  }
  return primitive(schema2);
}
var samples_default = (0, import_memoizee.default)(sampleFromSchema);
function getMediaTypeExamples(mediaType, mediaTypeObject, opts = {}) {
  if (mediaTypeObject.example) {
    return [
      {
        value: mediaTypeObject.example
      }
    ];
  } else if (mediaTypeObject.examples) {
    const { examples } = mediaTypeObject;
    const multipleExamples = Object.keys(examples).map((key) => {
      let summary = key;
      let description;
      let example = examples[key];
      if (example !== null && typeof example === "object") {
        if ("summary" in example) {
          summary = example.summary;
        }
        if ("description" in example) {
          description = example.description;
        }
        if ("value" in example) {
          if (example.value !== null && typeof example.value === "object" && "$ref" in example.value) {
            return false;
          }
          example = example.value;
        }
      }
      const ret = { summary, title: key, value: example };
      if (description) {
        ret.description = description;
      }
      return ret;
    }).filter(Boolean);
    if (multipleExamples.length) {
      return multipleExamples;
    }
  }
  if (mediaTypeObject.schema) {
    if (!matches_mimetype_default.xml(mediaType)) {
      return [
        {
          value: samples_default(JSON.parse(JSON.stringify(mediaTypeObject.schema)), opts)
        }
      ];
    }
  }
  return [];
}
function getResponseExamples(operation) {
  return Object.keys(operation.responses || {}).map((status) => {
    const response = operation.responses[status];
    let onlyHeaders = false;
    if (isRef(response)) {
      return false;
    }
    const mediaTypes = {};
    (response.content ? Object.keys(response.content) : []).forEach((mediaType) => {
      if (!mediaType)
        return;
      const mediaTypeObject = response.content[mediaType];
      const examples = getMediaTypeExamples(mediaType, mediaTypeObject, {
        includeReadOnly: true,
        includeWriteOnly: false
      });
      if (examples) {
        mediaTypes[mediaType] = examples;
      }
    });
    if (response.headers && Object.keys(response.headers).length && !Object.keys(mediaTypes).length) {
      mediaTypes["*/*"] = [];
      onlyHeaders = true;
    }
    if (!Object.keys(mediaTypes).length) {
      return false;
    }
    return {
      status,
      mediaTypes,
      ...onlyHeaders ? { onlyHeaders } : {}
    };
  }).filter(Boolean);
}
function getCallbackExamples(operation) {
  const ret = [];
  return ret.concat(
    ...Object.keys(operation.callbacks || {}).map((identifier) => {
      const callback = operation.callbacks[identifier];
      return [].concat(
        ...Object.keys(callback).map((expression) => {
          return Object.keys(callback[expression]).map((method) => {
            const pathItem = callback[expression];
            const example = getResponseExamples(pathItem[method]);
            if (example.length === 0)
              return false;
            return {
              identifier,
              expression,
              method,
              example
            };
          });
        })
      ).filter(Boolean);
    })
  );
}
var noCorrespondingResponseKey = "NoCorrespondingResponseForCustomCodeSample";
function addMatchingResponseExamples(groups, operation) {
  operation.getResponseExamples().forEach((example) => {
    Object.entries(example.mediaTypes || {}).forEach(([mediaType, mediaTypeExamples]) => {
      mediaTypeExamples.forEach((mediaTypeExample) => {
        if (mediaTypeExample.title && Object.keys(groups).includes(mediaTypeExample.title)) {
          groups[mediaTypeExample.title].response = {
            mediaType,
            mediaTypeExample,
            status: example.status
          };
          if (!groups[mediaTypeExample.title].name) {
            groups[mediaTypeExample.title].name = mediaTypeExample.summary;
          }
        }
      });
    });
  });
}
function getDefaultName(sample, count) {
  return sample.name && sample.name.length > 0 ? sample.name : `Default${count[sample.language] > 1 ? ` #${count[sample.language]}` : ""}`;
}
function getExampleGroups(operation) {
  const namelessCodeSampleCounts = {};
  const groups = {};
  const codeSamples = getExtension("code-samples", operation.api, operation);
  codeSamples?.forEach((sample, i) => {
    if (namelessCodeSampleCounts[sample.language]) {
      namelessCodeSampleCounts[sample.language] += 1;
    } else {
      namelessCodeSampleCounts[sample.language] = 1;
    }
    const name = getDefaultName(sample, namelessCodeSampleCounts);
    if (groups[sample.correspondingExample]?.customCodeSamples?.length) {
      groups[sample.correspondingExample].customCodeSamples.push({ ...sample, name, originalIndex: i });
    } else if (sample.correspondingExample) {
      groups[sample.correspondingExample] = {
        name,
        customCodeSamples: [{ ...sample, name, originalIndex: i }]
      };
    } else if (groups[noCorrespondingResponseKey]?.customCodeSamples?.length) {
      groups[noCorrespondingResponseKey].customCodeSamples.push({ ...sample, name, originalIndex: i });
    } else {
      groups[noCorrespondingResponseKey] = {
        name,
        customCodeSamples: [{ ...sample, name, originalIndex: i }]
      };
    }
  });
  if (Object.keys(groups).length) {
    addMatchingResponseExamples(groups, operation);
    return groups;
  }
  operation.getParameters().forEach((param) => {
    Object.entries(param.examples || {}).forEach(([exampleKey, paramExample]) => {
      groups[exampleKey] = {
        ...groups[exampleKey],
        name: groups[exampleKey]?.name || paramExample.summary,
        request: {
          ...groups[exampleKey]?.request,
          [param.in]: {
            ...groups[exampleKey]?.request?.[param.in],
            [param.name]: paramExample.value
          }
        }
      };
    });
  });
  operation.getRequestBodyExamples().forEach((requestExample) => {
    requestExample.examples.forEach((mediaTypeExample) => {
      if (mediaTypeExample.title) {
        const mediaType = requestExample.mediaType === "application/x-www-form-urlencoded" ? "formData" : "body";
        groups[mediaTypeExample.title] = {
          ...groups[mediaTypeExample.title],
          name: groups[mediaTypeExample.title]?.name || mediaTypeExample.summary,
          request: {
            ...groups[mediaTypeExample.title]?.request,
            [mediaType]: mediaTypeExample.value
          }
        };
      }
    });
  });
  if (Object.keys(groups).length) {
    addMatchingResponseExamples(groups, operation);
  }
  Object.entries(groups).forEach(([groupId, group]) => {
    if (group.request && !group.response) {
      delete groups[groupId];
    }
  });
  return groups;
}
function getRequestBodyExamples(operation) {
  const requestBody = operation.requestBody;
  if (!requestBody || !requestBody.content) {
    return [];
  }
  return Object.keys(requestBody.content || {}).map((mediaType) => {
    const mediaTypeObject = requestBody.content[mediaType];
    const examples = getMediaTypeExamples(mediaType, mediaTypeObject, {
      includeReadOnly: false,
      includeWriteOnly: true
    });
    if (!examples.length) {
      return false;
    }
    return {
      mediaType,
      examples
    };
  }).filter(Boolean);
}
var isJSON = matches_mimetype_default.json;
function buildHeadersSchema(response, opts) {
  const headers = response.headers;
  const headersSchema = {
    type: "object",
    properties: {}
  };
  Object.keys(headers).forEach((key) => {
    if (headers[key] && headers[key].schema) {
      const header = headers[key];
      headersSchema.properties[key] = toJSONSchema(header.schema, {
        addEnumsToDescriptions: true,
        transformer: opts.transformer
      });
      if (header.description) {
        headersSchema.properties[key].description = header.description;
      }
    }
  });
  const headersWrapper = {
    schema: headersSchema,
    type: "object",
    label: "Headers"
  };
  if (response.description && headersWrapper.schema) {
    headersWrapper.description = response.description;
  }
  return headersWrapper;
}
function getResponseAsJSONSchema(operation, api, statusCode, opts) {
  const response = operation.getResponseByStatusCode(statusCode);
  const jsonSchema = [];
  if (!response) {
    return null;
  }
  let hasCircularRefs = false;
  let hasDiscriminatorMappingRefs = false;
  function refLogger(ref, type2) {
    if (type2 === "ref") {
      hasCircularRefs = true;
    } else {
      hasDiscriminatorMappingRefs = true;
    }
  }
  function getPreferredSchema(content) {
    if (!content) {
      return null;
    }
    const contentTypes = Object.keys(content);
    if (!contentTypes.length) {
      return null;
    }
    for (let i = 0; i < contentTypes.length; i++) {
      if (isJSON(contentTypes[i])) {
        return toJSONSchema(cloneObject(content[contentTypes[i]].schema), {
          addEnumsToDescriptions: true,
          refLogger,
          transformer: opts.transformer
        });
      }
    }
    const contentType = contentTypes.shift();
    return toJSONSchema(cloneObject(content[contentType].schema), {
      addEnumsToDescriptions: true,
      refLogger,
      transformer: opts.transformer
    });
  }
  const foundSchema = getPreferredSchema(response.content);
  if (foundSchema) {
    const schema2 = cloneObject(foundSchema);
    const schemaWrapper = {
      // If there's no `type` then the root schema is a circular `$ref` that we likely won't be
      // able to render so instead of generating a JSON Schema with an `undefined` type we should
      // default to `string` so there's at least *something* the end-user can interact with.
      type: foundSchema.type || "string",
      schema: isPrimitive(schema2) ? schema2 : {
        ...schema2,
        $schema: getSchemaVersionString(schema2, api)
      },
      label: "Response body"
    };
    if (response.description && schemaWrapper.schema) {
      schemaWrapper.description = response.description;
    }
    if (api.components && schemaWrapper.schema) {
      if (hasCircularRefs || hasDiscriminatorMappingRefs && opts.includeDiscriminatorMappingRefs) {
        schemaWrapper.schema.components = api.components;
      }
    }
    jsonSchema.push(schemaWrapper);
  }
  if (response.headers) {
    jsonSchema.push(buildHeadersSchema(response, opts));
  }
  return jsonSchema.length ? jsonSchema : null;
}
var Operation = class {
  constructor(api, path, method, operation) {
    this.schema = operation;
    this.api = api;
    this.path = path;
    this.method = method;
    this.contentType = void 0;
    this.requestBodyExamples = void 0;
    this.responseExamples = void 0;
    this.callbackExamples = void 0;
    this.exampleGroups = void 0;
  }
  getSummary() {
    if (this.schema?.summary && typeof this.schema.summary === "string") {
      return this.schema.summary;
    } else if (this.api.paths[this.path].summary && typeof this.api.paths[this.path].summary === "string") {
      return this.api.paths[this.path].summary;
    }
    return void 0;
  }
  getDescription() {
    if (this.schema?.description && typeof this.schema.description === "string") {
      return this.schema.description;
    } else if (this.api.paths[this.path].description && typeof this.api.paths[this.path].description === "string") {
      return this.api.paths[this.path].description;
    }
    return void 0;
  }
  getContentType() {
    if (this.contentType) {
      return this.contentType;
    }
    let types3 = [];
    if (this.schema.requestBody) {
      if ("$ref" in this.schema.requestBody) {
        this.schema.requestBody = findSchemaDefinition(this.schema.requestBody.$ref, this.api);
      }
      if ("content" in this.schema.requestBody) {
        types3 = Object.keys(this.schema.requestBody.content);
      }
    }
    this.contentType = "application/json";
    if (types3 && types3.length) {
      this.contentType = types3[0];
    }
    types3.forEach((t) => {
      if (matches_mimetype_default.json(t)) {
        this.contentType = t;
      }
    });
    return this.contentType;
  }
  isFormUrlEncoded() {
    return matches_mimetype_default.formUrlEncoded(this.getContentType());
  }
  isMultipart() {
    return matches_mimetype_default.multipart(this.getContentType());
  }
  isJson() {
    return matches_mimetype_default.json(this.getContentType());
  }
  isXml() {
    return matches_mimetype_default.xml(this.getContentType());
  }
  /**
   * Returns an array of all security requirements associated wtih this operation. If none are
   * defined at the operation level, the securities for the entire API definition are returned
   * (with an empty array as a final fallback).
   *
   */
  getSecurity() {
    if (!this.api?.components?.securitySchemes || !Object.keys(this.api.components.securitySchemes).length) {
      return [];
    }
    return this.schema.security || this.api.security || [];
  }
  /**
   * Retrieve a collection of grouped security schemes. The inner array determines AND-grouped
   * security schemes, the outer array determines OR-groups.
   *
   * @see {@link https://swagger.io/docs/specification/authentication/#multiple}
   * @see {@link https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.3.md#security-requirement-object}
   * @see {@link https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.1.0.md#securityRequirementObject}
   * @param filterInvalid Optional flag that, when set to `true`, filters out invalid/nonexistent
   *    security schemes, rather than returning `false`.
   */
  getSecurityWithTypes(filterInvalid = false) {
    const securityRequirements = this.getSecurity();
    return securityRequirements.map((requirement) => {
      let keys;
      try {
        keys = Object.keys(requirement);
      } catch (e) {
        return false;
      }
      const keysWithTypes = keys.map((key) => {
        let security;
        try {
          security = this.api.components.securitySchemes[key];
        } catch (e) {
          return false;
        }
        if (!security)
          return false;
        let type2 = null;
        if (security.type === "http") {
          if (security.scheme === "basic")
            type2 = "Basic";
          else if (security.scheme === "bearer")
            type2 = "Bearer";
          else
            type2 = security.type;
        } else if (security.type === "oauth2") {
          type2 = "OAuth2";
        } else if (security.type === "apiKey") {
          if (security.in === "query")
            type2 = "Query";
          else if (security.in === "header")
            type2 = "Header";
          else if (security.in === "cookie")
            type2 = "Cookie";
          else
            type2 = security.type;
        } else {
          return false;
        }
        return {
          type: type2,
          security: {
            ...security,
            _key: key
          }
        };
      });
      if (filterInvalid)
        return keysWithTypes.filter((key) => key !== false);
      return keysWithTypes;
    });
  }
  /**
   * Retrieve an object where the keys are unique scheme types, and the values are arrays
   * containing each security scheme of that type.
   *
   */
  prepareSecurity() {
    const securitiesWithTypes = this.getSecurityWithTypes();
    return securitiesWithTypes.reduce(
      (prev, securities) => {
        if (!securities)
          return prev;
        securities.forEach((security) => {
          if (!security)
            return;
          if (!prev[security.type])
            prev[security.type] = [];
          const exists = prev[security.type].findIndex((sec) => sec._key === security.security._key);
          if (exists < 0) {
            prev[security.type].push(security.security);
          }
        });
        return prev;
      },
      {}
    );
  }
  getHeaders() {
    this.headers = {
      request: [],
      response: []
    };
    const security = this.prepareSecurity();
    if (security.Header) {
      this.headers.request = security.Header.map((h) => {
        return h.name;
      });
    }
    if (security.Bearer || security.Basic || security.OAuth2) {
      this.headers.request.push("Authorization");
    }
    if (security.Cookie) {
      this.headers.request.push("Cookie");
    }
    if (this.schema.parameters) {
      this.headers.request = this.headers.request.concat(
        // Remove the reference object because we will have already dereferenced.
        this.schema.parameters.map((p) => {
          if (p.in && p.in === "header")
            return p.name;
          return void 0;
        }).filter((p) => p)
      );
    }
    if (this.schema.responses) {
      this.headers.response = Object.keys(this.schema.responses).filter((r2) => this.schema.responses[r2].headers).map(
        (r2) => (
          // Remove the reference object because we will have already dereferenced.
          Object.keys(this.schema.responses[r2].headers)
        )
      ).reduce((a, b) => a.concat(b), []);
    }
    if (!this.headers.request.includes("Content-Type") && this.schema.requestBody) {
      if (this.schema.requestBody.content && Object.keys(this.schema.requestBody.content)) {
        this.headers.request.push("Content-Type");
      }
    }
    if (this.schema.responses) {
      if (Object.keys(this.schema.responses).some(
        (response) => !!this.schema.responses[response].content
      )) {
        if (!this.headers.request.includes("Accept"))
          this.headers.request.push("Accept");
        if (!this.headers.response.includes("Content-Type"))
          this.headers.response.push("Content-Type");
      }
    }
    return this.headers;
  }
  /**
   * Determine if the operation has an operation present in its schema. Note that if one is present
   * in the schema but is an empty string then this will return false.
   *
   */
  hasOperationId() {
    return Boolean("operationId" in this.schema && this.schema.operationId.length);
  }
  /**
   * Get an `operationId` for this operation. If one is not present (it's not required by the spec!)
   * a hash of the path and method will be returned instead.
   *
   */
  getOperationId(opts = {}) {
    function sanitize(id) {
      return id.replace(opts?.camelCase || opts?.friendlyCase ? /[^a-zA-Z0-9_]/g : /[^a-zA-Z0-9]/g, "-").replace(/--+/g, "-").replace(/^-|-$/g, "");
    }
    let operationId;
    if (this.hasOperationId()) {
      operationId = this.schema.operationId;
    } else {
      operationId = sanitize(this.path).toLowerCase();
    }
    const method = this.method.toLowerCase();
    if (opts?.camelCase || opts?.friendlyCase) {
      if (opts?.friendlyCase) {
        operationId = operationId.replaceAll("_", " ");
        if (!this.hasOperationId()) {
          operationId = operationId.replace(/[^a-zA-Z0-9_]+(.)/g, (_, chr) => ` ${chr}`).split(" ").filter((word, i, arr) => word !== arr[i - 1]).join(" ");
        }
      }
      operationId = operationId.replace(/[^a-zA-Z0-9_]+(.)/g, (_, chr) => chr.toUpperCase());
      if (this.hasOperationId()) {
        operationId = sanitize(operationId);
      }
      operationId = operationId.replace(/^[0-9]/g, (match2) => `_${match2}`);
      operationId = operationId.charAt(0).toLowerCase() + operationId.slice(1);
      if (operationId.startsWith(method)) {
        return operationId;
      }
      if (this.hasOperationId()) {
        return operationId;
      }
      operationId = operationId.charAt(0).toUpperCase() + operationId.slice(1);
      return `${method}${operationId}`;
    } else if (this.hasOperationId()) {
      return operationId;
    }
    return `${method}_${operationId}`;
  }
  /**
   * Return an array of all tags, and their metadata, that exist on this operation.
   *
   */
  getTags() {
    if (!("tags" in this.schema)) {
      return [];
    }
    const oasTagMap = /* @__PURE__ */ new Map();
    if ("tags" in this.api) {
      this.api.tags.forEach((tag) => {
        oasTagMap.set(tag.name, tag);
      });
    }
    const oasTags = Object.fromEntries(oasTagMap);
    const tags = [];
    if (Array.isArray(this.schema.tags)) {
      this.schema.tags.forEach((tag) => {
        if (tag in oasTags) {
          tags.push(oasTags[tag]);
        } else {
          tags.push({
            name: tag
          });
        }
      });
    }
    return tags;
  }
  /**
   * Return is the operation is flagged as `deprecated` or not.
   *
   */
  isDeprecated() {
    return "deprecated" in this.schema ? this.schema.deprecated : false;
  }
  /**
   * Determine if the operation has any (non-request body) parameters.
   *
   */
  hasParameters() {
    return !!this.getParameters().length;
  }
  /**
   * Return the parameters (non-request body) on the operation.
   *
   */
  getParameters() {
    let parameters = this.schema?.parameters || [];
    const commonParams = this.api?.paths?.[this.path]?.parameters || [];
    if (commonParams.length) {
      parameters = parameters.concat(dedupeCommonParameters(parameters, commonParams) || []);
    }
    return parameters;
  }
  /**
   * Determine if this operation has any required parameters.
   *
   */
  hasRequiredParameters() {
    return this.getParameters().some((param) => "required" in param && param.required);
  }
  /**
   * Convert the operation into an array of JSON Schema schemas for each available type of
   * parameter available on the operation.
   *
   */
  getParametersAsJSONSchema(opts = {}) {
    return getParametersAsJSONSchema(this, this.api, {
      includeDiscriminatorMappingRefs: true,
      transformer: (s) => s,
      ...opts
    });
  }
  /**
   * Get a single response for this status code, formatted as JSON schema.
   *
   * @param statusCode Status code to pull a JSON Schema response for.
   */
  getResponseAsJSONSchema(statusCode, opts = {}) {
    return getResponseAsJSONSchema(this, this.api, statusCode, {
      includeDiscriminatorMappingRefs: true,
      transformer: (s) => s,
      ...opts
    });
  }
  /**
   * Get an array of all valid response status codes for this operation.
   *
   */
  getResponseStatusCodes() {
    return this.schema.responses ? Object.keys(this.schema.responses) : [];
  }
  /**
   * Determine if the operation has any request bodies.
   *
   */
  hasRequestBody() {
    return !!this.schema.requestBody;
  }
  /**
   * Retrieve the list of all available media types that the operations request body can accept.
   *
   * @see {@link https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.3.md#mediaTypeObject}
   * @see {@link https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.1.0.md#mediaTypeObject}
   */
  getRequestBodyMediaTypes() {
    if (!this.hasRequestBody()) {
      return [];
    }
    const requestBody = this.schema.requestBody;
    if (isRef(requestBody)) {
      return [];
    }
    return Object.keys(requestBody.content);
  }
  /**
   * Determine if this operation has a required request body.
   *
   */
  hasRequiredRequestBody() {
    if (!this.hasRequestBody()) {
      return false;
    }
    const requestBody = this.schema.requestBody;
    if (isRef(requestBody)) {
      return false;
    }
    if (requestBody.required) {
      return true;
    }
    return !!this.getParametersAsJSONSchema().filter((js) => ["body", "formData"].includes(js.type)).find((js) => js.schema && Array.isArray(js.schema.required) && js.schema.required.length);
  }
  /**
   * Retrieve a specific request body content schema off this operation.
   *
   * If no media type is supplied this will return either the first available JSON-like request
   * body, or the first available if there are no JSON-like media types present. When this return
   * comes back it's in the form of an array with the first key being the selected media type,
   * followed by the media type object in question.
   *
   * @see {@link https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.3.md#mediaTypeObject}
   * @see {@link https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.1.0.md#mediaTypeObject}
   * @param mediaType Specific request body media type to retrieve if present.
   */
  getRequestBody(mediaType) {
    if (!this.hasRequestBody()) {
      return false;
    }
    const requestBody = this.schema.requestBody;
    if (isRef(requestBody)) {
      return false;
    }
    if (mediaType) {
      if (!(mediaType in requestBody.content)) {
        return false;
      }
      return requestBody.content[mediaType];
    }
    let availableMediaType;
    const mediaTypes = this.getRequestBodyMediaTypes();
    mediaTypes.forEach((mt) => {
      if (!availableMediaType && matches_mimetype_default.json(mt)) {
        availableMediaType = mt;
      }
    });
    if (!availableMediaType) {
      mediaTypes.forEach((mt) => {
        if (!availableMediaType) {
          availableMediaType = mt;
        }
      });
    }
    if (availableMediaType) {
      return [
        availableMediaType,
        requestBody.content[availableMediaType],
        ...requestBody.description ? [requestBody.description] : []
      ];
    }
    return false;
  }
  /**
   * Retrieve an array of request body examples that this operation has.
   *
   */
  getRequestBodyExamples() {
    if (this.requestBodyExamples) {
      return this.requestBodyExamples;
    }
    this.requestBodyExamples = getRequestBodyExamples(this.schema);
    return this.requestBodyExamples;
  }
  /**
   * Return a specific response out of the operation by a given HTTP status code.
   *
   * @param statusCode Status code to pull a response object for.
   */
  getResponseByStatusCode(statusCode) {
    if (!this.schema.responses) {
      return false;
    }
    if (typeof this.schema.responses[statusCode] === "undefined") {
      return false;
    }
    const response = this.schema.responses[statusCode];
    if (isRef(response)) {
      return false;
    }
    return response;
  }
  /**
   * Retrieve an array of response examples that this operation has.
   *
   */
  getResponseExamples() {
    if (this.responseExamples) {
      return this.responseExamples;
    }
    this.responseExamples = getResponseExamples(this.schema);
    return this.responseExamples;
  }
  /**
   * Determine if the operation has callbacks.
   *
   */
  hasCallbacks() {
    return !!this.schema.callbacks;
  }
  /**
   * Retrieve a specific callback.
   *
   * @see {@link https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.3.md#callbackObject}
   * @see {@link https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.1.0.md#callbackObject}
   * @param identifier Callback identifier to look for.
   * @param expression Callback expression to look for.
   * @param method HTTP Method on the callback to look for.
   */
  getCallback(identifier, expression, method) {
    if (!this.schema.callbacks)
      return false;
    const callback = this.schema.callbacks[identifier] ? this.schema.callbacks[identifier][expression] : false;
    if (!callback || !callback[method])
      return false;
    return new Callback(this.api, expression, method, callback[method], identifier, callback);
  }
  /**
   * Retrieve an array of operations created from each callback.
   *
   */
  getCallbacks() {
    const callbackOperations = [];
    if (!this.hasCallbacks())
      return false;
    Object.keys(this.schema.callbacks).forEach((callback) => {
      Object.keys(this.schema.callbacks[callback]).forEach((expression) => {
        const cb = this.schema.callbacks[callback];
        if (!isRef(cb)) {
          const exp = cb[expression];
          if (!isRef(exp)) {
            Object.keys(exp).forEach((method) => {
              if (!supportedMethods2.has(method))
                return;
              callbackOperations.push(this.getCallback(callback, expression, method));
            });
          }
        }
      });
    });
    return callbackOperations;
  }
  /**
   * Retrieve an array of callback examples that this operation has.
   *
   */
  getCallbackExamples() {
    if (this.callbackExamples) {
      return this.callbackExamples;
    }
    this.callbackExamples = getCallbackExamples(this.schema);
    return this.callbackExamples;
  }
  /**
   * Determine if a given a custom specification extension exists within the operation.
   *
   * @see {@link https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.3.md#specificationExtensions}
   * @see {@link https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.1.0.md#specificationExtensions}
   * @param extension Specification extension to lookup.
   */
  hasExtension(extension) {
    return Boolean(this.schema && extension in this.schema);
  }
  /**
   * Retrieve a custom specification extension off of the operation.
   *
   * @see {@link https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.3.md#specificationExtensions}
   * @see {@link https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.1.0.md#specificationExtensions}
   * @param extension Specification extension to lookup.
   *
   * @deprecated Use `oas.getExtension(extension, operation)` instead.
   */
  getExtension(extension) {
    return this.schema?.[extension];
  }
  /**
   * Returns an object with groups of all example definitions (body/header/query/path/response/etc.).
   * The examples are grouped by their key when defined via the `examples` map.
   *
   * Any custom code samples defined via the `x-readme.code-samples` extension are returned,
   * regardless of if they have a matching response example.
   *
   * For standard OAS request parameter (e.g., body/header/query/path/etc.) examples,
   * they are only present in the return object if they have a corresponding response example
   * (i.e., a response example with the same key in the `examples` map).
   */
  getExampleGroups() {
    if (this.exampleGroups)
      return this.exampleGroups;
    const groups = getExampleGroups(this);
    this.exampleGroups = groups;
    return groups;
  }
};
var Callback = class extends Operation {
  constructor(oas, path, method, operation, identifier, parentPathItem) {
    super(oas, path, method, operation);
    this.identifier = identifier;
    this.parentSchema = parentPathItem;
  }
  /**
   * Return the primary identifier for this callback.
   *
   * @see {@link https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.3.md#callback-object}
   * @see {@link https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.1.0.md#callbackObject}
   */
  getIdentifier() {
    return this.identifier;
  }
  getSummary() {
    if (this.schema?.summary && typeof this.schema.summary === "string") {
      return this.schema.summary;
    } else if (this.parentSchema.summary && typeof this.parentSchema.summary === "string") {
      return this.parentSchema.summary;
    }
    return void 0;
  }
  getDescription() {
    if (this.schema?.description && typeof this.schema.description === "string") {
      return this.schema.description;
    } else if (this.parentSchema.description && typeof this.parentSchema.description === "string") {
      return this.parentSchema.description;
    }
    return void 0;
  }
  getParameters() {
    let parameters = this.schema?.parameters || [];
    const commonParams = this.parentSchema.parameters || [];
    if (commonParams.length) {
      parameters = parameters.concat(dedupeCommonParameters(parameters, commonParams) || []);
    }
    return parameters;
  }
};
var Webhook = class extends Operation {
  getSummary() {
    if (this.schema?.summary && typeof this.schema.summary === "string") {
      return this.schema.summary;
    } else if (this.api.webhooks[this.path].summary && typeof this.api.webhooks[this.path].summary === "string") {
      return this.api.webhooks[this.path].summary;
    }
    return void 0;
  }
  getDescription() {
    if (this.schema?.description && typeof this.schema.description === "string") {
      return this.schema.description;
    } else if (this.api.webhooks[this.path].description && typeof this.api.webhooks[this.path].description === "string") {
      return this.api.webhooks[this.path].description;
    }
    return void 0;
  }
};

// node_modules/oas/dist/chunk-3YIKJDJG.js
var import_json_schema_ref_parser = __toESM(require_lib9(), 1);

// node_modules/path-to-regexp/dist.es2015/index.js
function lexer(str2) {
  var tokens = [];
  var i = 0;
  while (i < str2.length) {
    var char = str2[i];
    if (char === "*" || char === "+" || char === "?") {
      tokens.push({ type: "MODIFIER", index: i, value: str2[i++] });
      continue;
    }
    if (char === "\\") {
      tokens.push({ type: "ESCAPED_CHAR", index: i++, value: str2[i++] });
      continue;
    }
    if (char === "{") {
      tokens.push({ type: "OPEN", index: i, value: str2[i++] });
      continue;
    }
    if (char === "}") {
      tokens.push({ type: "CLOSE", index: i, value: str2[i++] });
      continue;
    }
    if (char === ":") {
      var name = "";
      var j = i + 1;
      while (j < str2.length) {
        var code = str2.charCodeAt(j);
        if (
          // `0-9`
          code >= 48 && code <= 57 || // `A-Z`
          code >= 65 && code <= 90 || // `a-z`
          code >= 97 && code <= 122 || // `_`
          code === 95
        ) {
          name += str2[j++];
          continue;
        }
        break;
      }
      if (!name)
        throw new TypeError("Missing parameter name at ".concat(i));
      tokens.push({ type: "NAME", index: i, value: name });
      i = j;
      continue;
    }
    if (char === "(") {
      var count = 1;
      var pattern = "";
      var j = i + 1;
      if (str2[j] === "?") {
        throw new TypeError('Pattern cannot start with "?" at '.concat(j));
      }
      while (j < str2.length) {
        if (str2[j] === "\\") {
          pattern += str2[j++] + str2[j++];
          continue;
        }
        if (str2[j] === ")") {
          count--;
          if (count === 0) {
            j++;
            break;
          }
        } else if (str2[j] === "(") {
          count++;
          if (str2[j + 1] !== "?") {
            throw new TypeError("Capturing groups are not allowed at ".concat(j));
          }
        }
        pattern += str2[j++];
      }
      if (count)
        throw new TypeError("Unbalanced pattern at ".concat(i));
      if (!pattern)
        throw new TypeError("Missing pattern at ".concat(i));
      tokens.push({ type: "PATTERN", index: i, value: pattern });
      i = j;
      continue;
    }
    tokens.push({ type: "CHAR", index: i, value: str2[i++] });
  }
  tokens.push({ type: "END", index: i, value: "" });
  return tokens;
}
function parse(str2, options) {
  if (options === void 0) {
    options = {};
  }
  var tokens = lexer(str2);
  var _a = options.prefixes, prefixes = _a === void 0 ? "./" : _a;
  var defaultPattern = "[^".concat(escapeString2(options.delimiter || "/#?"), "]+?");
  var result = [];
  var key = 0;
  var i = 0;
  var path = "";
  var tryConsume = function(type2) {
    if (i < tokens.length && tokens[i].type === type2)
      return tokens[i++].value;
  };
  var mustConsume = function(type2) {
    var value2 = tryConsume(type2);
    if (value2 !== void 0)
      return value2;
    var _a2 = tokens[i], nextType = _a2.type, index = _a2.index;
    throw new TypeError("Unexpected ".concat(nextType, " at ").concat(index, ", expected ").concat(type2));
  };
  var consumeText = function() {
    var result2 = "";
    var value2;
    while (value2 = tryConsume("CHAR") || tryConsume("ESCAPED_CHAR")) {
      result2 += value2;
    }
    return result2;
  };
  while (i < tokens.length) {
    var char = tryConsume("CHAR");
    var name = tryConsume("NAME");
    var pattern = tryConsume("PATTERN");
    if (name || pattern) {
      var prefix = char || "";
      if (prefixes.indexOf(prefix) === -1) {
        path += prefix;
        prefix = "";
      }
      if (path) {
        result.push(path);
        path = "";
      }
      result.push({
        name: name || key++,
        prefix,
        suffix: "",
        pattern: pattern || defaultPattern,
        modifier: tryConsume("MODIFIER") || ""
      });
      continue;
    }
    var value = char || tryConsume("ESCAPED_CHAR");
    if (value) {
      path += value;
      continue;
    }
    if (path) {
      result.push(path);
      path = "";
    }
    var open = tryConsume("OPEN");
    if (open) {
      var prefix = consumeText();
      var name_1 = tryConsume("NAME") || "";
      var pattern_1 = tryConsume("PATTERN") || "";
      var suffix = consumeText();
      mustConsume("CLOSE");
      result.push({
        name: name_1 || (pattern_1 ? key++ : ""),
        pattern: name_1 && !pattern_1 ? defaultPattern : pattern_1,
        prefix,
        suffix,
        modifier: tryConsume("MODIFIER") || ""
      });
      continue;
    }
    mustConsume("END");
  }
  return result;
}
function match(str2, options) {
  var keys = [];
  var re = pathToRegexp(str2, keys, options);
  return regexpToFunction(re, keys, options);
}
function regexpToFunction(re, keys, options) {
  if (options === void 0) {
    options = {};
  }
  var _a = options.decode, decode = _a === void 0 ? function(x) {
    return x;
  } : _a;
  return function(pathname) {
    var m = re.exec(pathname);
    if (!m)
      return false;
    var path = m[0], index = m.index;
    var params2 = /* @__PURE__ */ Object.create(null);
    var _loop_1 = function(i2) {
      if (m[i2] === void 0)
        return "continue";
      var key = keys[i2 - 1];
      if (key.modifier === "*" || key.modifier === "+") {
        params2[key.name] = m[i2].split(key.prefix + key.suffix).map(function(value) {
          return decode(value, key);
        });
      } else {
        params2[key.name] = decode(m[i2], key);
      }
    };
    for (var i = 1; i < m.length; i++) {
      _loop_1(i);
    }
    return { path, index, params: params2 };
  };
}
function escapeString2(str2) {
  return str2.replace(/([.+*?=^!:${}()[\]|/\\])/g, "\\$1");
}
function flags(options) {
  return options && options.sensitive ? "" : "i";
}
function regexpToRegexp(path, keys) {
  if (!keys)
    return path;
  var groupsRegex = /\((?:\?<(.*?)>)?(?!\?)/g;
  var index = 0;
  var execResult = groupsRegex.exec(path.source);
  while (execResult) {
    keys.push({
      // Use parenthesized substring match if available, index otherwise
      name: execResult[1] || index++,
      prefix: "",
      suffix: "",
      modifier: "",
      pattern: ""
    });
    execResult = groupsRegex.exec(path.source);
  }
  return path;
}
function arrayToRegexp(paths, keys, options) {
  var parts = paths.map(function(path) {
    return pathToRegexp(path, keys, options).source;
  });
  return new RegExp("(?:".concat(parts.join("|"), ")"), flags(options));
}
function stringToRegexp(path, keys, options) {
  return tokensToRegexp(parse(path, options), keys, options);
}
function tokensToRegexp(tokens, keys, options) {
  if (options === void 0) {
    options = {};
  }
  var _a = options.strict, strict = _a === void 0 ? false : _a, _b = options.start, start = _b === void 0 ? true : _b, _c = options.end, end = _c === void 0 ? true : _c, _d = options.encode, encode = _d === void 0 ? function(x) {
    return x;
  } : _d, _e = options.delimiter, delimiter = _e === void 0 ? "/#?" : _e, _f = options.endsWith, endsWith = _f === void 0 ? "" : _f;
  var endsWithRe = "[".concat(escapeString2(endsWith), "]|$");
  var delimiterRe = "[".concat(escapeString2(delimiter), "]");
  var route = start ? "^" : "";
  for (var _i = 0, tokens_1 = tokens; _i < tokens_1.length; _i++) {
    var token = tokens_1[_i];
    if (typeof token === "string") {
      route += escapeString2(encode(token));
    } else {
      var prefix = escapeString2(encode(token.prefix));
      var suffix = escapeString2(encode(token.suffix));
      if (token.pattern) {
        if (keys)
          keys.push(token);
        if (prefix || suffix) {
          if (token.modifier === "+" || token.modifier === "*") {
            var mod = token.modifier === "*" ? "?" : "";
            route += "(?:".concat(prefix, "((?:").concat(token.pattern, ")(?:").concat(suffix).concat(prefix, "(?:").concat(token.pattern, "))*)").concat(suffix, ")").concat(mod);
          } else {
            route += "(?:".concat(prefix, "(").concat(token.pattern, ")").concat(suffix, ")").concat(token.modifier);
          }
        } else {
          if (token.modifier === "+" || token.modifier === "*") {
            route += "((?:".concat(token.pattern, ")").concat(token.modifier, ")");
          } else {
            route += "(".concat(token.pattern, ")").concat(token.modifier);
          }
        }
      } else {
        route += "(?:".concat(prefix).concat(suffix, ")").concat(token.modifier);
      }
    }
  }
  if (end) {
    if (!strict)
      route += "".concat(delimiterRe, "?");
    route += !options.endsWith ? "$" : "(?=".concat(endsWithRe, ")");
  } else {
    var endToken = tokens[tokens.length - 1];
    var isEndDelimited = typeof endToken === "string" ? delimiterRe.indexOf(endToken[endToken.length - 1]) > -1 : endToken === void 0;
    if (!strict) {
      route += "(?:".concat(delimiterRe, "(?=").concat(endsWithRe, "))?");
    }
    if (!isEndDelimited) {
      route += "(?=".concat(delimiterRe, "|").concat(endsWithRe, ")");
    }
  }
  return new RegExp(route, flags(options));
}
function pathToRegexp(path, keys, options) {
  if (path instanceof RegExp)
    return regexpToRegexp(path, keys);
  if (Array.isArray(path))
    return arrayToRegexp(path, keys, options);
  return stringToRegexp(path, keys, options);
}

// node_modules/oas/dist/chunk-3YIKJDJG.js
function getKey(user, scheme) {
  switch (scheme.type) {
    case "oauth2":
    case "apiKey":
      return user[scheme._key] || user.apiKey || scheme["x-default"] || null;
    case "http":
      if (scheme.scheme === "basic") {
        return user[scheme._key] || { user: user.user || null, pass: user.pass || null };
      }
      if (scheme.scheme === "bearer") {
        return user[scheme._key] || user.apiKey || scheme["x-default"] || null;
      }
      return null;
    default:
      return null;
  }
}
function getByScheme(user, scheme = {}, selectedApp) {
  if (user?.keys && user.keys.length) {
    if (selectedApp) {
      return getKey(
        user.keys.find((key) => key.name === selectedApp),
        scheme
      );
    }
    return getKey(user.keys[0], scheme);
  }
  return getKey(user, scheme);
}
function getAuth(api, user, selectedApp) {
  return Object.keys(api?.components?.securitySchemes || {}).map((scheme) => {
    return {
      [scheme]: getByScheme(
        user,
        {
          // This sucks but since we dereference we'll never have a `$ref` pointer here with a
          // `ReferenceObject` type.
          ...api.components.securitySchemes[scheme],
          _key: scheme
        },
        selectedApp
      )
    };
  }).reduce((prev, next) => Object.assign(prev, next), {});
}
function getUserVariable(user, property, selectedApp) {
  let key = user;
  if ("keys" in user && Array.isArray(user.keys) && user.keys.length) {
    if (selectedApp) {
      key = user.keys.find((k) => k.name === selectedApp);
    } else {
      key = user.keys[0];
    }
  }
  return key[property] || user[property] || null;
}
var SERVER_VARIABLE_REGEX = /{([-_a-zA-Z0-9:.[\]]+)}/g;
function ensureProtocol(url) {
  if (url.match(/^\/\//)) {
    return `https:${url}`;
  }
  if (!url.match(/\/\//)) {
    return `https://${url}`;
  }
  return url;
}
function stripTrailingSlash(url) {
  if (url[url.length - 1] === "/") {
    return url.slice(0, -1);
  }
  return url;
}
function normalizedUrl(api, selected) {
  const exampleDotCom = "https://example.com";
  let url;
  try {
    url = api.servers[selected].url;
    if (!url)
      throw new Error("no url");
    url = stripTrailingSlash(url);
    if (url.startsWith("/") && !url.startsWith("//")) {
      const urlWithOrigin = new URL(exampleDotCom);
      urlWithOrigin.pathname = url;
      url = urlWithOrigin.href;
    }
  } catch (e) {
    url = exampleDotCom;
  }
  return ensureProtocol(url);
}
function transformUrlIntoRegex(url) {
  return stripTrailingSlash(url.replace(SERVER_VARIABLE_REGEX, "([-_a-zA-Z0-9:.[\\]]+)"));
}
function normalizePath(path) {
  return path.replace(/({?){(.*?)}(}?)/g, (str2, ...args) => {
    return `:${args[1].replace("-", "")}`;
  }).replace(/::/, "\\::").split("?")[0];
}
function generatePathMatches(paths, pathName, origin) {
  const prunedPathName = pathName.split("?")[0];
  return Object.keys(paths).map((path) => {
    const cleanedPath = normalizePath(path);
    let matchResult;
    try {
      const matchStatement = match(cleanedPath, { decode: decodeURIComponent });
      matchResult = matchStatement(prunedPathName);
    } catch (err) {
      return;
    }
    const slugs = {};
    if (matchResult && Object.keys(matchResult.params).length) {
      Object.keys(matchResult.params).forEach((param) => {
        slugs[`:${param}`] = matchResult.params[param];
      });
    }
    return {
      url: {
        origin,
        path: cleanedPath.replace(/\\::/, "::"),
        nonNormalizedPath: path,
        slugs
      },
      operation: paths[path],
      match: matchResult
    };
  }).filter(Boolean).filter((p) => p.match);
}
function filterPathMethods(pathMatches, targetMethod) {
  const regExp = pathToRegexp(targetMethod);
  return pathMatches.map((p) => {
    const captures = Object.keys(p.operation).filter((r2) => regExp.exec(r2));
    if (captures.length) {
      const method = captures[0];
      p.url.method = method.toUpperCase();
      return {
        url: p.url,
        operation: p.operation[method]
      };
    }
    return false;
  }).filter(Boolean);
}
function findTargetPath(pathMatches) {
  let minCount = Object.keys(pathMatches[0].url.slugs).length;
  let operation;
  for (let m = 0; m < pathMatches.length; m += 1) {
    const selection = pathMatches[m];
    const paramCount = Object.keys(selection.url.slugs).length;
    if (paramCount <= minCount) {
      minCount = paramCount;
      operation = selection;
    }
  }
  return operation;
}
var Oas = class _Oas {
  /**
   * @param oas An OpenAPI definition.
   * @param user The information about a user that we should use when pulling auth tokens from
   *    security schemes.
   */
  constructor(oas, user) {
    if (typeof oas === "string") {
      oas = JSON.parse(oas);
    }
    this.api = oas;
    this.user = user || {};
    this.promises = [];
    this.dereferencing = {
      processing: false,
      complete: false,
      circularRefs: []
    };
  }
  /**
   * This will initialize a new instance of the `Oas` class. This method is useful if you're using
   * Typescript and are attempting to supply an untyped JSON object into `Oas` as it will force-type
   * that object to an `OASDocument` for you.
   *
   * @param oas An OpenAPI definition.
   * @param user The information about a user that we should use when pulling auth tokens from
   *    security schemes.
   */
  static init(oas, user) {
    return new _Oas(oas, user);
  }
  /**
   * Retrieve the OpenAPI version that this API definition is targeted for.
   */
  getVersion() {
    if (this.api.openapi) {
      return this.api.openapi;
    }
    throw new Error("Unable to recognize what specification version this API definition conforms to.");
  }
  /**
   * Retrieve the current OpenAPI API Definition.
   *
   */
  getDefinition() {
    return this.api;
  }
  url(selected = 0, variables) {
    const url = normalizedUrl(this.api, selected);
    return this.replaceUrl(url, variables || this.defaultVariables(selected)).trim();
  }
  variables(selected = 0) {
    let variables;
    try {
      variables = this.api.servers[selected].variables;
      if (!variables)
        throw new Error("no variables");
    } catch (e) {
      variables = {};
    }
    return variables;
  }
  defaultVariables(selected = 0) {
    const variables = this.variables(selected);
    const defaults = {};
    Object.keys(variables).forEach((key) => {
      defaults[key] = getUserVariable(this.user, key) || variables[key].default || "";
    });
    return defaults;
  }
  splitUrl(selected = 0) {
    const url = normalizedUrl(this.api, selected);
    const variables = this.variables(selected);
    return url.split(/({.+?})/).filter(Boolean).map((part, i) => {
      const isVariable = part.match(/[{}]/);
      const value = part.replace(/[{}]/g, "");
      const key = `${value}-${i}`;
      if (!isVariable) {
        return {
          type: "text",
          value,
          key
        };
      }
      const variable = variables?.[value];
      return {
        type: "variable",
        value,
        key,
        description: variable?.description,
        enum: variable?.enum
      };
    });
  }
  /**
   * With a fully composed server URL, run through our list of known OAS servers and return back
   * which server URL was selected along with any contained server variables split out.
   *
   * For example, if you have an OAS server URL of `https://{name}.example.com:{port}/{basePath}`,
   * and pass in `https://buster.example.com:3000/pet` to this function, you'll get back the
   * following:
   *
   *    { selected: 0, variables: { name: 'buster', port: 3000, basePath: 'pet' } }
   *
   * Re-supplying this data to `oas.url()` should return the same URL you passed into this method.
   *
   * @param baseUrl A given URL to extract server variables out of.
   */
  splitVariables(baseUrl) {
    const matchedServer = (this.api.servers || []).map((server, i) => {
      const rgx = transformUrlIntoRegex(server.url);
      const found = new RegExp(rgx).exec(baseUrl);
      if (!found) {
        return false;
      }
      const variables = {};
      Array.from(server.url.matchAll(SERVER_VARIABLE_REGEX)).forEach((variable, y) => {
        variables[variable[1]] = found[y + 1];
      });
      return {
        selected: i,
        variables
      };
    }).filter(Boolean);
    return matchedServer.length ? matchedServer[0] : false;
  }
  /**
   * Replace templated variables with supplied data in a given URL.
   *
   * There are a couple ways that this will utilize variable data:
   *
   *  - Supplying a `variables` object. If this is supplied, this data will always take priority.
   *    This incoming `variables` object can be two formats:
   *    `{ variableName: { default: 'value' } }` and `{ variableName: 'value' }`. If the former is
   *    present, that will take precedence over the latter.
   *  - If the supplied `variables` object is empty or does not match the current template name,
   *    we fallback to the data stored in `this.user` and attempt to match against that.
   *    See `getUserVariable` for some more information on how this data is pulled from `this.user`.
   *
   * If no variables supplied match up with the template name, the template name will instead be
   * used as the variable data.
   *
   * @param url A URL to swap variables into.
   * @param variables An object containing variables to swap into the URL.
   */
  replaceUrl(url, variables = {}) {
    return stripTrailingSlash(
      url.replace(SERVER_VARIABLE_REGEX, (original, key) => {
        if (key in variables) {
          const data = variables[key];
          if (typeof data === "object") {
            if (!Array.isArray(data) && data !== null && "default" in data) {
              return data.default;
            }
          } else {
            return data;
          }
        }
        const userVariable = getUserVariable(this.user, key);
        if (userVariable) {
          return userVariable;
        }
        return original;
      })
    );
  }
  /**
   * Retrieve an Operation of Webhook class instance for a given path and method.
   *
   * @param path Path to lookup and retrieve.
   * @param method HTTP Method to retrieve on the path.
   */
  operation(path, method, opts = {}) {
    let operation = {
      parameters: []
    };
    if (opts.isWebhook) {
      const api = this.api;
      if (api?.webhooks[path]?.[method]) {
        operation = api.webhooks[path][method];
        return new Webhook(api, path, method, operation);
      }
    }
    if (this?.api?.paths?.[path]?.[method]) {
      operation = this.api.paths[path][method];
    }
    return new Operation(this.api, path, method, operation);
  }
  findOperationMatches(url) {
    const { origin, hostname } = new URL(url);
    const originRegExp = new RegExp(origin, "i");
    const { servers, paths } = this.api;
    let pathName;
    let targetServer;
    let matchedServer;
    if (!servers || !servers.length) {
      matchedServer = {
        url: "https://example.com"
      };
    } else {
      matchedServer = servers.find((s) => originRegExp.exec(this.replaceUrl(s.url, s.variables || {})));
      if (!matchedServer) {
        const hostnameRegExp = new RegExp(hostname);
        matchedServer = servers.find((s) => hostnameRegExp.exec(this.replaceUrl(s.url, s.variables || {})));
      }
    }
    if (!matchedServer) {
      const matchedServerAndPath = servers.map((server) => {
        const rgx = transformUrlIntoRegex(server.url);
        const found = new RegExp(rgx).exec(url);
        if (!found) {
          return void 0;
        }
        return {
          matchedServer: server,
          pathName: url.split(new RegExp(rgx)).slice(-1).pop()
        };
      }).filter(Boolean);
      if (!matchedServerAndPath.length) {
        return void 0;
      }
      pathName = matchedServerAndPath[0].pathName;
      targetServer = {
        ...matchedServerAndPath[0].matchedServer
      };
    } else {
      targetServer = {
        ...matchedServer,
        url: this.replaceUrl(matchedServer.url, matchedServer.variables || {})
      };
      [, pathName] = url.split(new RegExp(targetServer.url, "i"));
    }
    if (pathName === void 0)
      return void 0;
    if (pathName === "")
      pathName = "/";
    const annotatedPaths = generatePathMatches(paths, pathName, targetServer.url);
    if (!annotatedPaths.length)
      return void 0;
    return annotatedPaths;
  }
  /**
   * Discover an operation in an OAS from a fully-formed URL and HTTP method. Will return an object
   * containing a `url` object and another one for `operation`. This differs from `getOperation()`
   * in that it does not return an instance of the `Operation` class.
   *
   * @param url A full URL to look up.
   * @param method The cooresponding HTTP method to look up.
   */
  findOperation(url, method) {
    const annotatedPaths = this.findOperationMatches(url);
    if (!annotatedPaths) {
      return void 0;
    }
    const matches = filterPathMethods(annotatedPaths, method);
    if (!matches.length)
      return void 0;
    return findTargetPath(matches);
  }
  /**
   * Discover an operation in an OAS from a fully-formed URL without an HTTP method. Will return an
   * object containing a `url` object and another one for `operation`.
   *
   * @param url A full URL to look up.
   */
  findOperationWithoutMethod(url) {
    const annotatedPaths = this.findOperationMatches(url);
    if (!annotatedPaths) {
      return void 0;
    }
    return findTargetPath(annotatedPaths);
  }
  /**
   * Retrieve an operation in an OAS from a fully-formed URL and HTTP method. Differs from
   * `findOperation` in that while this method will return an `Operation` instance,
   * `findOperation()` does not.
   *
   * @param url A full URL to look up.
   * @param method The cooresponding HTTP method to look up.
   */
  getOperation(url, method) {
    const op = this.findOperation(url, method);
    if (op === void 0) {
      return void 0;
    }
    return this.operation(op.url.nonNormalizedPath, method);
  }
  /**
   * With an object of user information, retrieve the appropriate API auth keys from the current
   * OAS definition.
   *
   * @see {@link https://docs.readme.com/docs/passing-data-to-jwt}
   * @param user User
   * @param selectedApp The user app to retrieve an auth key for.
   */
  getAuth(user, selectedApp) {
    if (!this.api?.components?.securitySchemes) {
      return {};
    }
    return getAuth(this.api, user, selectedApp);
  }
  /**
   * Returns the `paths` object that exists in this API definition but with every `method` mapped
   * to an instance of the `Operation` class.
   *
   * @see {@link https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.0.md#oasObject}
   * @see {@link https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.1.0.md#openapi-object}
   */
  getPaths() {
    const paths = {};
    Object.keys(this.api.paths ? this.api.paths : []).forEach((path) => {
      if (path.startsWith("x-")) {
        return;
      }
      paths[path] = {};
      if ("$ref" in this.api.paths[path]) {
        this.api.paths[path] = findSchemaDefinition(this.api.paths[path].$ref, this.api);
      }
      Object.keys(this.api.paths[path]).forEach((method) => {
        if (!supportedMethods2.has(method))
          return;
        paths[path][method] = this.operation(path, method);
      });
    });
    return paths;
  }
  /**
   * Returns the `webhooks` object that exists in this API definition but with every `method`
   * mapped to an instance of the `Webhook` class.
   *
   * @see {@link https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.0.md#oasObject}
   * @see {@link https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.1.0.md#openapi-object}
   */
  getWebhooks() {
    const webhooks = {};
    const api = this.api;
    Object.keys(api.webhooks ? api.webhooks : []).forEach((id) => {
      webhooks[id] = {};
      Object.keys(api.webhooks[id]).forEach((method) => {
        webhooks[id][method] = this.operation(id, method, { isWebhook: true });
      });
    });
    return webhooks;
  }
  /**
   * Return an array of all tag names that exist on this API definition.
   *
   * @see {@link https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.0.md#oasObject}
   * @see {@link https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.1.0.md#openapi-object}
   * @param setIfMissing If a tag is not present on an operation that operations path will be added
   *    into the list of tags returned.
   */
  getTags(setIfMissing = false) {
    const allTags = /* @__PURE__ */ new Set();
    const oasTags = this.api.tags?.map((tag) => {
      return tag.name;
    }) || [];
    const disableTagSorting = getExtension("disable-tag-sorting", this.api);
    Object.entries(this.getPaths()).forEach(([path, operations]) => {
      Object.values(operations).forEach((operation) => {
        const tags = operation.getTags();
        if (setIfMissing && !tags.length) {
          allTags.add(path);
          return;
        }
        tags.forEach((tag) => {
          allTags.add(tag.name);
        });
      });
    });
    Object.entries(this.getWebhooks()).forEach(([path, webhooks]) => {
      Object.values(webhooks).forEach((webhook) => {
        const tags = webhook.getTags();
        if (setIfMissing && !tags.length) {
          allTags.add(path);
          return;
        }
        tags.forEach((tag) => {
          allTags.add(tag.name);
        });
      });
    });
    const endpointTags = [];
    const tagsArray = [];
    if (disableTagSorting) {
      return Array.from(allTags);
    }
    Array.from(allTags).forEach((tag) => {
      if (oasTags.includes(tag)) {
        tagsArray.push(tag);
      } else {
        endpointTags.push(tag);
      }
    });
    let sortedTags = tagsArray.sort((a, b) => {
      return oasTags.indexOf(a) - oasTags.indexOf(b);
    });
    sortedTags = sortedTags.concat(endpointTags);
    return sortedTags;
  }
  /**
   * Determine if a given a custom specification extension exists within the API definition.
   *
   * @see {@link https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.3.md#specificationExtensions}
   * @see {@link https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.1.0.md#specificationExtensions}
   * @param extension Specification extension to lookup.
   */
  hasExtension(extension) {
    return hasRootExtension(extension, this.api);
  }
  /**
   * Retrieve a custom specification extension off of the API definition.
   *
   * @see {@link https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.3.md#specificationExtensions}
   * @see {@link https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.1.0.md#specificationExtensions}
   * @param extension Specification extension to lookup.
   */
  getExtension(extension, operation) {
    return getExtension(extension, this.api, operation);
  }
  /**
   * Determine if a given OpenAPI custom extension is valid or not.
   *
   * @see {@link https://docs.readme.com/docs/openapi-extensions}
   * @see {@link https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.3.md#specificationExtensions}
   * @see {@link https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.1.0.md#specificationExtensions}
   * @param extension Specification extension to validate.
   * @throws
   */
  validateExtension(extension) {
    if (this.hasExtension("x-readme")) {
      const data = this.getExtension("x-readme");
      if (typeof data !== "object" || Array.isArray(data) || data === null) {
        throw new TypeError('"x-readme" must be of type "Object"');
      }
      if (extension in data) {
        if ([CODE_SAMPLES, HEADERS, PARAMETER_ORDERING, SAMPLES_LANGUAGES].includes(extension)) {
          if (!Array.isArray(data[extension])) {
            throw new TypeError(`"x-readme.${extension}" must be of type "Array"`);
          }
          if (extension === PARAMETER_ORDERING) {
            validateParameterOrdering(data[extension], `x-readme.${extension}`);
          }
        } else if (typeof data[extension] !== "boolean") {
          throw new TypeError(`"x-readme.${extension}" must be of type "Boolean"`);
        }
      }
    }
    if (this.hasExtension(`x-${extension}`)) {
      const data = this.getExtension(`x-${extension}`);
      if ([CODE_SAMPLES, HEADERS, PARAMETER_ORDERING, SAMPLES_LANGUAGES].includes(extension)) {
        if (!Array.isArray(data)) {
          throw new TypeError(`"x-${extension}" must be of type "Array"`);
        }
        if (extension === PARAMETER_ORDERING) {
          validateParameterOrdering(data, `x-${extension}`);
        }
      } else if (typeof data !== "boolean") {
        throw new TypeError(`"x-${extension}" must be of type "Boolean"`);
      }
    }
  }
  /**
   * Validate all of our custom or known OpenAPI extensions, throwing exceptions when necessary.
   *
   * @see {@link https://docs.readme.com/docs/openapi-extensions}
   * @see {@link https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.3.md#specificationExtensions}
   * @see {@link https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.1.0.md#specificationExtensions}
   */
  validateExtensions() {
    Object.keys(extensionDefaults).forEach((extension) => {
      this.validateExtension(extension);
    });
  }
  /**
   * Retrieve any circular `$ref` pointers that maybe present within the API definition.
   *
   * This method requires that you first dereference the definition.
   *
   * @see Oas.dereference
   */
  getCircularReferences() {
    if (!this.dereferencing.complete) {
      throw new Error("#dereference() must be called first in order for this method to obtain circular references.");
    }
    return this.dereferencing.circularRefs;
  }
  /**
   * Dereference the current OAS definition so it can be parsed free of worries of `$ref` schemas
   * and circular structures.
   *
   */
  async dereference(opts = { preserveRefAsJSONSchemaTitle: false }) {
    if (this.dereferencing.complete) {
      return new Promise((resolve) => {
        resolve(true);
      });
    }
    if (this.dereferencing.processing) {
      return new Promise((resolve, reject) => {
        this.promises.push({ resolve, reject });
      });
    }
    this.dereferencing.processing = true;
    const { api, promises } = this;
    if (api && api.components && api.components.schemas && typeof api.components.schemas === "object") {
      Object.keys(api.components.schemas).forEach((schemaName) => {
        if (isPrimitive(api.components.schemas[schemaName]) || Array.isArray(api.components.schemas[schemaName]) || api.components.schemas[schemaName] === null) {
          return;
        }
        if (opts.preserveRefAsJSONSchemaTitle) {
          api.components.schemas[schemaName].title = schemaName;
        }
        api.components.schemas[schemaName]["x-readme-ref-name"] = schemaName;
      });
    }
    const parser = new import_json_schema_ref_parser.default();
    return parser.dereference(api || {}, {
      resolve: {
        // We shouldn't be resolving external pointers at this point so just ignore them.
        external: false
      },
      dereference: {
        // If circular `$refs` are ignored they'll remain in the OAS as `$ref: String`, otherwise
        // `$ref just won't exist. This allows us to do easy circular reference detection.
        circular: "ignore"
      }
    }).then((dereferenced) => {
      let circularRefs = [];
      if (parser.$refs.circular) {
        circularRefs = parser.$refs.circularRefs.map((pointer) => {
          return `#${pointer.split("#")[1]}`;
        });
      }
      this.api = dereferenced;
      this.promises = promises;
      this.dereferencing = {
        processing: false,
        complete: true,
        circularRefs
      };
      if (opts.cb) {
        opts.cb();
      }
    }).then(() => {
      return this.promises.map((deferred) => deferred.resolve());
    });
  }
};

// node_modules/@readme/httpsnippet/dist/chunk-KT7MO6Z4.js
var reducer = (accumulator, pair) => {
  const currentValue = accumulator[pair.name];
  if (currentValue === void 0) {
    accumulator[pair.name] = pair.value;
    return accumulator;
  }
  if (Array.isArray(currentValue)) {
    currentValue.push(pair.value);
    return accumulator;
  }
  accumulator[pair.name] = [currentValue, pair.value];
  return accumulator;
};

// node_modules/@readme/httpsnippet/dist/index.js
var import_url = require("url");
var import_qs = __toESM(require_lib10(), 1);
var isHarEntry = (value) => typeof value === "object" && "log" in value && typeof value.log === "object" && "entries" in value.log && Array.isArray(value.log.entries);
var HTTPSnippet = class {
  constructor(input, opts = {}) {
    this.initCalled = false;
    this.entries = [];
    this.requests = [];
    this.options = {};
    this.options = {
      harIsAlreadyEncoded: false,
      ...opts
    };
    this.requests = [];
    if (isHarEntry(input)) {
      this.entries = input.log.entries;
    } else {
      this.entries = [
        {
          request: input
        }
      ];
    }
  }
  init() {
    this.initCalled = true;
    this.requests = this.entries.map(({ request: request2 }) => {
      const req = {
        bodySize: 0,
        headersSize: 0,
        headers: [],
        cookies: [],
        httpVersion: "HTTP/1.1",
        queryString: [],
        postData: {
          mimeType: request2.postData?.mimeType || "application/octet-stream"
        },
        ...request2
      };
      if (req.postData && !req.postData.mimeType) {
        req.postData.mimeType = "application/octet-stream";
      }
      return this.prepare(req, this.options);
    });
    return this;
  }
  prepare(harRequest, options) {
    const request2 = {
      ...harRequest,
      fullUrl: "",
      uriObj: {},
      queryObj: {},
      headersObj: {},
      cookiesObj: {},
      allHeaders: {}
    };
    if (request2.queryString && request2.queryString.length) {
      request2.queryObj = request2.queryString.reduce(reducer, {});
    }
    if (request2.headers && request2.headers.length) {
      const http2VersionRegex = /^HTTP\/2/;
      request2.headersObj = request2.headers.reduce((accumulator, { name, value }) => {
        const headerName = http2VersionRegex.exec(request2.httpVersion) ? name.toLocaleLowerCase() : name;
        return {
          ...accumulator,
          [headerName]: value
        };
      }, {});
    }
    if (request2.cookies && request2.cookies.length) {
      request2.cookiesObj = request2.cookies.reduceRight(
        (accumulator, { name, value }) => ({
          ...accumulator,
          [name]: value
        }),
        {}
      );
    }
    const cookies = request2.cookies?.map(({ name, value }) => {
      if (options.harIsAlreadyEncoded) {
        return `${name}=${value}`;
      }
      return `${encodeURIComponent(name)}=${encodeURIComponent(value)}`;
    });
    if (cookies?.length) {
      request2.allHeaders.cookie = cookies.join("; ");
    }
    switch (request2.postData.mimeType) {
      case "multipart/mixed":
      case "multipart/related":
      case "multipart/form-data":
      case "multipart/alternative":
        request2.postData.text = "";
        request2.postData.mimeType = "multipart/form-data";
        if (request2.postData?.params) {
          const boundary = "---011000010111000001101001";
          const carriage = `${boundary}--`;
          const rn = "\r\n";
          const escape3 = (str2) => str2.replace(/\n/g, "%0A").replace(/\r/g, "%0D").replace(/"/g, "%22");
          const normalizeLinefeeds = (value) => value.replace(/\r?\n|\r/g, "\r\n");
          const payload = [`--${boundary}`];
          request2.postData?.params.forEach((param, i) => {
            const name = param.name;
            const value = param.value || "";
            const filename = param.fileName || null;
            const contentType = param.contentType || "application/octet-stream";
            if (filename) {
              payload.push(
                `Content-Disposition: form-data; name="${escape3(normalizeLinefeeds(name))}"; filename="${filename}"`
              );
              payload.push(`Content-Type: ${contentType}`);
            } else {
              payload.push(`Content-Disposition: form-data; name="${escape3(normalizeLinefeeds(name))}"`);
            }
            payload.push("");
            payload.push(normalizeLinefeeds(value));
            if (i !== request2.postData.params.length - 1) {
              payload.push(`--${boundary}`);
            }
          });
          payload.push(`--${carriage}`);
          request2.postData.boundary = boundary;
          request2.postData.text = payload.join(rn);
          const contentTypeHeader = getHeaderName(request2.headersObj, "content-type") || "content-type";
          request2.headersObj[contentTypeHeader] = `multipart/form-data; boundary=${boundary}`;
        }
        break;
      case "application/x-www-form-urlencoded":
        if (!request2.postData.params) {
          request2.postData.text = "";
        } else {
          request2.postData.paramsObj = request2.postData.params.reduce(reducer, {});
          request2.postData.text = (0, import_qs.stringify)(request2.postData.paramsObj);
        }
        break;
      case "text/json":
      case "text/x-json":
      case "application/json":
      case "application/x-json":
        request2.postData.mimeType = "application/json";
        if (request2.postData.text) {
          try {
            request2.postData.jsonObj = JSON.parse(request2.postData.text);
          } catch (e) {
            request2.postData.mimeType = "text/plain";
          }
        }
        break;
    }
    const allHeaders = {
      ...request2.allHeaders,
      ...request2.headersObj
    };
    const urlWithParsedQuery = (0, import_url.parse)(request2.url, true, true);
    request2.queryObj = {
      ...request2.queryObj,
      ...urlWithParsedQuery.query
    };
    let search;
    if (options.harIsAlreadyEncoded) {
      search = (0, import_qs.stringify)(request2.queryObj, {
        encode: false,
        indices: false
      });
    } else {
      search = (0, import_qs.stringify)(request2.queryObj, {
        indices: false
      });
    }
    const uriObj = {
      ...urlWithParsedQuery,
      query: request2.queryObj,
      search,
      path: search ? `${urlWithParsedQuery.pathname}?${search}` : urlWithParsedQuery.pathname
    };
    const url = (0, import_url.format)({
      ...urlWithParsedQuery,
      query: null,
      search: null
    });
    const fullUrl = (0, import_url.format)({
      ...urlWithParsedQuery,
      ...uriObj
    });
    return {
      ...request2,
      allHeaders,
      fullUrl,
      url,
      uriObj
    };
  }
  convert(targetId, clientId, options) {
    if (!this.initCalled) {
      this.init();
    }
    if (!options && clientId) {
      options = clientId;
    }
    const target = targets[targetId];
    if (!target) {
      return false;
    }
    const { convert: convert2 } = target.clientsById[clientId || target.info.default];
    const results = this.requests.map((request2) => convert2(request2, options));
    return results;
  }
};

// node_modules/@readme/oas-to-har/dist/chunk-B6VBOO2O.js
function harValue(type2, value) {
  if (!value.value)
    return void 0;
  return { type: type2, value };
}
function configureSecurity(apiDefinition, values, scheme) {
  if (!scheme)
    return void 0;
  if (Object.keys(values || {}).length === 0)
    return void 0;
  if (!apiDefinition.components?.securitySchemes?.[scheme])
    return void 0;
  const security = apiDefinition.components.securitySchemes[scheme];
  if (isRef(security)) {
    return void 0;
  } else if (!values[scheme]) {
    return false;
  }
  if (security.type === "http") {
    if (security.scheme === "basic") {
      const auth = values[scheme];
      if (typeof auth !== "object")
        return false;
      if (!auth.user && !auth.pass)
        return false;
      let user = auth.user ?? null;
      if (user === null || user.length === 0) {
        user = "";
      }
      let pass = auth.pass ?? null;
      if (pass === null || pass.length === 0) {
        pass = "";
      }
      return harValue("headers", {
        name: "authorization",
        value: `Basic ${Buffer.from(`${user}:${pass}`).toString("base64")}`
      });
    } else if (security.scheme === "bearer") {
      return harValue("headers", {
        name: "authorization",
        value: `Bearer ${values[scheme]}`
      });
    }
  }
  if (security.type === "apiKey") {
    if (security.in === "query") {
      return harValue("queryString", {
        name: security.name,
        value: String(values[scheme])
      });
    } else if (security.in === "header") {
      const header = {
        name: security.name,
        value: String(values[scheme])
      };
      if (security["x-bearer-format"]) {
        const bearerFormat = security["x-bearer-format"].charAt(0).toUpperCase() + security["x-bearer-format"].slice(1);
        header.name = security.name;
        header.value = `${bearerFormat} ${header.value}`;
      }
      return harValue("headers", header);
    } else if (security.in === "cookie") {
      return harValue("cookies", {
        name: security.name,
        value: String(values[scheme])
      });
    }
  }
  if (security.type === "oauth2") {
    return harValue("headers", {
      name: "authorization",
      value: `Bearer ${values[scheme]}`
    });
  }
  return void 0;
}

// node_modules/@readme/data-urls/dist/index.js
var DATA_URL_REGEX = /^data:([a-z]+\/[a-z0-9-+.]+(;[a-z0-9-.!#$%*+.{}|~`]+=[a-z0-9-.!#$%*+.{}()_|~`]+)*)?(;base64)?,([a-z0-9!$&',()*+;=\-._~:@/?%\s<>]*?)$/i;
function validate(str2) {
  return DATA_URL_REGEX.test((str2 || "").trim());
}
function parse3(str2) {
  if (!validate(str2)) {
    return false;
  }
  const parts = str2.trim().match(DATA_URL_REGEX);
  const parsed = {};
  if (parts[1]) {
    parsed.mediaType = parts[1].toLowerCase();
    const mediaTypeParts = parts[1].split(";").map((x) => {
      if (x.startsWith("name=")) {
        return x;
      }
      return x.toLowerCase();
    });
    parsed.contentType = mediaTypeParts[0];
    mediaTypeParts.slice(1).forEach((attribute) => {
      const p = attribute.split("=");
      parsed[p[0]] = p[1];
    });
  }
  parsed.base64 = !!parts[parts.length - 2];
  parsed.data = parts[parts.length - 1] || "";
  parsed.toBuffer = () => {
    const encoding = parsed.base64 ? "base64" : "utf8";
    return Buffer.from(parsed.data, encoding);
  };
  return parsed;
}

// node_modules/@readme/oas-to-har/dist/index.js
var import_qs2 = __toESM(require_lib10(), 1);
function get(object, path) {
  if (!path)
    return void 0;
  const pathArray = String(path).match(/([^[.\]])+/g);
  const result = pathArray?.reduce((prevObj, key) => prevObj && prevObj[key], object);
  return result;
}
function set(object, path, value) {
  const pathArray = Array.isArray(path) ? path : String(path).match(/([^[.\]])+/g);
  return pathArray?.reduce((acc, key, i) => {
    if (acc[key] === void 0) {
      acc[key] = {};
    }
    if (i === pathArray.length - 1) {
      acc[key] = value;
    }
    return acc[key];
  }, object);
}
var isRfc3986Reserved = (char) => ":/?#[]@!$&'()*+,;=".indexOf(char) > -1;
var isRfc3986Unreserved = (char) => /^[a-z0-9\-._~]+$/i.test(char);
function isURIEncoded(value) {
  try {
    return decodeURIComponent(value) !== value;
  } catch (err) {
    return false;
  }
}
function isObject3(value) {
  return typeof value === "object" && value !== null;
}
function encodeDisallowedCharacters(str2, {
  escape: escape3,
  returnIfEncoded = false,
  isAllowedReserved
} = {}, parse6) {
  if (typeof str2 === "number") {
    str2 = str2.toString();
  }
  if (returnIfEncoded) {
    if (isURIEncoded(str2)) {
      return str2;
    }
  }
  if (typeof str2 !== "string" || !str2.length) {
    return str2;
  }
  if (!escape3) {
    return str2;
  }
  if (parse6) {
    return JSON.parse(str2);
  }
  return [...str2].map((char) => {
    if (isRfc3986Unreserved(char)) {
      return char;
    }
    if (isRfc3986Reserved(char) && (escape3 === "unsafe" || isAllowedReserved)) {
      return char;
    }
    const encoder = new TextEncoder();
    const encoded = Array.from(encoder.encode(char)).map((byte) => `0${byte.toString(16).toUpperCase()}`.slice(-2)).map((encodedByte) => `%${encodedByte}`).join("");
    return encoded;
  }).join("");
}
function stylize(config) {
  const { value } = config;
  if (Array.isArray(value)) {
    return encodeArray(config);
  }
  if (isObject3(value)) {
    return encodeObject(config);
  }
  return encodePrimitive(config);
}
function encodeArray({
  location: location2,
  key,
  value,
  style,
  explode,
  escape: escape3,
  isAllowedReserved = false
}) {
  const valueEncoder = (str2) => encodeDisallowedCharacters(str2, {
    escape: escape3,
    returnIfEncoded: location2 === "query",
    isAllowedReserved
  });
  switch (style) {
    case "simple":
      return value.map((val) => valueEncoder(val)).join(",");
    case "label":
      return `.${value.map((val) => valueEncoder(val)).join(".")}`;
    case "matrix":
      return value.map((val) => valueEncoder(val)).reduce((prev, curr) => {
        if (!prev || explode) {
          return `${prev || ""};${key}=${curr}`;
        }
        return `${prev},${curr}`;
      }, "");
    case "form":
      return value.map((val) => valueEncoder(val)).join(explode ? `&${key}=` : ",");
    case "spaceDelimited":
      return value.map((val) => valueEncoder(val)).join(` ${explode ? `${key}=` : ""}`);
    case "pipeDelimited":
      return value.map((val) => valueEncoder(val)).join(`|${explode ? `${key}=` : ""}`);
    default:
      return void 0;
  }
}
function encodeObject({ location: location2, key, value, style, explode, escape: escape3, isAllowedReserved = false }) {
  const valueEncoder = (str2) => encodeDisallowedCharacters(str2, {
    escape: escape3,
    returnIfEncoded: location2 === "query",
    isAllowedReserved
  });
  const valueKeys = Object.keys(value);
  switch (style) {
    case "simple":
      return valueKeys.reduce((prev, curr) => {
        const val = valueEncoder(value[curr]);
        const middleChar = explode ? "=" : ",";
        const prefix = prev ? `${prev},` : "";
        return `${prefix}${curr}${middleChar}${val}`;
      }, "");
    case "label":
      return valueKeys.reduce((prev, curr) => {
        const val = valueEncoder(value[curr]);
        const middleChar = explode ? "=" : ".";
        const prefix = prev ? `${prev}.` : ".";
        return `${prefix}${curr}${middleChar}${val}`;
      }, "");
    case "matrix":
      if (explode) {
        return valueKeys.reduce((prev, curr) => {
          const val = valueEncoder(value[curr]);
          const prefix = prev ? `${prev};` : ";";
          return `${prefix}${curr}=${val}`;
        }, "");
      }
      return valueKeys.reduce((prev, curr) => {
        const val = valueEncoder(value[curr]);
        const prefix = prev ? `${prev},` : `;${key}=`;
        return `${prefix}${curr},${val}`;
      }, "");
    case "form":
      return valueKeys.reduce((prev, curr) => {
        const val = valueEncoder(value[curr]);
        const prefix = prev ? `${prev}${explode ? "&" : ","}` : "";
        const separator = explode ? "=" : ",";
        return `${prefix}${curr}${separator}${val}`;
      }, "");
    case "spaceDelimited":
      return valueKeys.reduce((prev, curr) => {
        const val = valueEncoder(value[curr]);
        const prefix = prev ? `${prev} ` : "";
        return `${prefix}${curr} ${val}`;
      }, "");
    case "pipeDelimited":
      return valueKeys.reduce((prev, curr) => {
        const val = valueEncoder(value[curr]);
        const prefix = prev ? `${prev}|` : "";
        return `${prefix}${curr}|${val}`;
      }, "");
    case "deepObject":
      return valueKeys.reduce((curr) => {
        const val = valueEncoder(value[curr]);
        return `${val}`;
      }, "");
    default:
      return void 0;
  }
}
function encodePrimitive({ location: location2, key, value, style, escape: escape3, isAllowedReserved = false }) {
  const valueEncoder = (str2) => encodeDisallowedCharacters(str2, {
    escape: escape3,
    returnIfEncoded: location2 === "query" || location2 === "body",
    isAllowedReserved
  });
  switch (style) {
    case "simple":
      return valueEncoder(value);
    case "label":
      return `.${valueEncoder(value)}`;
    case "matrix":
      if (value === "") {
        return `;${key}`;
      }
      return `;${key}=${valueEncoder(value)}`;
    case "form":
      return valueEncoder(value);
    case "deepObject":
      return valueEncoder(value);
    default:
      return void 0;
  }
}
function shouldNotStyleEmptyValues(parameter) {
  return ["simple", "spaceDelimited", "pipeDelimited", "deepObject"].includes(parameter.style || "");
}
function shouldNotStyleReservedHeader(parameter) {
  return ["accept", "authorization", "content-type"].includes(parameter.name.toLowerCase());
}
function removeUndefinedForPath(value) {
  let finalValue = value;
  if (typeof finalValue === "undefined") {
    return "";
  }
  if (Array.isArray(finalValue)) {
    finalValue = finalValue.filter((val) => val === void 0 ? "" : val);
    if (finalValue.length === 0) {
      finalValue = "";
    }
  }
  if (typeof finalValue === "object") {
    Object.keys(finalValue).forEach((key) => {
      finalValue[key] = finalValue[key] === void 0 ? "" : finalValue[key];
    });
  }
  return finalValue;
}
function stylizeValue(value, parameter) {
  let finalValue = value;
  if (shouldNotStyleEmptyValues(parameter) && (typeof finalValue === "undefined" || finalValue === "")) {
    if (parameter.in === "path") {
      return "";
    }
    return void 0;
  }
  if (parameter.in === "path") {
    finalValue = removeUndefinedForPath(finalValue);
  }
  if (parameter.in === "header" && shouldNotStyleReservedHeader(parameter)) {
    return value;
  }
  let style = parameter.style;
  if (!style) {
    if (parameter.in === "query") {
      style = "form";
    } else if (parameter.in === "path") {
      style = "simple";
    } else if (parameter.in === "header") {
      style = "simple";
    } else if (parameter.in === "cookie") {
      style = "form";
    }
  }
  let explode = parameter.explode;
  if (explode === void 0 && style === "form") {
    explode = true;
  }
  return stylize({
    location: parameter.in,
    value: finalValue,
    key: parameter.name,
    style,
    explode,
    /**
     * @todo this parameter is optional to stylize. It defaults to false, and can accept falsy, truthy, or "unsafe".
     *  I do not know if it is correct for query to use this. See style-serializer for more info
     */
    escape: true,
    ...parameter.in === "query" ? { isAllowedReserved: parameter.allowReserved || false } : {}
  });
}
function handleDeepObject(value, parameter) {
  return import_qs2.default.stringify(value, {
    // eslint-disable-next-line consistent-return
    encoder(str2, defaultEncoder, charset, type2) {
      if (type2 === "key") {
        const prefixedKey = str2.split(/[[\]]/g).filter(Boolean).map((k) => `[${k}]`).join("");
        return `${parameter.name}${prefixedKey}`;
      } else if (type2 === "value") {
        return stylizeValue(str2, parameter);
      }
    }
  }).split("&").map((item) => {
    const split = item.split("=");
    return {
      label: split[0],
      // `qs` will coerce null values into being `undefined` string but we want to preserve them.
      value: split[1] === "undefined" ? null : split[1]
    };
  });
}
function handleExplode(value, parameter) {
  if (Array.isArray(value) && parameter.schema?.type === "array" && parameter.style === "deepObject") {
    const newObj = {};
    const deepObjs = handleDeepObject(value, parameter);
    deepObjs.forEach((obj) => {
      newObj[obj.label] = obj.value;
    });
    return newObj;
  }
  if (Array.isArray(value)) {
    return value.map((val) => {
      return stylizeValue(val, parameter);
    });
  }
  if (typeof value === "object" && value !== null) {
    const newObj = {};
    Object.keys(value).forEach((key) => {
      if (parameter.style === "deepObject") {
        const deepObjs = handleDeepObject(value, parameter);
        deepObjs.forEach((obj) => {
          newObj[obj.label] = obj.value;
        });
      } else {
        newObj[key] = stylizeValue(value[key], parameter);
      }
    });
    return newObj;
  }
  return stylizeValue(value, parameter);
}
function shouldExplode(parameter) {
  return (parameter.explode || parameter.explode !== false && parameter.style === "form" || // style: deepObject && explode: false doesn't exist so explode it always
  // https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.1.0.md#style-examples
  parameter.style === "deepObject") && // header and path doesn't explode into separate parameters like query and cookie do
  parameter.in !== "header" && parameter.in !== "path";
}
function formatStyle(value, parameter) {
  if (parameter.style === "deepObject" && (!value || typeof value !== "object" || parameter.explode === false)) {
    return void 0;
  }
  if (shouldExplode(parameter)) {
    return handleExplode(value, parameter);
  }
  return stylizeValue(value, parameter);
}
function hasSchemaType2(schema2, discriminator) {
  if (Array.isArray(schema2.type)) {
    return schema2.type.includes(discriminator);
  }
  return schema2.type === discriminator;
}
function getSafeRequestBody(obj) {
  if ("oneOf" in obj) {
    return getSafeRequestBody(obj.oneOf[0]);
  } else if ("anyOf" in obj) {
    return getSafeRequestBody(obj.anyOf[0]);
  }
  return obj;
}
function getSubschemas(schema2, opts) {
  let subSchemaDataSize = 0;
  if (opts.parentIsArray) {
    const parentData = get(opts.payload, opts.parentKey || "");
    if (parentData === void 0 || !Array.isArray(parentData)) {
      return false;
    }
    subSchemaDataSize = parentData.length;
  }
  let subschemas = [];
  if (subSchemaDataSize > 0) {
    for (let idx = 0; idx < subSchemaDataSize; idx += 1) {
      subschemas = subschemas.concat(
        Object.entries(schema2).map(([key, subschema]) => ({
          key: opts.parentKey ? [opts.parentKey, idx, key].join(".") : key,
          schema: getSafeRequestBody(subschema)
        }))
      );
    }
  } else {
    subschemas = Object.entries(schema2).map(([key, subschema]) => ({
      key: opts.parentKey ? [opts.parentKey, key].join(".") : key,
      schema: getSafeRequestBody(subschema)
    }));
  }
  return subschemas;
}
function getTypedFormatsInSchema(format6, schema2, opts) {
  try {
    if (schema2?.format === format6) {
      if (opts.parentIsArray) {
        const parentData = get(opts.payload, opts.parentKey || "");
        if (parentData !== void 0 && Array.isArray(parentData)) {
          return Object.keys(parentData).map((pdk) => {
            const currentKey = [opts.parentKey, pdk].join(".");
            if (get(opts.payload, currentKey) !== void 0) {
              return currentKey;
            }
            return false;
          }).filter(Boolean);
        }
      } else if (opts.parentKey && get(opts.payload, opts.parentKey) !== void 0) {
        return opts.parentKey;
      } else if (opts.payload !== void 0) {
        return true;
      }
      return false;
    }
    const subschemas = getSubschemas(schema2, opts);
    if (!subschemas) {
      return false;
    }
    return subschemas.map(({ key, schema: subschema }) => {
      if ("properties" in subschema) {
        return getTypedFormatsInSchema(format6, subschema.properties, { payload: opts.payload, parentKey: key });
      } else if ("items" in subschema) {
        if (subschema.items?.properties) {
          return getTypedFormatsInSchema(format6, subschema.items.properties, {
            payload: opts.payload,
            parentKey: key,
            parentIsArray: true
          });
        }
        return getTypedFormatsInSchema(format6, subschema.items, {
          payload: opts.payload,
          parentKey: key,
          parentIsArray: true
        });
      }
      return getTypedFormatsInSchema(format6, subschema, { payload: opts.payload, parentKey: key });
    }).flat().filter(Boolean);
  } catch (err) {
    return [];
  }
}
function formatter(values, param, type2, onlyIfExists = false) {
  if (param.style) {
    const value2 = values[type2][param.name];
    return formatStyle(value2, param);
  }
  let value;
  if (typeof values[type2][param.name] !== "undefined") {
    value = values[type2][param.name];
  } else if (onlyIfExists && !param.required) {
    value = void 0;
  } else if (param.required && param.schema && !isRef(param.schema) && param.schema.default) {
    value = param.schema.default;
  } else if (type2 === "path") {
    return param.name;
  }
  if (param.schema && !isRef(param.schema) && param.schema.type === "array" && param.schema.items && !isRef(param.schema.items) && param.schema.items.format === "binary") {
    if (Array.isArray(value)) {
      return value;
    }
    return JSON.stringify(value);
  }
  if (value !== void 0) {
    if (type2 === "query") {
      return formatStyle(value, param);
    }
    return value;
  }
  return void 0;
}
function multipartBodyToFormatterParams(payload, oasMediaTypeObject, schema2) {
  const encoding = oasMediaTypeObject.encoding;
  if (typeof payload === "object" && payload !== null) {
    return Object.keys(payload).map((key) => {
      if (!schema2.properties?.[key]) {
        return false;
      }
      const paramEncoding = encoding ? encoding[key] : void 0;
      return {
        name: key,
        // If the style isn't defined, use the default
        style: paramEncoding ? paramEncoding.style : void 0,
        // If explode isn't defined, use the default
        explode: paramEncoding ? paramEncoding.explode : void 0,
        required: schema2.required && typeof schema2.required === "boolean" && Boolean(schema2.required) || Array.isArray(schema2.required) && schema2.required.includes(key),
        schema: schema2.properties[key],
        in: "body"
      };
    }).filter(Boolean);
  }
  return [];
}
var defaultFormDataTypes = Object.keys(types).reduce((prev, curr) => {
  return Object.assign(prev, { [curr]: {} });
}, {});
function getResponseContentType(content) {
  const types3 = Object.keys(content) || [];
  if (types3 && types3.length) {
    const jsonType = types3.find((t) => matches_mimetype_default.json(t));
    if (jsonType) {
      return jsonType;
    }
    return types3[0];
  }
  return "application/json";
}
function isPrimitive2(val) {
  return typeof val === "string" || typeof val === "number" || typeof val === "boolean";
}
function stringify2(json3) {
  return JSON.stringify(removeUndefinedObjects(typeof json3.RAW_BODY !== "undefined" ? json3.RAW_BODY : json3));
}
function stringifyParameter(param) {
  if (param === null || isPrimitive2(param)) {
    return param;
  } else if (Array.isArray(param) && param.every(isPrimitive2)) {
    return String(param);
  }
  return JSON.stringify(param);
}
function appendHarValue(harParam, name, value, addtlData = {}) {
  if (typeof value === "undefined")
    return;
  if (Array.isArray(value)) {
    value.forEach((singleValue) => {
      appendHarValue(harParam, name, singleValue);
    });
  } else if (typeof value === "object" && value !== null) {
    Object.keys(value).forEach((key) => {
      appendHarValue(harParam, key, value[key]);
    });
  } else {
    harParam.push({
      ...addtlData,
      name,
      value: String(value)
    });
  }
}
function encodeBodyForHAR(body) {
  if (isPrimitive2(body)) {
    return body;
  } else if (typeof body === "object" && body !== null && !Array.isArray(body) && typeof body.RAW_BODY !== "undefined") {
    if (isPrimitive2(body.RAW_BODY)) {
      return body.RAW_BODY;
    }
    return stringify2(body.RAW_BODY);
  }
  return stringify2(body);
}
function oasToHar(oas, operationSchema, values = {}, auth = {}, opts = {
  // If true, the operation URL will be rewritten and prefixed with https://try.readme.io/ in
  // order to funnel requests through our CORS-friendly proxy.
  proxyUrl: false
}) {
  let operation;
  if (!operationSchema || typeof operationSchema.getParameters !== "function") {
    operation = new Operation(
      oas,
      operationSchema?.path || "",
      operationSchema?.method || "",
      operationSchema || { path: "", method: "" }
    );
  } else {
    operation = operationSchema;
  }
  const apiDefinition = oas.getDefinition();
  const formData = {
    ...defaultFormDataTypes,
    ...values
  };
  if (!formData.server) {
    formData.server = {
      selected: 0,
      variables: oas.defaultVariables(0)
    };
  }
  formData.server.variables = {
    ...oas.defaultVariables(formData.server.selected),
    ...formData.server.variables ? formData.server.variables : {}
  };
  const har = {
    cookies: [],
    headers: [],
    headersSize: 0,
    queryString: [],
    // @ts-expect-error This is fine because we're fleshing `postData` out further down.
    postData: {},
    bodySize: 0,
    method: operation.method.toUpperCase(),
    url: `${oas.url(formData.server.selected, formData.server.variables)}${operation.path}`.replace(
      /\s/g,
      "%20"
    ),
    httpVersion: "HTTP/1.1"
  };
  if (opts.proxyUrl) {
    if (oas.getExtension(PROXY_ENABLED, operation)) {
      har.url = `https://try.readme.io/${har.url}`;
    }
  }
  const parameters = operation.getParameters();
  har.url = har.url.replace(/{([-_a-zA-Z0-9[\]]+)}/g, (full, key) => {
    if (!operation || !parameters)
      return key;
    const parameter = parameters.find((param) => param.name === key) || { name: key };
    if (!("style" in parameter) || !parameter.style) {
      return encodeURIComponent(formatter(formData, parameter, "path"));
    }
    return formatter(formData, parameter, "path");
  });
  const queryStrings = parameters && parameters.filter((param) => param.in === "query");
  if (queryStrings && queryStrings.length) {
    queryStrings.forEach((queryString) => {
      const value = formatter(formData, queryString, "query", true);
      appendHarValue(har.queryString, queryString.name, value);
    });
  }
  const cookies = parameters && parameters.filter((param) => param.in === "cookie");
  if (cookies && cookies.length) {
    cookies.forEach((cookie) => {
      const value = formatter(formData, cookie, "cookie", true);
      appendHarValue(har.cookies, cookie.name, value);
    });
  }
  if (operation.schema.responses) {
    Object.keys(operation.schema.responses).some((response) => {
      if (isRef(operation.schema.responses?.[response]))
        return false;
      const content = (operation.schema.responses?.[response]).content;
      if (!content)
        return false;
      if (Object.keys(formData.header || {}).find((h) => h.toLowerCase() === "accept"))
        return true;
      har.headers.push({
        name: "accept",
        value: getResponseContentType(content)
      });
      return true;
    });
  }
  let hasContentType = false;
  let contentType = operation.getContentType();
  const headers = parameters && parameters.filter((param) => param.in === "header");
  if (headers && headers.length) {
    headers.forEach((header) => {
      const value = formatter(formData, header, "header", true);
      if (typeof value === "undefined")
        return;
      if (header.name.toLowerCase() === "content-type") {
        hasContentType = true;
        contentType = String(value);
      }
      appendHarValue(har.headers, header.name, value);
    });
  }
  const userDefinedHeaders = oas.getExtension(HEADERS, operation);
  if (userDefinedHeaders) {
    userDefinedHeaders.forEach((header) => {
      if (typeof header.key === "string" && header.key.toLowerCase() === "content-type") {
        hasContentType = true;
        contentType = String(header.value);
      }
      har.headers.push({
        name: String(header.key),
        value: String(header.value)
      });
    });
  }
  if (formData.header) {
    const acceptHeader = Object.keys(formData.header).find((h) => h.toLowerCase() === "accept");
    if (acceptHeader && !har.headers.find((hdr) => hdr.name.toLowerCase() === "accept")) {
      har.headers.push({
        name: "accept",
        value: String(formData.header[acceptHeader])
      });
    }
    const authorizationHeader = Object.keys(formData.header).find((h) => h.toLowerCase() === "authorization");
    if (authorizationHeader && !har.headers.find((hdr) => hdr.name.toLowerCase() === "authorization")) {
      har.headers.push({
        name: "authorization",
        value: String(formData.header[authorizationHeader])
      });
    }
  }
  let requestBody;
  if (operation.hasRequestBody()) {
    requestBody = operation.getParametersAsJSONSchema().find((payload) => {
      return payload.type === (operation.isFormUrlEncoded() ? "formData" : "body");
    });
  }
  if (requestBody && requestBody.schema && Object.keys(requestBody.schema).length) {
    const requestBodySchema = requestBody.schema;
    if (operation.isFormUrlEncoded()) {
      if (Object.keys(formData.formData || {}).length) {
        const cleanFormData = removeUndefinedObjects(JSON.parse(JSON.stringify(formData.formData)));
        if (cleanFormData !== void 0) {
          const postData = { params: [], mimeType: "application/x-www-form-urlencoded" };
          Object.keys(cleanFormData).forEach((name) => {
            postData.params.push({
              name,
              value: stringifyParameter(cleanFormData[name])
            });
          });
          har.postData = postData;
        }
      }
    } else if ("body" in formData && formData.body !== void 0 && (isPrimitive2(formData.body) || Object.keys(formData.body).length)) {
      const isMultipart = operation.isMultipart();
      const isJSON2 = operation.isJson();
      if (isMultipart || isJSON2) {
        try {
          let cleanBody = removeUndefinedObjects(JSON.parse(JSON.stringify(formData.body)));
          if (isMultipart) {
            har.postData = { params: [], mimeType: "multipart/form-data" };
            const safeBodySchema = getSafeRequestBody(requestBodySchema);
            const binaryTypes = Object.keys(safeBodySchema.properties).filter((key) => {
              const propData = safeBodySchema.properties[key];
              if (propData.format === "binary") {
                return true;
              } else if (propData.type === "array" && propData.items && typeof propData.items === "object" && propData.items !== null && propData.items.format === "binary") {
                return true;
              }
              return false;
            });
            if (cleanBody !== void 0) {
              const multipartParams = multipartBodyToFormatterParams(
                formData.body,
                operation.schema.requestBody.content["multipart/form-data"],
                safeBodySchema
              );
              if (multipartParams.length) {
                Object.keys(cleanBody).forEach((name) => {
                  const param = multipartParams.find((multipartParam) => multipartParam.name === name);
                  if (param) {
                    const addtlData = {};
                    let value = formatter(formData, param, "body", true);
                    if (!Array.isArray(value)) {
                      value = [value];
                    }
                    value.forEach((val) => {
                      if (binaryTypes.includes(name)) {
                        const parsed = parse3(val);
                        if (parsed) {
                          addtlData.fileName = "name" in parsed ? parsed.name : "unknown";
                          if ("contentType" in parsed) {
                            addtlData.contentType = parsed.contentType;
                          }
                        }
                      }
                      appendHarValue(har.postData?.params || [], name, val, addtlData);
                    });
                  }
                });
              }
            }
          } else {
            har.postData = { mimeType: contentType, text: "" };
            if (hasSchemaType2(requestBody.schema, "string") || hasSchemaType2(requestBody.schema, "integer") || hasSchemaType2(requestBody.schema, "number") || hasSchemaType2(requestBody.schema, "boolean")) {
              har.postData.text = JSON.stringify(JSON.parse(cleanBody));
            } else {
              const jsonTypes = getTypedFormatsInSchema("json", requestBodySchema.properties, { payload: cleanBody });
              if (Array.isArray(jsonTypes) && jsonTypes.length) {
                try {
                  jsonTypes.forEach((prop) => {
                    try {
                      set(cleanBody, String(prop), JSON.parse(get(cleanBody, String(prop))));
                    } catch (e) {
                    }
                  });
                  if (typeof cleanBody.RAW_BODY !== "undefined") {
                    cleanBody = cleanBody.RAW_BODY;
                  }
                  har.postData.text = JSON.stringify(cleanBody);
                } catch (e) {
                  har.postData.text = stringify2(formData.body);
                }
              } else {
                har.postData.text = encodeBodyForHAR(formData.body);
              }
            }
          }
        } catch (e) {
          har.postData = { mimeType: contentType, text: stringify2(formData.body) };
        }
      } else {
        har.postData = { mimeType: contentType, text: encodeBodyForHAR(formData.body) };
      }
    }
  }
  if ((har.postData?.text || requestBody && requestBody.schema && Object.keys(requestBody.schema).length) && !hasContentType) {
    har.headers.push({
      name: "content-type",
      value: contentType
    });
  }
  const securityRequirements = operation.getSecurity();
  if (securityRequirements && securityRequirements.length) {
    securityRequirements.forEach((schemes) => {
      Object.keys(schemes).forEach((security) => {
        const securityValue = configureSecurity(apiDefinition, auth, security);
        if (!securityValue) {
          return;
        }
        if (securityValue.value.name === "authorization") {
          if (har[securityValue.type].find((v) => v.name === securityValue.value.name)) {
            return;
          }
        }
        if (har[securityValue.type].find(
          (v) => v.name === securityValue.value.name && v.value === securityValue.value.value
        )) {
          return;
        }
        har[securityValue.type].push(securityValue.value);
      });
    });
  }
  if (Object.keys(har.postData || {}).length === 0) {
    delete har.postData;
  }
  return {
    log: {
      entries: [
        {
          request: har
        }
      ]
    }
  };
}

// node_modules/@readme/oas-to-snippet/dist/index.js
function oasToSnippet(oas, operation, values, auth, lang, opts = {}) {
  let config;
  let language;
  let target;
  const plugins = opts.plugins || [];
  const languages = getSupportedLanguages({
    plugins
  });
  try {
    ({ config, language, target } = getLanguageConfig(languages, lang));
  } catch (err) {
    if (!language || !target) {
      return { code: "", highlightMode: false, install: false };
    }
  }
  if (!config) {
    throw new Error(
      `The supplied language \`${lang.toString()}\` is not supported. If a plugin powers this language please initialize that plugin with the \`plugins\` option.`
    );
  }
  if (!language || !target) {
    return { code: "", highlightMode: false, install: false };
  }
  const har = opts.harOverride || oasToHar(oas, operation, values, auth);
  const snippet2 = new HTTPSnippet(har, {
    // We should only expect HAR's generated with `@readme/oas-to-har` to already be encoded.
    harIsAlreadyEncoded: !opts.harOverride
  });
  let targetOpts = config.httpsnippet.targets[target].opts || {};
  const highlightMode = config.highlight;
  plugins.forEach((plugin) => {
    addClientPlugin(plugin);
    if (plugin.target === "node" && plugin.client.info.key === "api") {
      targetOpts.api = {
        definition: oas ? oas.getDefinition() : null,
        identifier: opts?.openapi?.variableName,
        registryURI: opts?.openapi?.registryIdentifier
      };
    }
  });
  const install = getClientInstallationInstructions(languages, lang, opts?.openapi?.registryIdentifier) || false;
  try {
    const code = snippet2.convert(language, target, targetOpts);
    return {
      code: code ? code[0] : false,
      highlightMode,
      install
    };
  } catch (err) {
    if (language !== "node" && target !== "api") {
      throw err;
    }
    targetOpts = config.httpsnippet.targets.fetch.opts || {};
    const code = snippet2.convert(language, "fetch", targetOpts);
    return {
      code: code ? code[0] : false,
      highlightMode,
      install
    };
  }
}

// src/oas-normalize/index.ts
var import_node_fs = __toESM(require("node:fs"));
var import_openapi_parser = __toESM(require_lib16());
var import_postman_to_openapi = __toESM(require_src4());
var import_swagger2openapi = __toESM(require_swagger2openapi());

// node_modules/js-yaml/dist/js-yaml.mjs
function isNothing(subject) {
  return typeof subject === "undefined" || subject === null;
}
function isObject4(subject) {
  return typeof subject === "object" && subject !== null;
}
function toArray(sequence) {
  if (Array.isArray(sequence)) return sequence;
  else if (isNothing(sequence)) return [];
  return [sequence];
}
function extend2(target, source) {
  var index, length, key, sourceKeys;
  if (source) {
    sourceKeys = Object.keys(source);
    for (index = 0, length = sourceKeys.length; index < length; index += 1) {
      key = sourceKeys[index];
      target[key] = source[key];
    }
  }
  return target;
}
function repeat2(string, count) {
  var result = "", cycle;
  for (cycle = 0; cycle < count; cycle += 1) {
    result += string;
  }
  return result;
}
function isNegativeZero(number) {
  return number === 0 && Number.NEGATIVE_INFINITY === 1 / number;
}
var isNothing_1 = isNothing;
var isObject_1 = isObject4;
var toArray_1 = toArray;
var repeat_1 = repeat2;
var isNegativeZero_1 = isNegativeZero;
var extend_1 = extend2;
var common = {
  isNothing: isNothing_1,
  isObject: isObject_1,
  toArray: toArray_1,
  repeat: repeat_1,
  isNegativeZero: isNegativeZero_1,
  extend: extend_1
};
function formatError(exception2, compact) {
  var where = "", message = exception2.reason || "(unknown reason)";
  if (!exception2.mark) return message;
  if (exception2.mark.name) {
    where += 'in "' + exception2.mark.name + '" ';
  }
  where += "(" + (exception2.mark.line + 1) + ":" + (exception2.mark.column + 1) + ")";
  if (!compact && exception2.mark.snippet) {
    where += "\n\n" + exception2.mark.snippet;
  }
  return message + " " + where;
}
function YAMLException$1(reason, mark) {
  Error.call(this);
  this.name = "YAMLException";
  this.reason = reason;
  this.mark = mark;
  this.message = formatError(this, false);
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, this.constructor);
  } else {
    this.stack = new Error().stack || "";
  }
}
YAMLException$1.prototype = Object.create(Error.prototype);
YAMLException$1.prototype.constructor = YAMLException$1;
YAMLException$1.prototype.toString = function toString(compact) {
  return this.name + ": " + formatError(this, compact);
};
var exception = YAMLException$1;
function getLine(buffer, lineStart, lineEnd, position, maxLineLength) {
  var head = "";
  var tail = "";
  var maxHalfLength = Math.floor(maxLineLength / 2) - 1;
  if (position - lineStart > maxHalfLength) {
    head = " ... ";
    lineStart = position - maxHalfLength + head.length;
  }
  if (lineEnd - position > maxHalfLength) {
    tail = " ...";
    lineEnd = position + maxHalfLength - tail.length;
  }
  return {
    str: head + buffer.slice(lineStart, lineEnd).replace(/\t/g, "\u2192") + tail,
    pos: position - lineStart + head.length
    // relative position
  };
}
function padStart(string, max) {
  return common.repeat(" ", max - string.length) + string;
}
function makeSnippet(mark, options) {
  options = Object.create(options || null);
  if (!mark.buffer) return null;
  if (!options.maxLength) options.maxLength = 79;
  if (typeof options.indent !== "number") options.indent = 1;
  if (typeof options.linesBefore !== "number") options.linesBefore = 3;
  if (typeof options.linesAfter !== "number") options.linesAfter = 2;
  var re = /\r?\n|\r|\0/g;
  var lineStarts = [0];
  var lineEnds = [];
  var match2;
  var foundLineNo = -1;
  while (match2 = re.exec(mark.buffer)) {
    lineEnds.push(match2.index);
    lineStarts.push(match2.index + match2[0].length);
    if (mark.position <= match2.index && foundLineNo < 0) {
      foundLineNo = lineStarts.length - 2;
    }
  }
  if (foundLineNo < 0) foundLineNo = lineStarts.length - 1;
  var result = "", i, line;
  var lineNoLength = Math.min(mark.line + options.linesAfter, lineEnds.length).toString().length;
  var maxLineLength = options.maxLength - (options.indent + lineNoLength + 3);
  for (i = 1; i <= options.linesBefore; i++) {
    if (foundLineNo - i < 0) break;
    line = getLine(
      mark.buffer,
      lineStarts[foundLineNo - i],
      lineEnds[foundLineNo - i],
      mark.position - (lineStarts[foundLineNo] - lineStarts[foundLineNo - i]),
      maxLineLength
    );
    result = common.repeat(" ", options.indent) + padStart((mark.line - i + 1).toString(), lineNoLength) + " | " + line.str + "\n" + result;
  }
  line = getLine(mark.buffer, lineStarts[foundLineNo], lineEnds[foundLineNo], mark.position, maxLineLength);
  result += common.repeat(" ", options.indent) + padStart((mark.line + 1).toString(), lineNoLength) + " | " + line.str + "\n";
  result += common.repeat("-", options.indent + lineNoLength + 3 + line.pos) + "^\n";
  for (i = 1; i <= options.linesAfter; i++) {
    if (foundLineNo + i >= lineEnds.length) break;
    line = getLine(
      mark.buffer,
      lineStarts[foundLineNo + i],
      lineEnds[foundLineNo + i],
      mark.position - (lineStarts[foundLineNo] - lineStarts[foundLineNo + i]),
      maxLineLength
    );
    result += common.repeat(" ", options.indent) + padStart((mark.line + i + 1).toString(), lineNoLength) + " | " + line.str + "\n";
  }
  return result.replace(/\n$/, "");
}
var snippet = makeSnippet;
var TYPE_CONSTRUCTOR_OPTIONS = [
  "kind",
  "multi",
  "resolve",
  "construct",
  "instanceOf",
  "predicate",
  "represent",
  "representName",
  "defaultStyle",
  "styleAliases"
];
var YAML_NODE_KINDS = [
  "scalar",
  "sequence",
  "mapping"
];
function compileStyleAliases(map2) {
  var result = {};
  if (map2 !== null) {
    Object.keys(map2).forEach(function(style) {
      map2[style].forEach(function(alias) {
        result[String(alias)] = style;
      });
    });
  }
  return result;
}
function Type$1(tag, options) {
  options = options || {};
  Object.keys(options).forEach(function(name) {
    if (TYPE_CONSTRUCTOR_OPTIONS.indexOf(name) === -1) {
      throw new exception('Unknown option "' + name + '" is met in definition of "' + tag + '" YAML type.');
    }
  });
  this.options = options;
  this.tag = tag;
  this.kind = options["kind"] || null;
  this.resolve = options["resolve"] || function() {
    return true;
  };
  this.construct = options["construct"] || function(data) {
    return data;
  };
  this.instanceOf = options["instanceOf"] || null;
  this.predicate = options["predicate"] || null;
  this.represent = options["represent"] || null;
  this.representName = options["representName"] || null;
  this.defaultStyle = options["defaultStyle"] || null;
  this.multi = options["multi"] || false;
  this.styleAliases = compileStyleAliases(options["styleAliases"] || null);
  if (YAML_NODE_KINDS.indexOf(this.kind) === -1) {
    throw new exception('Unknown kind "' + this.kind + '" is specified for "' + tag + '" YAML type.');
  }
}
var type = Type$1;
function compileList(schema2, name) {
  var result = [];
  schema2[name].forEach(function(currentType) {
    var newIndex = result.length;
    result.forEach(function(previousType, previousIndex) {
      if (previousType.tag === currentType.tag && previousType.kind === currentType.kind && previousType.multi === currentType.multi) {
        newIndex = previousIndex;
      }
    });
    result[newIndex] = currentType;
  });
  return result;
}
function compileMap() {
  var result = {
    scalar: {},
    sequence: {},
    mapping: {},
    fallback: {},
    multi: {
      scalar: [],
      sequence: [],
      mapping: [],
      fallback: []
    }
  }, index, length;
  function collectType(type2) {
    if (type2.multi) {
      result.multi[type2.kind].push(type2);
      result.multi["fallback"].push(type2);
    } else {
      result[type2.kind][type2.tag] = result["fallback"][type2.tag] = type2;
    }
  }
  for (index = 0, length = arguments.length; index < length; index += 1) {
    arguments[index].forEach(collectType);
  }
  return result;
}
function Schema$1(definition) {
  return this.extend(definition);
}
Schema$1.prototype.extend = function extend3(definition) {
  var implicit = [];
  var explicit = [];
  if (definition instanceof type) {
    explicit.push(definition);
  } else if (Array.isArray(definition)) {
    explicit = explicit.concat(definition);
  } else if (definition && (Array.isArray(definition.implicit) || Array.isArray(definition.explicit))) {
    if (definition.implicit) implicit = implicit.concat(definition.implicit);
    if (definition.explicit) explicit = explicit.concat(definition.explicit);
  } else {
    throw new exception("Schema.extend argument should be a Type, [ Type ], or a schema definition ({ implicit: [...], explicit: [...] })");
  }
  implicit.forEach(function(type$1) {
    if (!(type$1 instanceof type)) {
      throw new exception("Specified list of YAML types (or a single Type object) contains a non-Type object.");
    }
    if (type$1.loadKind && type$1.loadKind !== "scalar") {
      throw new exception("There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.");
    }
    if (type$1.multi) {
      throw new exception("There is a multi type in the implicit list of a schema. Multi tags can only be listed as explicit.");
    }
  });
  explicit.forEach(function(type$1) {
    if (!(type$1 instanceof type)) {
      throw new exception("Specified list of YAML types (or a single Type object) contains a non-Type object.");
    }
  });
  var result = Object.create(Schema$1.prototype);
  result.implicit = (this.implicit || []).concat(implicit);
  result.explicit = (this.explicit || []).concat(explicit);
  result.compiledImplicit = compileList(result, "implicit");
  result.compiledExplicit = compileList(result, "explicit");
  result.compiledTypeMap = compileMap(result.compiledImplicit, result.compiledExplicit);
  return result;
};
var schema = Schema$1;
var str = new type("tag:yaml.org,2002:str", {
  kind: "scalar",
  construct: function(data) {
    return data !== null ? data : "";
  }
});
var seq = new type("tag:yaml.org,2002:seq", {
  kind: "sequence",
  construct: function(data) {
    return data !== null ? data : [];
  }
});
var map = new type("tag:yaml.org,2002:map", {
  kind: "mapping",
  construct: function(data) {
    return data !== null ? data : {};
  }
});
var failsafe = new schema({
  explicit: [
    str,
    seq,
    map
  ]
});
function resolveYamlNull(data) {
  if (data === null) return true;
  var max = data.length;
  return max === 1 && data === "~" || max === 4 && (data === "null" || data === "Null" || data === "NULL");
}
function constructYamlNull() {
  return null;
}
function isNull(object) {
  return object === null;
}
var _null = new type("tag:yaml.org,2002:null", {
  kind: "scalar",
  resolve: resolveYamlNull,
  construct: constructYamlNull,
  predicate: isNull,
  represent: {
    canonical: function() {
      return "~";
    },
    lowercase: function() {
      return "null";
    },
    uppercase: function() {
      return "NULL";
    },
    camelcase: function() {
      return "Null";
    },
    empty: function() {
      return "";
    }
  },
  defaultStyle: "lowercase"
});
function resolveYamlBoolean(data) {
  if (data === null) return false;
  var max = data.length;
  return max === 4 && (data === "true" || data === "True" || data === "TRUE") || max === 5 && (data === "false" || data === "False" || data === "FALSE");
}
function constructYamlBoolean(data) {
  return data === "true" || data === "True" || data === "TRUE";
}
function isBoolean(object) {
  return Object.prototype.toString.call(object) === "[object Boolean]";
}
var bool = new type("tag:yaml.org,2002:bool", {
  kind: "scalar",
  resolve: resolveYamlBoolean,
  construct: constructYamlBoolean,
  predicate: isBoolean,
  represent: {
    lowercase: function(object) {
      return object ? "true" : "false";
    },
    uppercase: function(object) {
      return object ? "TRUE" : "FALSE";
    },
    camelcase: function(object) {
      return object ? "True" : "False";
    }
  },
  defaultStyle: "lowercase"
});
function isHexCode(c2) {
  return 48 <= c2 && c2 <= 57 || 65 <= c2 && c2 <= 70 || 97 <= c2 && c2 <= 102;
}
function isOctCode(c2) {
  return 48 <= c2 && c2 <= 55;
}
function isDecCode(c2) {
  return 48 <= c2 && c2 <= 57;
}
function resolveYamlInteger(data) {
  if (data === null) return false;
  var max = data.length, index = 0, hasDigits = false, ch;
  if (!max) return false;
  ch = data[index];
  if (ch === "-" || ch === "+") {
    ch = data[++index];
  }
  if (ch === "0") {
    if (index + 1 === max) return true;
    ch = data[++index];
    if (ch === "b") {
      index++;
      for (; index < max; index++) {
        ch = data[index];
        if (ch === "_") continue;
        if (ch !== "0" && ch !== "1") return false;
        hasDigits = true;
      }
      return hasDigits && ch !== "_";
    }
    if (ch === "x") {
      index++;
      for (; index < max; index++) {
        ch = data[index];
        if (ch === "_") continue;
        if (!isHexCode(data.charCodeAt(index))) return false;
        hasDigits = true;
      }
      return hasDigits && ch !== "_";
    }
    if (ch === "o") {
      index++;
      for (; index < max; index++) {
        ch = data[index];
        if (ch === "_") continue;
        if (!isOctCode(data.charCodeAt(index))) return false;
        hasDigits = true;
      }
      return hasDigits && ch !== "_";
    }
  }
  if (ch === "_") return false;
  for (; index < max; index++) {
    ch = data[index];
    if (ch === "_") continue;
    if (!isDecCode(data.charCodeAt(index))) {
      return false;
    }
    hasDigits = true;
  }
  if (!hasDigits || ch === "_") return false;
  return true;
}
function constructYamlInteger(data) {
  var value = data, sign = 1, ch;
  if (value.indexOf("_") !== -1) {
    value = value.replace(/_/g, "");
  }
  ch = value[0];
  if (ch === "-" || ch === "+") {
    if (ch === "-") sign = -1;
    value = value.slice(1);
    ch = value[0];
  }
  if (value === "0") return 0;
  if (ch === "0") {
    if (value[1] === "b") return sign * parseInt(value.slice(2), 2);
    if (value[1] === "x") return sign * parseInt(value.slice(2), 16);
    if (value[1] === "o") return sign * parseInt(value.slice(2), 8);
  }
  return sign * parseInt(value, 10);
}
function isInteger(object) {
  return Object.prototype.toString.call(object) === "[object Number]" && (object % 1 === 0 && !common.isNegativeZero(object));
}
var int = new type("tag:yaml.org,2002:int", {
  kind: "scalar",
  resolve: resolveYamlInteger,
  construct: constructYamlInteger,
  predicate: isInteger,
  represent: {
    binary: function(obj) {
      return obj >= 0 ? "0b" + obj.toString(2) : "-0b" + obj.toString(2).slice(1);
    },
    octal: function(obj) {
      return obj >= 0 ? "0o" + obj.toString(8) : "-0o" + obj.toString(8).slice(1);
    },
    decimal: function(obj) {
      return obj.toString(10);
    },
    /* eslint-disable max-len */
    hexadecimal: function(obj) {
      return obj >= 0 ? "0x" + obj.toString(16).toUpperCase() : "-0x" + obj.toString(16).toUpperCase().slice(1);
    }
  },
  defaultStyle: "decimal",
  styleAliases: {
    binary: [2, "bin"],
    octal: [8, "oct"],
    decimal: [10, "dec"],
    hexadecimal: [16, "hex"]
  }
});
var YAML_FLOAT_PATTERN = new RegExp(
  // 2.5e4, 2.5 and integers
  "^(?:[-+]?(?:[0-9][0-9_]*)(?:\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?|\\.[0-9_]+(?:[eE][-+]?[0-9]+)?|[-+]?\\.(?:inf|Inf|INF)|\\.(?:nan|NaN|NAN))$"
);
function resolveYamlFloat(data) {
  if (data === null) return false;
  if (!YAML_FLOAT_PATTERN.test(data) || // Quick hack to not allow integers end with `_`
  // Probably should update regexp & check speed
  data[data.length - 1] === "_") {
    return false;
  }
  return true;
}
function constructYamlFloat(data) {
  var value, sign;
  value = data.replace(/_/g, "").toLowerCase();
  sign = value[0] === "-" ? -1 : 1;
  if ("+-".indexOf(value[0]) >= 0) {
    value = value.slice(1);
  }
  if (value === ".inf") {
    return sign === 1 ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;
  } else if (value === ".nan") {
    return NaN;
  }
  return sign * parseFloat(value, 10);
}
var SCIENTIFIC_WITHOUT_DOT = /^[-+]?[0-9]+e/;
function representYamlFloat(object, style) {
  var res;
  if (isNaN(object)) {
    switch (style) {
      case "lowercase":
        return ".nan";
      case "uppercase":
        return ".NAN";
      case "camelcase":
        return ".NaN";
    }
  } else if (Number.POSITIVE_INFINITY === object) {
    switch (style) {
      case "lowercase":
        return ".inf";
      case "uppercase":
        return ".INF";
      case "camelcase":
        return ".Inf";
    }
  } else if (Number.NEGATIVE_INFINITY === object) {
    switch (style) {
      case "lowercase":
        return "-.inf";
      case "uppercase":
        return "-.INF";
      case "camelcase":
        return "-.Inf";
    }
  } else if (common.isNegativeZero(object)) {
    return "-0.0";
  }
  res = object.toString(10);
  return SCIENTIFIC_WITHOUT_DOT.test(res) ? res.replace("e", ".e") : res;
}
function isFloat(object) {
  return Object.prototype.toString.call(object) === "[object Number]" && (object % 1 !== 0 || common.isNegativeZero(object));
}
var float = new type("tag:yaml.org,2002:float", {
  kind: "scalar",
  resolve: resolveYamlFloat,
  construct: constructYamlFloat,
  predicate: isFloat,
  represent: representYamlFloat,
  defaultStyle: "lowercase"
});
var json2 = failsafe.extend({
  implicit: [
    _null,
    bool,
    int,
    float
  ]
});
var core = json2;
var YAML_DATE_REGEXP = new RegExp(
  "^([0-9][0-9][0-9][0-9])-([0-9][0-9])-([0-9][0-9])$"
);
var YAML_TIMESTAMP_REGEXP = new RegExp(
  "^([0-9][0-9][0-9][0-9])-([0-9][0-9]?)-([0-9][0-9]?)(?:[Tt]|[ \\t]+)([0-9][0-9]?):([0-9][0-9]):([0-9][0-9])(?:\\.([0-9]*))?(?:[ \\t]*(Z|([-+])([0-9][0-9]?)(?::([0-9][0-9]))?))?$"
);
function resolveYamlTimestamp(data) {
  if (data === null) return false;
  if (YAML_DATE_REGEXP.exec(data) !== null) return true;
  if (YAML_TIMESTAMP_REGEXP.exec(data) !== null) return true;
  return false;
}
function constructYamlTimestamp(data) {
  var match2, year, month, day, hour, minute, second, fraction = 0, delta = null, tz_hour, tz_minute, date;
  match2 = YAML_DATE_REGEXP.exec(data);
  if (match2 === null) match2 = YAML_TIMESTAMP_REGEXP.exec(data);
  if (match2 === null) throw new Error("Date resolve error");
  year = +match2[1];
  month = +match2[2] - 1;
  day = +match2[3];
  if (!match2[4]) {
    return new Date(Date.UTC(year, month, day));
  }
  hour = +match2[4];
  minute = +match2[5];
  second = +match2[6];
  if (match2[7]) {
    fraction = match2[7].slice(0, 3);
    while (fraction.length < 3) {
      fraction += "0";
    }
    fraction = +fraction;
  }
  if (match2[9]) {
    tz_hour = +match2[10];
    tz_minute = +(match2[11] || 0);
    delta = (tz_hour * 60 + tz_minute) * 6e4;
    if (match2[9] === "-") delta = -delta;
  }
  date = new Date(Date.UTC(year, month, day, hour, minute, second, fraction));
  if (delta) date.setTime(date.getTime() - delta);
  return date;
}
function representYamlTimestamp(object) {
  return object.toISOString();
}
var timestamp = new type("tag:yaml.org,2002:timestamp", {
  kind: "scalar",
  resolve: resolveYamlTimestamp,
  construct: constructYamlTimestamp,
  instanceOf: Date,
  represent: representYamlTimestamp
});
function resolveYamlMerge(data) {
  return data === "<<" || data === null;
}
var merge = new type("tag:yaml.org,2002:merge", {
  kind: "scalar",
  resolve: resolveYamlMerge
});
var BASE64_MAP = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\n\r";
function resolveYamlBinary(data) {
  if (data === null) return false;
  var code, idx, bitlen = 0, max = data.length, map2 = BASE64_MAP;
  for (idx = 0; idx < max; idx++) {
    code = map2.indexOf(data.charAt(idx));
    if (code > 64) continue;
    if (code < 0) return false;
    bitlen += 6;
  }
  return bitlen % 8 === 0;
}
function constructYamlBinary(data) {
  var idx, tailbits, input = data.replace(/[\r\n=]/g, ""), max = input.length, map2 = BASE64_MAP, bits = 0, result = [];
  for (idx = 0; idx < max; idx++) {
    if (idx % 4 === 0 && idx) {
      result.push(bits >> 16 & 255);
      result.push(bits >> 8 & 255);
      result.push(bits & 255);
    }
    bits = bits << 6 | map2.indexOf(input.charAt(idx));
  }
  tailbits = max % 4 * 6;
  if (tailbits === 0) {
    result.push(bits >> 16 & 255);
    result.push(bits >> 8 & 255);
    result.push(bits & 255);
  } else if (tailbits === 18) {
    result.push(bits >> 10 & 255);
    result.push(bits >> 2 & 255);
  } else if (tailbits === 12) {
    result.push(bits >> 4 & 255);
  }
  return new Uint8Array(result);
}
function representYamlBinary(object) {
  var result = "", bits = 0, idx, tail, max = object.length, map2 = BASE64_MAP;
  for (idx = 0; idx < max; idx++) {
    if (idx % 3 === 0 && idx) {
      result += map2[bits >> 18 & 63];
      result += map2[bits >> 12 & 63];
      result += map2[bits >> 6 & 63];
      result += map2[bits & 63];
    }
    bits = (bits << 8) + object[idx];
  }
  tail = max % 3;
  if (tail === 0) {
    result += map2[bits >> 18 & 63];
    result += map2[bits >> 12 & 63];
    result += map2[bits >> 6 & 63];
    result += map2[bits & 63];
  } else if (tail === 2) {
    result += map2[bits >> 10 & 63];
    result += map2[bits >> 4 & 63];
    result += map2[bits << 2 & 63];
    result += map2[64];
  } else if (tail === 1) {
    result += map2[bits >> 2 & 63];
    result += map2[bits << 4 & 63];
    result += map2[64];
    result += map2[64];
  }
  return result;
}
function isBinary(obj) {
  return Object.prototype.toString.call(obj) === "[object Uint8Array]";
}
var binary = new type("tag:yaml.org,2002:binary", {
  kind: "scalar",
  resolve: resolveYamlBinary,
  construct: constructYamlBinary,
  predicate: isBinary,
  represent: representYamlBinary
});
var _hasOwnProperty$3 = Object.prototype.hasOwnProperty;
var _toString$2 = Object.prototype.toString;
function resolveYamlOmap(data) {
  if (data === null) return true;
  var objectKeys = [], index, length, pair, pairKey, pairHasKey, object = data;
  for (index = 0, length = object.length; index < length; index += 1) {
    pair = object[index];
    pairHasKey = false;
    if (_toString$2.call(pair) !== "[object Object]") return false;
    for (pairKey in pair) {
      if (_hasOwnProperty$3.call(pair, pairKey)) {
        if (!pairHasKey) pairHasKey = true;
        else return false;
      }
    }
    if (!pairHasKey) return false;
    if (objectKeys.indexOf(pairKey) === -1) objectKeys.push(pairKey);
    else return false;
  }
  return true;
}
function constructYamlOmap(data) {
  return data !== null ? data : [];
}
var omap = new type("tag:yaml.org,2002:omap", {
  kind: "sequence",
  resolve: resolveYamlOmap,
  construct: constructYamlOmap
});
var _toString$1 = Object.prototype.toString;
function resolveYamlPairs(data) {
  if (data === null) return true;
  var index, length, pair, keys, result, object = data;
  result = new Array(object.length);
  for (index = 0, length = object.length; index < length; index += 1) {
    pair = object[index];
    if (_toString$1.call(pair) !== "[object Object]") return false;
    keys = Object.keys(pair);
    if (keys.length !== 1) return false;
    result[index] = [keys[0], pair[keys[0]]];
  }
  return true;
}
function constructYamlPairs(data) {
  if (data === null) return [];
  var index, length, pair, keys, result, object = data;
  result = new Array(object.length);
  for (index = 0, length = object.length; index < length; index += 1) {
    pair = object[index];
    keys = Object.keys(pair);
    result[index] = [keys[0], pair[keys[0]]];
  }
  return result;
}
var pairs = new type("tag:yaml.org,2002:pairs", {
  kind: "sequence",
  resolve: resolveYamlPairs,
  construct: constructYamlPairs
});
var _hasOwnProperty$2 = Object.prototype.hasOwnProperty;
function resolveYamlSet(data) {
  if (data === null) return true;
  var key, object = data;
  for (key in object) {
    if (_hasOwnProperty$2.call(object, key)) {
      if (object[key] !== null) return false;
    }
  }
  return true;
}
function constructYamlSet(data) {
  return data !== null ? data : {};
}
var set2 = new type("tag:yaml.org,2002:set", {
  kind: "mapping",
  resolve: resolveYamlSet,
  construct: constructYamlSet
});
var _default = core.extend({
  implicit: [
    timestamp,
    merge
  ],
  explicit: [
    binary,
    omap,
    pairs,
    set2
  ]
});
var _hasOwnProperty$1 = Object.prototype.hasOwnProperty;
var CONTEXT_FLOW_IN = 1;
var CONTEXT_FLOW_OUT = 2;
var CONTEXT_BLOCK_IN = 3;
var CONTEXT_BLOCK_OUT = 4;
var CHOMPING_CLIP = 1;
var CHOMPING_STRIP = 2;
var CHOMPING_KEEP = 3;
var PATTERN_NON_PRINTABLE = /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
var PATTERN_NON_ASCII_LINE_BREAKS = /[\x85\u2028\u2029]/;
var PATTERN_FLOW_INDICATORS = /[,\[\]\{\}]/;
var PATTERN_TAG_HANDLE = /^(?:!|!!|![a-z\-]+!)$/i;
var PATTERN_TAG_URI = /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;
function _class(obj) {
  return Object.prototype.toString.call(obj);
}
function is_EOL(c2) {
  return c2 === 10 || c2 === 13;
}
function is_WHITE_SPACE(c2) {
  return c2 === 9 || c2 === 32;
}
function is_WS_OR_EOL(c2) {
  return c2 === 9 || c2 === 32 || c2 === 10 || c2 === 13;
}
function is_FLOW_INDICATOR(c2) {
  return c2 === 44 || c2 === 91 || c2 === 93 || c2 === 123 || c2 === 125;
}
function fromHexCode(c2) {
  var lc;
  if (48 <= c2 && c2 <= 57) {
    return c2 - 48;
  }
  lc = c2 | 32;
  if (97 <= lc && lc <= 102) {
    return lc - 97 + 10;
  }
  return -1;
}
function escapedHexLen(c2) {
  if (c2 === 120) {
    return 2;
  }
  if (c2 === 117) {
    return 4;
  }
  if (c2 === 85) {
    return 8;
  }
  return 0;
}
function fromDecimalCode(c2) {
  if (48 <= c2 && c2 <= 57) {
    return c2 - 48;
  }
  return -1;
}
function simpleEscapeSequence(c2) {
  return c2 === 48 ? "\0" : c2 === 97 ? "\x07" : c2 === 98 ? "\b" : c2 === 116 ? "	" : c2 === 9 ? "	" : c2 === 110 ? "\n" : c2 === 118 ? "\v" : c2 === 102 ? "\f" : c2 === 114 ? "\r" : c2 === 101 ? "\x1B" : c2 === 32 ? " " : c2 === 34 ? '"' : c2 === 47 ? "/" : c2 === 92 ? "\\" : c2 === 78 ? "\x85" : c2 === 95 ? "\xA0" : c2 === 76 ? "\u2028" : c2 === 80 ? "\u2029" : "";
}
function charFromCodepoint(c2) {
  if (c2 <= 65535) {
    return String.fromCharCode(c2);
  }
  return String.fromCharCode(
    (c2 - 65536 >> 10) + 55296,
    (c2 - 65536 & 1023) + 56320
  );
}
var simpleEscapeCheck = new Array(256);
var simpleEscapeMap = new Array(256);
for (i = 0; i < 256; i++) {
  simpleEscapeCheck[i] = simpleEscapeSequence(i) ? 1 : 0;
  simpleEscapeMap[i] = simpleEscapeSequence(i);
}
var i;
function State$1(input, options) {
  this.input = input;
  this.filename = options["filename"] || null;
  this.schema = options["schema"] || _default;
  this.onWarning = options["onWarning"] || null;
  this.legacy = options["legacy"] || false;
  this.json = options["json"] || false;
  this.listener = options["listener"] || null;
  this.implicitTypes = this.schema.compiledImplicit;
  this.typeMap = this.schema.compiledTypeMap;
  this.length = input.length;
  this.position = 0;
  this.line = 0;
  this.lineStart = 0;
  this.lineIndent = 0;
  this.firstTabInLine = -1;
  this.documents = [];
}
function generateError(state, message) {
  var mark = {
    name: state.filename,
    buffer: state.input.slice(0, -1),
    // omit trailing \0
    position: state.position,
    line: state.line,
    column: state.position - state.lineStart
  };
  mark.snippet = snippet(mark);
  return new exception(message, mark);
}
function throwError(state, message) {
  throw generateError(state, message);
}
function throwWarning(state, message) {
  if (state.onWarning) {
    state.onWarning.call(null, generateError(state, message));
  }
}
var directiveHandlers = {
  YAML: function handleYamlDirective(state, name, args) {
    var match2, major, minor;
    if (state.version !== null) {
      throwError(state, "duplication of %YAML directive");
    }
    if (args.length !== 1) {
      throwError(state, "YAML directive accepts exactly one argument");
    }
    match2 = /^([0-9]+)\.([0-9]+)$/.exec(args[0]);
    if (match2 === null) {
      throwError(state, "ill-formed argument of the YAML directive");
    }
    major = parseInt(match2[1], 10);
    minor = parseInt(match2[2], 10);
    if (major !== 1) {
      throwError(state, "unacceptable YAML version of the document");
    }
    state.version = args[0];
    state.checkLineBreaks = minor < 2;
    if (minor !== 1 && minor !== 2) {
      throwWarning(state, "unsupported YAML version of the document");
    }
  },
  TAG: function handleTagDirective(state, name, args) {
    var handle, prefix;
    if (args.length !== 2) {
      throwError(state, "TAG directive accepts exactly two arguments");
    }
    handle = args[0];
    prefix = args[1];
    if (!PATTERN_TAG_HANDLE.test(handle)) {
      throwError(state, "ill-formed tag handle (first argument) of the TAG directive");
    }
    if (_hasOwnProperty$1.call(state.tagMap, handle)) {
      throwError(state, 'there is a previously declared suffix for "' + handle + '" tag handle');
    }
    if (!PATTERN_TAG_URI.test(prefix)) {
      throwError(state, "ill-formed tag prefix (second argument) of the TAG directive");
    }
    try {
      prefix = decodeURIComponent(prefix);
    } catch (err) {
      throwError(state, "tag prefix is malformed: " + prefix);
    }
    state.tagMap[handle] = prefix;
  }
};
function captureSegment(state, start, end, checkJson) {
  var _position, _length, _character, _result;
  if (start < end) {
    _result = state.input.slice(start, end);
    if (checkJson) {
      for (_position = 0, _length = _result.length; _position < _length; _position += 1) {
        _character = _result.charCodeAt(_position);
        if (!(_character === 9 || 32 <= _character && _character <= 1114111)) {
          throwError(state, "expected valid JSON character");
        }
      }
    } else if (PATTERN_NON_PRINTABLE.test(_result)) {
      throwError(state, "the stream contains non-printable characters");
    }
    state.result += _result;
  }
}
function mergeMappings(state, destination, source, overridableKeys) {
  var sourceKeys, key, index, quantity;
  if (!common.isObject(source)) {
    throwError(state, "cannot merge mappings; the provided source object is unacceptable");
  }
  sourceKeys = Object.keys(source);
  for (index = 0, quantity = sourceKeys.length; index < quantity; index += 1) {
    key = sourceKeys[index];
    if (!_hasOwnProperty$1.call(destination, key)) {
      destination[key] = source[key];
      overridableKeys[key] = true;
    }
  }
}
function storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, startLine, startLineStart, startPos) {
  var index, quantity;
  if (Array.isArray(keyNode)) {
    keyNode = Array.prototype.slice.call(keyNode);
    for (index = 0, quantity = keyNode.length; index < quantity; index += 1) {
      if (Array.isArray(keyNode[index])) {
        throwError(state, "nested arrays are not supported inside keys");
      }
      if (typeof keyNode === "object" && _class(keyNode[index]) === "[object Object]") {
        keyNode[index] = "[object Object]";
      }
    }
  }
  if (typeof keyNode === "object" && _class(keyNode) === "[object Object]") {
    keyNode = "[object Object]";
  }
  keyNode = String(keyNode);
  if (_result === null) {
    _result = {};
  }
  if (keyTag === "tag:yaml.org,2002:merge") {
    if (Array.isArray(valueNode)) {
      for (index = 0, quantity = valueNode.length; index < quantity; index += 1) {
        mergeMappings(state, _result, valueNode[index], overridableKeys);
      }
    } else {
      mergeMappings(state, _result, valueNode, overridableKeys);
    }
  } else {
    if (!state.json && !_hasOwnProperty$1.call(overridableKeys, keyNode) && _hasOwnProperty$1.call(_result, keyNode)) {
      state.line = startLine || state.line;
      state.lineStart = startLineStart || state.lineStart;
      state.position = startPos || state.position;
      throwError(state, "duplicated mapping key");
    }
    if (keyNode === "__proto__") {
      Object.defineProperty(_result, keyNode, {
        configurable: true,
        enumerable: true,
        writable: true,
        value: valueNode
      });
    } else {
      _result[keyNode] = valueNode;
    }
    delete overridableKeys[keyNode];
  }
  return _result;
}
function readLineBreak(state) {
  var ch;
  ch = state.input.charCodeAt(state.position);
  if (ch === 10) {
    state.position++;
  } else if (ch === 13) {
    state.position++;
    if (state.input.charCodeAt(state.position) === 10) {
      state.position++;
    }
  } else {
    throwError(state, "a line break is expected");
  }
  state.line += 1;
  state.lineStart = state.position;
  state.firstTabInLine = -1;
}
function skipSeparationSpace(state, allowComments, checkIndent) {
  var lineBreaks = 0, ch = state.input.charCodeAt(state.position);
  while (ch !== 0) {
    while (is_WHITE_SPACE(ch)) {
      if (ch === 9 && state.firstTabInLine === -1) {
        state.firstTabInLine = state.position;
      }
      ch = state.input.charCodeAt(++state.position);
    }
    if (allowComments && ch === 35) {
      do {
        ch = state.input.charCodeAt(++state.position);
      } while (ch !== 10 && ch !== 13 && ch !== 0);
    }
    if (is_EOL(ch)) {
      readLineBreak(state);
      ch = state.input.charCodeAt(state.position);
      lineBreaks++;
      state.lineIndent = 0;
      while (ch === 32) {
        state.lineIndent++;
        ch = state.input.charCodeAt(++state.position);
      }
    } else {
      break;
    }
  }
  if (checkIndent !== -1 && lineBreaks !== 0 && state.lineIndent < checkIndent) {
    throwWarning(state, "deficient indentation");
  }
  return lineBreaks;
}
function testDocumentSeparator(state) {
  var _position = state.position, ch;
  ch = state.input.charCodeAt(_position);
  if ((ch === 45 || ch === 46) && ch === state.input.charCodeAt(_position + 1) && ch === state.input.charCodeAt(_position + 2)) {
    _position += 3;
    ch = state.input.charCodeAt(_position);
    if (ch === 0 || is_WS_OR_EOL(ch)) {
      return true;
    }
  }
  return false;
}
function writeFoldedLines(state, count) {
  if (count === 1) {
    state.result += " ";
  } else if (count > 1) {
    state.result += common.repeat("\n", count - 1);
  }
}
function readPlainScalar(state, nodeIndent, withinFlowCollection) {
  var preceding, following, captureStart, captureEnd, hasPendingContent, _line, _lineStart, _lineIndent, _kind = state.kind, _result = state.result, ch;
  ch = state.input.charCodeAt(state.position);
  if (is_WS_OR_EOL(ch) || is_FLOW_INDICATOR(ch) || ch === 35 || ch === 38 || ch === 42 || ch === 33 || ch === 124 || ch === 62 || ch === 39 || ch === 34 || ch === 37 || ch === 64 || ch === 96) {
    return false;
  }
  if (ch === 63 || ch === 45) {
    following = state.input.charCodeAt(state.position + 1);
    if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {
      return false;
    }
  }
  state.kind = "scalar";
  state.result = "";
  captureStart = captureEnd = state.position;
  hasPendingContent = false;
  while (ch !== 0) {
    if (ch === 58) {
      following = state.input.charCodeAt(state.position + 1);
      if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {
        break;
      }
    } else if (ch === 35) {
      preceding = state.input.charCodeAt(state.position - 1);
      if (is_WS_OR_EOL(preceding)) {
        break;
      }
    } else if (state.position === state.lineStart && testDocumentSeparator(state) || withinFlowCollection && is_FLOW_INDICATOR(ch)) {
      break;
    } else if (is_EOL(ch)) {
      _line = state.line;
      _lineStart = state.lineStart;
      _lineIndent = state.lineIndent;
      skipSeparationSpace(state, false, -1);
      if (state.lineIndent >= nodeIndent) {
        hasPendingContent = true;
        ch = state.input.charCodeAt(state.position);
        continue;
      } else {
        state.position = captureEnd;
        state.line = _line;
        state.lineStart = _lineStart;
        state.lineIndent = _lineIndent;
        break;
      }
    }
    if (hasPendingContent) {
      captureSegment(state, captureStart, captureEnd, false);
      writeFoldedLines(state, state.line - _line);
      captureStart = captureEnd = state.position;
      hasPendingContent = false;
    }
    if (!is_WHITE_SPACE(ch)) {
      captureEnd = state.position + 1;
    }
    ch = state.input.charCodeAt(++state.position);
  }
  captureSegment(state, captureStart, captureEnd, false);
  if (state.result) {
    return true;
  }
  state.kind = _kind;
  state.result = _result;
  return false;
}
function readSingleQuotedScalar(state, nodeIndent) {
  var ch, captureStart, captureEnd;
  ch = state.input.charCodeAt(state.position);
  if (ch !== 39) {
    return false;
  }
  state.kind = "scalar";
  state.result = "";
  state.position++;
  captureStart = captureEnd = state.position;
  while ((ch = state.input.charCodeAt(state.position)) !== 0) {
    if (ch === 39) {
      captureSegment(state, captureStart, state.position, true);
      ch = state.input.charCodeAt(++state.position);
      if (ch === 39) {
        captureStart = state.position;
        state.position++;
        captureEnd = state.position;
      } else {
        return true;
      }
    } else if (is_EOL(ch)) {
      captureSegment(state, captureStart, captureEnd, true);
      writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
      captureStart = captureEnd = state.position;
    } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
      throwError(state, "unexpected end of the document within a single quoted scalar");
    } else {
      state.position++;
      captureEnd = state.position;
    }
  }
  throwError(state, "unexpected end of the stream within a single quoted scalar");
}
function readDoubleQuotedScalar(state, nodeIndent) {
  var captureStart, captureEnd, hexLength, hexResult, tmp, ch;
  ch = state.input.charCodeAt(state.position);
  if (ch !== 34) {
    return false;
  }
  state.kind = "scalar";
  state.result = "";
  state.position++;
  captureStart = captureEnd = state.position;
  while ((ch = state.input.charCodeAt(state.position)) !== 0) {
    if (ch === 34) {
      captureSegment(state, captureStart, state.position, true);
      state.position++;
      return true;
    } else if (ch === 92) {
      captureSegment(state, captureStart, state.position, true);
      ch = state.input.charCodeAt(++state.position);
      if (is_EOL(ch)) {
        skipSeparationSpace(state, false, nodeIndent);
      } else if (ch < 256 && simpleEscapeCheck[ch]) {
        state.result += simpleEscapeMap[ch];
        state.position++;
      } else if ((tmp = escapedHexLen(ch)) > 0) {
        hexLength = tmp;
        hexResult = 0;
        for (; hexLength > 0; hexLength--) {
          ch = state.input.charCodeAt(++state.position);
          if ((tmp = fromHexCode(ch)) >= 0) {
            hexResult = (hexResult << 4) + tmp;
          } else {
            throwError(state, "expected hexadecimal character");
          }
        }
        state.result += charFromCodepoint(hexResult);
        state.position++;
      } else {
        throwError(state, "unknown escape sequence");
      }
      captureStart = captureEnd = state.position;
    } else if (is_EOL(ch)) {
      captureSegment(state, captureStart, captureEnd, true);
      writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
      captureStart = captureEnd = state.position;
    } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
      throwError(state, "unexpected end of the document within a double quoted scalar");
    } else {
      state.position++;
      captureEnd = state.position;
    }
  }
  throwError(state, "unexpected end of the stream within a double quoted scalar");
}
function readFlowCollection(state, nodeIndent) {
  var readNext = true, _line, _lineStart, _pos, _tag = state.tag, _result, _anchor = state.anchor, following, terminator, isPair, isExplicitPair, isMapping, overridableKeys = /* @__PURE__ */ Object.create(null), keyNode, keyTag, valueNode, ch;
  ch = state.input.charCodeAt(state.position);
  if (ch === 91) {
    terminator = 93;
    isMapping = false;
    _result = [];
  } else if (ch === 123) {
    terminator = 125;
    isMapping = true;
    _result = {};
  } else {
    return false;
  }
  if (state.anchor !== null) {
    state.anchorMap[state.anchor] = _result;
  }
  ch = state.input.charCodeAt(++state.position);
  while (ch !== 0) {
    skipSeparationSpace(state, true, nodeIndent);
    ch = state.input.charCodeAt(state.position);
    if (ch === terminator) {
      state.position++;
      state.tag = _tag;
      state.anchor = _anchor;
      state.kind = isMapping ? "mapping" : "sequence";
      state.result = _result;
      return true;
    } else if (!readNext) {
      throwError(state, "missed comma between flow collection entries");
    } else if (ch === 44) {
      throwError(state, "expected the node content, but found ','");
    }
    keyTag = keyNode = valueNode = null;
    isPair = isExplicitPair = false;
    if (ch === 63) {
      following = state.input.charCodeAt(state.position + 1);
      if (is_WS_OR_EOL(following)) {
        isPair = isExplicitPair = true;
        state.position++;
        skipSeparationSpace(state, true, nodeIndent);
      }
    }
    _line = state.line;
    _lineStart = state.lineStart;
    _pos = state.position;
    composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
    keyTag = state.tag;
    keyNode = state.result;
    skipSeparationSpace(state, true, nodeIndent);
    ch = state.input.charCodeAt(state.position);
    if ((isExplicitPair || state.line === _line) && ch === 58) {
      isPair = true;
      ch = state.input.charCodeAt(++state.position);
      skipSeparationSpace(state, true, nodeIndent);
      composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
      valueNode = state.result;
    }
    if (isMapping) {
      storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _line, _lineStart, _pos);
    } else if (isPair) {
      _result.push(storeMappingPair(state, null, overridableKeys, keyTag, keyNode, valueNode, _line, _lineStart, _pos));
    } else {
      _result.push(keyNode);
    }
    skipSeparationSpace(state, true, nodeIndent);
    ch = state.input.charCodeAt(state.position);
    if (ch === 44) {
      readNext = true;
      ch = state.input.charCodeAt(++state.position);
    } else {
      readNext = false;
    }
  }
  throwError(state, "unexpected end of the stream within a flow collection");
}
function readBlockScalar(state, nodeIndent) {
  var captureStart, folding, chomping = CHOMPING_CLIP, didReadContent = false, detectedIndent = false, textIndent = nodeIndent, emptyLines = 0, atMoreIndented = false, tmp, ch;
  ch = state.input.charCodeAt(state.position);
  if (ch === 124) {
    folding = false;
  } else if (ch === 62) {
    folding = true;
  } else {
    return false;
  }
  state.kind = "scalar";
  state.result = "";
  while (ch !== 0) {
    ch = state.input.charCodeAt(++state.position);
    if (ch === 43 || ch === 45) {
      if (CHOMPING_CLIP === chomping) {
        chomping = ch === 43 ? CHOMPING_KEEP : CHOMPING_STRIP;
      } else {
        throwError(state, "repeat of a chomping mode identifier");
      }
    } else if ((tmp = fromDecimalCode(ch)) >= 0) {
      if (tmp === 0) {
        throwError(state, "bad explicit indentation width of a block scalar; it cannot be less than one");
      } else if (!detectedIndent) {
        textIndent = nodeIndent + tmp - 1;
        detectedIndent = true;
      } else {
        throwError(state, "repeat of an indentation width identifier");
      }
    } else {
      break;
    }
  }
  if (is_WHITE_SPACE(ch)) {
    do {
      ch = state.input.charCodeAt(++state.position);
    } while (is_WHITE_SPACE(ch));
    if (ch === 35) {
      do {
        ch = state.input.charCodeAt(++state.position);
      } while (!is_EOL(ch) && ch !== 0);
    }
  }
  while (ch !== 0) {
    readLineBreak(state);
    state.lineIndent = 0;
    ch = state.input.charCodeAt(state.position);
    while ((!detectedIndent || state.lineIndent < textIndent) && ch === 32) {
      state.lineIndent++;
      ch = state.input.charCodeAt(++state.position);
    }
    if (!detectedIndent && state.lineIndent > textIndent) {
      textIndent = state.lineIndent;
    }
    if (is_EOL(ch)) {
      emptyLines++;
      continue;
    }
    if (state.lineIndent < textIndent) {
      if (chomping === CHOMPING_KEEP) {
        state.result += common.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
      } else if (chomping === CHOMPING_CLIP) {
        if (didReadContent) {
          state.result += "\n";
        }
      }
      break;
    }
    if (folding) {
      if (is_WHITE_SPACE(ch)) {
        atMoreIndented = true;
        state.result += common.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
      } else if (atMoreIndented) {
        atMoreIndented = false;
        state.result += common.repeat("\n", emptyLines + 1);
      } else if (emptyLines === 0) {
        if (didReadContent) {
          state.result += " ";
        }
      } else {
        state.result += common.repeat("\n", emptyLines);
      }
    } else {
      state.result += common.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
    }
    didReadContent = true;
    detectedIndent = true;
    emptyLines = 0;
    captureStart = state.position;
    while (!is_EOL(ch) && ch !== 0) {
      ch = state.input.charCodeAt(++state.position);
    }
    captureSegment(state, captureStart, state.position, false);
  }
  return true;
}
function readBlockSequence(state, nodeIndent) {
  var _line, _tag = state.tag, _anchor = state.anchor, _result = [], following, detected = false, ch;
  if (state.firstTabInLine !== -1) return false;
  if (state.anchor !== null) {
    state.anchorMap[state.anchor] = _result;
  }
  ch = state.input.charCodeAt(state.position);
  while (ch !== 0) {
    if (state.firstTabInLine !== -1) {
      state.position = state.firstTabInLine;
      throwError(state, "tab characters must not be used in indentation");
    }
    if (ch !== 45) {
      break;
    }
    following = state.input.charCodeAt(state.position + 1);
    if (!is_WS_OR_EOL(following)) {
      break;
    }
    detected = true;
    state.position++;
    if (skipSeparationSpace(state, true, -1)) {
      if (state.lineIndent <= nodeIndent) {
        _result.push(null);
        ch = state.input.charCodeAt(state.position);
        continue;
      }
    }
    _line = state.line;
    composeNode(state, nodeIndent, CONTEXT_BLOCK_IN, false, true);
    _result.push(state.result);
    skipSeparationSpace(state, true, -1);
    ch = state.input.charCodeAt(state.position);
    if ((state.line === _line || state.lineIndent > nodeIndent) && ch !== 0) {
      throwError(state, "bad indentation of a sequence entry");
    } else if (state.lineIndent < nodeIndent) {
      break;
    }
  }
  if (detected) {
    state.tag = _tag;
    state.anchor = _anchor;
    state.kind = "sequence";
    state.result = _result;
    return true;
  }
  return false;
}
function readBlockMapping(state, nodeIndent, flowIndent) {
  var following, allowCompact, _line, _keyLine, _keyLineStart, _keyPos, _tag = state.tag, _anchor = state.anchor, _result = {}, overridableKeys = /* @__PURE__ */ Object.create(null), keyTag = null, keyNode = null, valueNode = null, atExplicitKey = false, detected = false, ch;
  if (state.firstTabInLine !== -1) return false;
  if (state.anchor !== null) {
    state.anchorMap[state.anchor] = _result;
  }
  ch = state.input.charCodeAt(state.position);
  while (ch !== 0) {
    if (!atExplicitKey && state.firstTabInLine !== -1) {
      state.position = state.firstTabInLine;
      throwError(state, "tab characters must not be used in indentation");
    }
    following = state.input.charCodeAt(state.position + 1);
    _line = state.line;
    if ((ch === 63 || ch === 58) && is_WS_OR_EOL(following)) {
      if (ch === 63) {
        if (atExplicitKey) {
          storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
          keyTag = keyNode = valueNode = null;
        }
        detected = true;
        atExplicitKey = true;
        allowCompact = true;
      } else if (atExplicitKey) {
        atExplicitKey = false;
        allowCompact = true;
      } else {
        throwError(state, "incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line");
      }
      state.position += 1;
      ch = following;
    } else {
      _keyLine = state.line;
      _keyLineStart = state.lineStart;
      _keyPos = state.position;
      if (!composeNode(state, flowIndent, CONTEXT_FLOW_OUT, false, true)) {
        break;
      }
      if (state.line === _line) {
        ch = state.input.charCodeAt(state.position);
        while (is_WHITE_SPACE(ch)) {
          ch = state.input.charCodeAt(++state.position);
        }
        if (ch === 58) {
          ch = state.input.charCodeAt(++state.position);
          if (!is_WS_OR_EOL(ch)) {
            throwError(state, "a whitespace character is expected after the key-value separator within a block mapping");
          }
          if (atExplicitKey) {
            storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
            keyTag = keyNode = valueNode = null;
          }
          detected = true;
          atExplicitKey = false;
          allowCompact = false;
          keyTag = state.tag;
          keyNode = state.result;
        } else if (detected) {
          throwError(state, "can not read an implicit mapping pair; a colon is missed");
        } else {
          state.tag = _tag;
          state.anchor = _anchor;
          return true;
        }
      } else if (detected) {
        throwError(state, "can not read a block mapping entry; a multiline key may not be an implicit key");
      } else {
        state.tag = _tag;
        state.anchor = _anchor;
        return true;
      }
    }
    if (state.line === _line || state.lineIndent > nodeIndent) {
      if (atExplicitKey) {
        _keyLine = state.line;
        _keyLineStart = state.lineStart;
        _keyPos = state.position;
      }
      if (composeNode(state, nodeIndent, CONTEXT_BLOCK_OUT, true, allowCompact)) {
        if (atExplicitKey) {
          keyNode = state.result;
        } else {
          valueNode = state.result;
        }
      }
      if (!atExplicitKey) {
        storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _keyLine, _keyLineStart, _keyPos);
        keyTag = keyNode = valueNode = null;
      }
      skipSeparationSpace(state, true, -1);
      ch = state.input.charCodeAt(state.position);
    }
    if ((state.line === _line || state.lineIndent > nodeIndent) && ch !== 0) {
      throwError(state, "bad indentation of a mapping entry");
    } else if (state.lineIndent < nodeIndent) {
      break;
    }
  }
  if (atExplicitKey) {
    storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
  }
  if (detected) {
    state.tag = _tag;
    state.anchor = _anchor;
    state.kind = "mapping";
    state.result = _result;
  }
  return detected;
}
function readTagProperty(state) {
  var _position, isVerbatim = false, isNamed = false, tagHandle, tagName, ch;
  ch = state.input.charCodeAt(state.position);
  if (ch !== 33) return false;
  if (state.tag !== null) {
    throwError(state, "duplication of a tag property");
  }
  ch = state.input.charCodeAt(++state.position);
  if (ch === 60) {
    isVerbatim = true;
    ch = state.input.charCodeAt(++state.position);
  } else if (ch === 33) {
    isNamed = true;
    tagHandle = "!!";
    ch = state.input.charCodeAt(++state.position);
  } else {
    tagHandle = "!";
  }
  _position = state.position;
  if (isVerbatim) {
    do {
      ch = state.input.charCodeAt(++state.position);
    } while (ch !== 0 && ch !== 62);
    if (state.position < state.length) {
      tagName = state.input.slice(_position, state.position);
      ch = state.input.charCodeAt(++state.position);
    } else {
      throwError(state, "unexpected end of the stream within a verbatim tag");
    }
  } else {
    while (ch !== 0 && !is_WS_OR_EOL(ch)) {
      if (ch === 33) {
        if (!isNamed) {
          tagHandle = state.input.slice(_position - 1, state.position + 1);
          if (!PATTERN_TAG_HANDLE.test(tagHandle)) {
            throwError(state, "named tag handle cannot contain such characters");
          }
          isNamed = true;
          _position = state.position + 1;
        } else {
          throwError(state, "tag suffix cannot contain exclamation marks");
        }
      }
      ch = state.input.charCodeAt(++state.position);
    }
    tagName = state.input.slice(_position, state.position);
    if (PATTERN_FLOW_INDICATORS.test(tagName)) {
      throwError(state, "tag suffix cannot contain flow indicator characters");
    }
  }
  if (tagName && !PATTERN_TAG_URI.test(tagName)) {
    throwError(state, "tag name cannot contain such characters: " + tagName);
  }
  try {
    tagName = decodeURIComponent(tagName);
  } catch (err) {
    throwError(state, "tag name is malformed: " + tagName);
  }
  if (isVerbatim) {
    state.tag = tagName;
  } else if (_hasOwnProperty$1.call(state.tagMap, tagHandle)) {
    state.tag = state.tagMap[tagHandle] + tagName;
  } else if (tagHandle === "!") {
    state.tag = "!" + tagName;
  } else if (tagHandle === "!!") {
    state.tag = "tag:yaml.org,2002:" + tagName;
  } else {
    throwError(state, 'undeclared tag handle "' + tagHandle + '"');
  }
  return true;
}
function readAnchorProperty(state) {
  var _position, ch;
  ch = state.input.charCodeAt(state.position);
  if (ch !== 38) return false;
  if (state.anchor !== null) {
    throwError(state, "duplication of an anchor property");
  }
  ch = state.input.charCodeAt(++state.position);
  _position = state.position;
  while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
    ch = state.input.charCodeAt(++state.position);
  }
  if (state.position === _position) {
    throwError(state, "name of an anchor node must contain at least one character");
  }
  state.anchor = state.input.slice(_position, state.position);
  return true;
}
function readAlias(state) {
  var _position, alias, ch;
  ch = state.input.charCodeAt(state.position);
  if (ch !== 42) return false;
  ch = state.input.charCodeAt(++state.position);
  _position = state.position;
  while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
    ch = state.input.charCodeAt(++state.position);
  }
  if (state.position === _position) {
    throwError(state, "name of an alias node must contain at least one character");
  }
  alias = state.input.slice(_position, state.position);
  if (!_hasOwnProperty$1.call(state.anchorMap, alias)) {
    throwError(state, 'unidentified alias "' + alias + '"');
  }
  state.result = state.anchorMap[alias];
  skipSeparationSpace(state, true, -1);
  return true;
}
function composeNode(state, parentIndent, nodeContext, allowToSeek, allowCompact) {
  var allowBlockStyles, allowBlockScalars, allowBlockCollections, indentStatus = 1, atNewLine = false, hasContent = false, typeIndex, typeQuantity, typeList, type2, flowIndent, blockIndent;
  if (state.listener !== null) {
    state.listener("open", state);
  }
  state.tag = null;
  state.anchor = null;
  state.kind = null;
  state.result = null;
  allowBlockStyles = allowBlockScalars = allowBlockCollections = CONTEXT_BLOCK_OUT === nodeContext || CONTEXT_BLOCK_IN === nodeContext;
  if (allowToSeek) {
    if (skipSeparationSpace(state, true, -1)) {
      atNewLine = true;
      if (state.lineIndent > parentIndent) {
        indentStatus = 1;
      } else if (state.lineIndent === parentIndent) {
        indentStatus = 0;
      } else if (state.lineIndent < parentIndent) {
        indentStatus = -1;
      }
    }
  }
  if (indentStatus === 1) {
    while (readTagProperty(state) || readAnchorProperty(state)) {
      if (skipSeparationSpace(state, true, -1)) {
        atNewLine = true;
        allowBlockCollections = allowBlockStyles;
        if (state.lineIndent > parentIndent) {
          indentStatus = 1;
        } else if (state.lineIndent === parentIndent) {
          indentStatus = 0;
        } else if (state.lineIndent < parentIndent) {
          indentStatus = -1;
        }
      } else {
        allowBlockCollections = false;
      }
    }
  }
  if (allowBlockCollections) {
    allowBlockCollections = atNewLine || allowCompact;
  }
  if (indentStatus === 1 || CONTEXT_BLOCK_OUT === nodeContext) {
    if (CONTEXT_FLOW_IN === nodeContext || CONTEXT_FLOW_OUT === nodeContext) {
      flowIndent = parentIndent;
    } else {
      flowIndent = parentIndent + 1;
    }
    blockIndent = state.position - state.lineStart;
    if (indentStatus === 1) {
      if (allowBlockCollections && (readBlockSequence(state, blockIndent) || readBlockMapping(state, blockIndent, flowIndent)) || readFlowCollection(state, flowIndent)) {
        hasContent = true;
      } else {
        if (allowBlockScalars && readBlockScalar(state, flowIndent) || readSingleQuotedScalar(state, flowIndent) || readDoubleQuotedScalar(state, flowIndent)) {
          hasContent = true;
        } else if (readAlias(state)) {
          hasContent = true;
          if (state.tag !== null || state.anchor !== null) {
            throwError(state, "alias node should not have any properties");
          }
        } else if (readPlainScalar(state, flowIndent, CONTEXT_FLOW_IN === nodeContext)) {
          hasContent = true;
          if (state.tag === null) {
            state.tag = "?";
          }
        }
        if (state.anchor !== null) {
          state.anchorMap[state.anchor] = state.result;
        }
      }
    } else if (indentStatus === 0) {
      hasContent = allowBlockCollections && readBlockSequence(state, blockIndent);
    }
  }
  if (state.tag === null) {
    if (state.anchor !== null) {
      state.anchorMap[state.anchor] = state.result;
    }
  } else if (state.tag === "?") {
    if (state.result !== null && state.kind !== "scalar") {
      throwError(state, 'unacceptable node kind for !<?> tag; it should be "scalar", not "' + state.kind + '"');
    }
    for (typeIndex = 0, typeQuantity = state.implicitTypes.length; typeIndex < typeQuantity; typeIndex += 1) {
      type2 = state.implicitTypes[typeIndex];
      if (type2.resolve(state.result)) {
        state.result = type2.construct(state.result);
        state.tag = type2.tag;
        if (state.anchor !== null) {
          state.anchorMap[state.anchor] = state.result;
        }
        break;
      }
    }
  } else if (state.tag !== "!") {
    if (_hasOwnProperty$1.call(state.typeMap[state.kind || "fallback"], state.tag)) {
      type2 = state.typeMap[state.kind || "fallback"][state.tag];
    } else {
      type2 = null;
      typeList = state.typeMap.multi[state.kind || "fallback"];
      for (typeIndex = 0, typeQuantity = typeList.length; typeIndex < typeQuantity; typeIndex += 1) {
        if (state.tag.slice(0, typeList[typeIndex].tag.length) === typeList[typeIndex].tag) {
          type2 = typeList[typeIndex];
          break;
        }
      }
    }
    if (!type2) {
      throwError(state, "unknown tag !<" + state.tag + ">");
    }
    if (state.result !== null && type2.kind !== state.kind) {
      throwError(state, "unacceptable node kind for !<" + state.tag + '> tag; it should be "' + type2.kind + '", not "' + state.kind + '"');
    }
    if (!type2.resolve(state.result, state.tag)) {
      throwError(state, "cannot resolve a node with !<" + state.tag + "> explicit tag");
    } else {
      state.result = type2.construct(state.result, state.tag);
      if (state.anchor !== null) {
        state.anchorMap[state.anchor] = state.result;
      }
    }
  }
  if (state.listener !== null) {
    state.listener("close", state);
  }
  return state.tag !== null || state.anchor !== null || hasContent;
}
function readDocument(state) {
  var documentStart = state.position, _position, directiveName, directiveArgs, hasDirectives = false, ch;
  state.version = null;
  state.checkLineBreaks = state.legacy;
  state.tagMap = /* @__PURE__ */ Object.create(null);
  state.anchorMap = /* @__PURE__ */ Object.create(null);
  while ((ch = state.input.charCodeAt(state.position)) !== 0) {
    skipSeparationSpace(state, true, -1);
    ch = state.input.charCodeAt(state.position);
    if (state.lineIndent > 0 || ch !== 37) {
      break;
    }
    hasDirectives = true;
    ch = state.input.charCodeAt(++state.position);
    _position = state.position;
    while (ch !== 0 && !is_WS_OR_EOL(ch)) {
      ch = state.input.charCodeAt(++state.position);
    }
    directiveName = state.input.slice(_position, state.position);
    directiveArgs = [];
    if (directiveName.length < 1) {
      throwError(state, "directive name must not be less than one character in length");
    }
    while (ch !== 0) {
      while (is_WHITE_SPACE(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }
      if (ch === 35) {
        do {
          ch = state.input.charCodeAt(++state.position);
        } while (ch !== 0 && !is_EOL(ch));
        break;
      }
      if (is_EOL(ch)) break;
      _position = state.position;
      while (ch !== 0 && !is_WS_OR_EOL(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }
      directiveArgs.push(state.input.slice(_position, state.position));
    }
    if (ch !== 0) readLineBreak(state);
    if (_hasOwnProperty$1.call(directiveHandlers, directiveName)) {
      directiveHandlers[directiveName](state, directiveName, directiveArgs);
    } else {
      throwWarning(state, 'unknown document directive "' + directiveName + '"');
    }
  }
  skipSeparationSpace(state, true, -1);
  if (state.lineIndent === 0 && state.input.charCodeAt(state.position) === 45 && state.input.charCodeAt(state.position + 1) === 45 && state.input.charCodeAt(state.position + 2) === 45) {
    state.position += 3;
    skipSeparationSpace(state, true, -1);
  } else if (hasDirectives) {
    throwError(state, "directives end mark is expected");
  }
  composeNode(state, state.lineIndent - 1, CONTEXT_BLOCK_OUT, false, true);
  skipSeparationSpace(state, true, -1);
  if (state.checkLineBreaks && PATTERN_NON_ASCII_LINE_BREAKS.test(state.input.slice(documentStart, state.position))) {
    throwWarning(state, "non-ASCII line breaks are interpreted as content");
  }
  state.documents.push(state.result);
  if (state.position === state.lineStart && testDocumentSeparator(state)) {
    if (state.input.charCodeAt(state.position) === 46) {
      state.position += 3;
      skipSeparationSpace(state, true, -1);
    }
    return;
  }
  if (state.position < state.length - 1) {
    throwError(state, "end of the stream or a document separator is expected");
  } else {
    return;
  }
}
function loadDocuments(input, options) {
  input = String(input);
  options = options || {};
  if (input.length !== 0) {
    if (input.charCodeAt(input.length - 1) !== 10 && input.charCodeAt(input.length - 1) !== 13) {
      input += "\n";
    }
    if (input.charCodeAt(0) === 65279) {
      input = input.slice(1);
    }
  }
  var state = new State$1(input, options);
  var nullpos = input.indexOf("\0");
  if (nullpos !== -1) {
    state.position = nullpos;
    throwError(state, "null byte is not allowed in input");
  }
  state.input += "\0";
  while (state.input.charCodeAt(state.position) === 32) {
    state.lineIndent += 1;
    state.position += 1;
  }
  while (state.position < state.length - 1) {
    readDocument(state);
  }
  return state.documents;
}
function loadAll$1(input, iterator, options) {
  if (iterator !== null && typeof iterator === "object" && typeof options === "undefined") {
    options = iterator;
    iterator = null;
  }
  var documents = loadDocuments(input, options);
  if (typeof iterator !== "function") {
    return documents;
  }
  for (var index = 0, length = documents.length; index < length; index += 1) {
    iterator(documents[index]);
  }
}
function load$1(input, options) {
  var documents = loadDocuments(input, options);
  if (documents.length === 0) {
    return void 0;
  } else if (documents.length === 1) {
    return documents[0];
  }
  throw new exception("expected a single document in the stream, but found more");
}
var loadAll_1 = loadAll$1;
var load_1 = load$1;
var loader = {
  loadAll: loadAll_1,
  load: load_1
};
var _toString = Object.prototype.toString;
var _hasOwnProperty = Object.prototype.hasOwnProperty;
var CHAR_BOM = 65279;
var CHAR_TAB = 9;
var CHAR_LINE_FEED = 10;
var CHAR_CARRIAGE_RETURN = 13;
var CHAR_SPACE = 32;
var CHAR_EXCLAMATION = 33;
var CHAR_DOUBLE_QUOTE = 34;
var CHAR_SHARP = 35;
var CHAR_PERCENT = 37;
var CHAR_AMPERSAND = 38;
var CHAR_SINGLE_QUOTE = 39;
var CHAR_ASTERISK = 42;
var CHAR_COMMA = 44;
var CHAR_MINUS = 45;
var CHAR_COLON = 58;
var CHAR_EQUALS = 61;
var CHAR_GREATER_THAN = 62;
var CHAR_QUESTION = 63;
var CHAR_COMMERCIAL_AT = 64;
var CHAR_LEFT_SQUARE_BRACKET = 91;
var CHAR_RIGHT_SQUARE_BRACKET = 93;
var CHAR_GRAVE_ACCENT = 96;
var CHAR_LEFT_CURLY_BRACKET = 123;
var CHAR_VERTICAL_LINE = 124;
var CHAR_RIGHT_CURLY_BRACKET = 125;
var ESCAPE_SEQUENCES = {};
ESCAPE_SEQUENCES[0] = "\\0";
ESCAPE_SEQUENCES[7] = "\\a";
ESCAPE_SEQUENCES[8] = "\\b";
ESCAPE_SEQUENCES[9] = "\\t";
ESCAPE_SEQUENCES[10] = "\\n";
ESCAPE_SEQUENCES[11] = "\\v";
ESCAPE_SEQUENCES[12] = "\\f";
ESCAPE_SEQUENCES[13] = "\\r";
ESCAPE_SEQUENCES[27] = "\\e";
ESCAPE_SEQUENCES[34] = '\\"';
ESCAPE_SEQUENCES[92] = "\\\\";
ESCAPE_SEQUENCES[133] = "\\N";
ESCAPE_SEQUENCES[160] = "\\_";
ESCAPE_SEQUENCES[8232] = "\\L";
ESCAPE_SEQUENCES[8233] = "\\P";
var DEPRECATED_BOOLEANS_SYNTAX = [
  "y",
  "Y",
  "yes",
  "Yes",
  "YES",
  "on",
  "On",
  "ON",
  "n",
  "N",
  "no",
  "No",
  "NO",
  "off",
  "Off",
  "OFF"
];
var DEPRECATED_BASE60_SYNTAX = /^[-+]?[0-9_]+(?::[0-9_]+)+(?:\.[0-9_]*)?$/;
function compileStyleMap(schema2, map2) {
  var result, keys, index, length, tag, style, type2;
  if (map2 === null) return {};
  result = {};
  keys = Object.keys(map2);
  for (index = 0, length = keys.length; index < length; index += 1) {
    tag = keys[index];
    style = String(map2[tag]);
    if (tag.slice(0, 2) === "!!") {
      tag = "tag:yaml.org,2002:" + tag.slice(2);
    }
    type2 = schema2.compiledTypeMap["fallback"][tag];
    if (type2 && _hasOwnProperty.call(type2.styleAliases, style)) {
      style = type2.styleAliases[style];
    }
    result[tag] = style;
  }
  return result;
}
function encodeHex(character) {
  var string, handle, length;
  string = character.toString(16).toUpperCase();
  if (character <= 255) {
    handle = "x";
    length = 2;
  } else if (character <= 65535) {
    handle = "u";
    length = 4;
  } else if (character <= 4294967295) {
    handle = "U";
    length = 8;
  } else {
    throw new exception("code point within a string may not be greater than 0xFFFFFFFF");
  }
  return "\\" + handle + common.repeat("0", length - string.length) + string;
}
var QUOTING_TYPE_SINGLE = 1;
var QUOTING_TYPE_DOUBLE = 2;
function State(options) {
  this.schema = options["schema"] || _default;
  this.indent = Math.max(1, options["indent"] || 2);
  this.noArrayIndent = options["noArrayIndent"] || false;
  this.skipInvalid = options["skipInvalid"] || false;
  this.flowLevel = common.isNothing(options["flowLevel"]) ? -1 : options["flowLevel"];
  this.styleMap = compileStyleMap(this.schema, options["styles"] || null);
  this.sortKeys = options["sortKeys"] || false;
  this.lineWidth = options["lineWidth"] || 80;
  this.noRefs = options["noRefs"] || false;
  this.noCompatMode = options["noCompatMode"] || false;
  this.condenseFlow = options["condenseFlow"] || false;
  this.quotingType = options["quotingType"] === '"' ? QUOTING_TYPE_DOUBLE : QUOTING_TYPE_SINGLE;
  this.forceQuotes = options["forceQuotes"] || false;
  this.replacer = typeof options["replacer"] === "function" ? options["replacer"] : null;
  this.implicitTypes = this.schema.compiledImplicit;
  this.explicitTypes = this.schema.compiledExplicit;
  this.tag = null;
  this.result = "";
  this.duplicates = [];
  this.usedDuplicates = null;
}
function indentString(string, spaces) {
  var ind = common.repeat(" ", spaces), position = 0, next = -1, result = "", line, length = string.length;
  while (position < length) {
    next = string.indexOf("\n", position);
    if (next === -1) {
      line = string.slice(position);
      position = length;
    } else {
      line = string.slice(position, next + 1);
      position = next + 1;
    }
    if (line.length && line !== "\n") result += ind;
    result += line;
  }
  return result;
}
function generateNextLine(state, level) {
  return "\n" + common.repeat(" ", state.indent * level);
}
function testImplicitResolving(state, str2) {
  var index, length, type2;
  for (index = 0, length = state.implicitTypes.length; index < length; index += 1) {
    type2 = state.implicitTypes[index];
    if (type2.resolve(str2)) {
      return true;
    }
  }
  return false;
}
function isWhitespace(c2) {
  return c2 === CHAR_SPACE || c2 === CHAR_TAB;
}
function isPrintable(c2) {
  return 32 <= c2 && c2 <= 126 || 161 <= c2 && c2 <= 55295 && c2 !== 8232 && c2 !== 8233 || 57344 <= c2 && c2 <= 65533 && c2 !== CHAR_BOM || 65536 <= c2 && c2 <= 1114111;
}
function isNsCharOrWhitespace(c2) {
  return isPrintable(c2) && c2 !== CHAR_BOM && c2 !== CHAR_CARRIAGE_RETURN && c2 !== CHAR_LINE_FEED;
}
function isPlainSafe(c2, prev, inblock) {
  var cIsNsCharOrWhitespace = isNsCharOrWhitespace(c2);
  var cIsNsChar = cIsNsCharOrWhitespace && !isWhitespace(c2);
  return (
    // ns-plain-safe
    (inblock ? (
      // c = flow-in
      cIsNsCharOrWhitespace
    ) : cIsNsCharOrWhitespace && c2 !== CHAR_COMMA && c2 !== CHAR_LEFT_SQUARE_BRACKET && c2 !== CHAR_RIGHT_SQUARE_BRACKET && c2 !== CHAR_LEFT_CURLY_BRACKET && c2 !== CHAR_RIGHT_CURLY_BRACKET) && c2 !== CHAR_SHARP && !(prev === CHAR_COLON && !cIsNsChar) || isNsCharOrWhitespace(prev) && !isWhitespace(prev) && c2 === CHAR_SHARP || prev === CHAR_COLON && cIsNsChar
  );
}
function isPlainSafeFirst(c2) {
  return isPrintable(c2) && c2 !== CHAR_BOM && !isWhitespace(c2) && c2 !== CHAR_MINUS && c2 !== CHAR_QUESTION && c2 !== CHAR_COLON && c2 !== CHAR_COMMA && c2 !== CHAR_LEFT_SQUARE_BRACKET && c2 !== CHAR_RIGHT_SQUARE_BRACKET && c2 !== CHAR_LEFT_CURLY_BRACKET && c2 !== CHAR_RIGHT_CURLY_BRACKET && c2 !== CHAR_SHARP && c2 !== CHAR_AMPERSAND && c2 !== CHAR_ASTERISK && c2 !== CHAR_EXCLAMATION && c2 !== CHAR_VERTICAL_LINE && c2 !== CHAR_EQUALS && c2 !== CHAR_GREATER_THAN && c2 !== CHAR_SINGLE_QUOTE && c2 !== CHAR_DOUBLE_QUOTE && c2 !== CHAR_PERCENT && c2 !== CHAR_COMMERCIAL_AT && c2 !== CHAR_GRAVE_ACCENT;
}
function isPlainSafeLast(c2) {
  return !isWhitespace(c2) && c2 !== CHAR_COLON;
}
function codePointAt(string, pos) {
  var first = string.charCodeAt(pos), second;
  if (first >= 55296 && first <= 56319 && pos + 1 < string.length) {
    second = string.charCodeAt(pos + 1);
    if (second >= 56320 && second <= 57343) {
      return (first - 55296) * 1024 + second - 56320 + 65536;
    }
  }
  return first;
}
function needIndentIndicator(string) {
  var leadingSpaceRe = /^\n* /;
  return leadingSpaceRe.test(string);
}
var STYLE_PLAIN = 1;
var STYLE_SINGLE = 2;
var STYLE_LITERAL = 3;
var STYLE_FOLDED = 4;
var STYLE_DOUBLE = 5;
function chooseScalarStyle(string, singleLineOnly, indentPerLevel, lineWidth, testAmbiguousType, quotingType, forceQuotes, inblock) {
  var i;
  var char = 0;
  var prevChar = null;
  var hasLineBreak = false;
  var hasFoldableLine = false;
  var shouldTrackWidth = lineWidth !== -1;
  var previousLineBreak = -1;
  var plain = isPlainSafeFirst(codePointAt(string, 0)) && isPlainSafeLast(codePointAt(string, string.length - 1));
  if (singleLineOnly || forceQuotes) {
    for (i = 0; i < string.length; char >= 65536 ? i += 2 : i++) {
      char = codePointAt(string, i);
      if (!isPrintable(char)) {
        return STYLE_DOUBLE;
      }
      plain = plain && isPlainSafe(char, prevChar, inblock);
      prevChar = char;
    }
  } else {
    for (i = 0; i < string.length; char >= 65536 ? i += 2 : i++) {
      char = codePointAt(string, i);
      if (char === CHAR_LINE_FEED) {
        hasLineBreak = true;
        if (shouldTrackWidth) {
          hasFoldableLine = hasFoldableLine || // Foldable line = too long, and not more-indented.
          i - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== " ";
          previousLineBreak = i;
        }
      } else if (!isPrintable(char)) {
        return STYLE_DOUBLE;
      }
      plain = plain && isPlainSafe(char, prevChar, inblock);
      prevChar = char;
    }
    hasFoldableLine = hasFoldableLine || shouldTrackWidth && (i - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== " ");
  }
  if (!hasLineBreak && !hasFoldableLine) {
    if (plain && !forceQuotes && !testAmbiguousType(string)) {
      return STYLE_PLAIN;
    }
    return quotingType === QUOTING_TYPE_DOUBLE ? STYLE_DOUBLE : STYLE_SINGLE;
  }
  if (indentPerLevel > 9 && needIndentIndicator(string)) {
    return STYLE_DOUBLE;
  }
  if (!forceQuotes) {
    return hasFoldableLine ? STYLE_FOLDED : STYLE_LITERAL;
  }
  return quotingType === QUOTING_TYPE_DOUBLE ? STYLE_DOUBLE : STYLE_SINGLE;
}
function writeScalar(state, string, level, iskey, inblock) {
  state.dump = function() {
    if (string.length === 0) {
      return state.quotingType === QUOTING_TYPE_DOUBLE ? '""' : "''";
    }
    if (!state.noCompatMode) {
      if (DEPRECATED_BOOLEANS_SYNTAX.indexOf(string) !== -1 || DEPRECATED_BASE60_SYNTAX.test(string)) {
        return state.quotingType === QUOTING_TYPE_DOUBLE ? '"' + string + '"' : "'" + string + "'";
      }
    }
    var indent = state.indent * Math.max(1, level);
    var lineWidth = state.lineWidth === -1 ? -1 : Math.max(Math.min(state.lineWidth, 40), state.lineWidth - indent);
    var singleLineOnly = iskey || state.flowLevel > -1 && level >= state.flowLevel;
    function testAmbiguity(string2) {
      return testImplicitResolving(state, string2);
    }
    switch (chooseScalarStyle(
      string,
      singleLineOnly,
      state.indent,
      lineWidth,
      testAmbiguity,
      state.quotingType,
      state.forceQuotes && !iskey,
      inblock
    )) {
      case STYLE_PLAIN:
        return string;
      case STYLE_SINGLE:
        return "'" + string.replace(/'/g, "''") + "'";
      case STYLE_LITERAL:
        return "|" + blockHeader(string, state.indent) + dropEndingNewline(indentString(string, indent));
      case STYLE_FOLDED:
        return ">" + blockHeader(string, state.indent) + dropEndingNewline(indentString(foldString(string, lineWidth), indent));
      case STYLE_DOUBLE:
        return '"' + escapeString3(string) + '"';
      default:
        throw new exception("impossible error: invalid scalar style");
    }
  }();
}
function blockHeader(string, indentPerLevel) {
  var indentIndicator = needIndentIndicator(string) ? String(indentPerLevel) : "";
  var clip = string[string.length - 1] === "\n";
  var keep = clip && (string[string.length - 2] === "\n" || string === "\n");
  var chomp = keep ? "+" : clip ? "" : "-";
  return indentIndicator + chomp + "\n";
}
function dropEndingNewline(string) {
  return string[string.length - 1] === "\n" ? string.slice(0, -1) : string;
}
function foldString(string, width) {
  var lineRe = /(\n+)([^\n]*)/g;
  var result = function() {
    var nextLF = string.indexOf("\n");
    nextLF = nextLF !== -1 ? nextLF : string.length;
    lineRe.lastIndex = nextLF;
    return foldLine(string.slice(0, nextLF), width);
  }();
  var prevMoreIndented = string[0] === "\n" || string[0] === " ";
  var moreIndented;
  var match2;
  while (match2 = lineRe.exec(string)) {
    var prefix = match2[1], line = match2[2];
    moreIndented = line[0] === " ";
    result += prefix + (!prevMoreIndented && !moreIndented && line !== "" ? "\n" : "") + foldLine(line, width);
    prevMoreIndented = moreIndented;
  }
  return result;
}
function foldLine(line, width) {
  if (line === "" || line[0] === " ") return line;
  var breakRe = / [^ ]/g;
  var match2;
  var start = 0, end, curr = 0, next = 0;
  var result = "";
  while (match2 = breakRe.exec(line)) {
    next = match2.index;
    if (next - start > width) {
      end = curr > start ? curr : next;
      result += "\n" + line.slice(start, end);
      start = end + 1;
    }
    curr = next;
  }
  result += "\n";
  if (line.length - start > width && curr > start) {
    result += line.slice(start, curr) + "\n" + line.slice(curr + 1);
  } else {
    result += line.slice(start);
  }
  return result.slice(1);
}
function escapeString3(string) {
  var result = "";
  var char = 0;
  var escapeSeq;
  for (var i = 0; i < string.length; char >= 65536 ? i += 2 : i++) {
    char = codePointAt(string, i);
    escapeSeq = ESCAPE_SEQUENCES[char];
    if (!escapeSeq && isPrintable(char)) {
      result += string[i];
      if (char >= 65536) result += string[i + 1];
    } else {
      result += escapeSeq || encodeHex(char);
    }
  }
  return result;
}
function writeFlowSequence(state, level, object) {
  var _result = "", _tag = state.tag, index, length, value;
  for (index = 0, length = object.length; index < length; index += 1) {
    value = object[index];
    if (state.replacer) {
      value = state.replacer.call(object, String(index), value);
    }
    if (writeNode(state, level, value, false, false) || typeof value === "undefined" && writeNode(state, level, null, false, false)) {
      if (_result !== "") _result += "," + (!state.condenseFlow ? " " : "");
      _result += state.dump;
    }
  }
  state.tag = _tag;
  state.dump = "[" + _result + "]";
}
function writeBlockSequence(state, level, object, compact) {
  var _result = "", _tag = state.tag, index, length, value;
  for (index = 0, length = object.length; index < length; index += 1) {
    value = object[index];
    if (state.replacer) {
      value = state.replacer.call(object, String(index), value);
    }
    if (writeNode(state, level + 1, value, true, true, false, true) || typeof value === "undefined" && writeNode(state, level + 1, null, true, true, false, true)) {
      if (!compact || _result !== "") {
        _result += generateNextLine(state, level);
      }
      if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
        _result += "-";
      } else {
        _result += "- ";
      }
      _result += state.dump;
    }
  }
  state.tag = _tag;
  state.dump = _result || "[]";
}
function writeFlowMapping(state, level, object) {
  var _result = "", _tag = state.tag, objectKeyList = Object.keys(object), index, length, objectKey, objectValue, pairBuffer;
  for (index = 0, length = objectKeyList.length; index < length; index += 1) {
    pairBuffer = "";
    if (_result !== "") pairBuffer += ", ";
    if (state.condenseFlow) pairBuffer += '"';
    objectKey = objectKeyList[index];
    objectValue = object[objectKey];
    if (state.replacer) {
      objectValue = state.replacer.call(object, objectKey, objectValue);
    }
    if (!writeNode(state, level, objectKey, false, false)) {
      continue;
    }
    if (state.dump.length > 1024) pairBuffer += "? ";
    pairBuffer += state.dump + (state.condenseFlow ? '"' : "") + ":" + (state.condenseFlow ? "" : " ");
    if (!writeNode(state, level, objectValue, false, false)) {
      continue;
    }
    pairBuffer += state.dump;
    _result += pairBuffer;
  }
  state.tag = _tag;
  state.dump = "{" + _result + "}";
}
function writeBlockMapping(state, level, object, compact) {
  var _result = "", _tag = state.tag, objectKeyList = Object.keys(object), index, length, objectKey, objectValue, explicitPair, pairBuffer;
  if (state.sortKeys === true) {
    objectKeyList.sort();
  } else if (typeof state.sortKeys === "function") {
    objectKeyList.sort(state.sortKeys);
  } else if (state.sortKeys) {
    throw new exception("sortKeys must be a boolean or a function");
  }
  for (index = 0, length = objectKeyList.length; index < length; index += 1) {
    pairBuffer = "";
    if (!compact || _result !== "") {
      pairBuffer += generateNextLine(state, level);
    }
    objectKey = objectKeyList[index];
    objectValue = object[objectKey];
    if (state.replacer) {
      objectValue = state.replacer.call(object, objectKey, objectValue);
    }
    if (!writeNode(state, level + 1, objectKey, true, true, true)) {
      continue;
    }
    explicitPair = state.tag !== null && state.tag !== "?" || state.dump && state.dump.length > 1024;
    if (explicitPair) {
      if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
        pairBuffer += "?";
      } else {
        pairBuffer += "? ";
      }
    }
    pairBuffer += state.dump;
    if (explicitPair) {
      pairBuffer += generateNextLine(state, level);
    }
    if (!writeNode(state, level + 1, objectValue, true, explicitPair)) {
      continue;
    }
    if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
      pairBuffer += ":";
    } else {
      pairBuffer += ": ";
    }
    pairBuffer += state.dump;
    _result += pairBuffer;
  }
  state.tag = _tag;
  state.dump = _result || "{}";
}
function detectType(state, object, explicit) {
  var _result, typeList, index, length, type2, style;
  typeList = explicit ? state.explicitTypes : state.implicitTypes;
  for (index = 0, length = typeList.length; index < length; index += 1) {
    type2 = typeList[index];
    if ((type2.instanceOf || type2.predicate) && (!type2.instanceOf || typeof object === "object" && object instanceof type2.instanceOf) && (!type2.predicate || type2.predicate(object))) {
      if (explicit) {
        if (type2.multi && type2.representName) {
          state.tag = type2.representName(object);
        } else {
          state.tag = type2.tag;
        }
      } else {
        state.tag = "?";
      }
      if (type2.represent) {
        style = state.styleMap[type2.tag] || type2.defaultStyle;
        if (_toString.call(type2.represent) === "[object Function]") {
          _result = type2.represent(object, style);
        } else if (_hasOwnProperty.call(type2.represent, style)) {
          _result = type2.represent[style](object, style);
        } else {
          throw new exception("!<" + type2.tag + '> tag resolver accepts not "' + style + '" style');
        }
        state.dump = _result;
      }
      return true;
    }
  }
  return false;
}
function writeNode(state, level, object, block, compact, iskey, isblockseq) {
  state.tag = null;
  state.dump = object;
  if (!detectType(state, object, false)) {
    detectType(state, object, true);
  }
  var type2 = _toString.call(state.dump);
  var inblock = block;
  var tagStr;
  if (block) {
    block = state.flowLevel < 0 || state.flowLevel > level;
  }
  var objectOrArray = type2 === "[object Object]" || type2 === "[object Array]", duplicateIndex, duplicate;
  if (objectOrArray) {
    duplicateIndex = state.duplicates.indexOf(object);
    duplicate = duplicateIndex !== -1;
  }
  if (state.tag !== null && state.tag !== "?" || duplicate || state.indent !== 2 && level > 0) {
    compact = false;
  }
  if (duplicate && state.usedDuplicates[duplicateIndex]) {
    state.dump = "*ref_" + duplicateIndex;
  } else {
    if (objectOrArray && duplicate && !state.usedDuplicates[duplicateIndex]) {
      state.usedDuplicates[duplicateIndex] = true;
    }
    if (type2 === "[object Object]") {
      if (block && Object.keys(state.dump).length !== 0) {
        writeBlockMapping(state, level, state.dump, compact);
        if (duplicate) {
          state.dump = "&ref_" + duplicateIndex + state.dump;
        }
      } else {
        writeFlowMapping(state, level, state.dump);
        if (duplicate) {
          state.dump = "&ref_" + duplicateIndex + " " + state.dump;
        }
      }
    } else if (type2 === "[object Array]") {
      if (block && state.dump.length !== 0) {
        if (state.noArrayIndent && !isblockseq && level > 0) {
          writeBlockSequence(state, level - 1, state.dump, compact);
        } else {
          writeBlockSequence(state, level, state.dump, compact);
        }
        if (duplicate) {
          state.dump = "&ref_" + duplicateIndex + state.dump;
        }
      } else {
        writeFlowSequence(state, level, state.dump);
        if (duplicate) {
          state.dump = "&ref_" + duplicateIndex + " " + state.dump;
        }
      }
    } else if (type2 === "[object String]") {
      if (state.tag !== "?") {
        writeScalar(state, state.dump, level, iskey, inblock);
      }
    } else if (type2 === "[object Undefined]") {
      return false;
    } else {
      if (state.skipInvalid) return false;
      throw new exception("unacceptable kind of an object to dump " + type2);
    }
    if (state.tag !== null && state.tag !== "?") {
      tagStr = encodeURI(
        state.tag[0] === "!" ? state.tag.slice(1) : state.tag
      ).replace(/!/g, "%21");
      if (state.tag[0] === "!") {
        tagStr = "!" + tagStr;
      } else if (tagStr.slice(0, 18) === "tag:yaml.org,2002:") {
        tagStr = "!!" + tagStr.slice(18);
      } else {
        tagStr = "!<" + tagStr + ">";
      }
      state.dump = tagStr + " " + state.dump;
    }
  }
  return true;
}
function getDuplicateReferences(object, state) {
  var objects = [], duplicatesIndexes = [], index, length;
  inspectNode(object, objects, duplicatesIndexes);
  for (index = 0, length = duplicatesIndexes.length; index < length; index += 1) {
    state.duplicates.push(objects[duplicatesIndexes[index]]);
  }
  state.usedDuplicates = new Array(length);
}
function inspectNode(object, objects, duplicatesIndexes) {
  var objectKeyList, index, length;
  if (object !== null && typeof object === "object") {
    index = objects.indexOf(object);
    if (index !== -1) {
      if (duplicatesIndexes.indexOf(index) === -1) {
        duplicatesIndexes.push(index);
      }
    } else {
      objects.push(object);
      if (Array.isArray(object)) {
        for (index = 0, length = object.length; index < length; index += 1) {
          inspectNode(object[index], objects, duplicatesIndexes);
        }
      } else {
        objectKeyList = Object.keys(object);
        for (index = 0, length = objectKeyList.length; index < length; index += 1) {
          inspectNode(object[objectKeyList[index]], objects, duplicatesIndexes);
        }
      }
    }
  }
}
function dump$1(input, options) {
  options = options || {};
  var state = new State(options);
  if (!state.noRefs) getDuplicateReferences(input, state);
  var value = input;
  if (state.replacer) {
    value = state.replacer.call({ "": value }, "", value);
  }
  if (writeNode(state, 0, value, true, true)) return state.dump + "\n";
  return "";
}
var dump_1 = dump$1;
var dumper = {
  dump: dump_1
};
function renamed(from, to) {
  return function() {
    throw new Error("Function yaml." + from + " is removed in js-yaml 4. Use yaml." + to + " instead, which is now safe by default.");
  };
}
var Type = type;
var Schema = schema;
var FAILSAFE_SCHEMA = failsafe;
var JSON_SCHEMA = json2;
var CORE_SCHEMA = core;
var DEFAULT_SCHEMA = _default;
var load = loader.load;
var loadAll = loader.loadAll;
var dump = dumper.dump;
var YAMLException = exception;
var types2 = {
  binary,
  float,
  map,
  null: _null,
  pairs,
  set: set2,
  timestamp,
  bool,
  int,
  merge,
  omap,
  seq,
  str
};
var safeLoad = renamed("safeLoad", "load");
var safeLoadAll = renamed("safeLoadAll", "loadAll");
var safeDump = renamed("safeDump", "dump");
var jsYaml = {
  Type,
  Schema,
  FAILSAFE_SCHEMA,
  JSON_SCHEMA,
  CORE_SCHEMA,
  DEFAULT_SCHEMA,
  load,
  loadAll,
  dump,
  YAMLException,
  types: types2,
  safeLoad,
  safeLoadAll,
  safeDump
};
var js_yaml_default = jsYaml;

// src/oas-normalize/lib/utils.ts
function isBuffer(obj) {
  return obj != null && obj.constructor != null && typeof obj.constructor.isBuffer === "function" && obj.constructor.isBuffer(obj);
}
function normalizeURL(url) {
  if (url.startsWith("https://github.com/") && url.includes("/blob/")) {
    return url.replace("github.com", "raw.githubusercontent.com").replace("/blob/", "/");
  }
  return url;
}
function getType(obj) {
  if (isBuffer(obj)) {
    return "buffer";
  } else if (typeof obj === "object") {
    return "json";
  } else if (typeof obj === "string") {
    if (obj.match(/\s*{/)) {
      return "string-json";
    } else if (obj.match(/\n/)) {
      return "string-yaml";
    } else if (obj.substring(0, 4) === "http") {
      return "url";
    }
    return "path";
  }
  return false;
}
function isOpenAPI(schema2) {
  return !!schema2.openapi;
}
function isPostman(schema2) {
  return !!schema2.info && !!schema2.item;
}
function isSwagger(schema2) {
  return !!schema2.swagger;
}
function stringToJSON(string) {
  if (typeof string === "object") {
    return string;
  } else if (string.match(/^\s*{/)) {
    return JSON.parse(string);
  }
  return js_yaml_default.load(string, { schema: JSON_SCHEMA });
}
function getAPIDefinitionType(schema2) {
  if (isOpenAPI(schema2)) {
    return "openapi";
  } else if (isPostman(schema2)) {
    return "postman";
  } else if (isSwagger(schema2)) {
    return "swagger";
  }
  return "unknown";
}

// src/oas-normalize/index.ts
var OASNormalize = class _OASNormalize {
  cache;
  file;
  opts;
  type;
  constructor(file, opts) {
    this.file = file;
    this.opts = {
      colorizeErrors: false,
      enablePaths: false,
      ...opts
    };
    this.type = getType(this.file);
    this.cache = {
      load: false,
      bundle: false,
      deref: false
    };
  }
  /**
   * @private
   */
  async load() {
    if (this.cache.load) return Promise.resolve(this.cache.load);
    const resolve = (obj) => {
      const ret = stringToJSON(obj);
      this.cache.load = ret;
      return Promise.resolve(ret);
    };
    switch (this.type) {
      case "json":
      case "string-json":
      case "string-yaml":
        return resolve(this.file);
      case "buffer":
        return resolve(this.file.toString());
      case "url":
        const resp = await fetch(normalizeURL(this.file)).then((res) => res.text());
        return resolve(resp);
      case "path":
        if (!this.opts.enablePaths) {
          return Promise.reject(new Error("Use `opts.enablePaths` to enable accessing local files."));
        }
        const contents = import_node_fs.default.readFileSync(this.file).toString();
        if (!contents.trim()) {
          return Promise.reject(new Error("No file contents found."));
        }
        return resolve(contents);
      default:
        return Promise.reject(new Error("Could not load this file."));
    }
  }
  /**
   * @private
   */
  static convertPostmanToOpenAPI(schema2) {
    return (0, import_postman_to_openapi.default)(JSON.stringify(schema2), void 0, { outputFormat: "json", replaceVars: true }).then(JSON.parse);
  }
  /**
   * Bundle up the given API definition, resolving any external `$ref` pointers in the process.
   *
   */
  async bundle() {
    if (this.cache.bundle) return Promise.resolve(this.cache.bundle);
    return this.load().then((schema2) => {
      if (isPostman(schema2)) {
        return _OASNormalize.convertPostmanToOpenAPI(schema2);
      }
      return schema2;
    }).then((schema2) => import_openapi_parser.default.bundle(schema2)).then((bundle) => {
      this.cache.bundle = bundle;
      return bundle;
    });
  }
  /**
   * Dereference the given API definition.
   *
   */
  async deref() {
    if (this.cache.deref) return Promise.resolve(this.cache.deref);
    return this.load().then((schema2) => {
      if (isPostman(schema2)) {
        return _OASNormalize.convertPostmanToOpenAPI(schema2);
      }
      return schema2;
    }).then((schema2) => import_openapi_parser.default.dereference(schema2)).then((dereferenced) => {
      this.cache.deref = dereferenced;
      return dereferenced;
    });
  }
  /**
   * Validate, and potentially convert to OpenAPI, a given API definition.
   *
   */
  async validate(opts = { convertToLatest: false }) {
    const convertToLatest = opts.convertToLatest;
    const parserOptions = opts.parser || {};
    if (!parserOptions.validate) {
      parserOptions.validate = {};
    }
    parserOptions.validate.colorizeErrors = this.opts.colorizeErrors;
    return this.load().then(async (schema2) => {
      if (!isPostman(schema2)) {
        return schema2;
      }
      return _OASNormalize.convertPostmanToOpenAPI(schema2);
    }).then(async (schema2) => {
      if (!isSwagger(schema2) && !isOpenAPI(schema2)) {
        return Promise.reject(new Error("The supplied API definition is unsupported."));
      } else if (isSwagger(schema2)) {
        const baseVersion = parseInt(schema2.swagger, 10);
        if (baseVersion === 1) {
          return Promise.reject(new Error("Swagger v1.2 is unsupported."));
        }
      }
      const clonedSchema = JSON.parse(JSON.stringify(schema2));
      return import_openapi_parser.default.validate(clonedSchema, parserOptions).then(() => {
        if (!convertToLatest) {
          return schema2;
        }
        return import_swagger2openapi.default.convertObj(schema2, { anchors: true }).then((options) => options.openapi);
      }).catch((err) => Promise.reject(err));
    });
  }
  /**
   * Retrieve OpenAPI, Swagger, or Postman version information about the supplied API definition.
   *
   */
  version() {
    return this.load().then((schema2) => {
      switch (getAPIDefinitionType(schema2)) {
        case "openapi":
          return {
            specification: "openapi",
            version: schema2.openapi
          };
        case "postman":
          let version = "unknown";
          if (schema2?.info?.schema) {
            const match2 = schema2.info.schema.match(
              /http(s?):\/\/schema.getpostman.com\/json\/collection\/v([0-9.]+)\//
            );
            if (match2) {
              version = match2[2];
            }
          }
          return {
            specification: "postman",
            version
          };
        case "swagger":
          return {
            specification: "swagger",
            version: schema2.swagger
          };
        default:
          throw new Error("Unknown file detected.");
      }
    });
  }
};

// src/generateCodeSamplesOverlay.ts
async function generateCodeSamplesOverlay(fileContent, language) {
  const codeSamples = [];
  const errors = [];
  const oas = new OASNormalize(fileContent);
  const doc = await oas.deref();
  const docAsJsonString = JSON.stringify(doc, null, 2);
  const apiDefinition = new Oas(docAsJsonString);
  for (const [pathName, path] of Object.entries(apiDefinition.getPaths())) {
    for (const [method, operation] of Object.entries(path)) {
      const res = generateCodeSampleForOperation(
        operation,
        pathName,
        method,
        apiDefinition,
        language
      );
      if ("error" in res) {
        errors.push(res);
      } else {
        codeSamples.push(res);
      }
    }
  }
  const overlay = buildCodeSamplesOverlay(codeSamples);
  return { overlay, errors: errors.length > 0 ? errors : void 0 };
}
function generateCodeSampleForOperation(operation, pathName, method, apiDefinition, language) {
  const exampleGroups = Object.values(operation.getExampleGroups());
  const jsonPathSelector = buildJsonPathSelector(pathName, method);
  const buildError = (error) => ({
    jsonPathSelector,
    error
  });
  if (exampleGroups.length > 0) {
    return buildError(`Multiple example groups are not supported`);
  } else {
    const requestBodyExamples = operation.getRequestBodyExamples();
    if (requestBodyExamples?.length > 1) {
      return buildError(`Multiple requestBodyExamples are not supported`);
    }
    if (requestBodyExamples[0]?.examples?.length > 1) {
      return buildError(
        `Multiple requestBodyExamples[0].examples are not supported`
      );
    }
    const firstBodyExample = requestBodyExamples?.[0]?.examples[0];
    const dataForHAR = {
      body: firstBodyExample?.value
    };
    for (const param of operation.getParameters()) {
      if (param.example) {
        dataForHAR[param.in] = dataForHAR[param.in] || {};
        dataForHAR[param.in][param.name] = param.example;
      }
      const examples = Object.values(param.examples || {});
      if (examples?.length > 0) {
        return buildError(`Multiple parameter examples are not supported`);
      }
    }
    const auth = {};
    for (const securityRequirement of operation.getSecurityWithTypes()) {
      for (const sec of securityRequirement || []) {
        if (!sec) continue;
        auth[sec.security._key] = `MY_` + sec.security._key.replace(/[^a-zA-Z0-9]/g, "_").toUpperCase();
      }
    }
    const { code, highlightMode } = oasToSnippet(
      apiDefinition,
      operation,
      dataForHAR,
      auth,
      language
    );
    if (code && highlightMode) {
      return {
        lang: highlightMode,
        source: code,
        jsonPathSelector: buildJsonPathSelector(pathName, method)
      };
    }
    return buildError(`Could not generate code snippet`);
  }
}
function readFilePathOrUrl(filePathOrUrl) {
  if (filePathOrUrl.startsWith("https://") || filePathOrUrl.startsWith("http://")) {
    return fetch(filePathOrUrl).then((res) => res.text());
  }
  if (!import_fs.default.existsSync(filePathOrUrl)) {
    throw new Error(`File does not exist: ${filePathOrUrl}`);
  }
  return import_fs.default.readFileSync(filePathOrUrl, "utf8");
}
function buildCodeSamplesOverlay(codeSamples) {
  const overlay = {
    overlay: "1.0.0",
    info: {
      title: "Code Samples",
      version: "0.0.0"
    },
    actions: codeSamples.map((codeSample) => {
      return {
        target: codeSample.jsonPathSelector,
        update: {
          "x-codeSamples": [
            {
              lang: codeSample.lang,
              label: codeSample.label,
              source: codeSample.source
            }
          ]
        }
      };
    })
  };
  return overlay;
}
function buildJsonPathSelector(pathName, method) {
  return `$["paths"]["${pathName}"]["${method}"]`;
}

// src/main.ts
async function main() {
  const options = (0, import_command_line_args.default)([
    { name: "schema", alias: "s", type: String },
    { name: "language", alias: "l", type: String }
  ]);
  const filePathOrUrl = options.schema;
  const language = options.language;
  if (!filePathOrUrl) {
    throw new Error("Please provide a schema file");
  }
  if (!language || typeof language !== "string") {
    throw new Error("Please provide a language");
  }
  const supportedLanguages = getSupportedLanguages();
  const isSupportedLanguage = (x) => x in supportedLanguages;
  if (!isSupportedLanguage(language)) {
    throw new Error(
      `Language not supported: ${language}. Supported languages: ${Object.keys(
        supportedLanguages
      ).join(", ")}`
    );
  }
  const fileContent = await readFilePathOrUrl(filePathOrUrl);
  const { overlay, errors } = await generateCodeSamplesOverlay(
    fileContent,
    language
  );
  process.stdout.write(JSON.stringify(overlay, null, 2));
  for (const error of errors || []) {
    process.stderr.write(
      `Error generating code sample for ${error.jsonPathSelector}: ${error.error}`
    );
  }
}
main().catch((err) => {
  console.error(err);
  process.exit(1);
});
/*! Bundled license information:

uri-js/dist/es5/uri.all.js:
  (** @license URI.js v4.4.1 (c) 2011 Gary Court. License: http://github.com/garycourt/uri-js *)

mustache/mustache.js:
  (*!
   * mustache.js - Logic-less {{mustache}} templates with JavaScript
   * http://github.com/janl/mustache.js
   *)

oas/dist/chunk-OVRW7C6X.js:
  (**
   * Portions of this file have been extracted and modified from Swagger UI.
   *
   * @license Apache-2.0
   * @see {@link https://github.com/swagger-api/swagger-ui/blob/master/src/core/utils.js}
   *)
  (**
   * This file has been extracted and modified from Swagger UI.
   *
   * @license Apache-2.0
   * @see {@link https://github.com/swagger-api/swagger-ui/blob/master/src/core/plugins/samples/fn.js}
   *)

@readme/httpsnippet/dist/index.js:
  (*! formdata-polyfill. MIT License. Jimmy Wrting <https://jimmy.warting.se/opensource> *)

@readme/oas-to-har/dist/index.js:
  (**
   * This file has been extracted and modified from `swagger-client`.
   *
   * @license Apache 2.0
   * @link https://npm.im/swagger-client
   * @link https://github.com/swagger-api/swagger-js/blob/master/src/execute/oas3/style-serializer.js
   *)

js-yaml/dist/js-yaml.mjs:
  (*! js-yaml 4.1.0 https://github.com/nodeca/js-yaml @license MIT *)
*/
